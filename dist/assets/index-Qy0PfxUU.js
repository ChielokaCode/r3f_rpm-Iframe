var Zr=Object.defineProperty;var Jr=(a,e,i)=>e in a?Zr(a,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[e]=i;var Fr=(a,e,i)=>(Jr(a,typeof e!="symbol"?e+"":e,i),i);function _mergeNamespaces(a,e){for(var i=0;i<e.length;i++){const s=e[i];if(typeof s!="string"&&!Array.isArray(s)){for(const o in s)if(o!=="default"&&!(o in a)){const c=Object.getOwnPropertyDescriptor(s,o);c&&Object.defineProperty(a,o,c.get?c:{enumerable:!0,get:()=>s[o]})}}}return Object.freeze(Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))s(o);new MutationObserver(o=>{for(const c of o)if(c.type==="childList")for(const d of c.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&s(d)}).observe(document,{childList:!0,subtree:!0});function i(o){const c={};return o.integrity&&(c.integrity=o.integrity),o.referrerPolicy&&(c.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?c.credentials="include":o.crossOrigin==="anonymous"?c.credentials="omit":c.credentials="same-origin",c}function s(o){if(o.ep)return;o.ep=!0;const c=i(o);fetch(o.href,c)}})();var commonjsGlobal$1=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs$1(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}function getAugmentedNamespace(a){if(a.__esModule)return a;var e=a.default;if(typeof e=="function"){var i=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};i.prototype=e.prototype}else i={};return Object.defineProperty(i,"__esModule",{value:!0}),Object.keys(a).forEach(function(s){var o=Object.getOwnPropertyDescriptor(a,s);Object.defineProperty(i,s,o.get?o:{enumerable:!0,get:function(){return a[s]}})}),i}var jsxRuntime={exports:{}},reactJsxRuntime_production_min={},react={exports:{}},react_production_min={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$1=Symbol.for("react.element"),n$1=Symbol.for("react.portal"),p$3=Symbol.for("react.fragment"),q$1=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v$1=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z$1=Symbol.iterator;function A$2(a){return a===null||typeof a!="object"?null:(a=z$1&&a[z$1]||a["@@iterator"],typeof a=="function"?a:null)}var B$2={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C$2=Object.assign,D$1={};function E$1(a,e,i){this.props=a,this.context=e,this.refs=D$1,this.updater=i||B$2}E$1.prototype.isReactComponent={};E$1.prototype.setState=function(a,e){if(typeof a!="object"&&typeof a!="function"&&a!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,e,"setState")};E$1.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E$1.prototype;function G$1(a,e,i){this.props=a,this.context=e,this.refs=D$1,this.updater=i||B$2}var H$1=G$1.prototype=new F;H$1.constructor=G$1;C$2(H$1,E$1.prototype);H$1.isPureReactComponent=!0;var I$1=Array.isArray,J=Object.prototype.hasOwnProperty,K$1={current:null},L$1={key:!0,ref:!0,__self:!0,__source:!0};function M$1(a,e,i){var s,o={},c=null,d=null;if(e!=null)for(s in e.ref!==void 0&&(d=e.ref),e.key!==void 0&&(c=""+e.key),e)J.call(e,s)&&!L$1.hasOwnProperty(s)&&(o[s]=e[s]);var h=arguments.length-2;if(h===1)o.children=i;else if(1<h){for(var g=Array(h),_=0;_<h;_++)g[_]=arguments[_+2];o.children=g}if(a&&a.defaultProps)for(s in h=a.defaultProps,h)o[s]===void 0&&(o[s]=h[s]);return{$$typeof:l$1,type:a,key:c,ref:d,props:o,_owner:K$1.current}}function N$1(a,e){return{$$typeof:l$1,type:a.type,key:e,ref:a.ref,props:a.props,_owner:a._owner}}function O$1(a){return typeof a=="object"&&a!==null&&a.$$typeof===l$1}function escape$1(a){var e={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(i){return e[i]})}var P$3=/\/+/g;function Q$1(a,e){return typeof a=="object"&&a!==null&&a.key!=null?escape$1(""+a.key):e.toString(36)}function R$1(a,e,i,s,o){var c=typeof a;(c==="undefined"||c==="boolean")&&(a=null);var d=!1;if(a===null)d=!0;else switch(c){case"string":case"number":d=!0;break;case"object":switch(a.$$typeof){case l$1:case n$1:d=!0}}if(d)return d=a,o=o(d),a=s===""?"."+Q$1(d,0):s,I$1(o)?(i="",a!=null&&(i=a.replace(P$3,"$&/")+"/"),R$1(o,e,i,"",function(_){return _})):o!=null&&(O$1(o)&&(o=N$1(o,i+(!o.key||d&&d.key===o.key?"":(""+o.key).replace(P$3,"$&/")+"/")+a)),e.push(o)),1;if(d=0,s=s===""?".":s+":",I$1(a))for(var h=0;h<a.length;h++){c=a[h];var g=s+Q$1(c,h);d+=R$1(c,e,i,g,o)}else if(g=A$2(a),typeof g=="function")for(a=g.call(a),h=0;!(c=a.next()).done;)c=c.value,g=s+Q$1(c,h++),d+=R$1(c,e,i,g,o);else if(c==="object")throw e=String(a),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(a).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return d}function S$1(a,e,i){if(a==null)return a;var s=[],o=0;return R$1(a,s,"","",function(c){return e.call(i,c,o++)}),s}function T$1(a){if(a._status===-1){var e=a._result;e=e(),e.then(function(i){(a._status===0||a._status===-1)&&(a._status=1,a._result=i)},function(i){(a._status===0||a._status===-1)&&(a._status=2,a._result=i)}),a._status===-1&&(a._status=0,a._result=e)}if(a._status===1)return a._result.default;throw a._result}var U$1={current:null},V$1={transition:null},W$1={ReactCurrentDispatcher:U$1,ReactCurrentBatchConfig:V$1,ReactCurrentOwner:K$1};function X$1(){throw Error("act(...) is not supported in production builds of React.")}react_production_min.Children={map:S$1,forEach:function(a,e,i){S$1(a,function(){e.apply(this,arguments)},i)},count:function(a){var e=0;return S$1(a,function(){e++}),e},toArray:function(a){return S$1(a,function(e){return e})||[]},only:function(a){if(!O$1(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E$1;react_production_min.Fragment=p$3;react_production_min.Profiler=r;react_production_min.PureComponent=G$1;react_production_min.StrictMode=q$1;react_production_min.Suspense=w;react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W$1;react_production_min.act=X$1;react_production_min.cloneElement=function(a,e,i){if(a==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var s=C$2({},a.props),o=a.key,c=a.ref,d=a._owner;if(e!=null){if(e.ref!==void 0&&(c=e.ref,d=K$1.current),e.key!==void 0&&(o=""+e.key),a.type&&a.type.defaultProps)var h=a.type.defaultProps;for(g in e)J.call(e,g)&&!L$1.hasOwnProperty(g)&&(s[g]=e[g]===void 0&&h!==void 0?h[g]:e[g])}var g=arguments.length-2;if(g===1)s.children=i;else if(1<g){h=Array(g);for(var _=0;_<g;_++)h[_]=arguments[_+2];s.children=h}return{$$typeof:l$1,type:a.type,key:o,ref:c,props:s,_owner:d}};react_production_min.createContext=function(a){return a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},a.Provider={$$typeof:t,_context:a},a.Consumer=a};react_production_min.createElement=M$1;react_production_min.createFactory=function(a){var e=M$1.bind(null,a);return e.type=a,e};react_production_min.createRef=function(){return{current:null}};react_production_min.forwardRef=function(a){return{$$typeof:v$1,render:a}};react_production_min.isValidElement=O$1;react_production_min.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T$1}};react_production_min.memo=function(a,e){return{$$typeof:x,type:a,compare:e===void 0?null:e}};react_production_min.startTransition=function(a){var e=V$1.transition;V$1.transition={};try{a()}finally{V$1.transition=e}};react_production_min.unstable_act=X$1;react_production_min.useCallback=function(a,e){return U$1.current.useCallback(a,e)};react_production_min.useContext=function(a){return U$1.current.useContext(a)};react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U$1.current.useDeferredValue(a)};react_production_min.useEffect=function(a,e){return U$1.current.useEffect(a,e)};react_production_min.useId=function(){return U$1.current.useId()};react_production_min.useImperativeHandle=function(a,e,i){return U$1.current.useImperativeHandle(a,e,i)};react_production_min.useInsertionEffect=function(a,e){return U$1.current.useInsertionEffect(a,e)};react_production_min.useLayoutEffect=function(a,e){return U$1.current.useLayoutEffect(a,e)};react_production_min.useMemo=function(a,e){return U$1.current.useMemo(a,e)};react_production_min.useReducer=function(a,e,i){return U$1.current.useReducer(a,e,i)};react_production_min.useRef=function(a){return U$1.current.useRef(a)};react_production_min.useState=function(a){return U$1.current.useState(a)};react_production_min.useSyncExternalStore=function(a,e,i){return U$1.current.useSyncExternalStore(a,e,i)};react_production_min.useTransition=function(){return U$1.current.useTransition()};react_production_min.version="18.3.1";react.exports=react_production_min;var reactExports=react.exports;const React=getDefaultExportFromCjs$1(reactExports),React$1=_mergeNamespaces({__proto__:null,default:React},[reactExports]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var f=reactExports,k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m$1=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p$2={key:!0,ref:!0,__self:!0,__source:!0};function q(a,e,i){var s,o={},c=null,d=null;i!==void 0&&(c=""+i),e.key!==void 0&&(c=""+e.key),e.ref!==void 0&&(d=e.ref);for(s in e)m$1.call(e,s)&&!p$2.hasOwnProperty(s)&&(o[s]=e[s]);if(a&&a.defaultProps)for(s in e=a.defaultProps,e)o[s]===void 0&&(o[s]=e[s]);return{$$typeof:k,type:a,key:c,ref:d,props:o,_owner:n.current}}reactJsxRuntime_production_min.Fragment=l;reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;jsxRuntime.exports=reactJsxRuntime_production_min;var jsxRuntimeExports=jsxRuntime.exports,client={},reactDom={exports:{}},reactDom_production_min={},scheduler={exports:{}},scheduler_production_min={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(a){function e(wt,$t){var Ct=wt.length;wt.push($t);e:for(;0<Ct;){var Mt=Ct-1>>>1,Ot=wt[Mt];if(0<o(Ot,$t))wt[Mt]=$t,wt[Ct]=Ot,Ct=Mt;else break e}}function i(wt){return wt.length===0?null:wt[0]}function s(wt){if(wt.length===0)return null;var $t=wt[0],Ct=wt.pop();if(Ct!==$t){wt[0]=Ct;e:for(var Mt=0,Ot=wt.length,Dt=Ot>>>1;Mt<Dt;){var At=2*(Mt+1)-1,kt=wt[At],Ft=At+1,Bt=wt[Ft];if(0>o(kt,Ct))Ft<Ot&&0>o(Bt,kt)?(wt[Mt]=Bt,wt[Ft]=Ct,Mt=Ft):(wt[Mt]=kt,wt[At]=Ct,Mt=At);else if(Ft<Ot&&0>o(Bt,Ct))wt[Mt]=Bt,wt[Ft]=Ct,Mt=Ft;else break e}}return $t}function o(wt,$t){var Ct=wt.sortIndex-$t.sortIndex;return Ct!==0?Ct:wt.id-$t.id}if(typeof performance=="object"&&typeof performance.now=="function"){var c=performance;a.unstable_now=function(){return c.now()}}else{var d=Date,h=d.now();a.unstable_now=function(){return d.now()-h}}var g=[],_=[],b=1,$=null,j=3,_e=!1,tt=!1,et=!1,nt=typeof setTimeout=="function"?setTimeout:null,rt=typeof clearTimeout=="function"?clearTimeout:null,it=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function at(wt){for(var $t=i(_);$t!==null;){if($t.callback===null)s(_);else if($t.startTime<=wt)s(_),$t.sortIndex=$t.expirationTime,e(g,$t);else break;$t=i(_)}}function st(wt){if(et=!1,at(wt),!tt)if(i(g)!==null)tt=!0,vt(ot);else{var $t=i(_);$t!==null&&Nt(st,$t.startTime-wt)}}function ot(wt,$t){tt=!1,et&&(et=!1,rt(dt),dt=-1),_e=!0;var Ct=j;try{for(at($t),$=i(g);$!==null&&(!($.expirationTime>$t)||wt&&!ft());){var Mt=$.callback;if(typeof Mt=="function"){$.callback=null,j=$.priorityLevel;var Ot=Mt($.expirationTime<=$t);$t=a.unstable_now(),typeof Ot=="function"?$.callback=Ot:$===i(g)&&s(g),at($t)}else s(g);$=i(g)}if($!==null)var Dt=!0;else{var At=i(_);At!==null&&Nt(st,At.startTime-$t),Dt=!1}return Dt}finally{$=null,j=Ct,_e=!1}}var ct=!1,lt=null,dt=-1,xt=5,ut=-1;function ft(){return!(a.unstable_now()-ut<xt)}function mt(){if(lt!==null){var wt=a.unstable_now();ut=wt;var $t=!0;try{$t=lt(!0,wt)}finally{$t?yt():(ct=!1,lt=null)}}else ct=!1}var yt;if(typeof it=="function")yt=function(){it(mt)};else if(typeof MessageChannel<"u"){var St=new MessageChannel,Et=St.port2;St.port1.onmessage=mt,yt=function(){Et.postMessage(null)}}else yt=function(){nt(mt,0)};function vt(wt){lt=wt,ct||(ct=!0,yt())}function Nt(wt,$t){dt=nt(function(){wt(a.unstable_now())},$t)}a.unstable_IdlePriority=5,a.unstable_ImmediatePriority=1,a.unstable_LowPriority=4,a.unstable_NormalPriority=3,a.unstable_Profiling=null,a.unstable_UserBlockingPriority=2,a.unstable_cancelCallback=function(wt){wt.callback=null},a.unstable_continueExecution=function(){tt||_e||(tt=!0,vt(ot))},a.unstable_forceFrameRate=function(wt){0>wt||125<wt?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):xt=0<wt?Math.floor(1e3/wt):5},a.unstable_getCurrentPriorityLevel=function(){return j},a.unstable_getFirstCallbackNode=function(){return i(g)},a.unstable_next=function(wt){switch(j){case 1:case 2:case 3:var $t=3;break;default:$t=j}var Ct=j;j=$t;try{return wt()}finally{j=Ct}},a.unstable_pauseExecution=function(){},a.unstable_requestPaint=function(){},a.unstable_runWithPriority=function(wt,$t){switch(wt){case 1:case 2:case 3:case 4:case 5:break;default:wt=3}var Ct=j;j=wt;try{return $t()}finally{j=Ct}},a.unstable_scheduleCallback=function(wt,$t,Ct){var Mt=a.unstable_now();switch(typeof Ct=="object"&&Ct!==null?(Ct=Ct.delay,Ct=typeof Ct=="number"&&0<Ct?Mt+Ct:Mt):Ct=Mt,wt){case 1:var Ot=-1;break;case 2:Ot=250;break;case 5:Ot=1073741823;break;case 4:Ot=1e4;break;default:Ot=5e3}return Ot=Ct+Ot,wt={id:b++,callback:$t,priorityLevel:wt,startTime:Ct,expirationTime:Ot,sortIndex:-1},Ct>Mt?(wt.sortIndex=Ct,e(_,wt),i(g)===null&&wt===i(_)&&(et?(rt(dt),dt=-1):et=!0,Nt(st,Ct-Mt))):(wt.sortIndex=Ot,e(g,wt),tt||_e||(tt=!0,vt(ot))),wt},a.unstable_shouldYield=ft,a.unstable_wrapCallback=function(wt){var $t=j;return function(){var Ct=j;j=$t;try{return wt.apply(this,arguments)}finally{j=Ct}}}})(scheduler_production_min);scheduler.exports=scheduler_production_min;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aa=reactExports,ca=schedulerExports;function p$1(a){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+a,i=1;i<arguments.length;i++)e+="&args[]="+encodeURIComponent(arguments[i]);return"Minified React error #"+a+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,e){ha(a,e),ha(a+"Capture",e)}function ha(a,e){for(ea[a]=e,a=0;a<e.length;a++)da.add(e[a])}var ia=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la={},ma={};function oa(a){return ja.call(ma,a)?!0:ja.call(la,a)?!1:ka.test(a)?ma[a]=!0:(la[a]=!0,!1)}function pa(a,e,i,s){if(i!==null&&i.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return s?!1:i!==null?!i.acceptsBooleans:(a=a.toLowerCase().slice(0,5),a!=="data-"&&a!=="aria-");default:return!1}}function qa(a,e,i,s){if(e===null||typeof e>"u"||pa(a,e,i,s))return!0;if(s)return!1;if(i!==null)switch(i.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function v(a,e,i,s,o,c,d){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=s,this.attributeNamespace=o,this.mustUseProperty=i,this.propertyName=a,this.type=e,this.sanitizeURL=c,this.removeEmptyString=d}var z={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var e=a[0];z[e]=new v(e,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var e=a.replace(ra,sa);z[e]=new v(e,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var e=a.replace(ra,sa);z[e]=new v(e,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var e=a.replace(ra,sa);z[e]=new v(e,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});z.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});function ta(a,e,i,s){var o=z.hasOwnProperty(e)?z[e]:null;(o!==null?o.type!==0:s||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(qa(e,i,o,s)&&(i=null),s||o===null?oa(e)&&(i===null?a.removeAttribute(e):a.setAttribute(e,""+i)):o.mustUseProperty?a[o.propertyName]=i===null?o.type===3?!1:"":i:(e=o.attributeName,s=o.attributeNamespace,i===null?a.removeAttribute(e):(o=o.type,i=o===3||o===4&&i===!0?"":""+i,s?a.setAttributeNS(s,e,i):a.setAttribute(e,i))))}var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy"),Ia=Symbol.for("react.offscreen"),Ja=Symbol.iterator;function Ka(a){return a===null||typeof a!="object"?null:(a=Ja&&a[Ja]||a["@@iterator"],typeof a=="function"?a:null)}var A$1=Object.assign,La;function Ma(a){if(La===void 0)try{throw Error()}catch(i){var e=i.stack.trim().match(/\n( *(at )?)/);La=e&&e[1]||""}return`
`+La+a}var Na=!1;function Oa(a,e){if(!a||Na)return"";Na=!0;var i=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(_){var s=_}Reflect.construct(a,[],e)}else{try{e.call()}catch(_){s=_}a.call(e.prototype)}else{try{throw Error()}catch(_){s=_}a()}}catch(_){if(_&&s&&typeof _.stack=="string"){for(var o=_.stack.split(`
`),c=s.stack.split(`
`),d=o.length-1,h=c.length-1;1<=d&&0<=h&&o[d]!==c[h];)h--;for(;1<=d&&0<=h;d--,h--)if(o[d]!==c[h]){if(d!==1||h!==1)do if(d--,h--,0>h||o[d]!==c[h]){var g=`
`+o[d].replace(" at new "," at ");return a.displayName&&g.includes("<anonymous>")&&(g=g.replace("<anonymous>",a.displayName)),g}while(1<=d&&0<=h);break}}}finally{Na=!1,Error.prepareStackTrace=i}return(a=a?a.displayName||a.name:"")?Ma(a):""}function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return""}}function Qa(a){if(a==null)return null;if(typeof a=="function")return a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case ya:return"Fragment";case wa:return"Portal";case Aa:return"Profiler";case za:return"StrictMode";case Ea:return"Suspense";case Fa:return"SuspenseList"}if(typeof a=="object")switch(a.$$typeof){case Ca:return(a.displayName||"Context")+".Consumer";case Ba:return(a._context.displayName||"Context")+".Provider";case Da:var e=a.render;return a=a.displayName,a||(a=e.displayName||e.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case Ga:return e=a.displayName||null,e!==null?e:Qa(a.type)||"Memo";case Ha:e=a._payload,a=a._init;try{return Qa(a(e))}catch{}}return null}function Ra(a){var e=a.type;switch(a.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=e.render,a=a.displayName||a.name||"",e.displayName||(a!==""?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Qa(e);case 8:return e===za?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function Sa(a){switch(typeof a){case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function Ta(a){var e=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Ua(a){var e=Ta(a)?"checked":"value",i=Object.getOwnPropertyDescriptor(a.constructor.prototype,e),s=""+a[e];if(!a.hasOwnProperty(e)&&typeof i<"u"&&typeof i.get=="function"&&typeof i.set=="function"){var o=i.get,c=i.set;return Object.defineProperty(a,e,{configurable:!0,get:function(){return o.call(this)},set:function(d){s=""+d,c.call(this,d)}}),Object.defineProperty(a,e,{enumerable:i.enumerable}),{getValue:function(){return s},setValue:function(d){s=""+d},stopTracking:function(){a._valueTracker=null,delete a[e]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var e=a._valueTracker;if(!e)return!0;var i=e.getValue(),s="";return a&&(s=Ta(a)?a.checked?"true":"false":a.value),a=s,a!==i?(e.setValue(a),!0):!1}function Xa(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}function Ya(a,e){var i=e.checked;return A$1({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:i??a._wrapperState.initialChecked})}function Za(a,e){var i=e.defaultValue==null?"":e.defaultValue,s=e.checked!=null?e.checked:e.defaultChecked;i=Sa(e.value!=null?e.value:i),a._wrapperState={initialChecked:s,initialValue:i,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function ab(a,e){e=e.checked,e!=null&&ta(a,"checked",e,!1)}function bb(a,e){ab(a,e);var i=Sa(e.value),s=e.type;if(i!=null)s==="number"?(i===0&&a.value===""||a.value!=i)&&(a.value=""+i):a.value!==""+i&&(a.value=""+i);else if(s==="submit"||s==="reset"){a.removeAttribute("value");return}e.hasOwnProperty("value")?cb(a,e.type,i):e.hasOwnProperty("defaultValue")&&cb(a,e.type,Sa(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(a.defaultChecked=!!e.defaultChecked)}function db(a,e,i){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var s=e.type;if(!(s!=="submit"&&s!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+a._wrapperState.initialValue,i||e===a.value||(a.value=e),a.defaultValue=e}i=a.name,i!==""&&(a.name=""),a.defaultChecked=!!a._wrapperState.initialChecked,i!==""&&(a.name=i)}function cb(a,e,i){(e!=="number"||Xa(a.ownerDocument)!==a)&&(i==null?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+i&&(a.defaultValue=""+i))}var eb=Array.isArray;function fb(a,e,i,s){if(a=a.options,e){e={};for(var o=0;o<i.length;o++)e["$"+i[o]]=!0;for(i=0;i<a.length;i++)o=e.hasOwnProperty("$"+a[i].value),a[i].selected!==o&&(a[i].selected=o),o&&s&&(a[i].defaultSelected=!0)}else{for(i=""+Sa(i),e=null,o=0;o<a.length;o++){if(a[o].value===i){a[o].selected=!0,s&&(a[o].defaultSelected=!0);return}e!==null||a[o].disabled||(e=a[o])}e!==null&&(e.selected=!0)}}function gb(a,e){if(e.dangerouslySetInnerHTML!=null)throw Error(p$1(91));return A$1({},e,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,e){var i=e.value;if(i==null){if(i=e.children,e=e.defaultValue,i!=null){if(e!=null)throw Error(p$1(92));if(eb(i)){if(1<i.length)throw Error(p$1(93));i=i[0]}e=i}e==null&&(e=""),i=e}a._wrapperState={initialValue:Sa(i)}}function ib(a,e){var i=Sa(e.value),s=Sa(e.defaultValue);i!=null&&(i=""+i,i!==a.value&&(a.value=i),e.defaultValue==null&&a.defaultValue!==i&&(a.defaultValue=i)),s!=null&&(a.defaultValue=""+s)}function jb(a){var e=a.textContent;e===a._wrapperState.initialValue&&e!==""&&e!==null&&(a.value=e)}function kb(a){switch(a){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function lb(a,e){return a==null||a==="http://www.w3.org/1999/xhtml"?kb(e):a==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":a}var mb,nb=function(a){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,i,s,o){MSApp.execUnsafeLocalFunction(function(){return a(e,i,s,o)})}:a}(function(a,e){if(a.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in a)a.innerHTML=e;else{for(mb=mb||document.createElement("div"),mb.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;e.firstChild;)a.appendChild(e.firstChild)}});function ob(a,e){if(e){var i=a.firstChild;if(i&&i===a.lastChild&&i.nodeType===3){i.nodeValue=e;return}}a.textContent=e}var pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(e){e=e+a.charAt(0).toUpperCase()+a.substring(1),pb[e]=pb[a]})});function rb(a,e,i){return e==null||typeof e=="boolean"||e===""?"":i||typeof e!="number"||e===0||pb.hasOwnProperty(a)&&pb[a]?(""+e).trim():e+"px"}function sb(a,e){a=a.style;for(var i in e)if(e.hasOwnProperty(i)){var s=i.indexOf("--")===0,o=rb(i,e[i],s);i==="float"&&(i="cssFloat"),s?a.setProperty(i,o):a[i]=o}}var tb=A$1({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ub(a,e){if(e){if(tb[a]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(p$1(137,a));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(p$1(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(p$1(61))}if(e.style!=null&&typeof e.style!="object")throw Error(p$1(62))}}function vb(a,e){if(a.indexOf("-")===-1)return typeof e.is=="string";switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wb=null;function xb(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var yb=null,zb=null,Ab=null;function Bb(a){if(a=Cb(a)){if(typeof yb!="function")throw Error(p$1(280));var e=a.stateNode;e&&(e=Db(e),yb(a.stateNode,a.type,e))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,e=Ab;if(Ab=zb=null,Bb(a),e)for(a=0;a<e.length;a++)Bb(e[a])}}function Gb(a,e){return a(e)}function Hb(){}var Ib=!1;function Jb(a,e,i){if(Ib)return a(e,i);Ib=!0;try{return Gb(a,e,i)}finally{Ib=!1,(zb!==null||Ab!==null)&&(Hb(),Fb())}}function Kb(a,e){var i=a.stateNode;if(i===null)return null;var s=Db(i);if(s===null)return null;i=s[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(a=a.type,s=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!s;break e;default:a=!1}if(a)return null;if(i&&typeof i!="function")throw Error(p$1(231,e,typeof i));return i}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0}}),window.addEventListener("test",Mb,Mb),window.removeEventListener("test",Mb,Mb)}catch{Lb=!1}function Nb(a,e,i,s,o,c,d,h,g){var _=Array.prototype.slice.call(arguments,3);try{e.apply(i,_)}catch(b){this.onError(b)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0,Pb=a}};function Tb(a,e,i,s,o,c,d,h,g){Ob=!1,Pb=null,Nb.apply(Sb,arguments)}function Ub(a,e,i,s,o,c,d,h,g){if(Tb.apply(this,arguments),Ob){if(Ob){var _=Pb;Ob=!1,Pb=null}else throw Error(p$1(198));Qb||(Qb=!0,Rb=_)}}function Vb(a){var e=a,i=a;if(a.alternate)for(;e.return;)e=e.return;else{a=e;do e=a,e.flags&4098&&(i=e.return),a=e.return;while(a)}return e.tag===3?i:null}function Wb(a){if(a.tag===13){var e=a.memoizedState;if(e===null&&(a=a.alternate,a!==null&&(e=a.memoizedState)),e!==null)return e.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p$1(188))}function Yb(a){var e=a.alternate;if(!e){if(e=Vb(a),e===null)throw Error(p$1(188));return e!==a?null:a}for(var i=a,s=e;;){var o=i.return;if(o===null)break;var c=o.alternate;if(c===null){if(s=o.return,s!==null){i=s;continue}break}if(o.child===c.child){for(c=o.child;c;){if(c===i)return Xb(o),a;if(c===s)return Xb(o),e;c=c.sibling}throw Error(p$1(188))}if(i.return!==s.return)i=o,s=c;else{for(var d=!1,h=o.child;h;){if(h===i){d=!0,i=o,s=c;break}if(h===s){d=!0,s=o,i=c;break}h=h.sibling}if(!d){for(h=c.child;h;){if(h===i){d=!0,i=c,s=o;break}if(h===s){d=!0,s=c,i=o;break}h=h.sibling}if(!d)throw Error(p$1(189))}}if(i.alternate!==s)throw Error(p$1(190))}if(i.tag!==3)throw Error(p$1(188));return i.stateNode.current===i?a:e}function Zb(a){return a=Yb(a),a!==null?$b(a):null}function $b(a){if(a.tag===5||a.tag===6)return a;for(a=a.child;a!==null;){var e=$b(a);if(e!==null)return e;a=a.sibling}return null}var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B$1=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&typeof lc.onCommitFiberRoot=="function")try{lc.onCommitFiberRoot(kc,a,void 0,(a.current.flags&128)===128)}catch{}}var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){return a>>>=0,a===0?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return a}}function uc(a,e){var i=a.pendingLanes;if(i===0)return 0;var s=0,o=a.suspendedLanes,c=a.pingedLanes,d=i&268435455;if(d!==0){var h=d&~o;h!==0?s=tc(h):(c&=d,c!==0&&(s=tc(c)))}else d=i&~o,d!==0?s=tc(d):c!==0&&(s=tc(c));if(s===0)return 0;if(e!==0&&e!==s&&!(e&o)&&(o=s&-s,c=e&-e,o>=c||o===16&&(c&4194240)!==0))return e;if(s&4&&(s|=i&16),e=a.entangledLanes,e!==0)for(a=a.entanglements,e&=s;0<e;)i=31-oc(e),o=1<<i,s|=a[i],e&=~o;return s}function vc(a,e){switch(a){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function wc(a,e){for(var i=a.suspendedLanes,s=a.pingedLanes,o=a.expirationTimes,c=a.pendingLanes;0<c;){var d=31-oc(c),h=1<<d,g=o[d];g===-1?(!(h&i)||h&s)&&(o[d]=vc(h,e)):g<=e&&(a.expiredLanes|=h),c&=~h}}function xc(a){return a=a.pendingLanes&-1073741825,a!==0?a:a&1073741824?1073741824:0}function yc(){var a=rc;return rc<<=1,!(rc&4194240)&&(rc=64),a}function zc(a){for(var e=[],i=0;31>i;i++)e.push(a);return e}function Ac(a,e,i){a.pendingLanes|=e,e!==536870912&&(a.suspendedLanes=0,a.pingedLanes=0),a=a.eventTimes,e=31-oc(e),a[e]=i}function Bc(a,e){var i=a.pendingLanes&~e;a.pendingLanes=e,a.suspendedLanes=0,a.pingedLanes=0,a.expiredLanes&=e,a.mutableReadLanes&=e,a.entangledLanes&=e,e=a.entanglements;var s=a.eventTimes;for(a=a.expirationTimes;0<i;){var o=31-oc(i),c=1<<o;e[o]=0,s[o]=-1,a[o]=-1,i&=~c}}function Cc(a,e){var i=a.entangledLanes|=e;for(a=a.entanglements;i;){var s=31-oc(i),o=1<<s;o&e|a[s]&e&&(a[s]|=e),i&=~o}}var C$1=0;function Dc(a){return a&=-a,1<a?4<a?a&268435455?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Sc(a,e){switch(a){case"focusin":case"focusout":Lc=null;break;case"dragenter":case"dragleave":Mc=null;break;case"mouseover":case"mouseout":Nc=null;break;case"pointerover":case"pointerout":Oc.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pc.delete(e.pointerId)}}function Tc(a,e,i,s,o,c){return a===null||a.nativeEvent!==c?(a={blockedOn:e,domEventName:i,eventSystemFlags:s,nativeEvent:c,targetContainers:[o]},e!==null&&(e=Cb(e),e!==null&&Fc(e)),a):(a.eventSystemFlags|=s,e=a.targetContainers,o!==null&&e.indexOf(o)===-1&&e.push(o),a)}function Uc(a,e,i,s,o){switch(e){case"focusin":return Lc=Tc(Lc,a,e,i,s,o),!0;case"dragenter":return Mc=Tc(Mc,a,e,i,s,o),!0;case"mouseover":return Nc=Tc(Nc,a,e,i,s,o),!0;case"pointerover":var c=o.pointerId;return Oc.set(c,Tc(Oc.get(c)||null,a,e,i,s,o)),!0;case"gotpointercapture":return c=o.pointerId,Pc.set(c,Tc(Pc.get(c)||null,a,e,i,s,o)),!0}return!1}function Vc(a){var e=Wc(a.target);if(e!==null){var i=Vb(e);if(i!==null){if(e=i.tag,e===13){if(e=Wb(i),e!==null){a.blockedOn=e,Ic(a.priority,function(){Gc(i)});return}}else if(e===3&&i.stateNode.current.memoizedState.isDehydrated){a.blockedOn=i.tag===3?i.stateNode.containerInfo:null;return}}}a.blockedOn=null}function Xc(a){if(a.blockedOn!==null)return!1;for(var e=a.targetContainers;0<e.length;){var i=Yc(a.domEventName,a.eventSystemFlags,e[0],a.nativeEvent);if(i===null){i=a.nativeEvent;var s=new i.constructor(i.type,i);wb=s,i.target.dispatchEvent(s),wb=null}else return e=Cb(i),e!==null&&Fc(e),a.blockedOn=i,!1;e.shift()}return!0}function Zc(a,e,i){Xc(a)&&i.delete(e)}function $c(){Jc=!1,Lc!==null&&Xc(Lc)&&(Lc=null),Mc!==null&&Xc(Mc)&&(Mc=null),Nc!==null&&Xc(Nc)&&(Nc=null),Oc.forEach(Zc),Pc.forEach(Zc)}function ad(a,e){a.blockedOn===e&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}function bd(a){function e(o){return ad(o,a)}if(0<Kc.length){ad(Kc[0],a);for(var i=1;i<Kc.length;i++){var s=Kc[i];s.blockedOn===a&&(s.blockedOn=null)}}for(Lc!==null&&ad(Lc,a),Mc!==null&&ad(Mc,a),Nc!==null&&ad(Nc,a),Oc.forEach(e),Pc.forEach(e),i=0;i<Qc.length;i++)s=Qc[i],s.blockedOn===a&&(s.blockedOn=null);for(;0<Qc.length&&(i=Qc[0],i.blockedOn===null);)Vc(i),i.blockedOn===null&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;function ed(a,e,i,s){var o=C$1,c=cd.transition;cd.transition=null;try{C$1=1,fd(a,e,i,s)}finally{C$1=o,cd.transition=c}}function gd(a,e,i,s){var o=C$1,c=cd.transition;cd.transition=null;try{C$1=4,fd(a,e,i,s)}finally{C$1=o,cd.transition=c}}function fd(a,e,i,s){if(dd){var o=Yc(a,e,i,s);if(o===null)hd(a,e,s,id,i),Sc(a,s);else if(Uc(o,a,e,i,s))s.stopPropagation();else if(Sc(a,s),e&4&&-1<Rc.indexOf(a)){for(;o!==null;){var c=Cb(o);if(c!==null&&Ec(c),c=Yc(a,e,i,s),c===null&&hd(a,e,s,id,i),c===o)break;o=c}o!==null&&s.stopPropagation()}else hd(a,e,s,null,i)}}var id=null;function Yc(a,e,i,s){if(id=null,a=xb(s),a=Wc(a),a!==null)if(e=Vb(a),e===null)a=null;else if(i=e.tag,i===13){if(a=Wb(e),a!==null)return a;a=null}else if(i===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;a=null}else e!==a&&(a=null);return id=a,null}function jd(a){switch(a){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,e=ld,i=e.length,s,o="value"in kd?kd.value:kd.textContent,c=o.length;for(a=0;a<i&&e[a]===o[a];a++);var d=i-a;for(s=1;s<=d&&e[i-s]===o[c-s];s++);return md=o.slice(a,1<s?1-s:void 0)}function od(a){var e=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&e===13&&(a=13)):a=e,a===10&&(a=13),32<=a||a===13?a:0}function pd(){return!0}function qd(){return!1}function rd(a){function e(i,s,o,c,d){this._reactName=i,this._targetInst=o,this.type=s,this.nativeEvent=c,this.target=d,this.currentTarget=null;for(var h in a)a.hasOwnProperty(h)&&(i=a[h],this[h]=i?i(c):c[h]);return this.isDefaultPrevented=(c.defaultPrevented!=null?c.defaultPrevented:c.returnValue===!1)?pd:qd,this.isPropagationStopped=qd,this}return A$1(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var i=this.nativeEvent;i&&(i.preventDefault?i.preventDefault():typeof i.returnValue!="unknown"&&(i.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var i=this.nativeEvent;i&&(i.stopPropagation?i.stopPropagation():typeof i.cancelBubble!="unknown"&&(i.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd}),e}var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A$1({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A$1({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==yd&&(yd&&a.type==="mousemove"?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a),wd)},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A$1({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A$1({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A$1({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A$1({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A$1({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(a):(a=Od[a])?!!e[a]:!1}function zd(){return Pd}var Qd=A$1({},ud,{key:function(a){if(a.key){var e=Md[a.key]||a.key;if(e!=="Unidentified")return e}return a.type==="keypress"?(a=od(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return a.type==="keypress"?od(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?od(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),Rd=rd(Qd),Sd=A$1({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A$1({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A$1({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A$1({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=" ",fe=!1;function ge(a,e){switch(a){case"keyup":return $d.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function he(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var ie=!1;function je(a,e){switch(a){case"compositionend":return he(e);case"keypress":return e.which!==32?null:(fe=!0,ee);case"textInput":return a=e.data,a===ee&&fe?null:a;default:return null}}function ke(a,e){if(ie)return a==="compositionend"||!ae&&ge(a,e)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return de&&e.locale!=="ko"?null:e.data;default:return null}}var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var e=a&&a.nodeName&&a.nodeName.toLowerCase();return e==="input"?!!le[a.type]:e==="textarea"}function ne(a,e,i,s){Eb(s),e=oe(e,"onChange"),0<e.length&&(i=new td("onChange","change",null,i,s),a.push({event:i,listeners:e}))}var pe=null,qe=null;function re$1(a){se(a,0)}function te(a){var e=ue(a);if(Wa(e))return a}function ve(a,e){if(a==="change")return e}var we=!1;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;"),ye=typeof ze.oninput=="function"}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if(a.propertyName==="value"&&te(qe)){var e=[];ne(e,qe,a,xb(a)),Jb(re$1,e)}}function Ce(a,e,i){a==="focusin"?(Ae(),pe=e,qe=i,pe.attachEvent("onpropertychange",Be)):a==="focusout"&&Ae()}function De(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return te(qe)}function Ee(a,e){if(a==="click")return te(e)}function Fe(a,e){if(a==="input"||a==="change")return te(e)}function Ge(a,e){return a===e&&(a!==0||1/a===1/e)||a!==a&&e!==e}var He=typeof Object.is=="function"?Object.is:Ge;function Ie(a,e){if(He(a,e))return!0;if(typeof a!="object"||a===null||typeof e!="object"||e===null)return!1;var i=Object.keys(a),s=Object.keys(e);if(i.length!==s.length)return!1;for(s=0;s<i.length;s++){var o=i[s];if(!ja.call(e,o)||!He(a[o],e[o]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function Ke(a,e){var i=Je(a);a=0;for(var s;i;){if(i.nodeType===3){if(s=a+i.textContent.length,a<=e&&s>=e)return{node:i,offset:e-a};a=s}e:{for(;i;){if(i.nextSibling){i=i.nextSibling;break e}i=i.parentNode}i=void 0}i=Je(i)}}function Le(a,e){return a&&e?a===e?!0:a&&a.nodeType===3?!1:e&&e.nodeType===3?Le(a,e.parentNode):"contains"in a?a.contains(e):a.compareDocumentPosition?!!(a.compareDocumentPosition(e)&16):!1:!1}function Me(){for(var a=window,e=Xa();e instanceof a.HTMLIFrameElement;){try{var i=typeof e.contentWindow.location.href=="string"}catch{i=!1}if(i)a=e.contentWindow;else break;e=Xa(a.document)}return e}function Ne(a){var e=a&&a.nodeName&&a.nodeName.toLowerCase();return e&&(e==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||e==="textarea"||a.contentEditable==="true")}function Oe(a){var e=Me(),i=a.focusedElem,s=a.selectionRange;if(e!==i&&i&&i.ownerDocument&&Le(i.ownerDocument.documentElement,i)){if(s!==null&&Ne(i)){if(e=s.start,a=s.end,a===void 0&&(a=e),"selectionStart"in i)i.selectionStart=e,i.selectionEnd=Math.min(a,i.value.length);else if(a=(e=i.ownerDocument||document)&&e.defaultView||window,a.getSelection){a=a.getSelection();var o=i.textContent.length,c=Math.min(s.start,o);s=s.end===void 0?c:Math.min(s.end,o),!a.extend&&c>s&&(o=s,s=c,c=o),o=Ke(i,c);var d=Ke(i,s);o&&d&&(a.rangeCount!==1||a.anchorNode!==o.node||a.anchorOffset!==o.offset||a.focusNode!==d.node||a.focusOffset!==d.offset)&&(e=e.createRange(),e.setStart(o.node,o.offset),a.removeAllRanges(),c>s?(a.addRange(e),a.extend(d.node,d.offset)):(e.setEnd(d.node,d.offset),a.addRange(e)))}}for(e=[],a=i;a=a.parentNode;)a.nodeType===1&&e.push({element:a,left:a.scrollLeft,top:a.scrollTop});for(typeof i.focus=="function"&&i.focus(),i=0;i<e.length;i++)a=e[i],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;function Ue(a,e,i){var s=i.window===i?i.document:i.nodeType===9?i:i.ownerDocument;Te||Qe==null||Qe!==Xa(s)||(s=Qe,"selectionStart"in s&&Ne(s)?s={start:s.selectionStart,end:s.selectionEnd}:(s=(s.ownerDocument&&s.ownerDocument.defaultView||window).getSelection(),s={anchorNode:s.anchorNode,anchorOffset:s.anchorOffset,focusNode:s.focusNode,focusOffset:s.focusOffset}),Se&&Ie(Se,s)||(Se=s,s=oe(Re,"onSelect"),0<s.length&&(e=new td("onSelect","select",null,e,i),a.push({event:e,listeners:s}),e.target=Qe)))}function Ve(a,e){var i={};return i[a.toLowerCase()]=e.toLowerCase(),i["Webkit"+a]="webkit"+e,i["Moz"+a]="moz"+e,i}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var e=We[a],i;for(i in e)if(e.hasOwnProperty(i)&&i in Ye)return Xe[a]=e[i];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function ff(a,e){df.set(a,e),fa(e,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf)}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));function nf(a,e,i){var s=a.type||"unknown-event";a.currentTarget=i,Ub(s,e,void 0,a),a.currentTarget=null}function se(a,e){e=(e&4)!==0;for(var i=0;i<a.length;i++){var s=a[i],o=s.event;s=s.listeners;e:{var c=void 0;if(e)for(var d=s.length-1;0<=d;d--){var h=s[d],g=h.instance,_=h.currentTarget;if(h=h.listener,g!==c&&o.isPropagationStopped())break e;nf(o,h,_),c=g}else for(d=0;d<s.length;d++){if(h=s[d],g=h.instance,_=h.currentTarget,h=h.listener,g!==c&&o.isPropagationStopped())break e;nf(o,h,_),c=g}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a}function D(a,e){var i=e[of];i===void 0&&(i=e[of]=new Set);var s=a+"__bubble";i.has(s)||(pf(e,a,2,!1),i.add(s))}function qf(a,e,i){var s=0;e&&(s|=4),pf(i,a,s,e)}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0,da.forEach(function(i){i!=="selectionchange"&&(mf.has(i)||qf(i,!1,a),qf(i,!0,a))});var e=a.nodeType===9?a:a.ownerDocument;e===null||e[rf]||(e[rf]=!0,qf("selectionchange",!1,e))}}function pf(a,e,i,s){switch(jd(e)){case 1:var o=ed;break;case 4:o=gd;break;default:o=fd}i=o.bind(null,e,i,a),o=void 0,!Lb||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(o=!0),s?o!==void 0?a.addEventListener(e,i,{capture:!0,passive:o}):a.addEventListener(e,i,!0):o!==void 0?a.addEventListener(e,i,{passive:o}):a.addEventListener(e,i,!1)}function hd(a,e,i,s,o){var c=s;if(!(e&1)&&!(e&2)&&s!==null)e:for(;;){if(s===null)return;var d=s.tag;if(d===3||d===4){var h=s.stateNode.containerInfo;if(h===o||h.nodeType===8&&h.parentNode===o)break;if(d===4)for(d=s.return;d!==null;){var g=d.tag;if((g===3||g===4)&&(g=d.stateNode.containerInfo,g===o||g.nodeType===8&&g.parentNode===o))return;d=d.return}for(;h!==null;){if(d=Wc(h),d===null)return;if(g=d.tag,g===5||g===6){s=c=d;continue e}h=h.parentNode}}s=s.return}Jb(function(){var _=c,b=xb(i),$=[];e:{var j=df.get(a);if(j!==void 0){var _e=td,tt=a;switch(a){case"keypress":if(od(i)===0)break e;case"keydown":case"keyup":_e=Rd;break;case"focusin":tt="focus",_e=Fd;break;case"focusout":tt="blur",_e=Fd;break;case"beforeblur":case"afterblur":_e=Fd;break;case"click":if(i.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":_e=Bd;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":_e=Dd;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":_e=Vd;break;case $e:case af:case bf:_e=Hd;break;case cf:_e=Xd;break;case"scroll":_e=vd;break;case"wheel":_e=Zd;break;case"copy":case"cut":case"paste":_e=Jd;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":_e=Td}var et=(e&4)!==0,nt=!et&&a==="scroll",rt=et?j!==null?j+"Capture":null:j;et=[];for(var it=_,at;it!==null;){at=it;var st=at.stateNode;if(at.tag===5&&st!==null&&(at=st,rt!==null&&(st=Kb(it,rt),st!=null&&et.push(tf(it,st,at)))),nt)break;it=it.return}0<et.length&&(j=new _e(j,tt,null,i,b),$.push({event:j,listeners:et}))}}if(!(e&7)){e:{if(j=a==="mouseover"||a==="pointerover",_e=a==="mouseout"||a==="pointerout",j&&i!==wb&&(tt=i.relatedTarget||i.fromElement)&&(Wc(tt)||tt[uf]))break e;if((_e||j)&&(j=b.window===b?b:(j=b.ownerDocument)?j.defaultView||j.parentWindow:window,_e?(tt=i.relatedTarget||i.toElement,_e=_,tt=tt?Wc(tt):null,tt!==null&&(nt=Vb(tt),tt!==nt||tt.tag!==5&&tt.tag!==6)&&(tt=null)):(_e=null,tt=_),_e!==tt)){if(et=Bd,st="onMouseLeave",rt="onMouseEnter",it="mouse",(a==="pointerout"||a==="pointerover")&&(et=Td,st="onPointerLeave",rt="onPointerEnter",it="pointer"),nt=_e==null?j:ue(_e),at=tt==null?j:ue(tt),j=new et(st,it+"leave",_e,i,b),j.target=nt,j.relatedTarget=at,st=null,Wc(b)===_&&(et=new et(rt,it+"enter",tt,i,b),et.target=at,et.relatedTarget=nt,st=et),nt=st,_e&&tt)t:{for(et=_e,rt=tt,it=0,at=et;at;at=vf(at))it++;for(at=0,st=rt;st;st=vf(st))at++;for(;0<it-at;)et=vf(et),it--;for(;0<at-it;)rt=vf(rt),at--;for(;it--;){if(et===rt||rt!==null&&et===rt.alternate)break t;et=vf(et),rt=vf(rt)}et=null}else et=null;_e!==null&&wf($,j,_e,et,!1),tt!==null&&nt!==null&&wf($,nt,tt,et,!0)}}e:{if(j=_?ue(_):window,_e=j.nodeName&&j.nodeName.toLowerCase(),_e==="select"||_e==="input"&&j.type==="file")var ot=ve;else if(me(j))if(we)ot=Fe;else{ot=De;var ct=Ce}else(_e=j.nodeName)&&_e.toLowerCase()==="input"&&(j.type==="checkbox"||j.type==="radio")&&(ot=Ee);if(ot&&(ot=ot(a,_))){ne($,ot,i,b);break e}ct&&ct(a,j,_),a==="focusout"&&(ct=j._wrapperState)&&ct.controlled&&j.type==="number"&&cb(j,"number",j.value)}switch(ct=_?ue(_):window,a){case"focusin":(me(ct)||ct.contentEditable==="true")&&(Qe=ct,Re=_,Se=null);break;case"focusout":Se=Re=Qe=null;break;case"mousedown":Te=!0;break;case"contextmenu":case"mouseup":case"dragend":Te=!1,Ue($,i,b);break;case"selectionchange":if(Pe)break;case"keydown":case"keyup":Ue($,i,b)}var lt;if(ae)e:{switch(a){case"compositionstart":var dt="onCompositionStart";break e;case"compositionend":dt="onCompositionEnd";break e;case"compositionupdate":dt="onCompositionUpdate";break e}dt=void 0}else ie?ge(a,i)&&(dt="onCompositionEnd"):a==="keydown"&&i.keyCode===229&&(dt="onCompositionStart");dt&&(de&&i.locale!=="ko"&&(ie||dt!=="onCompositionStart"?dt==="onCompositionEnd"&&ie&&(lt=nd()):(kd=b,ld="value"in kd?kd.value:kd.textContent,ie=!0)),ct=oe(_,dt),0<ct.length&&(dt=new Ld(dt,a,null,i,b),$.push({event:dt,listeners:ct}),lt?dt.data=lt:(lt=he(i),lt!==null&&(dt.data=lt)))),(lt=ce?je(a,i):ke(a,i))&&(_=oe(_,"onBeforeInput"),0<_.length&&(b=new Ld("onBeforeInput","beforeinput",null,i,b),$.push({event:b,listeners:_}),b.data=lt))}se($,e)})}function tf(a,e,i){return{instance:a,listener:e,currentTarget:i}}function oe(a,e){for(var i=e+"Capture",s=[];a!==null;){var o=a,c=o.stateNode;o.tag===5&&c!==null&&(o=c,c=Kb(a,i),c!=null&&s.unshift(tf(a,c,o)),c=Kb(a,e),c!=null&&s.push(tf(a,c,o))),a=a.return}return s}function vf(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5);return a||null}function wf(a,e,i,s,o){for(var c=e._reactName,d=[];i!==null&&i!==s;){var h=i,g=h.alternate,_=h.stateNode;if(g!==null&&g===s)break;h.tag===5&&_!==null&&(h=_,o?(g=Kb(i,c),g!=null&&d.unshift(tf(i,g,h))):o||(g=Kb(i,c),g!=null&&d.push(tf(i,g,h)))),i=i.return}d.length!==0&&a.push({event:e,listeners:d})}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return(typeof a=="string"?a:""+a).replace(xf,`
`).replace(yf,"")}function Af(a,e,i){if(e=zf(e),zf(a)!==e&&i)throw Error(p$1(425))}function Bf(){}var Cf=null,Df=null;function Ef(a,e){return a==="textarea"||a==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var Ff=typeof setTimeout=="function"?setTimeout:void 0,Gf=typeof clearTimeout=="function"?clearTimeout:void 0,Hf=typeof Promise=="function"?Promise:void 0,Jf=typeof queueMicrotask=="function"?queueMicrotask:typeof Hf<"u"?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a})}function Kf(a,e){var i=e,s=0;do{var o=i.nextSibling;if(a.removeChild(i),o&&o.nodeType===8)if(i=o.data,i==="/$"){if(s===0){a.removeChild(o),bd(e);return}s--}else i!=="$"&&i!=="$?"&&i!=="$!"||s++;i=o}while(i);bd(e)}function Lf(a){for(;a!=null;a=a.nextSibling){var e=a.nodeType;if(e===1||e===3)break;if(e===8){if(e=a.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return a}function Mf(a){a=a.previousSibling;for(var e=0;a;){if(a.nodeType===8){var i=a.data;if(i==="$"||i==="$!"||i==="$?"){if(e===0)return a;e--}else i==="/$"&&e++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;function Wc(a){var e=a[Of];if(e)return e;for(var i=a.parentNode;i;){if(e=i[uf]||i[Of]){if(i=e.alternate,e.child!==null||i!==null&&i.child!==null)for(a=Mf(a);a!==null;){if(i=a[Of])return i;a=Mf(a)}return e}a=i,i=a.parentNode}return null}function Cb(a){return a=a[Of]||a[uf],!a||a.tag!==5&&a.tag!==6&&a.tag!==13&&a.tag!==3?null:a}function ue(a){if(a.tag===5||a.tag===6)return a.stateNode;throw Error(p$1(33))}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}function E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,e){Tf++,Sf[Tf]=a.current,a.current=e}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,e){var i=a.type.contextTypes;if(!i)return Vf;var s=a.stateNode;if(s&&s.__reactInternalMemoizedUnmaskedChildContext===e)return s.__reactInternalMemoizedMaskedChildContext;var o={},c;for(c in i)o[c]=e[c];return s&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=o),o}function Zf(a){return a=a.childContextTypes,a!=null}function $f(){E(Wf),E(H)}function ag(a,e,i){if(H.current!==Vf)throw Error(p$1(168));G(H,e),G(Wf,i)}function bg(a,e,i){var s=a.stateNode;if(e=e.childContextTypes,typeof s.getChildContext!="function")return i;s=s.getChildContext();for(var o in s)if(!(o in e))throw Error(p$1(108,Ra(a)||"Unknown",o));return A$1({},i,s)}function cg(a){return a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf,Xf=H.current,G(H,a),G(Wf,Wf.current),!0}function dg(a,e,i){var s=a.stateNode;if(!s)throw Error(p$1(169));i?(a=bg(a,e,Xf),s.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf),G(Wf,i)}var eg=null,fg=!1,gg=!1;function hg(a){eg===null?eg=[a]:eg.push(a)}function ig(a){fg=!0,hg(a)}function jg(){if(!gg&&eg!==null){gg=!0;var a=0,e=C$1;try{var i=eg;for(C$1=1;a<i.length;a++){var s=i[a];do s=s(!0);while(s!==null)}eg=null,fg=!1}catch(o){throw eg!==null&&(eg=eg.slice(a+1)),ac(fc,jg),o}finally{C$1=e,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,e){kg[lg++]=ng,kg[lg++]=mg,mg=a,ng=e}function ug(a,e,i){og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,qg=a;var s=rg;a=sg;var o=32-oc(s)-1;s&=~(1<<o),i+=1;var c=32-oc(e)+o;if(30<c){var d=o-o%5;c=(s&(1<<d)-1).toString(32),s>>=d,o-=d,rg=1<<32-oc(e)+o|i<<o|s,sg=c+a}else rg=1<<c|i<<o|s,sg=a}function vg(a){a.return!==null&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;function Ag(a,e){var i=Bg(5,null,null,0);i.elementType="DELETED",i.stateNode=e,i.return=a,e=a.deletions,e===null?(a.deletions=[i],a.flags|=16):e.push(i)}function Cg(a,e){switch(a.tag){case 5:var i=a.type;return e=e.nodeType!==1||i.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(a.stateNode=e,xg=a,yg=Lf(e.firstChild),!0):!1;case 6:return e=a.pendingProps===""||e.nodeType!==3?null:e,e!==null?(a.stateNode=e,xg=a,yg=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(i=qg!==null?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:e,treeContext:i,retryLane:1073741824},i=Bg(18,null,null,0),i.stateNode=e,i.return=a,a.child=i,xg=a,yg=null,!0):!1;default:return!1}}function Dg(a){return(a.mode&1)!==0&&(a.flags&128)===0}function Eg(a){if(I){var e=yg;if(e){var i=e;if(!Cg(a,e)){if(Dg(a))throw Error(p$1(418));e=Lf(i.nextSibling);var s=xg;e&&Cg(a,e)?Ag(s,i):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p$1(418));a.flags=a.flags&-4097|2,I=!1,xg=a}}}function Fg(a){for(a=a.return;a!==null&&a.tag!==5&&a.tag!==3&&a.tag!==13;)a=a.return;xg=a}function Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var e;if((e=a.tag!==3)&&!(e=a.tag!==5)&&(e=a.type,e=e!=="head"&&e!=="body"&&!Ef(a.type,a.memoizedProps)),e&&(e=yg)){if(Dg(a))throw Hg(),Error(p$1(418));for(;e;)Ag(a,e),e=Lf(e.nextSibling)}if(Fg(a),a.tag===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(p$1(317));e:{for(a=a.nextSibling,e=0;a;){if(a.nodeType===8){var i=a.data;if(i==="/$"){if(e===0){yg=Lf(a.nextSibling);break e}e--}else i!=="$"&&i!=="$!"&&i!=="$?"||e++}a=a.nextSibling}yg=null}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null,I=!1}function Jg(a){zg===null?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,e,i){if(a=i.ref,a!==null&&typeof a!="function"&&typeof a!="object"){if(i._owner){if(i=i._owner,i){if(i.tag!==1)throw Error(p$1(309));var s=i.stateNode}if(!s)throw Error(p$1(147,a));var o=s,c=""+a;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===c?e.ref:(e=function(d){var h=o.refs;d===null?delete h[c]:h[c]=d},e._stringRef=c,e)}if(typeof a!="string")throw Error(p$1(284));if(!i._owner)throw Error(p$1(290,a))}return a}function Mg(a,e){throw a=Object.prototype.toString.call(e),Error(p$1(31,a==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":a))}function Ng(a){var e=a._init;return e(a._payload)}function Og(a){function e(rt,it){if(a){var at=rt.deletions;at===null?(rt.deletions=[it],rt.flags|=16):at.push(it)}}function i(rt,it){if(!a)return null;for(;it!==null;)e(rt,it),it=it.sibling;return null}function s(rt,it){for(rt=new Map;it!==null;)it.key!==null?rt.set(it.key,it):rt.set(it.index,it),it=it.sibling;return rt}function o(rt,it){return rt=Pg(rt,it),rt.index=0,rt.sibling=null,rt}function c(rt,it,at){return rt.index=at,a?(at=rt.alternate,at!==null?(at=at.index,at<it?(rt.flags|=2,it):at):(rt.flags|=2,it)):(rt.flags|=1048576,it)}function d(rt){return a&&rt.alternate===null&&(rt.flags|=2),rt}function h(rt,it,at,st){return it===null||it.tag!==6?(it=Qg(at,rt.mode,st),it.return=rt,it):(it=o(it,at),it.return=rt,it)}function g(rt,it,at,st){var ot=at.type;return ot===ya?b(rt,it,at.props.children,st,at.key):it!==null&&(it.elementType===ot||typeof ot=="object"&&ot!==null&&ot.$$typeof===Ha&&Ng(ot)===it.type)?(st=o(it,at.props),st.ref=Lg(rt,it,at),st.return=rt,st):(st=Rg(at.type,at.key,at.props,null,rt.mode,st),st.ref=Lg(rt,it,at),st.return=rt,st)}function _(rt,it,at,st){return it===null||it.tag!==4||it.stateNode.containerInfo!==at.containerInfo||it.stateNode.implementation!==at.implementation?(it=Sg(at,rt.mode,st),it.return=rt,it):(it=o(it,at.children||[]),it.return=rt,it)}function b(rt,it,at,st,ot){return it===null||it.tag!==7?(it=Tg(at,rt.mode,st,ot),it.return=rt,it):(it=o(it,at),it.return=rt,it)}function $(rt,it,at){if(typeof it=="string"&&it!==""||typeof it=="number")return it=Qg(""+it,rt.mode,at),it.return=rt,it;if(typeof it=="object"&&it!==null){switch(it.$$typeof){case va:return at=Rg(it.type,it.key,it.props,null,rt.mode,at),at.ref=Lg(rt,null,it),at.return=rt,at;case wa:return it=Sg(it,rt.mode,at),it.return=rt,it;case Ha:var st=it._init;return $(rt,st(it._payload),at)}if(eb(it)||Ka(it))return it=Tg(it,rt.mode,at,null),it.return=rt,it;Mg(rt,it)}return null}function j(rt,it,at,st){var ot=it!==null?it.key:null;if(typeof at=="string"&&at!==""||typeof at=="number")return ot!==null?null:h(rt,it,""+at,st);if(typeof at=="object"&&at!==null){switch(at.$$typeof){case va:return at.key===ot?g(rt,it,at,st):null;case wa:return at.key===ot?_(rt,it,at,st):null;case Ha:return ot=at._init,j(rt,it,ot(at._payload),st)}if(eb(at)||Ka(at))return ot!==null?null:b(rt,it,at,st,null);Mg(rt,at)}return null}function _e(rt,it,at,st,ot){if(typeof st=="string"&&st!==""||typeof st=="number")return rt=rt.get(at)||null,h(it,rt,""+st,ot);if(typeof st=="object"&&st!==null){switch(st.$$typeof){case va:return rt=rt.get(st.key===null?at:st.key)||null,g(it,rt,st,ot);case wa:return rt=rt.get(st.key===null?at:st.key)||null,_(it,rt,st,ot);case Ha:var ct=st._init;return _e(rt,it,at,ct(st._payload),ot)}if(eb(st)||Ka(st))return rt=rt.get(at)||null,b(it,rt,st,ot,null);Mg(it,st)}return null}function tt(rt,it,at,st){for(var ot=null,ct=null,lt=it,dt=it=0,xt=null;lt!==null&&dt<at.length;dt++){lt.index>dt?(xt=lt,lt=null):xt=lt.sibling;var ut=j(rt,lt,at[dt],st);if(ut===null){lt===null&&(lt=xt);break}a&&lt&&ut.alternate===null&&e(rt,lt),it=c(ut,it,dt),ct===null?ot=ut:ct.sibling=ut,ct=ut,lt=xt}if(dt===at.length)return i(rt,lt),I&&tg(rt,dt),ot;if(lt===null){for(;dt<at.length;dt++)lt=$(rt,at[dt],st),lt!==null&&(it=c(lt,it,dt),ct===null?ot=lt:ct.sibling=lt,ct=lt);return I&&tg(rt,dt),ot}for(lt=s(rt,lt);dt<at.length;dt++)xt=_e(lt,rt,dt,at[dt],st),xt!==null&&(a&&xt.alternate!==null&&lt.delete(xt.key===null?dt:xt.key),it=c(xt,it,dt),ct===null?ot=xt:ct.sibling=xt,ct=xt);return a&&lt.forEach(function(ft){return e(rt,ft)}),I&&tg(rt,dt),ot}function et(rt,it,at,st){var ot=Ka(at);if(typeof ot!="function")throw Error(p$1(150));if(at=ot.call(at),at==null)throw Error(p$1(151));for(var ct=ot=null,lt=it,dt=it=0,xt=null,ut=at.next();lt!==null&&!ut.done;dt++,ut=at.next()){lt.index>dt?(xt=lt,lt=null):xt=lt.sibling;var ft=j(rt,lt,ut.value,st);if(ft===null){lt===null&&(lt=xt);break}a&&lt&&ft.alternate===null&&e(rt,lt),it=c(ft,it,dt),ct===null?ot=ft:ct.sibling=ft,ct=ft,lt=xt}if(ut.done)return i(rt,lt),I&&tg(rt,dt),ot;if(lt===null){for(;!ut.done;dt++,ut=at.next())ut=$(rt,ut.value,st),ut!==null&&(it=c(ut,it,dt),ct===null?ot=ut:ct.sibling=ut,ct=ut);return I&&tg(rt,dt),ot}for(lt=s(rt,lt);!ut.done;dt++,ut=at.next())ut=_e(lt,rt,dt,ut.value,st),ut!==null&&(a&&ut.alternate!==null&&lt.delete(ut.key===null?dt:ut.key),it=c(ut,it,dt),ct===null?ot=ut:ct.sibling=ut,ct=ut);return a&&lt.forEach(function(mt){return e(rt,mt)}),I&&tg(rt,dt),ot}function nt(rt,it,at,st){if(typeof at=="object"&&at!==null&&at.type===ya&&at.key===null&&(at=at.props.children),typeof at=="object"&&at!==null){switch(at.$$typeof){case va:e:{for(var ot=at.key,ct=it;ct!==null;){if(ct.key===ot){if(ot=at.type,ot===ya){if(ct.tag===7){i(rt,ct.sibling),it=o(ct,at.props.children),it.return=rt,rt=it;break e}}else if(ct.elementType===ot||typeof ot=="object"&&ot!==null&&ot.$$typeof===Ha&&Ng(ot)===ct.type){i(rt,ct.sibling),it=o(ct,at.props),it.ref=Lg(rt,ct,at),it.return=rt,rt=it;break e}i(rt,ct);break}else e(rt,ct);ct=ct.sibling}at.type===ya?(it=Tg(at.props.children,rt.mode,st,at.key),it.return=rt,rt=it):(st=Rg(at.type,at.key,at.props,null,rt.mode,st),st.ref=Lg(rt,it,at),st.return=rt,rt=st)}return d(rt);case wa:e:{for(ct=at.key;it!==null;){if(it.key===ct)if(it.tag===4&&it.stateNode.containerInfo===at.containerInfo&&it.stateNode.implementation===at.implementation){i(rt,it.sibling),it=o(it,at.children||[]),it.return=rt,rt=it;break e}else{i(rt,it);break}else e(rt,it);it=it.sibling}it=Sg(at,rt.mode,st),it.return=rt,rt=it}return d(rt);case Ha:return ct=at._init,nt(rt,it,ct(at._payload),st)}if(eb(at))return tt(rt,it,at,st);if(Ka(at))return et(rt,it,at,st);Mg(rt,at)}return typeof at=="string"&&at!==""||typeof at=="number"?(at=""+at,it!==null&&it.tag===6?(i(rt,it.sibling),it=o(it,at),it.return=rt,rt=it):(i(rt,it),it=Qg(at,rt.mode,st),it.return=rt,rt=it),d(rt)):i(rt,it)}return nt}var Ug=Og(!0),Vg=Og(!1),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null}function ah(a){var e=Wg.current;E(Wg),a._currentValue=e}function bh(a,e,i){for(;a!==null;){var s=a.alternate;if((a.childLanes&e)!==e?(a.childLanes|=e,s!==null&&(s.childLanes|=e)):s!==null&&(s.childLanes&e)!==e&&(s.childLanes|=e),a===i)break;a=a.return}}function ch(a,e){Xg=a,Zg=Yg=null,a=a.dependencies,a!==null&&a.firstContext!==null&&(a.lanes&e&&(dh=!0),a.firstContext=null)}function eh(a){var e=a._currentValue;if(Zg!==a)if(a={context:a,memoizedValue:e,next:null},Yg===null){if(Xg===null)throw Error(p$1(308));Yg=a,Xg.dependencies={lanes:0,firstContext:a}}else Yg=Yg.next=a;return e}var fh=null;function gh(a){fh===null?fh=[a]:fh.push(a)}function hh(a,e,i,s){var o=e.interleaved;return o===null?(i.next=i,gh(e)):(i.next=o.next,o.next=i),e.interleaved=i,ih(a,s)}function ih(a,e){a.lanes|=e;var i=a.alternate;for(i!==null&&(i.lanes|=e),i=a,a=a.return;a!==null;)a.childLanes|=e,i=a.alternate,i!==null&&(i.childLanes|=e),i=a,a=a.return;return i.tag===3?i.stateNode:null}var jh=!1;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function lh(a,e){a=a.updateQueue,e.updateQueue===a&&(e.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function mh(a,e){return{eventTime:a,lane:e,tag:0,payload:null,callback:null,next:null}}function nh(a,e,i){var s=a.updateQueue;if(s===null)return null;if(s=s.shared,K&2){var o=s.pending;return o===null?e.next=e:(e.next=o.next,o.next=e),s.pending=e,ih(a,i)}return o=s.interleaved,o===null?(e.next=e,gh(s)):(e.next=o.next,o.next=e),s.interleaved=e,ih(a,i)}function oh(a,e,i){if(e=e.updateQueue,e!==null&&(e=e.shared,(i&4194240)!==0)){var s=e.lanes;s&=a.pendingLanes,i|=s,e.lanes=i,Cc(a,i)}}function ph(a,e){var i=a.updateQueue,s=a.alternate;if(s!==null&&(s=s.updateQueue,i===s)){var o=null,c=null;if(i=i.firstBaseUpdate,i!==null){do{var d={eventTime:i.eventTime,lane:i.lane,tag:i.tag,payload:i.payload,callback:i.callback,next:null};c===null?o=c=d:c=c.next=d,i=i.next}while(i!==null);c===null?o=c=e:c=c.next=e}else o=c=e;i={baseState:s.baseState,firstBaseUpdate:o,lastBaseUpdate:c,shared:s.shared,effects:s.effects},a.updateQueue=i;return}a=i.lastBaseUpdate,a===null?i.firstBaseUpdate=e:a.next=e,i.lastBaseUpdate=e}function qh(a,e,i,s){var o=a.updateQueue;jh=!1;var c=o.firstBaseUpdate,d=o.lastBaseUpdate,h=o.shared.pending;if(h!==null){o.shared.pending=null;var g=h,_=g.next;g.next=null,d===null?c=_:d.next=_,d=g;var b=a.alternate;b!==null&&(b=b.updateQueue,h=b.lastBaseUpdate,h!==d&&(h===null?b.firstBaseUpdate=_:h.next=_,b.lastBaseUpdate=g))}if(c!==null){var $=o.baseState;d=0,b=_=g=null,h=c;do{var j=h.lane,_e=h.eventTime;if((s&j)===j){b!==null&&(b=b.next={eventTime:_e,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,next:null});e:{var tt=a,et=h;switch(j=e,_e=i,et.tag){case 1:if(tt=et.payload,typeof tt=="function"){$=tt.call(_e,$,j);break e}$=tt;break e;case 3:tt.flags=tt.flags&-65537|128;case 0:if(tt=et.payload,j=typeof tt=="function"?tt.call(_e,$,j):tt,j==null)break e;$=A$1({},$,j);break e;case 2:jh=!0}}h.callback!==null&&h.lane!==0&&(a.flags|=64,j=o.effects,j===null?o.effects=[h]:j.push(h))}else _e={eventTime:_e,lane:j,tag:h.tag,payload:h.payload,callback:h.callback,next:null},b===null?(_=b=_e,g=$):b=b.next=_e,d|=j;if(h=h.next,h===null){if(h=o.shared.pending,h===null)break;j=h,h=j.next,j.next=null,o.lastBaseUpdate=j,o.shared.pending=null}}while(!0);if(b===null&&(g=$),o.baseState=g,o.firstBaseUpdate=_,o.lastBaseUpdate=b,e=o.shared.interleaved,e!==null){o=e;do d|=o.lane,o=o.next;while(o!==e)}else c===null&&(o.shared.lanes=0);rh|=d,a.lanes=d,a.memoizedState=$}}function sh(a,e,i){if(a=e.effects,e.effects=null,a!==null)for(e=0;e<a.length;e++){var s=a[e],o=s.callback;if(o!==null){if(s.callback=null,s=i,typeof o!="function")throw Error(p$1(191,o));o.call(s)}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(a){if(a===th)throw Error(p$1(174));return a}function yh(a,e){switch(G(wh,e),G(vh,a),G(uh,th),a=e.nodeType,a){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:lb(null,"");break;default:a=a===8?e.parentNode:e,e=a.namespaceURI||null,a=a.tagName,e=lb(e,a)}E(uh),G(uh,e)}function zh(){E(uh),E(vh),E(wh)}function Ah(a){xh(wh.current);var e=xh(uh.current),i=lb(e,a.type);e!==i&&(G(vh,a),G(uh,i))}function Bh(a){vh.current===a&&(E(uh),E(vh))}var L=Uf(0);function Ch(a){for(var e=a;e!==null;){if(e.tag===13){var i=e.memoizedState;if(i!==null&&(i=i.dehydrated,i===null||i.data==="$?"||i.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===a)break;for(;e.sibling===null;){if(e.return===null||e.return===a)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Dh=[];function Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M=null,N=null,O=null,Ih=!1,Jh=!1,Kh=0,Lh=0;function P$2(){throw Error(p$1(321))}function Mh(a,e){if(e===null)return!1;for(var i=0;i<e.length&&i<a.length;i++)if(!He(a[i],e[i]))return!1;return!0}function Nh(a,e,i,s,o,c){if(Hh=c,M=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Fh.current=a===null||a.memoizedState===null?Oh:Ph,a=i(s,o),Jh){c=0;do{if(Jh=!1,Kh=0,25<=c)throw Error(p$1(301));c+=1,O=N=null,e.updateQueue=null,Fh.current=Qh,a=i(s,o)}while(Jh)}if(Fh.current=Rh,e=N!==null&&N.next!==null,Hh=0,O=N=M=null,Ih=!1,e)throw Error(p$1(300));return a}function Sh(){var a=Kh!==0;return Kh=0,a}function Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return O===null?M.memoizedState=O=a:O=O.next=a,O}function Uh(){if(N===null){var a=M.alternate;a=a!==null?a.memoizedState:null}else a=N.next;var e=O===null?M.memoizedState:O.next;if(e!==null)O=e,N=a;else{if(a===null)throw Error(p$1(310));N=a,a={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null},O===null?M.memoizedState=O=a:O=O.next=a}return O}function Vh(a,e){return typeof e=="function"?e(a):e}function Wh(a){var e=Uh(),i=e.queue;if(i===null)throw Error(p$1(311));i.lastRenderedReducer=a;var s=N,o=s.baseQueue,c=i.pending;if(c!==null){if(o!==null){var d=o.next;o.next=c.next,c.next=d}s.baseQueue=o=c,i.pending=null}if(o!==null){c=o.next,s=s.baseState;var h=d=null,g=null,_=c;do{var b=_.lane;if((Hh&b)===b)g!==null&&(g=g.next={lane:0,action:_.action,hasEagerState:_.hasEagerState,eagerState:_.eagerState,next:null}),s=_.hasEagerState?_.eagerState:a(s,_.action);else{var $={lane:b,action:_.action,hasEagerState:_.hasEagerState,eagerState:_.eagerState,next:null};g===null?(h=g=$,d=s):g=g.next=$,M.lanes|=b,rh|=b}_=_.next}while(_!==null&&_!==c);g===null?d=s:g.next=h,He(s,e.memoizedState)||(dh=!0),e.memoizedState=s,e.baseState=d,e.baseQueue=g,i.lastRenderedState=s}if(a=i.interleaved,a!==null){o=a;do c=o.lane,M.lanes|=c,rh|=c,o=o.next;while(o!==a)}else o===null&&(i.lanes=0);return[e.memoizedState,i.dispatch]}function Xh(a){var e=Uh(),i=e.queue;if(i===null)throw Error(p$1(311));i.lastRenderedReducer=a;var s=i.dispatch,o=i.pending,c=e.memoizedState;if(o!==null){i.pending=null;var d=o=o.next;do c=a(c,d.action),d=d.next;while(d!==o);He(c,e.memoizedState)||(dh=!0),e.memoizedState=c,e.baseQueue===null&&(e.baseState=c),i.lastRenderedState=c}return[c,s]}function Yh(){}function Zh(a,e){var i=M,s=Uh(),o=e(),c=!He(s.memoizedState,o);if(c&&(s.memoizedState=o,dh=!0),s=s.queue,$h(ai.bind(null,i,s,a),[a]),s.getSnapshot!==e||c||O!==null&&O.memoizedState.tag&1){if(i.flags|=2048,bi(9,ci.bind(null,i,s,o,e),void 0,null),Q===null)throw Error(p$1(349));Hh&30||di(i,e,o)}return o}function di(a,e,i){a.flags|=16384,a={getSnapshot:e,value:i},e=M.updateQueue,e===null?(e={lastEffect:null,stores:null},M.updateQueue=e,e.stores=[a]):(i=e.stores,i===null?e.stores=[a]:i.push(a))}function ci(a,e,i,s){e.value=i,e.getSnapshot=s,ei(e)&&fi(a)}function ai(a,e,i){return i(function(){ei(e)&&fi(a)})}function ei(a){var e=a.getSnapshot;a=a.value;try{var i=e();return!He(a,i)}catch{return!0}}function fi(a){var e=ih(a,1);e!==null&&gi(e,a,1,-1)}function hi(a){var e=Th();return typeof a=="function"&&(a=a()),e.memoizedState=e.baseState=a,a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a},e.queue=a,a=a.dispatch=ii.bind(null,M,a),[e.memoizedState,a]}function bi(a,e,i,s){return a={tag:a,create:e,destroy:i,deps:s,next:null},e=M.updateQueue,e===null?(e={lastEffect:null,stores:null},M.updateQueue=e,e.lastEffect=a.next=a):(i=e.lastEffect,i===null?e.lastEffect=a.next=a:(s=i.next,i.next=a,a.next=s,e.lastEffect=a)),a}function ji(){return Uh().memoizedState}function ki(a,e,i,s){var o=Th();M.flags|=a,o.memoizedState=bi(1|e,i,void 0,s===void 0?null:s)}function li(a,e,i,s){var o=Uh();s=s===void 0?null:s;var c=void 0;if(N!==null){var d=N.memoizedState;if(c=d.destroy,s!==null&&Mh(s,d.deps)){o.memoizedState=bi(e,i,c,s);return}}M.flags|=a,o.memoizedState=bi(1|e,i,c,s)}function mi(a,e){return ki(8390656,8,a,e)}function $h(a,e){return li(2048,8,a,e)}function ni(a,e){return li(4,2,a,e)}function oi(a,e){return li(4,4,a,e)}function pi(a,e){if(typeof e=="function")return a=a(),e(a),function(){e(null)};if(e!=null)return a=a(),e.current=a,function(){e.current=null}}function qi(a,e,i){return i=i!=null?i.concat([a]):null,li(4,4,pi.bind(null,e,a),i)}function ri(){}function si(a,e){var i=Uh();e=e===void 0?null:e;var s=i.memoizedState;return s!==null&&e!==null&&Mh(e,s[1])?s[0]:(i.memoizedState=[a,e],a)}function ti(a,e){var i=Uh();e=e===void 0?null:e;var s=i.memoizedState;return s!==null&&e!==null&&Mh(e,s[1])?s[0]:(a=a(),i.memoizedState=[a,e],a)}function ui(a,e,i){return Hh&21?(He(i,e)||(i=yc(),M.lanes|=i,rh|=i,a.baseState=!0),e):(a.baseState&&(a.baseState=!1,dh=!0),a.memoizedState=i)}function vi(a,e){var i=C$1;C$1=i!==0&&4>i?i:4,a(!0);var s=Gh.transition;Gh.transition={};try{a(!1),e()}finally{C$1=i,Gh.transition=s}}function wi(){return Uh().memoizedState}function xi(a,e,i){var s=yi(a);if(i={lane:s,action:i,hasEagerState:!1,eagerState:null,next:null},zi(a))Ai(e,i);else if(i=hh(a,e,i,s),i!==null){var o=R();gi(i,a,s,o),Bi(i,e,s)}}function ii(a,e,i){var s=yi(a),o={lane:s,action:i,hasEagerState:!1,eagerState:null,next:null};if(zi(a))Ai(e,o);else{var c=a.alternate;if(a.lanes===0&&(c===null||c.lanes===0)&&(c=e.lastRenderedReducer,c!==null))try{var d=e.lastRenderedState,h=c(d,i);if(o.hasEagerState=!0,o.eagerState=h,He(h,d)){var g=e.interleaved;g===null?(o.next=o,gh(e)):(o.next=g.next,g.next=o),e.interleaved=o;return}}catch{}finally{}i=hh(a,e,o,s),i!==null&&(o=R(),gi(i,a,s,o),Bi(i,e,s))}}function zi(a){var e=a.alternate;return a===M||e!==null&&e===M}function Ai(a,e){Jh=Ih=!0;var i=a.pending;i===null?e.next=e:(e.next=i.next,i.next=e),a.pending=e}function Bi(a,e,i){if(i&4194240){var s=e.lanes;s&=a.pendingLanes,i|=s,e.lanes=i,Cc(a,i)}}var Rh={readContext:eh,useCallback:P$2,useContext:P$2,useEffect:P$2,useImperativeHandle:P$2,useInsertionEffect:P$2,useLayoutEffect:P$2,useMemo:P$2,useReducer:P$2,useRef:P$2,useState:P$2,useDebugValue:P$2,useDeferredValue:P$2,useTransition:P$2,useMutableSource:P$2,useSyncExternalStore:P$2,useId:P$2,unstable_isNewReconciler:!1},Oh={readContext:eh,useCallback:function(a,e){return Th().memoizedState=[a,e===void 0?null:e],a},useContext:eh,useEffect:mi,useImperativeHandle:function(a,e,i){return i=i!=null?i.concat([a]):null,ki(4194308,4,pi.bind(null,e,a),i)},useLayoutEffect:function(a,e){return ki(4194308,4,a,e)},useInsertionEffect:function(a,e){return ki(4,2,a,e)},useMemo:function(a,e){var i=Th();return e=e===void 0?null:e,a=a(),i.memoizedState=[a,e],a},useReducer:function(a,e,i){var s=Th();return e=i!==void 0?i(e):e,s.memoizedState=s.baseState=e,a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:e},s.queue=a,a=a.dispatch=xi.bind(null,M,a),[s.memoizedState,a]},useRef:function(a){var e=Th();return a={current:a},e.memoizedState=a},useState:hi,useDebugValue:ri,useDeferredValue:function(a){return Th().memoizedState=a},useTransition:function(){var a=hi(!1),e=a[0];return a=vi.bind(null,a[1]),Th().memoizedState=a,[e,a]},useMutableSource:function(){},useSyncExternalStore:function(a,e,i){var s=M,o=Th();if(I){if(i===void 0)throw Error(p$1(407));i=i()}else{if(i=e(),Q===null)throw Error(p$1(349));Hh&30||di(s,e,i)}o.memoizedState=i;var c={value:i,getSnapshot:e};return o.queue=c,mi(ai.bind(null,s,c,a),[a]),s.flags|=2048,bi(9,ci.bind(null,s,c,i,e),void 0,null),i},useId:function(){var a=Th(),e=Q.identifierPrefix;if(I){var i=sg,s=rg;i=(s&~(1<<32-oc(s)-1)).toString(32)+i,e=":"+e+"R"+i,i=Kh++,0<i&&(e+="H"+i.toString(32)),e+=":"}else i=Lh++,e=":"+e+"r"+i.toString(32)+":";return a.memoizedState=e},unstable_isNewReconciler:!1},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var e=Uh();return ui(e,N.memoizedState,a)},useTransition:function(){var a=Wh(Vh)[0],e=Uh().memoizedState;return[a,e]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var e=Uh();return N===null?e.memoizedState=a:ui(e,N.memoizedState,a)},useTransition:function(){var a=Xh(Vh)[0],e=Uh().memoizedState;return[a,e]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:!1};function Ci(a,e){if(a&&a.defaultProps){e=A$1({},e),a=a.defaultProps;for(var i in a)e[i]===void 0&&(e[i]=a[i]);return e}return e}function Di(a,e,i,s){e=a.memoizedState,i=i(s,e),i=i==null?e:A$1({},e,i),a.memoizedState=i,a.lanes===0&&(a.updateQueue.baseState=i)}var Ei={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,e,i){a=a._reactInternals;var s=R(),o=yi(a),c=mh(s,o);c.payload=e,i!=null&&(c.callback=i),e=nh(a,c,o),e!==null&&(gi(e,a,o,s),oh(e,a,o))},enqueueReplaceState:function(a,e,i){a=a._reactInternals;var s=R(),o=yi(a),c=mh(s,o);c.tag=1,c.payload=e,i!=null&&(c.callback=i),e=nh(a,c,o),e!==null&&(gi(e,a,o,s),oh(e,a,o))},enqueueForceUpdate:function(a,e){a=a._reactInternals;var i=R(),s=yi(a),o=mh(i,s);o.tag=2,e!=null&&(o.callback=e),e=nh(a,o,s),e!==null&&(gi(e,a,s,i),oh(e,a,s))}};function Fi(a,e,i,s,o,c,d){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(s,c,d):e.prototype&&e.prototype.isPureReactComponent?!Ie(i,s)||!Ie(o,c):!0}function Gi(a,e,i){var s=!1,o=Vf,c=e.contextType;return typeof c=="object"&&c!==null?c=eh(c):(o=Zf(e)?Xf:H.current,s=e.contextTypes,c=(s=s!=null)?Yf(a,o):Vf),e=new e(i,c),a.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=Ei,a.stateNode=e,e._reactInternals=a,s&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=o,a.__reactInternalMemoizedMaskedChildContext=c),e}function Hi(a,e,i,s){a=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(i,s),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(i,s),e.state!==a&&Ei.enqueueReplaceState(e,e.state,null)}function Ii(a,e,i,s){var o=a.stateNode;o.props=i,o.state=a.memoizedState,o.refs={},kh(a);var c=e.contextType;typeof c=="object"&&c!==null?o.context=eh(c):(c=Zf(e)?Xf:H.current,o.context=Yf(a,c)),o.state=a.memoizedState,c=e.getDerivedStateFromProps,typeof c=="function"&&(Di(a,e,c,i),o.state=a.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof o.getSnapshotBeforeUpdate=="function"||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(e=o.state,typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount(),e!==o.state&&Ei.enqueueReplaceState(o,o.state,null),qh(a,i,o,s),o.state=a.memoizedState),typeof o.componentDidMount=="function"&&(a.flags|=4194308)}function Ji(a,e){try{var i="",s=e;do i+=Pa(s),s=s.return;while(s);var o=i}catch(c){o=`
Error generating stack: `+c.message+`
`+c.stack}return{value:a,source:e,stack:o,digest:null}}function Ki(a,e,i){return{value:a,source:null,stack:i??null,digest:e??null}}function Li(a,e){try{console.error(e.value)}catch(i){setTimeout(function(){throw i})}}var Mi=typeof WeakMap=="function"?WeakMap:Map;function Ni(a,e,i){i=mh(-1,i),i.tag=3,i.payload={element:null};var s=e.value;return i.callback=function(){Oi||(Oi=!0,Pi=s),Li(a,e)},i}function Qi(a,e,i){i=mh(-1,i),i.tag=3;var s=a.type.getDerivedStateFromError;if(typeof s=="function"){var o=e.value;i.payload=function(){return s(o)},i.callback=function(){Li(a,e)}}var c=a.stateNode;return c!==null&&typeof c.componentDidCatch=="function"&&(i.callback=function(){Li(a,e),typeof s!="function"&&(Ri===null?Ri=new Set([this]):Ri.add(this));var d=e.stack;this.componentDidCatch(e.value,{componentStack:d!==null?d:""})}),i}function Si(a,e,i){var s=a.pingCache;if(s===null){s=a.pingCache=new Mi;var o=new Set;s.set(e,o)}else o=s.get(e),o===void 0&&(o=new Set,s.set(e,o));o.has(i)||(o.add(i),a=Ti.bind(null,a,e,i),e.then(a,a))}function Ui(a){do{var e;if((e=a.tag===13)&&(e=a.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return a;a=a.return}while(a!==null);return null}function Vi(a,e,i,s,o){return a.mode&1?(a.flags|=65536,a.lanes=o,a):(a===e?a.flags|=65536:(a.flags|=128,i.flags|=131072,i.flags&=-52805,i.tag===1&&(i.alternate===null?i.tag=17:(e=mh(-1,1),e.tag=2,nh(i,e,1))),i.lanes|=1),a)}var Wi=ua.ReactCurrentOwner,dh=!1;function Xi(a,e,i,s){e.child=a===null?Vg(e,null,i,s):Ug(e,a.child,i,s)}function Yi(a,e,i,s,o){i=i.render;var c=e.ref;return ch(e,o),s=Nh(a,e,i,s,c,o),i=Sh(),a!==null&&!dh?(e.updateQueue=a.updateQueue,e.flags&=-2053,a.lanes&=~o,Zi(a,e,o)):(I&&i&&vg(e),e.flags|=1,Xi(a,e,s,o),e.child)}function $i(a,e,i,s,o){if(a===null){var c=i.type;return typeof c=="function"&&!aj(c)&&c.defaultProps===void 0&&i.compare===null&&i.defaultProps===void 0?(e.tag=15,e.type=c,bj(a,e,c,s,o)):(a=Rg(i.type,null,s,e,e.mode,o),a.ref=e.ref,a.return=e,e.child=a)}if(c=a.child,!(a.lanes&o)){var d=c.memoizedProps;if(i=i.compare,i=i!==null?i:Ie,i(d,s)&&a.ref===e.ref)return Zi(a,e,o)}return e.flags|=1,a=Pg(c,s),a.ref=e.ref,a.return=e,e.child=a}function bj(a,e,i,s,o){if(a!==null){var c=a.memoizedProps;if(Ie(c,s)&&a.ref===e.ref)if(dh=!1,e.pendingProps=s=c,(a.lanes&o)!==0)a.flags&131072&&(dh=!0);else return e.lanes=a.lanes,Zi(a,e,o)}return cj(a,e,i,s,o)}function dj(a,e,i){var s=e.pendingProps,o=s.children,c=a!==null?a.memoizedState:null;if(s.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=i;else{if(!(i&1073741824))return a=c!==null?c.baseLanes|i:i,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:a,cachePool:null,transitions:null},e.updateQueue=null,G(ej,fj),fj|=a,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},s=c!==null?c.baseLanes:i,G(ej,fj),fj|=s}else c!==null?(s=c.baseLanes|i,e.memoizedState=null):s=i,G(ej,fj),fj|=s;return Xi(a,e,o,i),e.child}function gj(a,e){var i=e.ref;(a===null&&i!==null||a!==null&&a.ref!==i)&&(e.flags|=512,e.flags|=2097152)}function cj(a,e,i,s,o){var c=Zf(i)?Xf:H.current;return c=Yf(e,c),ch(e,o),i=Nh(a,e,i,s,c,o),s=Sh(),a!==null&&!dh?(e.updateQueue=a.updateQueue,e.flags&=-2053,a.lanes&=~o,Zi(a,e,o)):(I&&s&&vg(e),e.flags|=1,Xi(a,e,i,o),e.child)}function hj(a,e,i,s,o){if(Zf(i)){var c=!0;cg(e)}else c=!1;if(ch(e,o),e.stateNode===null)ij(a,e),Gi(e,i,s),Ii(e,i,s,o),s=!0;else if(a===null){var d=e.stateNode,h=e.memoizedProps;d.props=h;var g=d.context,_=i.contextType;typeof _=="object"&&_!==null?_=eh(_):(_=Zf(i)?Xf:H.current,_=Yf(e,_));var b=i.getDerivedStateFromProps,$=typeof b=="function"||typeof d.getSnapshotBeforeUpdate=="function";$||typeof d.UNSAFE_componentWillReceiveProps!="function"&&typeof d.componentWillReceiveProps!="function"||(h!==s||g!==_)&&Hi(e,d,s,_),jh=!1;var j=e.memoizedState;d.state=j,qh(e,s,d,o),g=e.memoizedState,h!==s||j!==g||Wf.current||jh?(typeof b=="function"&&(Di(e,i,b,s),g=e.memoizedState),(h=jh||Fi(e,i,h,s,j,g,_))?($||typeof d.UNSAFE_componentWillMount!="function"&&typeof d.componentWillMount!="function"||(typeof d.componentWillMount=="function"&&d.componentWillMount(),typeof d.UNSAFE_componentWillMount=="function"&&d.UNSAFE_componentWillMount()),typeof d.componentDidMount=="function"&&(e.flags|=4194308)):(typeof d.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=s,e.memoizedState=g),d.props=s,d.state=g,d.context=_,s=h):(typeof d.componentDidMount=="function"&&(e.flags|=4194308),s=!1)}else{d=e.stateNode,lh(a,e),h=e.memoizedProps,_=e.type===e.elementType?h:Ci(e.type,h),d.props=_,$=e.pendingProps,j=d.context,g=i.contextType,typeof g=="object"&&g!==null?g=eh(g):(g=Zf(i)?Xf:H.current,g=Yf(e,g));var _e=i.getDerivedStateFromProps;(b=typeof _e=="function"||typeof d.getSnapshotBeforeUpdate=="function")||typeof d.UNSAFE_componentWillReceiveProps!="function"&&typeof d.componentWillReceiveProps!="function"||(h!==$||j!==g)&&Hi(e,d,s,g),jh=!1,j=e.memoizedState,d.state=j,qh(e,s,d,o);var tt=e.memoizedState;h!==$||j!==tt||Wf.current||jh?(typeof _e=="function"&&(Di(e,i,_e,s),tt=e.memoizedState),(_=jh||Fi(e,i,_,s,j,tt,g)||!1)?(b||typeof d.UNSAFE_componentWillUpdate!="function"&&typeof d.componentWillUpdate!="function"||(typeof d.componentWillUpdate=="function"&&d.componentWillUpdate(s,tt,g),typeof d.UNSAFE_componentWillUpdate=="function"&&d.UNSAFE_componentWillUpdate(s,tt,g)),typeof d.componentDidUpdate=="function"&&(e.flags|=4),typeof d.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof d.componentDidUpdate!="function"||h===a.memoizedProps&&j===a.memoizedState||(e.flags|=4),typeof d.getSnapshotBeforeUpdate!="function"||h===a.memoizedProps&&j===a.memoizedState||(e.flags|=1024),e.memoizedProps=s,e.memoizedState=tt),d.props=s,d.state=tt,d.context=g,s=_):(typeof d.componentDidUpdate!="function"||h===a.memoizedProps&&j===a.memoizedState||(e.flags|=4),typeof d.getSnapshotBeforeUpdate!="function"||h===a.memoizedProps&&j===a.memoizedState||(e.flags|=1024),s=!1)}return jj(a,e,i,s,c,o)}function jj(a,e,i,s,o,c){gj(a,e);var d=(e.flags&128)!==0;if(!s&&!d)return o&&dg(e,i,!1),Zi(a,e,c);s=e.stateNode,Wi.current=e;var h=d&&typeof i.getDerivedStateFromError!="function"?null:s.render();return e.flags|=1,a!==null&&d?(e.child=Ug(e,a.child,null,c),e.child=Ug(e,null,h,c)):Xi(a,e,h,c),e.memoizedState=s.state,o&&dg(e,i,!0),e.child}function kj(a){var e=a.stateNode;e.pendingContext?ag(a,e.pendingContext,e.pendingContext!==e.context):e.context&&ag(a,e.context,!1),yh(a,e.containerInfo)}function lj(a,e,i,s,o){return Ig(),Jg(o),e.flags|=256,Xi(a,e,i,s),e.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return{baseLanes:a,cachePool:null,transitions:null}}function oj(a,e,i){var s=e.pendingProps,o=L.current,c=!1,d=(e.flags&128)!==0,h;if((h=d)||(h=a!==null&&a.memoizedState===null?!1:(o&2)!==0),h?(c=!0,e.flags&=-129):(a===null||a.memoizedState!==null)&&(o|=1),G(L,o&1),a===null)return Eg(e),a=e.memoizedState,a!==null&&(a=a.dehydrated,a!==null)?(e.mode&1?a.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(d=s.children,a=s.fallback,c?(s=e.mode,c=e.child,d={mode:"hidden",children:d},!(s&1)&&c!==null?(c.childLanes=0,c.pendingProps=d):c=pj(d,s,0,null),a=Tg(a,s,i,null),c.return=e,a.return=e,c.sibling=a,e.child=c,e.child.memoizedState=nj(i),e.memoizedState=mj,a):qj(e,d));if(o=a.memoizedState,o!==null&&(h=o.dehydrated,h!==null))return rj(a,e,d,s,h,o,i);if(c){c=s.fallback,d=e.mode,o=a.child,h=o.sibling;var g={mode:"hidden",children:s.children};return!(d&1)&&e.child!==o?(s=e.child,s.childLanes=0,s.pendingProps=g,e.deletions=null):(s=Pg(o,g),s.subtreeFlags=o.subtreeFlags&14680064),h!==null?c=Pg(h,c):(c=Tg(c,d,i,null),c.flags|=2),c.return=e,s.return=e,s.sibling=c,e.child=s,s=c,c=e.child,d=a.child.memoizedState,d=d===null?nj(i):{baseLanes:d.baseLanes|i,cachePool:null,transitions:d.transitions},c.memoizedState=d,c.childLanes=a.childLanes&~i,e.memoizedState=mj,s}return c=a.child,a=c.sibling,s=Pg(c,{mode:"visible",children:s.children}),!(e.mode&1)&&(s.lanes=i),s.return=e,s.sibling=null,a!==null&&(i=e.deletions,i===null?(e.deletions=[a],e.flags|=16):i.push(a)),e.child=s,e.memoizedState=null,s}function qj(a,e){return e=pj({mode:"visible",children:e},a.mode,0,null),e.return=a,a.child=e}function sj(a,e,i,s){return s!==null&&Jg(s),Ug(e,a.child,null,i),a=qj(e,e.pendingProps.children),a.flags|=2,e.memoizedState=null,a}function rj(a,e,i,s,o,c,d){if(i)return e.flags&256?(e.flags&=-257,s=Ki(Error(p$1(422))),sj(a,e,d,s)):e.memoizedState!==null?(e.child=a.child,e.flags|=128,null):(c=s.fallback,o=e.mode,s=pj({mode:"visible",children:s.children},o,0,null),c=Tg(c,o,d,null),c.flags|=2,s.return=e,c.return=e,s.sibling=c,e.child=s,e.mode&1&&Ug(e,a.child,null,d),e.child.memoizedState=nj(d),e.memoizedState=mj,c);if(!(e.mode&1))return sj(a,e,d,null);if(o.data==="$!"){if(s=o.nextSibling&&o.nextSibling.dataset,s)var h=s.dgst;return s=h,c=Error(p$1(419)),s=Ki(c,s,void 0),sj(a,e,d,s)}if(h=(d&a.childLanes)!==0,dh||h){if(s=Q,s!==null){switch(d&-d){case 4:o=2;break;case 16:o=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:o=32;break;case 536870912:o=268435456;break;default:o=0}o=o&(s.suspendedLanes|d)?0:o,o!==0&&o!==c.retryLane&&(c.retryLane=o,ih(a,o),gi(s,a,o,-1))}return tj(),s=Ki(Error(p$1(421))),sj(a,e,d,s)}return o.data==="$?"?(e.flags|=128,e.child=a.child,e=uj.bind(null,a),o._reactRetry=e,null):(a=c.treeContext,yg=Lf(o.nextSibling),xg=e,I=!0,zg=null,a!==null&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=e),e=qj(e,s.children),e.flags|=4096,e)}function vj(a,e,i){a.lanes|=e;var s=a.alternate;s!==null&&(s.lanes|=e),bh(a.return,e,i)}function wj(a,e,i,s,o){var c=a.memoizedState;c===null?a.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:s,tail:i,tailMode:o}:(c.isBackwards=e,c.rendering=null,c.renderingStartTime=0,c.last=s,c.tail=i,c.tailMode=o)}function xj(a,e,i){var s=e.pendingProps,o=s.revealOrder,c=s.tail;if(Xi(a,e,s.children,i),s=L.current,s&2)s=s&1|2,e.flags|=128;else{if(a!==null&&a.flags&128)e:for(a=e.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&vj(a,i,e);else if(a.tag===19)vj(a,i,e);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===e)break e;for(;a.sibling===null;){if(a.return===null||a.return===e)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}s&=1}if(G(L,s),!(e.mode&1))e.memoizedState=null;else switch(o){case"forwards":for(i=e.child,o=null;i!==null;)a=i.alternate,a!==null&&Ch(a)===null&&(o=i),i=i.sibling;i=o,i===null?(o=e.child,e.child=null):(o=i.sibling,i.sibling=null),wj(e,!1,o,i,c);break;case"backwards":for(i=null,o=e.child,e.child=null;o!==null;){if(a=o.alternate,a!==null&&Ch(a)===null){e.child=o;break}a=o.sibling,o.sibling=i,i=o,o=a}wj(e,!0,i,null,c);break;case"together":wj(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function ij(a,e){!(e.mode&1)&&a!==null&&(a.alternate=null,e.alternate=null,e.flags|=2)}function Zi(a,e,i){if(a!==null&&(e.dependencies=a.dependencies),rh|=e.lanes,!(i&e.childLanes))return null;if(a!==null&&e.child!==a.child)throw Error(p$1(153));if(e.child!==null){for(a=e.child,i=Pg(a,a.pendingProps),e.child=i,i.return=e;a.sibling!==null;)a=a.sibling,i=i.sibling=Pg(a,a.pendingProps),i.return=e;i.sibling=null}return e.child}function yj(a,e,i){switch(e.tag){case 3:kj(e),Ig();break;case 5:Ah(e);break;case 1:Zf(e.type)&&cg(e);break;case 4:yh(e,e.stateNode.containerInfo);break;case 10:var s=e.type._context,o=e.memoizedProps.value;G(Wg,s._currentValue),s._currentValue=o;break;case 13:if(s=e.memoizedState,s!==null)return s.dehydrated!==null?(G(L,L.current&1),e.flags|=128,null):i&e.child.childLanes?oj(a,e,i):(G(L,L.current&1),a=Zi(a,e,i),a!==null?a.sibling:null);G(L,L.current&1);break;case 19:if(s=(i&e.childLanes)!==0,a.flags&128){if(s)return xj(a,e,i);e.flags|=128}if(o=e.memoizedState,o!==null&&(o.rendering=null,o.tail=null,o.lastEffect=null),G(L,L.current),s)break;return null;case 22:case 23:return e.lanes=0,dj(a,e,i)}return Zi(a,e,i)}var zj,Aj,Bj,Cj;zj=function(a,e){for(var i=e.child;i!==null;){if(i.tag===5||i.tag===6)a.appendChild(i.stateNode);else if(i.tag!==4&&i.child!==null){i.child.return=i,i=i.child;continue}if(i===e)break;for(;i.sibling===null;){if(i.return===null||i.return===e)return;i=i.return}i.sibling.return=i.return,i=i.sibling}};Aj=function(){};Bj=function(a,e,i,s){var o=a.memoizedProps;if(o!==s){a=e.stateNode,xh(uh.current);var c=null;switch(i){case"input":o=Ya(a,o),s=Ya(a,s),c=[];break;case"select":o=A$1({},o,{value:void 0}),s=A$1({},s,{value:void 0}),c=[];break;case"textarea":o=gb(a,o),s=gb(a,s),c=[];break;default:typeof o.onClick!="function"&&typeof s.onClick=="function"&&(a.onclick=Bf)}ub(i,s);var d;i=null;for(_ in o)if(!s.hasOwnProperty(_)&&o.hasOwnProperty(_)&&o[_]!=null)if(_==="style"){var h=o[_];for(d in h)h.hasOwnProperty(d)&&(i||(i={}),i[d]="")}else _!=="dangerouslySetInnerHTML"&&_!=="children"&&_!=="suppressContentEditableWarning"&&_!=="suppressHydrationWarning"&&_!=="autoFocus"&&(ea.hasOwnProperty(_)?c||(c=[]):(c=c||[]).push(_,null));for(_ in s){var g=s[_];if(h=o!=null?o[_]:void 0,s.hasOwnProperty(_)&&g!==h&&(g!=null||h!=null))if(_==="style")if(h){for(d in h)!h.hasOwnProperty(d)||g&&g.hasOwnProperty(d)||(i||(i={}),i[d]="");for(d in g)g.hasOwnProperty(d)&&h[d]!==g[d]&&(i||(i={}),i[d]=g[d])}else i||(c||(c=[]),c.push(_,i)),i=g;else _==="dangerouslySetInnerHTML"?(g=g?g.__html:void 0,h=h?h.__html:void 0,g!=null&&h!==g&&(c=c||[]).push(_,g)):_==="children"?typeof g!="string"&&typeof g!="number"||(c=c||[]).push(_,""+g):_!=="suppressContentEditableWarning"&&_!=="suppressHydrationWarning"&&(ea.hasOwnProperty(_)?(g!=null&&_==="onScroll"&&D("scroll",a),c||h===g||(c=[])):(c=c||[]).push(_,g))}i&&(c=c||[]).push("style",i);var _=c;(e.updateQueue=_)&&(e.flags|=4)}};Cj=function(a,e,i,s){i!==s&&(e.flags|=4)};function Dj(a,e){if(!I)switch(a.tailMode){case"hidden":e=a.tail;for(var i=null;e!==null;)e.alternate!==null&&(i=e),e=e.sibling;i===null?a.tail=null:i.sibling=null;break;case"collapsed":i=a.tail;for(var s=null;i!==null;)i.alternate!==null&&(s=i),i=i.sibling;s===null?e||a.tail===null?a.tail=null:a.tail.sibling=null:s.sibling=null}}function S(a){var e=a.alternate!==null&&a.alternate.child===a.child,i=0,s=0;if(e)for(var o=a.child;o!==null;)i|=o.lanes|o.childLanes,s|=o.subtreeFlags&14680064,s|=o.flags&14680064,o.return=a,o=o.sibling;else for(o=a.child;o!==null;)i|=o.lanes|o.childLanes,s|=o.subtreeFlags,s|=o.flags,o.return=a,o=o.sibling;return a.subtreeFlags|=s,a.childLanes=i,e}function Ej(a,e,i){var s=e.pendingProps;switch(wg(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(e),null;case 1:return Zf(e.type)&&$f(),S(e),null;case 3:return s=e.stateNode,zh(),E(Wf),E(H),Eh(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(a===null||a.child===null)&&(Gg(e)?e.flags|=4:a===null||a.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,zg!==null&&(Fj(zg),zg=null))),Aj(a,e),S(e),null;case 5:Bh(e);var o=xh(wh.current);if(i=e.type,a!==null&&e.stateNode!=null)Bj(a,e,i,s,o),a.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!s){if(e.stateNode===null)throw Error(p$1(166));return S(e),null}if(a=xh(uh.current),Gg(e)){s=e.stateNode,i=e.type;var c=e.memoizedProps;switch(s[Of]=e,s[Pf]=c,a=(e.mode&1)!==0,i){case"dialog":D("cancel",s),D("close",s);break;case"iframe":case"object":case"embed":D("load",s);break;case"video":case"audio":for(o=0;o<lf.length;o++)D(lf[o],s);break;case"source":D("error",s);break;case"img":case"image":case"link":D("error",s),D("load",s);break;case"details":D("toggle",s);break;case"input":Za(s,c),D("invalid",s);break;case"select":s._wrapperState={wasMultiple:!!c.multiple},D("invalid",s);break;case"textarea":hb(s,c),D("invalid",s)}ub(i,c),o=null;for(var d in c)if(c.hasOwnProperty(d)){var h=c[d];d==="children"?typeof h=="string"?s.textContent!==h&&(c.suppressHydrationWarning!==!0&&Af(s.textContent,h,a),o=["children",h]):typeof h=="number"&&s.textContent!==""+h&&(c.suppressHydrationWarning!==!0&&Af(s.textContent,h,a),o=["children",""+h]):ea.hasOwnProperty(d)&&h!=null&&d==="onScroll"&&D("scroll",s)}switch(i){case"input":Va(s),db(s,c,!0);break;case"textarea":Va(s),jb(s);break;case"select":case"option":break;default:typeof c.onClick=="function"&&(s.onclick=Bf)}s=o,e.updateQueue=s,s!==null&&(e.flags|=4)}else{d=o.nodeType===9?o:o.ownerDocument,a==="http://www.w3.org/1999/xhtml"&&(a=kb(i)),a==="http://www.w3.org/1999/xhtml"?i==="script"?(a=d.createElement("div"),a.innerHTML="<script><\/script>",a=a.removeChild(a.firstChild)):typeof s.is=="string"?a=d.createElement(i,{is:s.is}):(a=d.createElement(i),i==="select"&&(d=a,s.multiple?d.multiple=!0:s.size&&(d.size=s.size))):a=d.createElementNS(a,i),a[Of]=e,a[Pf]=s,zj(a,e,!1,!1),e.stateNode=a;e:{switch(d=vb(i,s),i){case"dialog":D("cancel",a),D("close",a),o=s;break;case"iframe":case"object":case"embed":D("load",a),o=s;break;case"video":case"audio":for(o=0;o<lf.length;o++)D(lf[o],a);o=s;break;case"source":D("error",a),o=s;break;case"img":case"image":case"link":D("error",a),D("load",a),o=s;break;case"details":D("toggle",a),o=s;break;case"input":Za(a,s),o=Ya(a,s),D("invalid",a);break;case"option":o=s;break;case"select":a._wrapperState={wasMultiple:!!s.multiple},o=A$1({},s,{value:void 0}),D("invalid",a);break;case"textarea":hb(a,s),o=gb(a,s),D("invalid",a);break;default:o=s}ub(i,o),h=o;for(c in h)if(h.hasOwnProperty(c)){var g=h[c];c==="style"?sb(a,g):c==="dangerouslySetInnerHTML"?(g=g?g.__html:void 0,g!=null&&nb(a,g)):c==="children"?typeof g=="string"?(i!=="textarea"||g!=="")&&ob(a,g):typeof g=="number"&&ob(a,""+g):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(ea.hasOwnProperty(c)?g!=null&&c==="onScroll"&&D("scroll",a):g!=null&&ta(a,c,g,d))}switch(i){case"input":Va(a),db(a,s,!1);break;case"textarea":Va(a),jb(a);break;case"option":s.value!=null&&a.setAttribute("value",""+Sa(s.value));break;case"select":a.multiple=!!s.multiple,c=s.value,c!=null?fb(a,!!s.multiple,c,!1):s.defaultValue!=null&&fb(a,!!s.multiple,s.defaultValue,!0);break;default:typeof o.onClick=="function"&&(a.onclick=Bf)}switch(i){case"button":case"input":case"select":case"textarea":s=!!s.autoFocus;break e;case"img":s=!0;break e;default:s=!1}}s&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return S(e),null;case 6:if(a&&e.stateNode!=null)Cj(a,e,a.memoizedProps,s);else{if(typeof s!="string"&&e.stateNode===null)throw Error(p$1(166));if(i=xh(wh.current),xh(uh.current),Gg(e)){if(s=e.stateNode,i=e.memoizedProps,s[Of]=e,(c=s.nodeValue!==i)&&(a=xg,a!==null))switch(a.tag){case 3:Af(s.nodeValue,i,(a.mode&1)!==0);break;case 5:a.memoizedProps.suppressHydrationWarning!==!0&&Af(s.nodeValue,i,(a.mode&1)!==0)}c&&(e.flags|=4)}else s=(i.nodeType===9?i:i.ownerDocument).createTextNode(s),s[Of]=e,e.stateNode=s}return S(e),null;case 13:if(E(L),s=e.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(I&&yg!==null&&e.mode&1&&!(e.flags&128))Hg(),Ig(),e.flags|=98560,c=!1;else if(c=Gg(e),s!==null&&s.dehydrated!==null){if(a===null){if(!c)throw Error(p$1(318));if(c=e.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(p$1(317));c[Of]=e}else Ig(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;S(e),c=!1}else zg!==null&&(Fj(zg),zg=null),c=!0;if(!c)return e.flags&65536?e:null}return e.flags&128?(e.lanes=i,e):(s=s!==null,s!==(a!==null&&a.memoizedState!==null)&&s&&(e.child.flags|=8192,e.mode&1&&(a===null||L.current&1?T===0&&(T=3):tj())),e.updateQueue!==null&&(e.flags|=4),S(e),null);case 4:return zh(),Aj(a,e),a===null&&sf(e.stateNode.containerInfo),S(e),null;case 10:return ah(e.type._context),S(e),null;case 17:return Zf(e.type)&&$f(),S(e),null;case 19:if(E(L),c=e.memoizedState,c===null)return S(e),null;if(s=(e.flags&128)!==0,d=c.rendering,d===null)if(s)Dj(c,!1);else{if(T!==0||a!==null&&a.flags&128)for(a=e.child;a!==null;){if(d=Ch(a),d!==null){for(e.flags|=128,Dj(c,!1),s=d.updateQueue,s!==null&&(e.updateQueue=s,e.flags|=4),e.subtreeFlags=0,s=i,i=e.child;i!==null;)c=i,a=s,c.flags&=14680066,d=c.alternate,d===null?(c.childLanes=0,c.lanes=a,c.child=null,c.subtreeFlags=0,c.memoizedProps=null,c.memoizedState=null,c.updateQueue=null,c.dependencies=null,c.stateNode=null):(c.childLanes=d.childLanes,c.lanes=d.lanes,c.child=d.child,c.subtreeFlags=0,c.deletions=null,c.memoizedProps=d.memoizedProps,c.memoizedState=d.memoizedState,c.updateQueue=d.updateQueue,c.type=d.type,a=d.dependencies,c.dependencies=a===null?null:{lanes:a.lanes,firstContext:a.firstContext}),i=i.sibling;return G(L,L.current&1|2),e.child}a=a.sibling}c.tail!==null&&B$1()>Gj&&(e.flags|=128,s=!0,Dj(c,!1),e.lanes=4194304)}else{if(!s)if(a=Ch(d),a!==null){if(e.flags|=128,s=!0,i=a.updateQueue,i!==null&&(e.updateQueue=i,e.flags|=4),Dj(c,!0),c.tail===null&&c.tailMode==="hidden"&&!d.alternate&&!I)return S(e),null}else 2*B$1()-c.renderingStartTime>Gj&&i!==1073741824&&(e.flags|=128,s=!0,Dj(c,!1),e.lanes=4194304);c.isBackwards?(d.sibling=e.child,e.child=d):(i=c.last,i!==null?i.sibling=d:e.child=d,c.last=d)}return c.tail!==null?(e=c.tail,c.rendering=e,c.tail=e.sibling,c.renderingStartTime=B$1(),e.sibling=null,i=L.current,G(L,s?i&1|2:i&1),e):(S(e),null);case 22:case 23:return Hj(),s=e.memoizedState!==null,a!==null&&a.memoizedState!==null!==s&&(e.flags|=8192),s&&e.mode&1?fj&1073741824&&(S(e),e.subtreeFlags&6&&(e.flags|=8192)):S(e),null;case 24:return null;case 25:return null}throw Error(p$1(156,e.tag))}function Ij(a,e){switch(wg(e),e.tag){case 1:return Zf(e.type)&&$f(),a=e.flags,a&65536?(e.flags=a&-65537|128,e):null;case 3:return zh(),E(Wf),E(H),Eh(),a=e.flags,a&65536&&!(a&128)?(e.flags=a&-65537|128,e):null;case 5:return Bh(e),null;case 13:if(E(L),a=e.memoizedState,a!==null&&a.dehydrated!==null){if(e.alternate===null)throw Error(p$1(340));Ig()}return a=e.flags,a&65536?(e.flags=a&-65537|128,e):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(e.type._context),null;case 22:case 23:return Hj(),null;case 24:return null;default:return null}}var Jj=!1,U=!1,Kj=typeof WeakSet=="function"?WeakSet:Set,V=null;function Lj(a,e){var i=a.ref;if(i!==null)if(typeof i=="function")try{i(null)}catch(s){W(a,e,s)}else i.current=null}function Mj(a,e,i){try{i()}catch(s){W(a,e,s)}}var Nj=!1;function Oj(a,e){if(Cf=dd,a=Me(),Ne(a)){if("selectionStart"in a)var i={start:a.selectionStart,end:a.selectionEnd};else e:{i=(i=a.ownerDocument)&&i.defaultView||window;var s=i.getSelection&&i.getSelection();if(s&&s.rangeCount!==0){i=s.anchorNode;var o=s.anchorOffset,c=s.focusNode;s=s.focusOffset;try{i.nodeType,c.nodeType}catch{i=null;break e}var d=0,h=-1,g=-1,_=0,b=0,$=a,j=null;t:for(;;){for(var _e;$!==i||o!==0&&$.nodeType!==3||(h=d+o),$!==c||s!==0&&$.nodeType!==3||(g=d+s),$.nodeType===3&&(d+=$.nodeValue.length),(_e=$.firstChild)!==null;)j=$,$=_e;for(;;){if($===a)break t;if(j===i&&++_===o&&(h=d),j===c&&++b===s&&(g=d),(_e=$.nextSibling)!==null)break;$=j,j=$.parentNode}$=_e}i=h===-1||g===-1?null:{start:h,end:g}}else i=null}i=i||{start:0,end:0}}else i=null;for(Df={focusedElem:a,selectionRange:i},dd=!1,V=e;V!==null;)if(e=V,a=e.child,(e.subtreeFlags&1028)!==0&&a!==null)a.return=e,V=a;else for(;V!==null;){e=V;try{var tt=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(tt!==null){var et=tt.memoizedProps,nt=tt.memoizedState,rt=e.stateNode,it=rt.getSnapshotBeforeUpdate(e.elementType===e.type?et:Ci(e.type,et),nt);rt.__reactInternalSnapshotBeforeUpdate=it}break;case 3:var at=e.stateNode.containerInfo;at.nodeType===1?at.textContent="":at.nodeType===9&&at.documentElement&&at.removeChild(at.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p$1(163))}}catch(st){W(e,e.return,st)}if(a=e.sibling,a!==null){a.return=e.return,V=a;break}V=e.return}return tt=Nj,Nj=!1,tt}function Pj(a,e,i){var s=e.updateQueue;if(s=s!==null?s.lastEffect:null,s!==null){var o=s=s.next;do{if((o.tag&a)===a){var c=o.destroy;o.destroy=void 0,c!==void 0&&Mj(e,i,c)}o=o.next}while(o!==s)}}function Qj(a,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var i=e=e.next;do{if((i.tag&a)===a){var s=i.create;i.destroy=s()}i=i.next}while(i!==e)}}function Rj(a){var e=a.ref;if(e!==null){var i=a.stateNode;switch(a.tag){case 5:a=i;break;default:a=i}typeof e=="function"?e(a):e.current=a}}function Sj(a){var e=a.alternate;e!==null&&(a.alternate=null,Sj(e)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(e=a.stateNode,e!==null&&(delete e[Of],delete e[Pf],delete e[of],delete e[Qf],delete e[Rf])),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}function Tj(a){return a.tag===5||a.tag===3||a.tag===4}function Uj(a){e:for(;;){for(;a.sibling===null;){if(a.return===null||Tj(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.flags&2||a.child===null||a.tag===4)continue e;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function Vj(a,e,i){var s=a.tag;if(s===5||s===6)a=a.stateNode,e?i.nodeType===8?i.parentNode.insertBefore(a,e):i.insertBefore(a,e):(i.nodeType===8?(e=i.parentNode,e.insertBefore(a,i)):(e=i,e.appendChild(a)),i=i._reactRootContainer,i!=null||e.onclick!==null||(e.onclick=Bf));else if(s!==4&&(a=a.child,a!==null))for(Vj(a,e,i),a=a.sibling;a!==null;)Vj(a,e,i),a=a.sibling}function Wj(a,e,i){var s=a.tag;if(s===5||s===6)a=a.stateNode,e?i.insertBefore(a,e):i.appendChild(a);else if(s!==4&&(a=a.child,a!==null))for(Wj(a,e,i),a=a.sibling;a!==null;)Wj(a,e,i),a=a.sibling}var X=null,Xj=!1;function Yj(a,e,i){for(i=i.child;i!==null;)Zj(a,e,i),i=i.sibling}function Zj(a,e,i){if(lc&&typeof lc.onCommitFiberUnmount=="function")try{lc.onCommitFiberUnmount(kc,i)}catch{}switch(i.tag){case 5:U||Lj(i,e);case 6:var s=X,o=Xj;X=null,Yj(a,e,i),X=s,Xj=o,X!==null&&(Xj?(a=X,i=i.stateNode,a.nodeType===8?a.parentNode.removeChild(i):a.removeChild(i)):X.removeChild(i.stateNode));break;case 18:X!==null&&(Xj?(a=X,i=i.stateNode,a.nodeType===8?Kf(a.parentNode,i):a.nodeType===1&&Kf(a,i),bd(a)):Kf(X,i.stateNode));break;case 4:s=X,o=Xj,X=i.stateNode.containerInfo,Xj=!0,Yj(a,e,i),X=s,Xj=o;break;case 0:case 11:case 14:case 15:if(!U&&(s=i.updateQueue,s!==null&&(s=s.lastEffect,s!==null))){o=s=s.next;do{var c=o,d=c.destroy;c=c.tag,d!==void 0&&(c&2||c&4)&&Mj(i,e,d),o=o.next}while(o!==s)}Yj(a,e,i);break;case 1:if(!U&&(Lj(i,e),s=i.stateNode,typeof s.componentWillUnmount=="function"))try{s.props=i.memoizedProps,s.state=i.memoizedState,s.componentWillUnmount()}catch(h){W(i,e,h)}Yj(a,e,i);break;case 21:Yj(a,e,i);break;case 22:i.mode&1?(U=(s=U)||i.memoizedState!==null,Yj(a,e,i),U=s):Yj(a,e,i);break;default:Yj(a,e,i)}}function ak(a){var e=a.updateQueue;if(e!==null){a.updateQueue=null;var i=a.stateNode;i===null&&(i=a.stateNode=new Kj),e.forEach(function(s){var o=bk.bind(null,a,s);i.has(s)||(i.add(s),s.then(o,o))})}}function ck(a,e){var i=e.deletions;if(i!==null)for(var s=0;s<i.length;s++){var o=i[s];try{var c=a,d=e,h=d;e:for(;h!==null;){switch(h.tag){case 5:X=h.stateNode,Xj=!1;break e;case 3:X=h.stateNode.containerInfo,Xj=!0;break e;case 4:X=h.stateNode.containerInfo,Xj=!0;break e}h=h.return}if(X===null)throw Error(p$1(160));Zj(c,d,o),X=null,Xj=!1;var g=o.alternate;g!==null&&(g.return=null),o.return=null}catch(_){W(o,e,_)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)dk(e,a),e=e.sibling}function dk(a,e){var i=a.alternate,s=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:if(ck(e,a),ek(a),s&4){try{Pj(3,a,a.return),Qj(3,a)}catch(et){W(a,a.return,et)}try{Pj(5,a,a.return)}catch(et){W(a,a.return,et)}}break;case 1:ck(e,a),ek(a),s&512&&i!==null&&Lj(i,i.return);break;case 5:if(ck(e,a),ek(a),s&512&&i!==null&&Lj(i,i.return),a.flags&32){var o=a.stateNode;try{ob(o,"")}catch(et){W(a,a.return,et)}}if(s&4&&(o=a.stateNode,o!=null)){var c=a.memoizedProps,d=i!==null?i.memoizedProps:c,h=a.type,g=a.updateQueue;if(a.updateQueue=null,g!==null)try{h==="input"&&c.type==="radio"&&c.name!=null&&ab(o,c),vb(h,d);var _=vb(h,c);for(d=0;d<g.length;d+=2){var b=g[d],$=g[d+1];b==="style"?sb(o,$):b==="dangerouslySetInnerHTML"?nb(o,$):b==="children"?ob(o,$):ta(o,b,$,_)}switch(h){case"input":bb(o,c);break;case"textarea":ib(o,c);break;case"select":var j=o._wrapperState.wasMultiple;o._wrapperState.wasMultiple=!!c.multiple;var _e=c.value;_e!=null?fb(o,!!c.multiple,_e,!1):j!==!!c.multiple&&(c.defaultValue!=null?fb(o,!!c.multiple,c.defaultValue,!0):fb(o,!!c.multiple,c.multiple?[]:"",!1))}o[Pf]=c}catch(et){W(a,a.return,et)}}break;case 6:if(ck(e,a),ek(a),s&4){if(a.stateNode===null)throw Error(p$1(162));o=a.stateNode,c=a.memoizedProps;try{o.nodeValue=c}catch(et){W(a,a.return,et)}}break;case 3:if(ck(e,a),ek(a),s&4&&i!==null&&i.memoizedState.isDehydrated)try{bd(e.containerInfo)}catch(et){W(a,a.return,et)}break;case 4:ck(e,a),ek(a);break;case 13:ck(e,a),ek(a),o=a.child,o.flags&8192&&(c=o.memoizedState!==null,o.stateNode.isHidden=c,!c||o.alternate!==null&&o.alternate.memoizedState!==null||(fk=B$1())),s&4&&ak(a);break;case 22:if(b=i!==null&&i.memoizedState!==null,a.mode&1?(U=(_=U)||b,ck(e,a),U=_):ck(e,a),ek(a),s&8192){if(_=a.memoizedState!==null,(a.stateNode.isHidden=_)&&!b&&a.mode&1)for(V=a,b=a.child;b!==null;){for($=V=b;V!==null;){switch(j=V,_e=j.child,j.tag){case 0:case 11:case 14:case 15:Pj(4,j,j.return);break;case 1:Lj(j,j.return);var tt=j.stateNode;if(typeof tt.componentWillUnmount=="function"){s=j,i=j.return;try{e=s,tt.props=e.memoizedProps,tt.state=e.memoizedState,tt.componentWillUnmount()}catch(et){W(s,i,et)}}break;case 5:Lj(j,j.return);break;case 22:if(j.memoizedState!==null){gk($);continue}}_e!==null?(_e.return=j,V=_e):gk($)}b=b.sibling}e:for(b=null,$=a;;){if($.tag===5){if(b===null){b=$;try{o=$.stateNode,_?(c=o.style,typeof c.setProperty=="function"?c.setProperty("display","none","important"):c.display="none"):(h=$.stateNode,g=$.memoizedProps.style,d=g!=null&&g.hasOwnProperty("display")?g.display:null,h.style.display=rb("display",d))}catch(et){W(a,a.return,et)}}}else if($.tag===6){if(b===null)try{$.stateNode.nodeValue=_?"":$.memoizedProps}catch(et){W(a,a.return,et)}}else if(($.tag!==22&&$.tag!==23||$.memoizedState===null||$===a)&&$.child!==null){$.child.return=$,$=$.child;continue}if($===a)break e;for(;$.sibling===null;){if($.return===null||$.return===a)break e;b===$&&(b=null),$=$.return}b===$&&(b=null),$.sibling.return=$.return,$=$.sibling}}break;case 19:ck(e,a),ek(a),s&4&&ak(a);break;case 21:break;default:ck(e,a),ek(a)}}function ek(a){var e=a.flags;if(e&2){try{e:{for(var i=a.return;i!==null;){if(Tj(i)){var s=i;break e}i=i.return}throw Error(p$1(160))}switch(s.tag){case 5:var o=s.stateNode;s.flags&32&&(ob(o,""),s.flags&=-33);var c=Uj(a);Wj(a,c,o);break;case 3:case 4:var d=s.stateNode.containerInfo,h=Uj(a);Vj(a,h,d);break;default:throw Error(p$1(161))}}catch(g){W(a,a.return,g)}a.flags&=-3}e&4096&&(a.flags&=-4097)}function hk(a,e,i){V=a,ik(a)}function ik(a,e,i){for(var s=(a.mode&1)!==0;V!==null;){var o=V,c=o.child;if(o.tag===22&&s){var d=o.memoizedState!==null||Jj;if(!d){var h=o.alternate,g=h!==null&&h.memoizedState!==null||U;h=Jj;var _=U;if(Jj=d,(U=g)&&!_)for(V=o;V!==null;)d=V,g=d.child,d.tag===22&&d.memoizedState!==null?jk(o):g!==null?(g.return=d,V=g):jk(o);for(;c!==null;)V=c,ik(c),c=c.sibling;V=o,Jj=h,U=_}kk(a)}else o.subtreeFlags&8772&&c!==null?(c.return=o,V=c):kk(a)}}function kk(a){for(;V!==null;){var e=V;if(e.flags&8772){var i=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:U||Qj(5,e);break;case 1:var s=e.stateNode;if(e.flags&4&&!U)if(i===null)s.componentDidMount();else{var o=e.elementType===e.type?i.memoizedProps:Ci(e.type,i.memoizedProps);s.componentDidUpdate(o,i.memoizedState,s.__reactInternalSnapshotBeforeUpdate)}var c=e.updateQueue;c!==null&&sh(e,c,s);break;case 3:var d=e.updateQueue;if(d!==null){if(i=null,e.child!==null)switch(e.child.tag){case 5:i=e.child.stateNode;break;case 1:i=e.child.stateNode}sh(e,d,i)}break;case 5:var h=e.stateNode;if(i===null&&e.flags&4){i=h;var g=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":g.autoFocus&&i.focus();break;case"img":g.src&&(i.src=g.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var _=e.alternate;if(_!==null){var b=_.memoizedState;if(b!==null){var $=b.dehydrated;$!==null&&bd($)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(p$1(163))}U||e.flags&512&&Rj(e)}catch(j){W(e,e.return,j)}}if(e===a){V=null;break}if(i=e.sibling,i!==null){i.return=e.return,V=i;break}V=e.return}}function gk(a){for(;V!==null;){var e=V;if(e===a){V=null;break}var i=e.sibling;if(i!==null){i.return=e.return,V=i;break}V=e.return}}function jk(a){for(;V!==null;){var e=V;try{switch(e.tag){case 0:case 11:case 15:var i=e.return;try{Qj(4,e)}catch(g){W(e,i,g)}break;case 1:var s=e.stateNode;if(typeof s.componentDidMount=="function"){var o=e.return;try{s.componentDidMount()}catch(g){W(e,o,g)}}var c=e.return;try{Rj(e)}catch(g){W(e,c,g)}break;case 5:var d=e.return;try{Rj(e)}catch(g){W(e,d,g)}}}catch(g){W(e,e.return,g)}if(e===a){V=null;break}var h=e.sibling;if(h!==null){h.return=e.return,V=h;break}V=e.return}}var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=1/0,uk=null,Oi=!1,Pi=null,Ri=null,vk=!1,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return K&6?B$1():Ak!==-1?Ak:Ak=B$1()}function yi(a){return a.mode&1?K&2&&Z!==0?Z&-Z:Kg.transition!==null?(Bk===0&&(Bk=yc()),Bk):(a=C$1,a!==0||(a=window.event,a=a===void 0?16:jd(a.type)),a):1}function gi(a,e,i,s){if(50<yk)throw yk=0,zk=null,Error(p$1(185));Ac(a,i,s),(!(K&2)||a!==Q)&&(a===Q&&(!(K&2)&&(qk|=i),T===4&&Ck(a,Z)),Dk(a,s),i===1&&K===0&&!(e.mode&1)&&(Gj=B$1()+500,fg&&jg()))}function Dk(a,e){var i=a.callbackNode;wc(a,e);var s=uc(a,a===Q?Z:0);if(s===0)i!==null&&bc(i),a.callbackNode=null,a.callbackPriority=0;else if(e=s&-s,a.callbackPriority!==e){if(i!=null&&bc(i),e===1)a.tag===0?ig(Ek.bind(null,a)):hg(Ek.bind(null,a)),Jf(function(){!(K&6)&&jg()}),i=null;else{switch(Dc(s)){case 1:i=fc;break;case 4:i=gc;break;case 16:i=hc;break;case 536870912:i=jc;break;default:i=hc}i=Fk(i,Gk.bind(null,a))}a.callbackPriority=e,a.callbackNode=i}}function Gk(a,e){if(Ak=-1,Bk=0,K&6)throw Error(p$1(327));var i=a.callbackNode;if(Hk()&&a.callbackNode!==i)return null;var s=uc(a,a===Q?Z:0);if(s===0)return null;if(s&30||s&a.expiredLanes||e)e=Ik(a,s);else{e=s;var o=K;K|=2;var c=Jk();(Q!==a||Z!==e)&&(uk=null,Gj=B$1()+500,Kk(a,e));do try{Lk();break}catch(h){Mk(a,h)}while(!0);$g(),mk.current=c,K=o,Y!==null?e=0:(Q=null,Z=0,e=T)}if(e!==0){if(e===2&&(o=xc(a),o!==0&&(s=o,e=Nk(a,o))),e===1)throw i=pk,Kk(a,0),Ck(a,s),Dk(a,B$1()),i;if(e===6)Ck(a,s);else{if(o=a.current.alternate,!(s&30)&&!Ok(o)&&(e=Ik(a,s),e===2&&(c=xc(a),c!==0&&(s=c,e=Nk(a,c))),e===1))throw i=pk,Kk(a,0),Ck(a,s),Dk(a,B$1()),i;switch(a.finishedWork=o,a.finishedLanes=s,e){case 0:case 1:throw Error(p$1(345));case 2:Pk(a,tk,uk);break;case 3:if(Ck(a,s),(s&130023424)===s&&(e=fk+500-B$1(),10<e)){if(uc(a,0)!==0)break;if(o=a.suspendedLanes,(o&s)!==s){R(),a.pingedLanes|=a.suspendedLanes&o;break}a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),e);break}Pk(a,tk,uk);break;case 4:if(Ck(a,s),(s&4194240)===s)break;for(e=a.eventTimes,o=-1;0<s;){var d=31-oc(s);c=1<<d,d=e[d],d>o&&(o=d),s&=~c}if(s=o,s=B$1()-s,s=(120>s?120:480>s?480:1080>s?1080:1920>s?1920:3e3>s?3e3:4320>s?4320:1960*lk(s/1960))-s,10<s){a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),s);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p$1(329))}}}return Dk(a,B$1()),a.callbackNode===i?Gk.bind(null,a):null}function Nk(a,e){var i=sk;return a.current.memoizedState.isDehydrated&&(Kk(a,e).flags|=256),a=Ik(a,e),a!==2&&(e=tk,tk=i,e!==null&&Fj(e)),a}function Fj(a){tk===null?tk=a:tk.push.apply(tk,a)}function Ok(a){for(var e=a;;){if(e.flags&16384){var i=e.updateQueue;if(i!==null&&(i=i.stores,i!==null))for(var s=0;s<i.length;s++){var o=i[s],c=o.getSnapshot;o=o.value;try{if(!He(c(),o))return!1}catch{return!1}}}if(i=e.child,e.subtreeFlags&16384&&i!==null)i.return=e,e=i;else{if(e===a)break;for(;e.sibling===null;){if(e.return===null||e.return===a)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function Ck(a,e){for(e&=~rk,e&=~qk,a.suspendedLanes|=e,a.pingedLanes&=~e,a=a.expirationTimes;0<e;){var i=31-oc(e),s=1<<i;a[i]=-1,e&=~s}}function Ek(a){if(K&6)throw Error(p$1(327));Hk();var e=uc(a,0);if(!(e&1))return Dk(a,B$1()),null;var i=Ik(a,e);if(a.tag!==0&&i===2){var s=xc(a);s!==0&&(e=s,i=Nk(a,s))}if(i===1)throw i=pk,Kk(a,0),Ck(a,e),Dk(a,B$1()),i;if(i===6)throw Error(p$1(345));return a.finishedWork=a.current.alternate,a.finishedLanes=e,Pk(a,tk,uk),Dk(a,B$1()),null}function Qk(a,e){var i=K;K|=1;try{return a(e)}finally{K=i,K===0&&(Gj=B$1()+500,fg&&jg())}}function Rk(a){wk!==null&&wk.tag===0&&!(K&6)&&Hk();var e=K;K|=1;var i=ok.transition,s=C$1;try{if(ok.transition=null,C$1=1,a)return a()}finally{C$1=s,ok.transition=i,K=e,!(K&6)&&jg()}}function Hj(){fj=ej.current,E(ej)}function Kk(a,e){a.finishedWork=null,a.finishedLanes=0;var i=a.timeoutHandle;if(i!==-1&&(a.timeoutHandle=-1,Gf(i)),Y!==null)for(i=Y.return;i!==null;){var s=i;switch(wg(s),s.tag){case 1:s=s.type.childContextTypes,s!=null&&$f();break;case 3:zh(),E(Wf),E(H),Eh();break;case 5:Bh(s);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(s.type._context);break;case 22:case 23:Hj()}i=i.return}if(Q=a,Y=a=Pg(a.current,null),Z=fj=e,T=0,pk=null,rk=qk=rh=0,tk=sk=null,fh!==null){for(e=0;e<fh.length;e++)if(i=fh[e],s=i.interleaved,s!==null){i.interleaved=null;var o=s.next,c=i.pending;if(c!==null){var d=c.next;c.next=o,s.next=d}i.pending=s}fh=null}return a}function Mk(a,e){do{var i=Y;try{if($g(),Fh.current=Rh,Ih){for(var s=M.memoizedState;s!==null;){var o=s.queue;o!==null&&(o.pending=null),s=s.next}Ih=!1}if(Hh=0,O=N=M=null,Jh=!1,Kh=0,nk.current=null,i===null||i.return===null){T=1,pk=e,Y=null;break}e:{var c=a,d=i.return,h=i,g=e;if(e=Z,h.flags|=32768,g!==null&&typeof g=="object"&&typeof g.then=="function"){var _=g,b=h,$=b.tag;if(!(b.mode&1)&&($===0||$===11||$===15)){var j=b.alternate;j?(b.updateQueue=j.updateQueue,b.memoizedState=j.memoizedState,b.lanes=j.lanes):(b.updateQueue=null,b.memoizedState=null)}var _e=Ui(d);if(_e!==null){_e.flags&=-257,Vi(_e,d,h,c,e),_e.mode&1&&Si(c,_,e),e=_e,g=_;var tt=e.updateQueue;if(tt===null){var et=new Set;et.add(g),e.updateQueue=et}else tt.add(g);break e}else{if(!(e&1)){Si(c,_,e),tj();break e}g=Error(p$1(426))}}else if(I&&h.mode&1){var nt=Ui(d);if(nt!==null){!(nt.flags&65536)&&(nt.flags|=256),Vi(nt,d,h,c,e),Jg(Ji(g,h));break e}}c=g=Ji(g,h),T!==4&&(T=2),sk===null?sk=[c]:sk.push(c),c=d;do{switch(c.tag){case 3:c.flags|=65536,e&=-e,c.lanes|=e;var rt=Ni(c,g,e);ph(c,rt);break e;case 1:h=g;var it=c.type,at=c.stateNode;if(!(c.flags&128)&&(typeof it.getDerivedStateFromError=="function"||at!==null&&typeof at.componentDidCatch=="function"&&(Ri===null||!Ri.has(at)))){c.flags|=65536,e&=-e,c.lanes|=e;var st=Qi(c,h,e);ph(c,st);break e}}c=c.return}while(c!==null)}Sk(i)}catch(ot){e=ot,Y===i&&i!==null&&(Y=i=i.return);continue}break}while(!0)}function Jk(){var a=mk.current;return mk.current=Rh,a===null?Rh:a}function tj(){(T===0||T===3||T===2)&&(T=4),Q===null||!(rh&268435455)&&!(qk&268435455)||Ck(Q,Z)}function Ik(a,e){var i=K;K|=2;var s=Jk();(Q!==a||Z!==e)&&(uk=null,Kk(a,e));do try{Tk();break}catch(o){Mk(a,o)}while(!0);if($g(),K=i,mk.current=s,Y!==null)throw Error(p$1(261));return Q=null,Z=0,T}function Tk(){for(;Y!==null;)Uk(Y)}function Lk(){for(;Y!==null&&!cc();)Uk(Y)}function Uk(a){var e=Vk(a.alternate,a,fj);a.memoizedProps=a.pendingProps,e===null?Sk(a):Y=e,nk.current=null}function Sk(a){var e=a;do{var i=e.alternate;if(a=e.return,e.flags&32768){if(i=Ij(i,e),i!==null){i.flags&=32767,Y=i;return}if(a!==null)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6,Y=null;return}}else if(i=Ej(i,e,fj),i!==null){Y=i;return}if(e=e.sibling,e!==null){Y=e;return}Y=e=a}while(e!==null);T===0&&(T=5)}function Pk(a,e,i){var s=C$1,o=ok.transition;try{ok.transition=null,C$1=1,Wk(a,e,i,s)}finally{ok.transition=o,C$1=s}return null}function Wk(a,e,i,s){do Hk();while(wk!==null);if(K&6)throw Error(p$1(327));i=a.finishedWork;var o=a.finishedLanes;if(i===null)return null;if(a.finishedWork=null,a.finishedLanes=0,i===a.current)throw Error(p$1(177));a.callbackNode=null,a.callbackPriority=0;var c=i.lanes|i.childLanes;if(Bc(a,c),a===Q&&(Y=Q=null,Z=0),!(i.subtreeFlags&2064)&&!(i.flags&2064)||vk||(vk=!0,Fk(hc,function(){return Hk(),null})),c=(i.flags&15990)!==0,i.subtreeFlags&15990||c){c=ok.transition,ok.transition=null;var d=C$1;C$1=1;var h=K;K|=4,nk.current=null,Oj(a,i),dk(i,a),Oe(Df),dd=!!Cf,Df=Cf=null,a.current=i,hk(i),dc(),K=h,C$1=d,ok.transition=c}else a.current=i;if(vk&&(vk=!1,wk=a,xk=o),c=a.pendingLanes,c===0&&(Ri=null),mc(i.stateNode),Dk(a,B$1()),e!==null)for(s=a.onRecoverableError,i=0;i<e.length;i++)o=e[i],s(o.value,{componentStack:o.stack,digest:o.digest});if(Oi)throw Oi=!1,a=Pi,Pi=null,a;return xk&1&&a.tag!==0&&Hk(),c=a.pendingLanes,c&1?a===zk?yk++:(yk=0,zk=a):yk=0,jg(),null}function Hk(){if(wk!==null){var a=Dc(xk),e=ok.transition,i=C$1;try{if(ok.transition=null,C$1=16>a?16:a,wk===null)var s=!1;else{if(a=wk,wk=null,xk=0,K&6)throw Error(p$1(331));var o=K;for(K|=4,V=a.current;V!==null;){var c=V,d=c.child;if(V.flags&16){var h=c.deletions;if(h!==null){for(var g=0;g<h.length;g++){var _=h[g];for(V=_;V!==null;){var b=V;switch(b.tag){case 0:case 11:case 15:Pj(8,b,c)}var $=b.child;if($!==null)$.return=b,V=$;else for(;V!==null;){b=V;var j=b.sibling,_e=b.return;if(Sj(b),b===_){V=null;break}if(j!==null){j.return=_e,V=j;break}V=_e}}}var tt=c.alternate;if(tt!==null){var et=tt.child;if(et!==null){tt.child=null;do{var nt=et.sibling;et.sibling=null,et=nt}while(et!==null)}}V=c}}if(c.subtreeFlags&2064&&d!==null)d.return=c,V=d;else e:for(;V!==null;){if(c=V,c.flags&2048)switch(c.tag){case 0:case 11:case 15:Pj(9,c,c.return)}var rt=c.sibling;if(rt!==null){rt.return=c.return,V=rt;break e}V=c.return}}var it=a.current;for(V=it;V!==null;){d=V;var at=d.child;if(d.subtreeFlags&2064&&at!==null)at.return=d,V=at;else e:for(d=it;V!==null;){if(h=V,h.flags&2048)try{switch(h.tag){case 0:case 11:case 15:Qj(9,h)}}catch(ot){W(h,h.return,ot)}if(h===d){V=null;break e}var st=h.sibling;if(st!==null){st.return=h.return,V=st;break e}V=h.return}}if(K=o,jg(),lc&&typeof lc.onPostCommitFiberRoot=="function")try{lc.onPostCommitFiberRoot(kc,a)}catch{}s=!0}return s}finally{C$1=i,ok.transition=e}}return!1}function Xk(a,e,i){e=Ji(i,e),e=Ni(a,e,1),a=nh(a,e,1),e=R(),a!==null&&(Ac(a,1,e),Dk(a,e))}function W(a,e,i){if(a.tag===3)Xk(a,a,i);else for(;e!==null;){if(e.tag===3){Xk(e,a,i);break}else if(e.tag===1){var s=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof s.componentDidCatch=="function"&&(Ri===null||!Ri.has(s))){a=Ji(i,a),a=Qi(e,a,1),e=nh(e,a,1),a=R(),e!==null&&(Ac(e,1,a),Dk(e,a));break}}e=e.return}}function Ti(a,e,i){var s=a.pingCache;s!==null&&s.delete(e),e=R(),a.pingedLanes|=a.suspendedLanes&i,Q===a&&(Z&i)===i&&(T===4||T===3&&(Z&130023424)===Z&&500>B$1()-fk?Kk(a,0):rk|=i),Dk(a,e)}function Yk(a,e){e===0&&(a.mode&1?(e=sc,sc<<=1,!(sc&130023424)&&(sc=4194304)):e=1);var i=R();a=ih(a,e),a!==null&&(Ac(a,e,i),Dk(a,i))}function uj(a){var e=a.memoizedState,i=0;e!==null&&(i=e.retryLane),Yk(a,i)}function bk(a,e){var i=0;switch(a.tag){case 13:var s=a.stateNode,o=a.memoizedState;o!==null&&(i=o.retryLane);break;case 19:s=a.stateNode;break;default:throw Error(p$1(314))}s!==null&&s.delete(e),Yk(a,i)}var Vk;Vk=function(a,e,i){if(a!==null)if(a.memoizedProps!==e.pendingProps||Wf.current)dh=!0;else{if(!(a.lanes&i)&&!(e.flags&128))return dh=!1,yj(a,e,i);dh=!!(a.flags&131072)}else dh=!1,I&&e.flags&1048576&&ug(e,ng,e.index);switch(e.lanes=0,e.tag){case 2:var s=e.type;ij(a,e),a=e.pendingProps;var o=Yf(e,H.current);ch(e,i),o=Nh(null,e,s,a,o,i);var c=Sh();return e.flags|=1,typeof o=="object"&&o!==null&&typeof o.render=="function"&&o.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Zf(s)?(c=!0,cg(e)):c=!1,e.memoizedState=o.state!==null&&o.state!==void 0?o.state:null,kh(e),o.updater=Ei,e.stateNode=o,o._reactInternals=e,Ii(e,s,a,i),e=jj(null,e,s,!0,c,i)):(e.tag=0,I&&c&&vg(e),Xi(null,e,o,i),e=e.child),e;case 16:s=e.elementType;e:{switch(ij(a,e),a=e.pendingProps,o=s._init,s=o(s._payload),e.type=s,o=e.tag=Zk(s),a=Ci(s,a),o){case 0:e=cj(null,e,s,a,i);break e;case 1:e=hj(null,e,s,a,i);break e;case 11:e=Yi(null,e,s,a,i);break e;case 14:e=$i(null,e,s,Ci(s.type,a),i);break e}throw Error(p$1(306,s,""))}return e;case 0:return s=e.type,o=e.pendingProps,o=e.elementType===s?o:Ci(s,o),cj(a,e,s,o,i);case 1:return s=e.type,o=e.pendingProps,o=e.elementType===s?o:Ci(s,o),hj(a,e,s,o,i);case 3:e:{if(kj(e),a===null)throw Error(p$1(387));s=e.pendingProps,c=e.memoizedState,o=c.element,lh(a,e),qh(e,s,null,i);var d=e.memoizedState;if(s=d.element,c.isDehydrated)if(c={element:s,isDehydrated:!1,cache:d.cache,pendingSuspenseBoundaries:d.pendingSuspenseBoundaries,transitions:d.transitions},e.updateQueue.baseState=c,e.memoizedState=c,e.flags&256){o=Ji(Error(p$1(423)),e),e=lj(a,e,s,i,o);break e}else if(s!==o){o=Ji(Error(p$1(424)),e),e=lj(a,e,s,i,o);break e}else for(yg=Lf(e.stateNode.containerInfo.firstChild),xg=e,I=!0,zg=null,i=Vg(e,null,s,i),e.child=i;i;)i.flags=i.flags&-3|4096,i=i.sibling;else{if(Ig(),s===o){e=Zi(a,e,i);break e}Xi(a,e,s,i)}e=e.child}return e;case 5:return Ah(e),a===null&&Eg(e),s=e.type,o=e.pendingProps,c=a!==null?a.memoizedProps:null,d=o.children,Ef(s,o)?d=null:c!==null&&Ef(s,c)&&(e.flags|=32),gj(a,e),Xi(a,e,d,i),e.child;case 6:return a===null&&Eg(e),null;case 13:return oj(a,e,i);case 4:return yh(e,e.stateNode.containerInfo),s=e.pendingProps,a===null?e.child=Ug(e,null,s,i):Xi(a,e,s,i),e.child;case 11:return s=e.type,o=e.pendingProps,o=e.elementType===s?o:Ci(s,o),Yi(a,e,s,o,i);case 7:return Xi(a,e,e.pendingProps,i),e.child;case 8:return Xi(a,e,e.pendingProps.children,i),e.child;case 12:return Xi(a,e,e.pendingProps.children,i),e.child;case 10:e:{if(s=e.type._context,o=e.pendingProps,c=e.memoizedProps,d=o.value,G(Wg,s._currentValue),s._currentValue=d,c!==null)if(He(c.value,d)){if(c.children===o.children&&!Wf.current){e=Zi(a,e,i);break e}}else for(c=e.child,c!==null&&(c.return=e);c!==null;){var h=c.dependencies;if(h!==null){d=c.child;for(var g=h.firstContext;g!==null;){if(g.context===s){if(c.tag===1){g=mh(-1,i&-i),g.tag=2;var _=c.updateQueue;if(_!==null){_=_.shared;var b=_.pending;b===null?g.next=g:(g.next=b.next,b.next=g),_.pending=g}}c.lanes|=i,g=c.alternate,g!==null&&(g.lanes|=i),bh(c.return,i,e),h.lanes|=i;break}g=g.next}}else if(c.tag===10)d=c.type===e.type?null:c.child;else if(c.tag===18){if(d=c.return,d===null)throw Error(p$1(341));d.lanes|=i,h=d.alternate,h!==null&&(h.lanes|=i),bh(d,i,e),d=c.sibling}else d=c.child;if(d!==null)d.return=c;else for(d=c;d!==null;){if(d===e){d=null;break}if(c=d.sibling,c!==null){c.return=d.return,d=c;break}d=d.return}c=d}Xi(a,e,o.children,i),e=e.child}return e;case 9:return o=e.type,s=e.pendingProps.children,ch(e,i),o=eh(o),s=s(o),e.flags|=1,Xi(a,e,s,i),e.child;case 14:return s=e.type,o=Ci(s,e.pendingProps),o=Ci(s.type,o),$i(a,e,s,o,i);case 15:return bj(a,e,e.type,e.pendingProps,i);case 17:return s=e.type,o=e.pendingProps,o=e.elementType===s?o:Ci(s,o),ij(a,e),e.tag=1,Zf(s)?(a=!0,cg(e)):a=!1,ch(e,i),Gi(e,s,o),Ii(e,s,o,i),jj(null,e,s,!0,a,i);case 19:return xj(a,e,i);case 22:return dj(a,e,i)}throw Error(p$1(156,e.tag))};function Fk(a,e){return ac(a,e)}function $k(a,e,i,s){this.tag=a,this.key=i,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=s,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bg(a,e,i,s){return new $k(a,e,i,s)}function aj(a){return a=a.prototype,!(!a||!a.isReactComponent)}function Zk(a){if(typeof a=="function")return aj(a)?1:0;if(a!=null){if(a=a.$$typeof,a===Da)return 11;if(a===Ga)return 14}return 2}function Pg(a,e){var i=a.alternate;return i===null?(i=Bg(a.tag,e,a.key,a.mode),i.elementType=a.elementType,i.type=a.type,i.stateNode=a.stateNode,i.alternate=a,a.alternate=i):(i.pendingProps=e,i.type=a.type,i.flags=0,i.subtreeFlags=0,i.deletions=null),i.flags=a.flags&14680064,i.childLanes=a.childLanes,i.lanes=a.lanes,i.child=a.child,i.memoizedProps=a.memoizedProps,i.memoizedState=a.memoizedState,i.updateQueue=a.updateQueue,e=a.dependencies,i.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},i.sibling=a.sibling,i.index=a.index,i.ref=a.ref,i}function Rg(a,e,i,s,o,c){var d=2;if(s=a,typeof a=="function")aj(a)&&(d=1);else if(typeof a=="string")d=5;else e:switch(a){case ya:return Tg(i.children,o,c,e);case za:d=8,o|=8;break;case Aa:return a=Bg(12,i,e,o|2),a.elementType=Aa,a.lanes=c,a;case Ea:return a=Bg(13,i,e,o),a.elementType=Ea,a.lanes=c,a;case Fa:return a=Bg(19,i,e,o),a.elementType=Fa,a.lanes=c,a;case Ia:return pj(i,o,c,e);default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case Ba:d=10;break e;case Ca:d=9;break e;case Da:d=11;break e;case Ga:d=14;break e;case Ha:d=16,s=null;break e}throw Error(p$1(130,a==null?a:typeof a,""))}return e=Bg(d,i,e,o),e.elementType=a,e.type=s,e.lanes=c,e}function Tg(a,e,i,s){return a=Bg(7,a,s,e),a.lanes=i,a}function pj(a,e,i,s){return a=Bg(22,a,s,e),a.elementType=Ia,a.lanes=i,a.stateNode={isHidden:!1},a}function Qg(a,e,i){return a=Bg(6,a,null,e),a.lanes=i,a}function Sg(a,e,i){return e=Bg(4,a.children!==null?a.children:[],a.key,e),e.lanes=i,e.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},e}function al(a,e,i,s,o){this.tag=e,this.containerInfo=a,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=zc(0),this.expirationTimes=zc(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=zc(0),this.identifierPrefix=s,this.onRecoverableError=o,this.mutableSourceEagerHydrationData=null}function bl(a,e,i,s,o,c,d,h,g){return a=new al(a,e,i,h,g),e===1?(e=1,c===!0&&(e|=8)):e=0,c=Bg(3,null,null,e),a.current=c,c.stateNode=a,c.memoizedState={element:s,isDehydrated:i,cache:null,transitions:null,pendingSuspenseBoundaries:null},kh(c),a}function cl(a,e,i){var s=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:wa,key:s==null?null:""+s,children:a,containerInfo:e,implementation:i}}function dl(a){if(!a)return Vf;a=a._reactInternals;e:{if(Vb(a)!==a||a.tag!==1)throw Error(p$1(170));var e=a;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(Zf(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(p$1(171))}if(a.tag===1){var i=a.type;if(Zf(i))return bg(a,i,e)}return e}function el(a,e,i,s,o,c,d,h,g){return a=bl(i,s,!0,a,o,c,d,h,g),a.context=dl(null),i=a.current,s=R(),o=yi(i),c=mh(s,o),c.callback=e??null,nh(i,c,o),a.current.lanes=o,Ac(a,o,s),Dk(a,s),a}function fl(a,e,i,s){var o=e.current,c=R(),d=yi(o);return i=dl(i),e.context===null?e.context=i:e.pendingContext=i,e=mh(c,d),e.payload={element:a},s=s===void 0?null:s,s!==null&&(e.callback=s),a=nh(o,e,d),a!==null&&(gi(a,o,d,c),oh(a,o,d)),d}function gl(a){if(a=a.current,!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,e){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var i=a.retryLane;a.retryLane=i!==0&&i<e?i:e}}function il(a,e){hl(a,e),(a=a.alternate)&&hl(a,e)}function jl(){return null}var kl=typeof reportError=="function"?reportError:function(a){console.error(a)};function ll(a){this._internalRoot=a}ml.prototype.render=ll.prototype.render=function(a){var e=this._internalRoot;if(e===null)throw Error(p$1(409));fl(a,e,null,null)};ml.prototype.unmount=ll.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var e=a.containerInfo;Rk(function(){fl(null,a,null,null)}),e[uf]=null}};function ml(a){this._internalRoot=a}ml.prototype.unstable_scheduleHydration=function(a){if(a){var e=Hc();a={blockedOn:null,target:a,priority:e};for(var i=0;i<Qc.length&&e!==0&&e<Qc[i].priority;i++);Qc.splice(i,0,a),i===0&&Vc(a)}};function nl(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function ol(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11&&(a.nodeType!==8||a.nodeValue!==" react-mount-point-unstable "))}function pl(){}function ql(a,e,i,s,o){if(o){if(typeof s=="function"){var c=s;s=function(){var _=gl(d);c.call(_)}}var d=el(e,s,a,0,null,!1,!1,"",pl);return a._reactRootContainer=d,a[uf]=d.current,sf(a.nodeType===8?a.parentNode:a),Rk(),d}for(;o=a.lastChild;)a.removeChild(o);if(typeof s=="function"){var h=s;s=function(){var _=gl(g);h.call(_)}}var g=bl(a,0,!1,null,null,!1,!1,"",pl);return a._reactRootContainer=g,a[uf]=g.current,sf(a.nodeType===8?a.parentNode:a),Rk(function(){fl(e,g,i,s)}),g}function rl(a,e,i,s,o){var c=i._reactRootContainer;if(c){var d=c;if(typeof o=="function"){var h=o;o=function(){var g=gl(d);h.call(g)}}fl(e,d,a,o)}else d=ql(i,e,a,o,s);return gl(d)}Ec=function(a){switch(a.tag){case 3:var e=a.stateNode;if(e.current.memoizedState.isDehydrated){var i=tc(e.pendingLanes);i!==0&&(Cc(e,i|1),Dk(e,B$1()),!(K&6)&&(Gj=B$1()+500,jg()))}break;case 13:Rk(function(){var s=ih(a,1);if(s!==null){var o=R();gi(s,a,1,o)}}),il(a,1)}};Fc=function(a){if(a.tag===13){var e=ih(a,134217728);if(e!==null){var i=R();gi(e,a,134217728,i)}il(a,134217728)}};Gc=function(a){if(a.tag===13){var e=yi(a),i=ih(a,e);if(i!==null){var s=R();gi(i,a,e,s)}il(a,e)}};Hc=function(){return C$1};Ic=function(a,e){var i=C$1;try{return C$1=a,e()}finally{C$1=i}};yb=function(a,e,i){switch(e){case"input":if(bb(a,i),e=i.name,i.type==="radio"&&e!=null){for(i=a;i.parentNode;)i=i.parentNode;for(i=i.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<i.length;e++){var s=i[e];if(s!==a&&s.form===a.form){var o=Db(s);if(!o)throw Error(p$1(90));Wa(s),bb(s,o)}}}break;case"textarea":ib(a,i);break;case"select":e=i.value,e!=null&&fb(a,!!i.multiple,e,!1)}};Gb=Qk;Hb=Rk;var sl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){return a=Zb(a),a===null?null:a.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl}catch{}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;reactDom_production_min.createPortal=function(a,e){var i=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!nl(e))throw Error(p$1(200));return cl(a,e,null,i)};reactDom_production_min.createRoot=function(a,e){if(!nl(a))throw Error(p$1(299));var i=!1,s="",o=kl;return e!=null&&(e.unstable_strictMode===!0&&(i=!0),e.identifierPrefix!==void 0&&(s=e.identifierPrefix),e.onRecoverableError!==void 0&&(o=e.onRecoverableError)),e=bl(a,1,!1,null,null,i,!1,s,o),a[uf]=e.current,sf(a.nodeType===8?a.parentNode:a),new ll(e)};reactDom_production_min.findDOMNode=function(a){if(a==null)return null;if(a.nodeType===1)return a;var e=a._reactInternals;if(e===void 0)throw typeof a.render=="function"?Error(p$1(188)):(a=Object.keys(a).join(","),Error(p$1(268,a)));return a=Zb(e),a=a===null?null:a.stateNode,a};reactDom_production_min.flushSync=function(a){return Rk(a)};reactDom_production_min.hydrate=function(a,e,i){if(!ol(e))throw Error(p$1(200));return rl(null,a,e,!0,i)};reactDom_production_min.hydrateRoot=function(a,e,i){if(!nl(a))throw Error(p$1(405));var s=i!=null&&i.hydratedSources||null,o=!1,c="",d=kl;if(i!=null&&(i.unstable_strictMode===!0&&(o=!0),i.identifierPrefix!==void 0&&(c=i.identifierPrefix),i.onRecoverableError!==void 0&&(d=i.onRecoverableError)),e=el(e,null,a,1,i??null,o,!1,c,d),a[uf]=e.current,sf(a),s)for(a=0;a<s.length;a++)i=s[a],o=i._getVersion,o=o(i._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[i,o]:e.mutableSourceEagerHydrationData.push(i,o);return new ml(e)};reactDom_production_min.render=function(a,e,i){if(!ol(e))throw Error(p$1(200));return rl(null,a,e,!1,i)};reactDom_production_min.unmountComponentAtNode=function(a){if(!ol(a))throw Error(p$1(40));return a._reactRootContainer?(Rk(function(){rl(null,null,a,!1,function(){a._reactRootContainer=null,a[uf]=null})}),!0):!1};reactDom_production_min.unstable_batchedUpdates=Qk;reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,e,i,s){if(!ol(i))throw Error(p$1(200));if(a==null||a._reactInternals===void 0)throw Error(p$1(38));return rl(a,e,i,!1,s)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";function checkDCE(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)}catch(a){console.error(a)}}checkDCE(),reactDom.exports=reactDom_production_min;var reactDomExports=reactDom.exports,m=reactDomExports;client.createRoot=m.createRoot,client.hydrateRoot=m.hydrateRoot;/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _extends$2(){return _extends$2=Object.assign?Object.assign.bind():function(a){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(a[s]=i[s])}return a},_extends$2.apply(this,arguments)}var Action;(function(a){a.Pop="POP",a.Push="PUSH",a.Replace="REPLACE"})(Action||(Action={}));const PopStateEventType="popstate";function createBrowserHistory(a){a===void 0&&(a={});function e(s,o){let{pathname:c,search:d,hash:h}=s.location;return createLocation("",{pathname:c,search:d,hash:h},o.state&&o.state.usr||null,o.state&&o.state.key||"default")}function i(s,o){return typeof o=="string"?o:createPath(o)}return getUrlBasedHistory(e,i,null,a)}function invariant(a,e){if(a===!1||a===null||typeof a>"u")throw new Error(e)}function warning(a,e){if(!a){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function createKey(){return Math.random().toString(36).substr(2,8)}function getHistoryState(a,e){return{usr:a.state,key:a.key,idx:e}}function createLocation(a,e,i,s){return i===void 0&&(i=null),_extends$2({pathname:typeof a=="string"?a:a.pathname,search:"",hash:""},typeof e=="string"?parsePath(e):e,{state:i,key:e&&e.key||s||createKey()})}function createPath(a){let{pathname:e="/",search:i="",hash:s=""}=a;return i&&i!=="?"&&(e+=i.charAt(0)==="?"?i:"?"+i),s&&s!=="#"&&(e+=s.charAt(0)==="#"?s:"#"+s),e}function parsePath(a){let e={};if(a){let i=a.indexOf("#");i>=0&&(e.hash=a.substr(i),a=a.substr(0,i));let s=a.indexOf("?");s>=0&&(e.search=a.substr(s),a=a.substr(0,s)),a&&(e.pathname=a)}return e}function getUrlBasedHistory(a,e,i,s){s===void 0&&(s={});let{window:o=document.defaultView,v5Compat:c=!1}=s,d=o.history,h=Action.Pop,g=null,_=b();_==null&&(_=0,d.replaceState(_extends$2({},d.state,{idx:_}),""));function b(){return(d.state||{idx:null}).idx}function $(){h=Action.Pop;let nt=b(),rt=nt==null?null:nt-_;_=nt,g&&g({action:h,location:et.location,delta:rt})}function j(nt,rt){h=Action.Push;let it=createLocation(et.location,nt,rt);_=b()+1;let at=getHistoryState(it,_),st=et.createHref(it);try{d.pushState(at,"",st)}catch(ot){if(ot instanceof DOMException&&ot.name==="DataCloneError")throw ot;o.location.assign(st)}c&&g&&g({action:h,location:et.location,delta:1})}function _e(nt,rt){h=Action.Replace;let it=createLocation(et.location,nt,rt);_=b();let at=getHistoryState(it,_),st=et.createHref(it);d.replaceState(at,"",st),c&&g&&g({action:h,location:et.location,delta:0})}function tt(nt){let rt=o.location.origin!=="null"?o.location.origin:o.location.href,it=typeof nt=="string"?nt:createPath(nt);return it=it.replace(/ $/,"%20"),invariant(rt,"No window.location.(origin|href) available to create URL for href: "+it),new URL(it,rt)}let et={get action(){return h},get location(){return a(o,d)},listen(nt){if(g)throw new Error("A history only accepts one active listener");return o.addEventListener(PopStateEventType,$),g=nt,()=>{o.removeEventListener(PopStateEventType,$),g=null}},createHref(nt){return e(o,nt)},createURL:tt,encodeLocation(nt){let rt=tt(nt);return{pathname:rt.pathname,search:rt.search,hash:rt.hash}},push:j,replace:_e,go(nt){return d.go(nt)}};return et}var ResultType;(function(a){a.data="data",a.deferred="deferred",a.redirect="redirect",a.error="error"})(ResultType||(ResultType={}));function matchRoutes(a,e,i){i===void 0&&(i="/");let s=typeof e=="string"?parsePath(e):e,o=stripBasename(s.pathname||"/",i);if(o==null)return null;let c=flattenRoutes(a);rankRouteBranches(c);let d=null;for(let h=0;d==null&&h<c.length;++h){let g=decodePath(o);d=matchRouteBranch(c[h],g)}return d}function flattenRoutes(a,e,i,s){e===void 0&&(e=[]),i===void 0&&(i=[]),s===void 0&&(s="");let o=(c,d,h)=>{let g={relativePath:h===void 0?c.path||"":h,caseSensitive:c.caseSensitive===!0,childrenIndex:d,route:c};g.relativePath.startsWith("/")&&(invariant(g.relativePath.startsWith(s),'Absolute route path "'+g.relativePath+'" nested under path '+('"'+s+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),g.relativePath=g.relativePath.slice(s.length));let _=joinPaths([s,g.relativePath]),b=i.concat(g);c.children&&c.children.length>0&&(invariant(c.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+_+'".')),flattenRoutes(c.children,e,b,_)),!(c.path==null&&!c.index)&&e.push({path:_,score:computeScore(_,c.index),routesMeta:b})};return a.forEach((c,d)=>{var h;if(c.path===""||!((h=c.path)!=null&&h.includes("?")))o(c,d);else for(let g of explodeOptionalSegments(c.path))o(c,d,g)}),e}function explodeOptionalSegments(a){let e=a.split("/");if(e.length===0)return[];let[i,...s]=e,o=i.endsWith("?"),c=i.replace(/\?$/,"");if(s.length===0)return o?[c,""]:[c];let d=explodeOptionalSegments(s.join("/")),h=[];return h.push(...d.map(g=>g===""?c:[c,g].join("/"))),o&&h.push(...d),h.map(g=>a.startsWith("/")&&g===""?"/":g)}function rankRouteBranches(a){a.sort((e,i)=>e.score!==i.score?i.score-e.score:compareIndexes(e.routesMeta.map(s=>s.childrenIndex),i.routesMeta.map(s=>s.childrenIndex)))}const paramRe=/^:[\w-]+$/,dynamicSegmentValue=3,indexRouteValue=2,emptySegmentValue=1,staticSegmentValue=10,splatPenalty=-2,isSplat=a=>a==="*";function computeScore(a,e){let i=a.split("/"),s=i.length;return i.some(isSplat)&&(s+=splatPenalty),e&&(s+=indexRouteValue),i.filter(o=>!isSplat(o)).reduce((o,c)=>o+(paramRe.test(c)?dynamicSegmentValue:c===""?emptySegmentValue:staticSegmentValue),s)}function compareIndexes(a,e){return a.length===e.length&&a.slice(0,-1).every((s,o)=>s===e[o])?a[a.length-1]-e[e.length-1]:0}function matchRouteBranch(a,e){let{routesMeta:i}=a,s={},o="/",c=[];for(let d=0;d<i.length;++d){let h=i[d],g=d===i.length-1,_=o==="/"?e:e.slice(o.length)||"/",b=matchPath({path:h.relativePath,caseSensitive:h.caseSensitive,end:g},_);if(!b)return null;Object.assign(s,b.params);let $=h.route;c.push({params:s,pathname:joinPaths([o,b.pathname]),pathnameBase:normalizePathname(joinPaths([o,b.pathnameBase])),route:$}),b.pathnameBase!=="/"&&(o=joinPaths([o,b.pathnameBase]))}return c}function matchPath(a,e){typeof a=="string"&&(a={path:a,caseSensitive:!1,end:!0});let[i,s]=compilePath(a.path,a.caseSensitive,a.end),o=e.match(i);if(!o)return null;let c=o[0],d=c.replace(/(.)\/+$/,"$1"),h=o.slice(1);return{params:s.reduce((_,b,$)=>{let{paramName:j,isOptional:_e}=b;if(j==="*"){let et=h[$]||"";d=c.slice(0,c.length-et.length).replace(/(.)\/+$/,"$1")}const tt=h[$];return _e&&!tt?_[j]=void 0:_[j]=(tt||"").replace(/%2F/g,"/"),_},{}),pathname:c,pathnameBase:d,pattern:a}}function compilePath(a,e,i){e===void 0&&(e=!1),i===void 0&&(i=!0),warning(a==="*"||!a.endsWith("*")||a.endsWith("/*"),'Route path "'+a+'" will be treated as if it were '+('"'+a.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+a.replace(/\*$/,"/*")+'".'));let s=[],o="^"+a.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(d,h,g)=>(s.push({paramName:h,isOptional:g!=null}),g?"/?([^\\/]+)?":"/([^\\/]+)"));return a.endsWith("*")?(s.push({paramName:"*"}),o+=a==="*"||a==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):i?o+="\\/*$":a!==""&&a!=="/"&&(o+="(?:(?=\\/|$))"),[new RegExp(o,e?void 0:"i"),s]}function decodePath(a){try{return a.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return warning(!1,'The URL path "'+a+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+e+").")),a}}function stripBasename(a,e){if(e==="/")return a;if(!a.toLowerCase().startsWith(e.toLowerCase()))return null;let i=e.endsWith("/")?e.length-1:e.length,s=a.charAt(i);return s&&s!=="/"?null:a.slice(i)||"/"}function resolvePath(a,e){e===void 0&&(e="/");let{pathname:i,search:s="",hash:o=""}=typeof a=="string"?parsePath(a):a;return{pathname:i?i.startsWith("/")?i:resolvePathname(i,e):e,search:normalizeSearch(s),hash:normalizeHash(o)}}function resolvePathname(a,e){let i=e.replace(/\/+$/,"").split("/");return a.split("/").forEach(o=>{o===".."?i.length>1&&i.pop():o!=="."&&i.push(o)}),i.length>1?i.join("/"):"/"}function getInvalidPathError(a,e,i,s){return"Cannot include a '"+a+"' character in a manually specified "+("`to."+e+"` field ["+JSON.stringify(s)+"].  Please separate it out to the ")+("`to."+i+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function getPathContributingMatches(a){return a.filter((e,i)=>i===0||e.route.path&&e.route.path.length>0)}function getResolveToMatches(a,e){let i=getPathContributingMatches(a);return e?i.map((s,o)=>o===a.length-1?s.pathname:s.pathnameBase):i.map(s=>s.pathnameBase)}function resolveTo(a,e,i,s){s===void 0&&(s=!1);let o;typeof a=="string"?o=parsePath(a):(o=_extends$2({},a),invariant(!o.pathname||!o.pathname.includes("?"),getInvalidPathError("?","pathname","search",o)),invariant(!o.pathname||!o.pathname.includes("#"),getInvalidPathError("#","pathname","hash",o)),invariant(!o.search||!o.search.includes("#"),getInvalidPathError("#","search","hash",o)));let c=a===""||o.pathname==="",d=c?"/":o.pathname,h;if(d==null)h=i;else{let $=e.length-1;if(!s&&d.startsWith("..")){let j=d.split("/");for(;j[0]==="..";)j.shift(),$-=1;o.pathname=j.join("/")}h=$>=0?e[$]:"/"}let g=resolvePath(o,h),_=d&&d!=="/"&&d.endsWith("/"),b=(c||d===".")&&i.endsWith("/");return!g.pathname.endsWith("/")&&(_||b)&&(g.pathname+="/"),g}const joinPaths=a=>a.join("/").replace(/\/\/+/g,"/"),normalizePathname=a=>a.replace(/\/+$/,"").replace(/^\/*/,"/"),normalizeSearch=a=>!a||a==="?"?"":a.startsWith("?")?a:"?"+a,normalizeHash=a=>!a||a==="#"?"":a.startsWith("#")?a:"#"+a;function isRouteErrorResponse(a){return a!=null&&typeof a.status=="number"&&typeof a.statusText=="string"&&typeof a.internal=="boolean"&&"data"in a}const validMutationMethodsArr=["post","put","patch","delete"];new Set(validMutationMethodsArr);const validRequestMethodsArr=["get",...validMutationMethodsArr];new Set(validRequestMethodsArr);/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _extends$1(){return _extends$1=Object.assign?Object.assign.bind():function(a){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(a[s]=i[s])}return a},_extends$1.apply(this,arguments)}const DataRouterContext=reactExports.createContext(null),DataRouterStateContext=reactExports.createContext(null),NavigationContext=reactExports.createContext(null),LocationContext=reactExports.createContext(null),RouteContext=reactExports.createContext({outlet:null,matches:[],isDataRoute:!1}),RouteErrorContext=reactExports.createContext(null);function useInRouterContext(){return reactExports.useContext(LocationContext)!=null}function useLocation(){return useInRouterContext()||invariant(!1),reactExports.useContext(LocationContext).location}function useIsomorphicLayoutEffect(a){reactExports.useContext(NavigationContext).static||reactExports.useLayoutEffect(a)}function useNavigate(){let{isDataRoute:a}=reactExports.useContext(RouteContext);return a?useNavigateStable():useNavigateUnstable()}function useNavigateUnstable(){useInRouterContext()||invariant(!1);let a=reactExports.useContext(DataRouterContext),{basename:e,future:i,navigator:s}=reactExports.useContext(NavigationContext),{matches:o}=reactExports.useContext(RouteContext),{pathname:c}=useLocation(),d=JSON.stringify(getResolveToMatches(o,i.v7_relativeSplatPath)),h=reactExports.useRef(!1);return useIsomorphicLayoutEffect(()=>{h.current=!0}),reactExports.useCallback(function(_,b){if(b===void 0&&(b={}),!h.current)return;if(typeof _=="number"){s.go(_);return}let $=resolveTo(_,JSON.parse(d),c,b.relative==="path");a==null&&e!=="/"&&($.pathname=$.pathname==="/"?e:joinPaths([e,$.pathname])),(b.replace?s.replace:s.push)($,b.state,b)},[e,s,d,c,a])}function useRoutes(a,e){return useRoutesImpl(a,e)}function useRoutesImpl(a,e,i,s){useInRouterContext()||invariant(!1);let{navigator:o}=reactExports.useContext(NavigationContext),{matches:c}=reactExports.useContext(RouteContext),d=c[c.length-1],h=d?d.params:{};d&&d.pathname;let g=d?d.pathnameBase:"/";d&&d.route;let _=useLocation(),b;if(e){var $;let nt=typeof e=="string"?parsePath(e):e;g==="/"||($=nt.pathname)!=null&&$.startsWith(g)||invariant(!1),b=nt}else b=_;let j=b.pathname||"/",_e=j;if(g!=="/"){let nt=g.replace(/^\//,"").split("/");_e="/"+j.replace(/^\//,"").split("/").slice(nt.length).join("/")}let tt=matchRoutes(a,{pathname:_e}),et=_renderMatches(tt&&tt.map(nt=>Object.assign({},nt,{params:Object.assign({},h,nt.params),pathname:joinPaths([g,o.encodeLocation?o.encodeLocation(nt.pathname).pathname:nt.pathname]),pathnameBase:nt.pathnameBase==="/"?g:joinPaths([g,o.encodeLocation?o.encodeLocation(nt.pathnameBase).pathname:nt.pathnameBase])})),c,i,s);return e&&et?reactExports.createElement(LocationContext.Provider,{value:{location:_extends$1({pathname:"/",search:"",hash:"",state:null,key:"default"},b),navigationType:Action.Pop}},et):et}function DefaultErrorComponent(){let a=useRouteError(),e=isRouteErrorResponse(a)?a.status+" "+a.statusText:a instanceof Error?a.message:JSON.stringify(a),i=a instanceof Error?a.stack:null,o={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return reactExports.createElement(reactExports.Fragment,null,reactExports.createElement("h2",null,"Unexpected Application Error!"),reactExports.createElement("h3",{style:{fontStyle:"italic"}},e),i?reactExports.createElement("pre",{style:o},i):null,null)}const defaultErrorElement=reactExports.createElement(DefaultErrorComponent,null);class RenderErrorBoundary extends reactExports.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,i){return i.location!==e.location||i.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:i.error,location:i.location,revalidation:e.revalidation||i.revalidation}}componentDidCatch(e,i){console.error("React Router caught the following error during render",e,i)}render(){return this.state.error!==void 0?reactExports.createElement(RouteContext.Provider,{value:this.props.routeContext},reactExports.createElement(RouteErrorContext.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function RenderedRoute(a){let{routeContext:e,match:i,children:s}=a,o=reactExports.useContext(DataRouterContext);return o&&o.static&&o.staticContext&&(i.route.errorElement||i.route.ErrorBoundary)&&(o.staticContext._deepestRenderedBoundaryId=i.route.id),reactExports.createElement(RouteContext.Provider,{value:e},s)}function _renderMatches(a,e,i,s){var o;if(e===void 0&&(e=[]),i===void 0&&(i=null),s===void 0&&(s=null),a==null){var c;if((c=i)!=null&&c.errors)a=i.matches;else return null}let d=a,h=(o=i)==null?void 0:o.errors;if(h!=null){let b=d.findIndex($=>$.route.id&&(h==null?void 0:h[$.route.id])!==void 0);b>=0||invariant(!1),d=d.slice(0,Math.min(d.length,b+1))}let g=!1,_=-1;if(i&&s&&s.v7_partialHydration)for(let b=0;b<d.length;b++){let $=d[b];if(($.route.HydrateFallback||$.route.hydrateFallbackElement)&&(_=b),$.route.id){let{loaderData:j,errors:_e}=i,tt=$.route.loader&&j[$.route.id]===void 0&&(!_e||_e[$.route.id]===void 0);if($.route.lazy||tt){g=!0,_>=0?d=d.slice(0,_+1):d=[d[0]];break}}}return d.reduceRight((b,$,j)=>{let _e,tt=!1,et=null,nt=null;i&&(_e=h&&$.route.id?h[$.route.id]:void 0,et=$.route.errorElement||defaultErrorElement,g&&(_<0&&j===0?(tt=!0,nt=null):_===j&&(tt=!0,nt=$.route.hydrateFallbackElement||null)));let rt=e.concat(d.slice(0,j+1)),it=()=>{let at;return _e?at=et:tt?at=nt:$.route.Component?at=reactExports.createElement($.route.Component,null):$.route.element?at=$.route.element:at=b,reactExports.createElement(RenderedRoute,{match:$,routeContext:{outlet:b,matches:rt,isDataRoute:i!=null},children:at})};return i&&($.route.ErrorBoundary||$.route.errorElement||j===0)?reactExports.createElement(RenderErrorBoundary,{location:i.location,revalidation:i.revalidation,component:et,error:_e,children:it(),routeContext:{outlet:null,matches:rt,isDataRoute:!0}}):it()},null)}var DataRouterHook$1=function(a){return a.UseBlocker="useBlocker",a.UseRevalidator="useRevalidator",a.UseNavigateStable="useNavigate",a}(DataRouterHook$1||{}),DataRouterStateHook$1=function(a){return a.UseBlocker="useBlocker",a.UseLoaderData="useLoaderData",a.UseActionData="useActionData",a.UseRouteError="useRouteError",a.UseNavigation="useNavigation",a.UseRouteLoaderData="useRouteLoaderData",a.UseMatches="useMatches",a.UseRevalidator="useRevalidator",a.UseNavigateStable="useNavigate",a.UseRouteId="useRouteId",a}(DataRouterStateHook$1||{});function useDataRouterContext(a){let e=reactExports.useContext(DataRouterContext);return e||invariant(!1),e}function useDataRouterState(a){let e=reactExports.useContext(DataRouterStateContext);return e||invariant(!1),e}function useRouteContext(a){let e=reactExports.useContext(RouteContext);return e||invariant(!1),e}function useCurrentRouteId(a){let e=useRouteContext(),i=e.matches[e.matches.length-1];return i.route.id||invariant(!1),i.route.id}function useRouteError(){var a;let e=reactExports.useContext(RouteErrorContext),i=useDataRouterState(DataRouterStateHook$1.UseRouteError),s=useCurrentRouteId(DataRouterStateHook$1.UseRouteError);return e!==void 0?e:(a=i.errors)==null?void 0:a[s]}function useNavigateStable(){let{router:a}=useDataRouterContext(DataRouterHook$1.UseNavigateStable),e=useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable),i=reactExports.useRef(!1);return useIsomorphicLayoutEffect(()=>{i.current=!0}),reactExports.useCallback(function(o,c){c===void 0&&(c={}),i.current&&(typeof o=="number"?a.navigate(o):a.navigate(o,_extends$1({fromRouteId:e},c)))},[a,e])}function Route(a){invariant(!1)}function Router(a){let{basename:e="/",children:i=null,location:s,navigationType:o=Action.Pop,navigator:c,static:d=!1,future:h}=a;useInRouterContext()&&invariant(!1);let g=e.replace(/^\/*/,"/"),_=reactExports.useMemo(()=>({basename:g,navigator:c,static:d,future:_extends$1({v7_relativeSplatPath:!1},h)}),[g,h,c,d]);typeof s=="string"&&(s=parsePath(s));let{pathname:b="/",search:$="",hash:j="",state:_e=null,key:tt="default"}=s,et=reactExports.useMemo(()=>{let nt=stripBasename(b,g);return nt==null?null:{location:{pathname:nt,search:$,hash:j,state:_e,key:tt},navigationType:o}},[g,b,$,j,_e,tt,o]);return et==null?null:reactExports.createElement(NavigationContext.Provider,{value:_},reactExports.createElement(LocationContext.Provider,{children:i,value:et}))}function Routes(a){let{children:e,location:i}=a;return useRoutes(createRoutesFromChildren(e),i)}new Promise(()=>{});function createRoutesFromChildren(a,e){e===void 0&&(e=[]);let i=[];return reactExports.Children.forEach(a,(s,o)=>{if(!reactExports.isValidElement(s))return;let c=[...e,o];if(s.type===reactExports.Fragment){i.push.apply(i,createRoutesFromChildren(s.props.children,c));return}s.type!==Route&&invariant(!1),!s.props.index||!s.props.children||invariant(!1);let d={id:s.props.id||c.join("-"),caseSensitive:s.props.caseSensitive,element:s.props.element,Component:s.props.Component,index:s.props.index,path:s.props.path,loader:s.props.loader,action:s.props.action,errorElement:s.props.errorElement,ErrorBoundary:s.props.ErrorBoundary,hasErrorBoundary:s.props.ErrorBoundary!=null||s.props.errorElement!=null,shouldRevalidate:s.props.shouldRevalidate,handle:s.props.handle,lazy:s.props.lazy};s.props.children&&(d.children=createRoutesFromChildren(s.props.children,c)),i.push(d)}),i}/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */const REACT_ROUTER_VERSION="6";try{window.__reactRouterVersion=REACT_ROUTER_VERSION}catch{}const START_TRANSITION="startTransition",startTransitionImpl=React$1[START_TRANSITION];function BrowserRouter(a){let{basename:e,children:i,future:s,window:o}=a,c=reactExports.useRef();c.current==null&&(c.current=createBrowserHistory({window:o,v5Compat:!0}));let d=c.current,[h,g]=reactExports.useState({action:d.action,location:d.location}),{v7_startTransition:_}=s||{},b=reactExports.useCallback($=>{_&&startTransitionImpl?startTransitionImpl(()=>g($)):g($)},[g,_]);return reactExports.useLayoutEffect(()=>d.listen(b),[d,b]),reactExports.createElement(Router,{basename:e,children:i,location:h.location,navigationType:h.action,navigator:d,future:s})}var DataRouterHook;(function(a){a.UseScrollRestoration="useScrollRestoration",a.UseSubmit="useSubmit",a.UseSubmitFetcher="useSubmitFetcher",a.UseFetcher="useFetcher",a.useViewTransitionState="useViewTransitionState"})(DataRouterHook||(DataRouterHook={}));var DataRouterStateHook;(function(a){a.UseFetcher="useFetcher",a.UseFetchers="useFetchers",a.UseScrollRestoration="useScrollRestoration"})(DataRouterStateHook||(DataRouterStateHook={}));var propTypes={exports:{}},ReactPropTypesSecret$1="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",ReactPropTypesSecret_1=ReactPropTypesSecret$1,ReactPropTypesSecret=ReactPropTypesSecret_1;function emptyFunction(){}function emptyFunctionWithReset(){}emptyFunctionWithReset.resetWarningCache=emptyFunction;var factoryWithThrowingShims=function(){function a(s,o,c,d,h,g){if(g!==ReactPropTypesSecret){var _=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw _.name="Invariant Violation",_}}a.isRequired=a;function e(){return a}var i={array:a,bigint:a,bool:a,func:a,number:a,object:a,string:a,symbol:a,any:a,arrayOf:e,element:a,elementType:a,instanceOf:e,node:a,objectOf:e,oneOf:e,oneOfType:e,shape:e,exact:e,checkPropTypes:emptyFunctionWithReset,resetWarningCache:emptyFunction};return i.PropTypes=i,i};propTypes.exports=factoryWithThrowingShims();var propTypesExports=propTypes.exports;const PropTypes=getDefaultExportFromCjs$1(propTypesExports);/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="165",MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AgXToneMapping=6,NeutralToneMapping=7,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipmapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipmapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,UnsignedInt5999Type=35902,AlphaFormat=1021,RGBFormat=1022,RGBAFormat=1023,LuminanceFormat=1024,LuminanceAlphaFormat=1025,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,BasicDepthPacking=3200,RGBADepthPacking=3201,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear",LinearTransfer="linear",SRGBTransfer="srgb",Rec709Primaries="rec709",P3Primaries="p3",KeepStencilOp=7680,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,GLSL3="300 es",WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001;class EventDispatcher{addEventListener(e,i){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(i)===-1&&s[e].push(i)}hasEventListener(e,i){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(i)!==-1}removeEventListener(e,i){if(this._listeners===void 0)return;const o=this._listeners[e];if(o!==void 0){const c=o.indexOf(i);c!==-1&&o.splice(c,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const o=s.slice(0);for(let c=0,d=o.length;c<d;c++)o[c].call(this,e);e.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const a=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(_lut[a&255]+_lut[a>>8&255]+_lut[a>>16&255]+_lut[a>>24&255]+"-"+_lut[e&255]+_lut[e>>8&255]+"-"+_lut[e>>16&15|64]+_lut[e>>24&255]+"-"+_lut[i&63|128]+_lut[i>>8&255]+"-"+_lut[i>>16&255]+_lut[i>>24&255]+_lut[s&255]+_lut[s>>8&255]+_lut[s>>16&255]+_lut[s>>24&255]).toLowerCase()}function clamp$2(a,e,i){return Math.max(e,Math.min(i,a))}function euclideanModulo(a,e){return(a%e+e)%e}function mapLinear(a,e,i,s,o){return s+(a-e)*(o-s)/(i-e)}function inverseLerp(a,e,i){return a!==e?(i-a)/(e-a):0}function lerp(a,e,i){return(1-i)*a+i*e}function damp(a,e,i,s){return lerp(a,e,1-Math.exp(-i*s))}function pingpong(a,e=1){return e-Math.abs(euclideanModulo(a,e*2)-e)}function smoothstep(a,e,i){return a<=e?0:a>=i?1:(a=(a-e)/(i-e),a*a*(3-2*a))}function smootherstep(a,e,i){return a<=e?0:a>=i?1:(a=(a-e)/(i-e),a*a*a*(a*(a*6-15)+10))}function randInt(a,e){return a+Math.floor(Math.random()*(e-a+1))}function randFloat(a,e){return a+Math.random()*(e-a)}function randFloatSpread(a){return a*(.5-Math.random())}function seededRandom(a){a!==void 0&&(_seed=a);let e=_seed+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function degToRad(a){return a*DEG2RAD}function radToDeg(a){return a*RAD2DEG}function isPowerOfTwo(a){return(a&a-1)===0&&a!==0}function ceilPowerOfTwo(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function floorPowerOfTwo(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}function setQuaternionFromProperEuler(a,e,i,s,o){const c=Math.cos,d=Math.sin,h=c(i/2),g=d(i/2),_=c((e+s)/2),b=d((e+s)/2),$=c((e-s)/2),j=d((e-s)/2),_e=c((s-e)/2),tt=d((s-e)/2);switch(o){case"XYX":a.set(h*b,g*$,g*j,h*_);break;case"YZY":a.set(g*j,h*b,g*$,h*_);break;case"ZXZ":a.set(g*$,g*j,h*b,h*_);break;case"XZX":a.set(h*b,g*tt,g*_e,h*_);break;case"YXY":a.set(g*_e,h*b,g*tt,h*_);break;case"ZYZ":a.set(g*tt,g*_e,h*b,h*_);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+o)}}function denormalize(a,e){switch(e.constructor){case Float32Array:return a;case Uint32Array:return a/4294967295;case Uint16Array:return a/65535;case Uint8Array:return a/255;case Int32Array:return Math.max(a/2147483647,-1);case Int16Array:return Math.max(a/32767,-1);case Int8Array:return Math.max(a/127,-1);default:throw new Error("Invalid component type.")}}function normalize(a,e){switch(e.constructor){case Float32Array:return a;case Uint32Array:return Math.round(a*4294967295);case Uint16Array:return Math.round(a*65535);case Uint8Array:return Math.round(a*255);case Int32Array:return Math.round(a*2147483647);case Int16Array:return Math.round(a*32767);case Int8Array:return Math.round(a*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp:clamp$2,euclideanModulo,mapLinear,inverseLerp,lerp,damp,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg,isPowerOfTwo,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize,denormalize};class Vector2{constructor(e=0,i=0){Vector2.prototype.isVector2=!0,this.x=e,this.y=i}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,i){return this.x=e,this.y=i,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,i){switch(e){case 0:this.x=i;break;case 1:this.y=i;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,i){return this.x=e.x+i.x,this.y=e.y+i.y,this}addScaledVector(e,i){return this.x+=e.x*i,this.y+=e.y*i,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,i){return this.x=e.x-i.x,this.y=e.y-i.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const i=this.x,s=this.y,o=e.elements;return this.x=o[0]*i+o[3]*s+o[6],this.y=o[1]*i+o[4]*s+o[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,i){return this.x=Math.max(e.x,Math.min(i.x,this.x)),this.y=Math.max(e.y,Math.min(i.y,this.y)),this}clampScalar(e,i){return this.x=Math.max(e,Math.min(i,this.x)),this.y=Math.max(e,Math.min(i,this.y)),this}clampLength(e,i){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(i,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const i=Math.sqrt(this.lengthSq()*e.lengthSq());if(i===0)return Math.PI/2;const s=this.dot(e)/i;return Math.acos(clamp$2(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const i=this.x-e.x,s=this.y-e.y;return i*i+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,i){return this.x+=(e.x-this.x)*i,this.y+=(e.y-this.y)*i,this}lerpVectors(e,i,s){return this.x=e.x+(i.x-e.x)*s,this.y=e.y+(i.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,i=0){return this.x=e[i],this.y=e[i+1],this}toArray(e=[],i=0){return e[i]=this.x,e[i+1]=this.y,e}fromBufferAttribute(e,i){return this.x=e.getX(i),this.y=e.getY(i),this}rotateAround(e,i){const s=Math.cos(i),o=Math.sin(i),c=this.x-e.x,d=this.y-e.y;return this.x=c*s-d*o+e.x,this.y=c*o+d*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(e,i,s,o,c,d,h,g,_){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,i,s,o,c,d,h,g,_)}set(e,i,s,o,c,d,h,g,_){const b=this.elements;return b[0]=e,b[1]=o,b[2]=h,b[3]=i,b[4]=c,b[5]=g,b[6]=s,b[7]=d,b[8]=_,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const i=this.elements,s=e.elements;return i[0]=s[0],i[1]=s[1],i[2]=s[2],i[3]=s[3],i[4]=s[4],i[5]=s[5],i[6]=s[6],i[7]=s[7],i[8]=s[8],this}extractBasis(e,i,s){return e.setFromMatrix3Column(this,0),i.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const i=e.elements;return this.set(i[0],i[4],i[8],i[1],i[5],i[9],i[2],i[6],i[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,i){const s=e.elements,o=i.elements,c=this.elements,d=s[0],h=s[3],g=s[6],_=s[1],b=s[4],$=s[7],j=s[2],_e=s[5],tt=s[8],et=o[0],nt=o[3],rt=o[6],it=o[1],at=o[4],st=o[7],ot=o[2],ct=o[5],lt=o[8];return c[0]=d*et+h*it+g*ot,c[3]=d*nt+h*at+g*ct,c[6]=d*rt+h*st+g*lt,c[1]=_*et+b*it+$*ot,c[4]=_*nt+b*at+$*ct,c[7]=_*rt+b*st+$*lt,c[2]=j*et+_e*it+tt*ot,c[5]=j*nt+_e*at+tt*ct,c[8]=j*rt+_e*st+tt*lt,this}multiplyScalar(e){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=e,i[4]*=e,i[7]*=e,i[2]*=e,i[5]*=e,i[8]*=e,this}determinant(){const e=this.elements,i=e[0],s=e[1],o=e[2],c=e[3],d=e[4],h=e[5],g=e[6],_=e[7],b=e[8];return i*d*b-i*h*_-s*c*b+s*h*g+o*c*_-o*d*g}invert(){const e=this.elements,i=e[0],s=e[1],o=e[2],c=e[3],d=e[4],h=e[5],g=e[6],_=e[7],b=e[8],$=b*d-h*_,j=h*g-b*c,_e=_*c-d*g,tt=i*$+s*j+o*_e;if(tt===0)return this.set(0,0,0,0,0,0,0,0,0);const et=1/tt;return e[0]=$*et,e[1]=(o*_-b*s)*et,e[2]=(h*s-o*d)*et,e[3]=j*et,e[4]=(b*i-o*g)*et,e[5]=(o*c-h*i)*et,e[6]=_e*et,e[7]=(s*g-_*i)*et,e[8]=(d*i-s*c)*et,this}transpose(){let e;const i=this.elements;return e=i[1],i[1]=i[3],i[3]=e,e=i[2],i[2]=i[6],i[6]=e,e=i[5],i[5]=i[7],i[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const i=this.elements;return e[0]=i[0],e[1]=i[3],e[2]=i[6],e[3]=i[1],e[4]=i[4],e[5]=i[7],e[6]=i[2],e[7]=i[5],e[8]=i[8],this}setUvTransform(e,i,s,o,c,d,h){const g=Math.cos(c),_=Math.sin(c);return this.set(s*g,s*_,-s*(g*d+_*h)+d+e,-o*_,o*g,-o*(-_*d+g*h)+h+i,0,0,1),this}scale(e,i){return this.premultiply(_m3.makeScale(e,i)),this}rotate(e){return this.premultiply(_m3.makeRotation(-e)),this}translate(e,i){return this.premultiply(_m3.makeTranslation(e,i)),this}makeTranslation(e,i){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,i,0,0,1),this}makeRotation(e){const i=Math.cos(e),s=Math.sin(e);return this.set(i,-s,0,s,i,0,0,0,1),this}makeScale(e,i){return this.set(e,0,0,0,i,0,0,0,1),this}equals(e){const i=this.elements,s=e.elements;for(let o=0;o<9;o++)if(i[o]!==s[o])return!1;return!0}fromArray(e,i=0){for(let s=0;s<9;s++)this.elements[s]=e[s+i];return this}toArray(e=[],i=0){const s=this.elements;return e[i]=s[0],e[i+1]=s[1],e[i+2]=s[2],e[i+3]=s[3],e[i+4]=s[4],e[i+5]=s[5],e[i+6]=s[6],e[i+7]=s[7],e[i+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3;function arrayNeedsUint32(a){for(let e=a.length-1;e>=0;--e)if(a[e]>=65535)return!0;return!1}function createElementNS(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}function createCanvasElement(){const a=createElementNS("canvas");return a.style.display="block",a}const _cache={};function warnOnce(a){a in _cache||(_cache[a]=!0,console.warn(a))}function probeAsync(a,e,i){return new Promise(function(s,o){function c(){switch(a.clientWaitSync(e,a.SYNC_FLUSH_COMMANDS_BIT,0)){case a.WAIT_FAILED:o();break;case a.TIMEOUT_EXPIRED:setTimeout(c,i);break;default:s()}}setTimeout(c,i)})}const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3=new Matrix3().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),LINEAR_DISPLAY_P3_TO_LINEAR_SRGB=new Matrix3().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),COLOR_SPACES={[LinearSRGBColorSpace]:{transfer:LinearTransfer,primaries:Rec709Primaries,toReference:a=>a,fromReference:a=>a},[SRGBColorSpace]:{transfer:SRGBTransfer,primaries:Rec709Primaries,toReference:a=>a.convertSRGBToLinear(),fromReference:a=>a.convertLinearToSRGB()},[LinearDisplayP3ColorSpace]:{transfer:LinearTransfer,primaries:P3Primaries,toReference:a=>a.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:a=>a.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)},[DisplayP3ColorSpace]:{transfer:SRGBTransfer,primaries:P3Primaries,toReference:a=>a.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:a=>a.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()}},SUPPORTED_WORKING_COLOR_SPACES=new Set([LinearSRGBColorSpace,LinearDisplayP3ColorSpace]),ColorManagement={enabled:!0,_workingColorSpace:LinearSRGBColorSpace,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(a){if(!SUPPORTED_WORKING_COLOR_SPACES.has(a))throw new Error(`Unsupported working color space, "${a}".`);this._workingColorSpace=a},convert:function(a,e,i){if(this.enabled===!1||e===i||!e||!i)return a;const s=COLOR_SPACES[e].toReference,o=COLOR_SPACES[i].fromReference;return o(s(a))},fromWorkingColorSpace:function(a,e){return this.convert(a,this._workingColorSpace,e)},toWorkingColorSpace:function(a,e){return this.convert(a,e,this._workingColorSpace)},getPrimaries:function(a){return COLOR_SPACES[a].primaries},getTransfer:function(a){return a===NoColorSpace?LinearTransfer:COLOR_SPACES[a].transfer}};function SRGBToLinear(a){return a<.04045?a*.0773993808:Math.pow(a*.9478672986+.0521327014,2.4)}function LinearToSRGB(a){return a<.0031308?a*12.92:1.055*Math.pow(a,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let i;if(e instanceof HTMLCanvasElement)i=e;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=e.width,_canvas.height=e.height;const s=_canvas.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),i=_canvas}return i.width>2048||i.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),i.toDataURL("image/jpeg",.6)):i.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const i=createElementNS("canvas");i.width=e.width,i.height=e.height;const s=i.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const o=s.getImageData(0,0,e.width,e.height),c=o.data;for(let d=0;d<c.length;d++)c[d]=SRGBToLinear(c[d]/255)*255;return s.putImageData(o,0,0),i}else if(e.data){const i=e.data.slice(0);for(let s=0;s<i.length;s++)i instanceof Uint8Array||i instanceof Uint8ClampedArray?i[s]=Math.floor(SRGBToLinear(i[s]/255)*255):i[s]=SRGBToLinear(i[s]);return{data:i,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let _sourceId=0;class Source{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const i=e===void 0||typeof e=="string";if(!i&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},o=this.data;if(o!==null){let c;if(Array.isArray(o)){c=[];for(let d=0,h=o.length;d<h;d++)o[d].isDataTexture?c.push(serializeImage(o[d].image)):c.push(serializeImage(o[d]))}else c=serializeImage(o);s.url=c}return i||(e.images[this.uuid]=s),s}}function serializeImage(a){return typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&a instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&a instanceof ImageBitmap?ImageUtils.getDataURL(a):a.data?{data:Array.from(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _textureId=0;class Texture extends EventDispatcher{constructor(e=Texture.DEFAULT_IMAGE,i=Texture.DEFAULT_MAPPING,s=ClampToEdgeWrapping,o=ClampToEdgeWrapping,c=LinearFilter,d=LinearMipmapLinearFilter,h=RGBAFormat,g=UnsignedByteType,_=Texture.DEFAULT_ANISOTROPY,b=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(e),this.mipmaps=[],this.mapping=i,this.channel=0,this.wrapS=s,this.wrapT=o,this.magFilter=c,this.minFilter=d,this.anisotropy=_,this.format=h,this.internalFormat=null,this.type=g,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=b,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const i=e===void 0||typeof e=="string";if(!i&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),i||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==UVMapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case RepeatWrapping:e.x=e.x-Math.floor(e.x);break;case ClampToEdgeWrapping:e.x=e.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case RepeatWrapping:e.y=e.y-Math.floor(e.y);break;case ClampToEdgeWrapping:e.y=e.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(e=0,i=0,s=0,o=1){Vector4.prototype.isVector4=!0,this.x=e,this.y=i,this.z=s,this.w=o}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,i,s,o){return this.x=e,this.y=i,this.z=s,this.w=o,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,i){switch(e){case 0:this.x=i;break;case 1:this.y=i;break;case 2:this.z=i;break;case 3:this.w=i;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,i){return this.x=e.x+i.x,this.y=e.y+i.y,this.z=e.z+i.z,this.w=e.w+i.w,this}addScaledVector(e,i){return this.x+=e.x*i,this.y+=e.y*i,this.z+=e.z*i,this.w+=e.w*i,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,i){return this.x=e.x-i.x,this.y=e.y-i.y,this.z=e.z-i.z,this.w=e.w-i.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const i=this.x,s=this.y,o=this.z,c=this.w,d=e.elements;return this.x=d[0]*i+d[4]*s+d[8]*o+d[12]*c,this.y=d[1]*i+d[5]*s+d[9]*o+d[13]*c,this.z=d[2]*i+d[6]*s+d[10]*o+d[14]*c,this.w=d[3]*i+d[7]*s+d[11]*o+d[15]*c,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const i=Math.sqrt(1-e.w*e.w);return i<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/i,this.y=e.y/i,this.z=e.z/i),this}setAxisAngleFromRotationMatrix(e){let i,s,o,c;const g=e.elements,_=g[0],b=g[4],$=g[8],j=g[1],_e=g[5],tt=g[9],et=g[2],nt=g[6],rt=g[10];if(Math.abs(b-j)<.01&&Math.abs($-et)<.01&&Math.abs(tt-nt)<.01){if(Math.abs(b+j)<.1&&Math.abs($+et)<.1&&Math.abs(tt+nt)<.1&&Math.abs(_+_e+rt-3)<.1)return this.set(1,0,0,0),this;i=Math.PI;const at=(_+1)/2,st=(_e+1)/2,ot=(rt+1)/2,ct=(b+j)/4,lt=($+et)/4,dt=(tt+nt)/4;return at>st&&at>ot?at<.01?(s=0,o=.707106781,c=.707106781):(s=Math.sqrt(at),o=ct/s,c=lt/s):st>ot?st<.01?(s=.707106781,o=0,c=.707106781):(o=Math.sqrt(st),s=ct/o,c=dt/o):ot<.01?(s=.707106781,o=.707106781,c=0):(c=Math.sqrt(ot),s=lt/c,o=dt/c),this.set(s,o,c,i),this}let it=Math.sqrt((nt-tt)*(nt-tt)+($-et)*($-et)+(j-b)*(j-b));return Math.abs(it)<.001&&(it=1),this.x=(nt-tt)/it,this.y=($-et)/it,this.z=(j-b)/it,this.w=Math.acos((_+_e+rt-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,i){return this.x=Math.max(e.x,Math.min(i.x,this.x)),this.y=Math.max(e.y,Math.min(i.y,this.y)),this.z=Math.max(e.z,Math.min(i.z,this.z)),this.w=Math.max(e.w,Math.min(i.w,this.w)),this}clampScalar(e,i){return this.x=Math.max(e,Math.min(i,this.x)),this.y=Math.max(e,Math.min(i,this.y)),this.z=Math.max(e,Math.min(i,this.z)),this.w=Math.max(e,Math.min(i,this.w)),this}clampLength(e,i){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(i,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,i){return this.x+=(e.x-this.x)*i,this.y+=(e.y-this.y)*i,this.z+=(e.z-this.z)*i,this.w+=(e.w-this.w)*i,this}lerpVectors(e,i,s){return this.x=e.x+(i.x-e.x)*s,this.y=e.y+(i.y-e.y)*s,this.z=e.z+(i.z-e.z)*s,this.w=e.w+(i.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,i=0){return this.x=e[i],this.y=e[i+1],this.z=e[i+2],this.w=e[i+3],this}toArray(e=[],i=0){return e[i]=this.x,e[i+1]=this.y,e[i+2]=this.z,e[i+3]=this.w,e}fromBufferAttribute(e,i){return this.x=e.getX(i),this.y=e.getY(i),this.z=e.getZ(i),this.w=e.getW(i),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(e=1,i=1,s={}){super(),this.isRenderTarget=!0,this.width=e,this.height=i,this.depth=1,this.scissor=new Vector4(0,0,e,i),this.scissorTest=!1,this.viewport=new Vector4(0,0,e,i);const o={width:e,height:i,depth:1};s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},s);const c=new Texture(o,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace);c.flipY=!1,c.generateMipmaps=s.generateMipmaps,c.internalFormat=s.internalFormat,this.textures=[];const d=s.count;for(let h=0;h<d;h++)this.textures[h]=c.clone(),this.textures[h].isRenderTargetTexture=!0;this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this.depthTexture=s.depthTexture,this.samples=s.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}setSize(e,i,s=1){if(this.width!==e||this.height!==i||this.depth!==s){this.width=e,this.height=i,this.depth=s;for(let o=0,c=this.textures.length;o<c;o++)this.textures[o].image.width=e,this.textures[o].image.height=i,this.textures[o].image.depth=s;this.dispose()}this.viewport.set(0,0,e,i),this.scissor.set(0,0,e,i)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let s=0,o=e.textures.length;s<o;s++)this.textures[s]=e.textures[s].clone(),this.textures[s].isRenderTargetTexture=!0;const i=Object.assign({},e.texture.image);return this.texture.source=new Source(i),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(e=1,i=1,s={}){super(e,i,s),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture{constructor(e=null,i=1,s=1,o=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:i,height:s,depth:o},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class Data3DTexture extends Texture{constructor(e=null,i=1,s=1,o=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:i,height:s,depth:o},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Quaternion{constructor(e=0,i=0,s=0,o=1){this.isQuaternion=!0,this._x=e,this._y=i,this._z=s,this._w=o}static slerpFlat(e,i,s,o,c,d,h){let g=s[o+0],_=s[o+1],b=s[o+2],$=s[o+3];const j=c[d+0],_e=c[d+1],tt=c[d+2],et=c[d+3];if(h===0){e[i+0]=g,e[i+1]=_,e[i+2]=b,e[i+3]=$;return}if(h===1){e[i+0]=j,e[i+1]=_e,e[i+2]=tt,e[i+3]=et;return}if($!==et||g!==j||_!==_e||b!==tt){let nt=1-h;const rt=g*j+_*_e+b*tt+$*et,it=rt>=0?1:-1,at=1-rt*rt;if(at>Number.EPSILON){const ot=Math.sqrt(at),ct=Math.atan2(ot,rt*it);nt=Math.sin(nt*ct)/ot,h=Math.sin(h*ct)/ot}const st=h*it;if(g=g*nt+j*st,_=_*nt+_e*st,b=b*nt+tt*st,$=$*nt+et*st,nt===1-h){const ot=1/Math.sqrt(g*g+_*_+b*b+$*$);g*=ot,_*=ot,b*=ot,$*=ot}}e[i]=g,e[i+1]=_,e[i+2]=b,e[i+3]=$}static multiplyQuaternionsFlat(e,i,s,o,c,d){const h=s[o],g=s[o+1],_=s[o+2],b=s[o+3],$=c[d],j=c[d+1],_e=c[d+2],tt=c[d+3];return e[i]=h*tt+b*$+g*_e-_*j,e[i+1]=g*tt+b*j+_*$-h*_e,e[i+2]=_*tt+b*_e+h*j-g*$,e[i+3]=b*tt-h*$-g*j-_*_e,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,i,s,o){return this._x=e,this._y=i,this._z=s,this._w=o,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,i=!0){const s=e._x,o=e._y,c=e._z,d=e._order,h=Math.cos,g=Math.sin,_=h(s/2),b=h(o/2),$=h(c/2),j=g(s/2),_e=g(o/2),tt=g(c/2);switch(d){case"XYZ":this._x=j*b*$+_*_e*tt,this._y=_*_e*$-j*b*tt,this._z=_*b*tt+j*_e*$,this._w=_*b*$-j*_e*tt;break;case"YXZ":this._x=j*b*$+_*_e*tt,this._y=_*_e*$-j*b*tt,this._z=_*b*tt-j*_e*$,this._w=_*b*$+j*_e*tt;break;case"ZXY":this._x=j*b*$-_*_e*tt,this._y=_*_e*$+j*b*tt,this._z=_*b*tt+j*_e*$,this._w=_*b*$-j*_e*tt;break;case"ZYX":this._x=j*b*$-_*_e*tt,this._y=_*_e*$+j*b*tt,this._z=_*b*tt-j*_e*$,this._w=_*b*$+j*_e*tt;break;case"YZX":this._x=j*b*$+_*_e*tt,this._y=_*_e*$+j*b*tt,this._z=_*b*tt-j*_e*$,this._w=_*b*$-j*_e*tt;break;case"XZY":this._x=j*b*$-_*_e*tt,this._y=_*_e*$-j*b*tt,this._z=_*b*tt+j*_e*$,this._w=_*b*$+j*_e*tt;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+d)}return i===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,i){const s=i/2,o=Math.sin(s);return this._x=e.x*o,this._y=e.y*o,this._z=e.z*o,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const i=e.elements,s=i[0],o=i[4],c=i[8],d=i[1],h=i[5],g=i[9],_=i[2],b=i[6],$=i[10],j=s+h+$;if(j>0){const _e=.5/Math.sqrt(j+1);this._w=.25/_e,this._x=(b-g)*_e,this._y=(c-_)*_e,this._z=(d-o)*_e}else if(s>h&&s>$){const _e=2*Math.sqrt(1+s-h-$);this._w=(b-g)/_e,this._x=.25*_e,this._y=(o+d)/_e,this._z=(c+_)/_e}else if(h>$){const _e=2*Math.sqrt(1+h-s-$);this._w=(c-_)/_e,this._x=(o+d)/_e,this._y=.25*_e,this._z=(g+b)/_e}else{const _e=2*Math.sqrt(1+$-s-h);this._w=(d-o)/_e,this._x=(c+_)/_e,this._y=(g+b)/_e,this._z=.25*_e}return this._onChangeCallback(),this}setFromUnitVectors(e,i){let s=e.dot(i)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*i.z-e.z*i.y,this._y=e.z*i.x-e.x*i.z,this._z=e.x*i.y-e.y*i.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(clamp$2(this.dot(e),-1,1)))}rotateTowards(e,i){const s=this.angleTo(e);if(s===0)return this;const o=Math.min(1,i/s);return this.slerp(e,o),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,i){const s=e._x,o=e._y,c=e._z,d=e._w,h=i._x,g=i._y,_=i._z,b=i._w;return this._x=s*b+d*h+o*_-c*g,this._y=o*b+d*g+c*h-s*_,this._z=c*b+d*_+s*g-o*h,this._w=d*b-s*h-o*g-c*_,this._onChangeCallback(),this}slerp(e,i){if(i===0)return this;if(i===1)return this.copy(e);const s=this._x,o=this._y,c=this._z,d=this._w;let h=d*e._w+s*e._x+o*e._y+c*e._z;if(h<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,h=-h):this.copy(e),h>=1)return this._w=d,this._x=s,this._y=o,this._z=c,this;const g=1-h*h;if(g<=Number.EPSILON){const _e=1-i;return this._w=_e*d+i*this._w,this._x=_e*s+i*this._x,this._y=_e*o+i*this._y,this._z=_e*c+i*this._z,this.normalize(),this}const _=Math.sqrt(g),b=Math.atan2(_,h),$=Math.sin((1-i)*b)/_,j=Math.sin(i*b)/_;return this._w=d*$+this._w*j,this._x=s*$+this._x*j,this._y=o*$+this._y*j,this._z=c*$+this._z*j,this._onChangeCallback(),this}slerpQuaternions(e,i,s){return this.copy(e).slerp(i,s)}random(){const e=2*Math.PI*Math.random(),i=2*Math.PI*Math.random(),s=Math.random(),o=Math.sqrt(1-s),c=Math.sqrt(s);return this.set(o*Math.sin(e),o*Math.cos(e),c*Math.sin(i),c*Math.cos(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,i=0){return this._x=e[i],this._y=e[i+1],this._z=e[i+2],this._w=e[i+3],this._onChangeCallback(),this}toArray(e=[],i=0){return e[i]=this._x,e[i+1]=this._y,e[i+2]=this._z,e[i+3]=this._w,e}fromBufferAttribute(e,i){return this._x=e.getX(i),this._y=e.getY(i),this._z=e.getZ(i),this._w=e.getW(i),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(e=0,i=0,s=0){Vector3.prototype.isVector3=!0,this.x=e,this.y=i,this.z=s}set(e,i,s){return s===void 0&&(s=this.z),this.x=e,this.y=i,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,i){switch(e){case 0:this.x=i;break;case 1:this.y=i;break;case 2:this.z=i;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,i){return this.x=e.x+i.x,this.y=e.y+i.y,this.z=e.z+i.z,this}addScaledVector(e,i){return this.x+=e.x*i,this.y+=e.y*i,this.z+=e.z*i,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,i){return this.x=e.x-i.x,this.y=e.y-i.y,this.z=e.z-i.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,i){return this.x=e.x*i.x,this.y=e.y*i.y,this.z=e.z*i.z,this}applyEuler(e){return this.applyQuaternion(_quaternion$4.setFromEuler(e))}applyAxisAngle(e,i){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e,i))}applyMatrix3(e){const i=this.x,s=this.y,o=this.z,c=e.elements;return this.x=c[0]*i+c[3]*s+c[6]*o,this.y=c[1]*i+c[4]*s+c[7]*o,this.z=c[2]*i+c[5]*s+c[8]*o,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const i=this.x,s=this.y,o=this.z,c=e.elements,d=1/(c[3]*i+c[7]*s+c[11]*o+c[15]);return this.x=(c[0]*i+c[4]*s+c[8]*o+c[12])*d,this.y=(c[1]*i+c[5]*s+c[9]*o+c[13])*d,this.z=(c[2]*i+c[6]*s+c[10]*o+c[14])*d,this}applyQuaternion(e){const i=this.x,s=this.y,o=this.z,c=e.x,d=e.y,h=e.z,g=e.w,_=2*(d*o-h*s),b=2*(h*i-c*o),$=2*(c*s-d*i);return this.x=i+g*_+d*$-h*b,this.y=s+g*b+h*_-c*$,this.z=o+g*$+c*b-d*_,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const i=this.x,s=this.y,o=this.z,c=e.elements;return this.x=c[0]*i+c[4]*s+c[8]*o,this.y=c[1]*i+c[5]*s+c[9]*o,this.z=c[2]*i+c[6]*s+c[10]*o,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,i){return this.x=Math.max(e.x,Math.min(i.x,this.x)),this.y=Math.max(e.y,Math.min(i.y,this.y)),this.z=Math.max(e.z,Math.min(i.z,this.z)),this}clampScalar(e,i){return this.x=Math.max(e,Math.min(i,this.x)),this.y=Math.max(e,Math.min(i,this.y)),this.z=Math.max(e,Math.min(i,this.z)),this}clampLength(e,i){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(i,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,i){return this.x+=(e.x-this.x)*i,this.y+=(e.y-this.y)*i,this.z+=(e.z-this.z)*i,this}lerpVectors(e,i,s){return this.x=e.x+(i.x-e.x)*s,this.y=e.y+(i.y-e.y)*s,this.z=e.z+(i.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,i){const s=e.x,o=e.y,c=e.z,d=i.x,h=i.y,g=i.z;return this.x=o*g-c*h,this.y=c*d-s*g,this.z=s*h-o*d,this}projectOnVector(e){const i=e.lengthSq();if(i===0)return this.set(0,0,0);const s=e.dot(this)/i;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return _vector$c.copy(this).projectOnVector(e),this.sub(_vector$c)}reflect(e){return this.sub(_vector$c.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const i=Math.sqrt(this.lengthSq()*e.lengthSq());if(i===0)return Math.PI/2;const s=this.dot(e)/i;return Math.acos(clamp$2(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const i=this.x-e.x,s=this.y-e.y,o=this.z-e.z;return i*i+s*s+o*o}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,i,s){const o=Math.sin(i)*e;return this.x=o*Math.sin(s),this.y=Math.cos(i)*e,this.z=o*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,i,s){return this.x=e*Math.sin(i),this.y=s,this.z=e*Math.cos(i),this}setFromMatrixPosition(e){const i=e.elements;return this.x=i[12],this.y=i[13],this.z=i[14],this}setFromMatrixScale(e){const i=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),o=this.setFromMatrixColumn(e,2).length();return this.x=i,this.y=s,this.z=o,this}setFromMatrixColumn(e,i){return this.fromArray(e.elements,i*4)}setFromMatrix3Column(e,i){return this.fromArray(e.elements,i*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,i=0){return this.x=e[i],this.y=e[i+1],this.z=e[i+2],this}toArray(e=[],i=0){return e[i]=this.x,e[i+1]=this.y,e[i+2]=this.z,e}fromBufferAttribute(e,i){return this.x=e.getX(i),this.y=e.getY(i),this.z=e.getZ(i),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,i=Math.random()*2-1,s=Math.sqrt(1-i*i);return this.x=s*Math.cos(e),this.y=i,this.z=s*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(e=new Vector3(1/0,1/0,1/0),i=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=i}set(e,i){return this.min.copy(e),this.max.copy(i),this}setFromArray(e){this.makeEmpty();for(let i=0,s=e.length;i<s;i+=3)this.expandByPoint(_vector$b.fromArray(e,i));return this}setFromBufferAttribute(e){this.makeEmpty();for(let i=0,s=e.count;i<s;i++)this.expandByPoint(_vector$b.fromBufferAttribute(e,i));return this}setFromPoints(e){this.makeEmpty();for(let i=0,s=e.length;i<s;i++)this.expandByPoint(e[i]);return this}setFromCenterAndSize(e,i){const s=_vector$b.copy(i).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,i=!1){return this.makeEmpty(),this.expandByObject(e,i)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,i=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const c=s.getAttribute("position");if(i===!0&&c!==void 0&&e.isInstancedMesh!==!0)for(let d=0,h=c.count;d<h;d++)e.isMesh===!0?e.getVertexPosition(d,_vector$b):_vector$b.fromBufferAttribute(c,d),_vector$b.applyMatrix4(e.matrixWorld),this.expandByPoint(_vector$b);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),_box$4.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),_box$4.copy(s.boundingBox)),_box$4.applyMatrix4(e.matrixWorld),this.union(_box$4)}const o=e.children;for(let c=0,d=o.length;c<d;c++)this.expandByObject(o[c],i);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,i){return i.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,_vector$b),_vector$b.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let i,s;return e.normal.x>0?(i=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(i=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(i+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(i+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(i+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(i+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),i<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(e.a,_center),_v1$7.subVectors(e.b,_center),_v2$4.subVectors(e.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let i=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(i,_v0$2,_v1$7,_v2$4,_extents)||(i=[1,0,0,0,1,0,0,0,1],!satForAxes(i,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),i=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(i,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(e,i){return i.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,_vector$b).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(_vector$b).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(_points),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$4=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(a,e,i,s,o){for(let c=0,d=a.length-3;c<=d;c+=3){_testAxis.fromArray(a,c);const h=o.x*Math.abs(_testAxis.x)+o.y*Math.abs(_testAxis.y)+o.z*Math.abs(_testAxis.z),g=e.dot(_testAxis),_=i.dot(_testAxis),b=s.dot(_testAxis);if(Math.max(-Math.max(g,_,b),Math.min(g,_,b))>h)return!1}return!0}const _box$3=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(e=new Vector3,i=-1){this.isSphere=!0,this.center=e,this.radius=i}set(e,i){return this.center.copy(e),this.radius=i,this}setFromPoints(e,i){const s=this.center;i!==void 0?s.copy(i):_box$3.setFromPoints(e).getCenter(s);let o=0;for(let c=0,d=e.length;c<d;c++)o=Math.max(o,s.distanceToSquared(e[c]));return this.radius=Math.sqrt(o),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const i=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=i*i}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,i){const s=this.center.distanceToSquared(e);return i.copy(e),s>this.radius*this.radius&&(i.sub(this.center).normalize(),i.multiplyScalar(this.radius).add(this.center)),i}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;_v1$6.subVectors(e,this.center);const i=_v1$6.lengthSq();if(i>this.radius*this.radius){const s=Math.sqrt(i),o=(s-this.radius)*.5;this.center.addScaledVector(_v1$6,o/s),this.radius+=o}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(_v2$3.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(_v1$6.copy(e.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(e.center).sub(_v2$3))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(e=new Vector3,i=new Vector3(0,0,-1)){this.origin=e,this.direction=i}set(e,i){return this.origin.copy(e),this.direction.copy(i),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,i){return i.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,_vector$a)),this}closestPointToPoint(e,i){i.subVectors(e,this.origin);const s=i.dot(this.direction);return s<0?i.copy(this.origin):i.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const i=_vector$a.subVectors(e,this.origin).dot(this.direction);return i<0?this.origin.distanceToSquared(e):(_vector$a.copy(this.origin).addScaledVector(this.direction,i),_vector$a.distanceToSquared(e))}distanceSqToSegment(e,i,s,o){_segCenter.copy(e).add(i).multiplyScalar(.5),_segDir.copy(i).sub(e).normalize(),_diff.copy(this.origin).sub(_segCenter);const c=e.distanceTo(i)*.5,d=-this.direction.dot(_segDir),h=_diff.dot(this.direction),g=-_diff.dot(_segDir),_=_diff.lengthSq(),b=Math.abs(1-d*d);let $,j,_e,tt;if(b>0)if($=d*g-h,j=d*h-g,tt=c*b,$>=0)if(j>=-tt)if(j<=tt){const et=1/b;$*=et,j*=et,_e=$*($+d*j+2*h)+j*(d*$+j+2*g)+_}else j=c,$=Math.max(0,-(d*j+h)),_e=-$*$+j*(j+2*g)+_;else j=-c,$=Math.max(0,-(d*j+h)),_e=-$*$+j*(j+2*g)+_;else j<=-tt?($=Math.max(0,-(-d*c+h)),j=$>0?-c:Math.min(Math.max(-c,-g),c),_e=-$*$+j*(j+2*g)+_):j<=tt?($=0,j=Math.min(Math.max(-c,-g),c),_e=j*(j+2*g)+_):($=Math.max(0,-(d*c+h)),j=$>0?c:Math.min(Math.max(-c,-g),c),_e=-$*$+j*(j+2*g)+_);else j=d>0?-c:c,$=Math.max(0,-(d*j+h)),_e=-$*$+j*(j+2*g)+_;return s&&s.copy(this.origin).addScaledVector(this.direction,$),o&&o.copy(_segCenter).addScaledVector(_segDir,j),_e}intersectSphere(e,i){_vector$a.subVectors(e.center,this.origin);const s=_vector$a.dot(this.direction),o=_vector$a.dot(_vector$a)-s*s,c=e.radius*e.radius;if(o>c)return null;const d=Math.sqrt(c-o),h=s-d,g=s+d;return g<0?null:h<0?this.at(g,i):this.at(h,i)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const i=e.normal.dot(this.direction);if(i===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/i;return s>=0?s:null}intersectPlane(e,i){const s=this.distanceToPlane(e);return s===null?null:this.at(s,i)}intersectsPlane(e){const i=e.distanceToPoint(this.origin);return i===0||e.normal.dot(this.direction)*i<0}intersectBox(e,i){let s,o,c,d,h,g;const _=1/this.direction.x,b=1/this.direction.y,$=1/this.direction.z,j=this.origin;return _>=0?(s=(e.min.x-j.x)*_,o=(e.max.x-j.x)*_):(s=(e.max.x-j.x)*_,o=(e.min.x-j.x)*_),b>=0?(c=(e.min.y-j.y)*b,d=(e.max.y-j.y)*b):(c=(e.max.y-j.y)*b,d=(e.min.y-j.y)*b),s>d||c>o||((c>s||isNaN(s))&&(s=c),(d<o||isNaN(o))&&(o=d),$>=0?(h=(e.min.z-j.z)*$,g=(e.max.z-j.z)*$):(h=(e.max.z-j.z)*$,g=(e.min.z-j.z)*$),s>g||h>o)||((h>s||s!==s)&&(s=h),(g<o||o!==o)&&(o=g),o<0)?null:this.at(s>=0?s:o,i)}intersectsBox(e){return this.intersectBox(e,_vector$a)!==null}intersectTriangle(e,i,s,o,c){_edge1.subVectors(i,e),_edge2.subVectors(s,e),_normal$1.crossVectors(_edge1,_edge2);let d=this.direction.dot(_normal$1),h;if(d>0){if(o)return null;h=1}else if(d<0)h=-1,d=-d;else return null;_diff.subVectors(this.origin,e);const g=h*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(g<0)return null;const _=h*this.direction.dot(_edge1.cross(_diff));if(_<0||g+_>d)return null;const b=-h*_diff.dot(_normal$1);return b<0?null:this.at(b/d,c)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(e,i,s,o,c,d,h,g,_,b,$,j,_e,tt,et,nt){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,i,s,o,c,d,h,g,_,b,$,j,_e,tt,et,nt)}set(e,i,s,o,c,d,h,g,_,b,$,j,_e,tt,et,nt){const rt=this.elements;return rt[0]=e,rt[4]=i,rt[8]=s,rt[12]=o,rt[1]=c,rt[5]=d,rt[9]=h,rt[13]=g,rt[2]=_,rt[6]=b,rt[10]=$,rt[14]=j,rt[3]=_e,rt[7]=tt,rt[11]=et,rt[15]=nt,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(e){const i=this.elements,s=e.elements;return i[0]=s[0],i[1]=s[1],i[2]=s[2],i[3]=s[3],i[4]=s[4],i[5]=s[5],i[6]=s[6],i[7]=s[7],i[8]=s[8],i[9]=s[9],i[10]=s[10],i[11]=s[11],i[12]=s[12],i[13]=s[13],i[14]=s[14],i[15]=s[15],this}copyPosition(e){const i=this.elements,s=e.elements;return i[12]=s[12],i[13]=s[13],i[14]=s[14],this}setFromMatrix3(e){const i=e.elements;return this.set(i[0],i[3],i[6],0,i[1],i[4],i[7],0,i[2],i[5],i[8],0,0,0,0,1),this}extractBasis(e,i,s){return e.setFromMatrixColumn(this,0),i.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,i,s){return this.set(e.x,i.x,s.x,0,e.y,i.y,s.y,0,e.z,i.z,s.z,0,0,0,0,1),this}extractRotation(e){const i=this.elements,s=e.elements,o=1/_v1$5.setFromMatrixColumn(e,0).length(),c=1/_v1$5.setFromMatrixColumn(e,1).length(),d=1/_v1$5.setFromMatrixColumn(e,2).length();return i[0]=s[0]*o,i[1]=s[1]*o,i[2]=s[2]*o,i[3]=0,i[4]=s[4]*c,i[5]=s[5]*c,i[6]=s[6]*c,i[7]=0,i[8]=s[8]*d,i[9]=s[9]*d,i[10]=s[10]*d,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}makeRotationFromEuler(e){const i=this.elements,s=e.x,o=e.y,c=e.z,d=Math.cos(s),h=Math.sin(s),g=Math.cos(o),_=Math.sin(o),b=Math.cos(c),$=Math.sin(c);if(e.order==="XYZ"){const j=d*b,_e=d*$,tt=h*b,et=h*$;i[0]=g*b,i[4]=-g*$,i[8]=_,i[1]=_e+tt*_,i[5]=j-et*_,i[9]=-h*g,i[2]=et-j*_,i[6]=tt+_e*_,i[10]=d*g}else if(e.order==="YXZ"){const j=g*b,_e=g*$,tt=_*b,et=_*$;i[0]=j+et*h,i[4]=tt*h-_e,i[8]=d*_,i[1]=d*$,i[5]=d*b,i[9]=-h,i[2]=_e*h-tt,i[6]=et+j*h,i[10]=d*g}else if(e.order==="ZXY"){const j=g*b,_e=g*$,tt=_*b,et=_*$;i[0]=j-et*h,i[4]=-d*$,i[8]=tt+_e*h,i[1]=_e+tt*h,i[5]=d*b,i[9]=et-j*h,i[2]=-d*_,i[6]=h,i[10]=d*g}else if(e.order==="ZYX"){const j=d*b,_e=d*$,tt=h*b,et=h*$;i[0]=g*b,i[4]=tt*_-_e,i[8]=j*_+et,i[1]=g*$,i[5]=et*_+j,i[9]=_e*_-tt,i[2]=-_,i[6]=h*g,i[10]=d*g}else if(e.order==="YZX"){const j=d*g,_e=d*_,tt=h*g,et=h*_;i[0]=g*b,i[4]=et-j*$,i[8]=tt*$+_e,i[1]=$,i[5]=d*b,i[9]=-h*b,i[2]=-_*b,i[6]=_e*$+tt,i[10]=j-et*$}else if(e.order==="XZY"){const j=d*g,_e=d*_,tt=h*g,et=h*_;i[0]=g*b,i[4]=-$,i[8]=_*b,i[1]=j*$+et,i[5]=d*b,i[9]=_e*$-tt,i[2]=tt*$-_e,i[6]=h*b,i[10]=et*$+j}return i[3]=0,i[7]=0,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}makeRotationFromQuaternion(e){return this.compose(_zero,e,_one)}lookAt(e,i,s){const o=this.elements;return _z.subVectors(e,i),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(s,_z),_x.lengthSq()===0&&(Math.abs(s.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(s,_z)),_x.normalize(),_y.crossVectors(_z,_x),o[0]=_x.x,o[4]=_y.x,o[8]=_z.x,o[1]=_x.y,o[5]=_y.y,o[9]=_z.y,o[2]=_x.z,o[6]=_y.z,o[10]=_z.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,i){const s=e.elements,o=i.elements,c=this.elements,d=s[0],h=s[4],g=s[8],_=s[12],b=s[1],$=s[5],j=s[9],_e=s[13],tt=s[2],et=s[6],nt=s[10],rt=s[14],it=s[3],at=s[7],st=s[11],ot=s[15],ct=o[0],lt=o[4],dt=o[8],xt=o[12],ut=o[1],ft=o[5],mt=o[9],yt=o[13],St=o[2],Et=o[6],vt=o[10],Nt=o[14],wt=o[3],$t=o[7],Ct=o[11],Mt=o[15];return c[0]=d*ct+h*ut+g*St+_*wt,c[4]=d*lt+h*ft+g*Et+_*$t,c[8]=d*dt+h*mt+g*vt+_*Ct,c[12]=d*xt+h*yt+g*Nt+_*Mt,c[1]=b*ct+$*ut+j*St+_e*wt,c[5]=b*lt+$*ft+j*Et+_e*$t,c[9]=b*dt+$*mt+j*vt+_e*Ct,c[13]=b*xt+$*yt+j*Nt+_e*Mt,c[2]=tt*ct+et*ut+nt*St+rt*wt,c[6]=tt*lt+et*ft+nt*Et+rt*$t,c[10]=tt*dt+et*mt+nt*vt+rt*Ct,c[14]=tt*xt+et*yt+nt*Nt+rt*Mt,c[3]=it*ct+at*ut+st*St+ot*wt,c[7]=it*lt+at*ft+st*Et+ot*$t,c[11]=it*dt+at*mt+st*vt+ot*Ct,c[15]=it*xt+at*yt+st*Nt+ot*Mt,this}multiplyScalar(e){const i=this.elements;return i[0]*=e,i[4]*=e,i[8]*=e,i[12]*=e,i[1]*=e,i[5]*=e,i[9]*=e,i[13]*=e,i[2]*=e,i[6]*=e,i[10]*=e,i[14]*=e,i[3]*=e,i[7]*=e,i[11]*=e,i[15]*=e,this}determinant(){const e=this.elements,i=e[0],s=e[4],o=e[8],c=e[12],d=e[1],h=e[5],g=e[9],_=e[13],b=e[2],$=e[6],j=e[10],_e=e[14],tt=e[3],et=e[7],nt=e[11],rt=e[15];return tt*(+c*g*$-o*_*$-c*h*j+s*_*j+o*h*_e-s*g*_e)+et*(+i*g*_e-i*_*j+c*d*j-o*d*_e+o*_*b-c*g*b)+nt*(+i*_*$-i*h*_e-c*d*$+s*d*_e+c*h*b-s*_*b)+rt*(-o*h*b-i*g*$+i*h*j+o*d*$-s*d*j+s*g*b)}transpose(){const e=this.elements;let i;return i=e[1],e[1]=e[4],e[4]=i,i=e[2],e[2]=e[8],e[8]=i,i=e[6],e[6]=e[9],e[9]=i,i=e[3],e[3]=e[12],e[12]=i,i=e[7],e[7]=e[13],e[13]=i,i=e[11],e[11]=e[14],e[14]=i,this}setPosition(e,i,s){const o=this.elements;return e.isVector3?(o[12]=e.x,o[13]=e.y,o[14]=e.z):(o[12]=e,o[13]=i,o[14]=s),this}invert(){const e=this.elements,i=e[0],s=e[1],o=e[2],c=e[3],d=e[4],h=e[5],g=e[6],_=e[7],b=e[8],$=e[9],j=e[10],_e=e[11],tt=e[12],et=e[13],nt=e[14],rt=e[15],it=$*nt*_-et*j*_+et*g*_e-h*nt*_e-$*g*rt+h*j*rt,at=tt*j*_-b*nt*_-tt*g*_e+d*nt*_e+b*g*rt-d*j*rt,st=b*et*_-tt*$*_+tt*h*_e-d*et*_e-b*h*rt+d*$*rt,ot=tt*$*g-b*et*g-tt*h*j+d*et*j+b*h*nt-d*$*nt,ct=i*it+s*at+o*st+c*ot;if(ct===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const lt=1/ct;return e[0]=it*lt,e[1]=(et*j*c-$*nt*c-et*o*_e+s*nt*_e+$*o*rt-s*j*rt)*lt,e[2]=(h*nt*c-et*g*c+et*o*_-s*nt*_-h*o*rt+s*g*rt)*lt,e[3]=($*g*c-h*j*c-$*o*_+s*j*_+h*o*_e-s*g*_e)*lt,e[4]=at*lt,e[5]=(b*nt*c-tt*j*c+tt*o*_e-i*nt*_e-b*o*rt+i*j*rt)*lt,e[6]=(tt*g*c-d*nt*c-tt*o*_+i*nt*_+d*o*rt-i*g*rt)*lt,e[7]=(d*j*c-b*g*c+b*o*_-i*j*_-d*o*_e+i*g*_e)*lt,e[8]=st*lt,e[9]=(tt*$*c-b*et*c-tt*s*_e+i*et*_e+b*s*rt-i*$*rt)*lt,e[10]=(d*et*c-tt*h*c+tt*s*_-i*et*_-d*s*rt+i*h*rt)*lt,e[11]=(b*h*c-d*$*c-b*s*_+i*$*_+d*s*_e-i*h*_e)*lt,e[12]=ot*lt,e[13]=(b*et*o-tt*$*o+tt*s*j-i*et*j-b*s*nt+i*$*nt)*lt,e[14]=(tt*h*o-d*et*o-tt*s*g+i*et*g+d*s*nt-i*h*nt)*lt,e[15]=(d*$*o-b*h*o+b*s*g-i*$*g-d*s*j+i*h*j)*lt,this}scale(e){const i=this.elements,s=e.x,o=e.y,c=e.z;return i[0]*=s,i[4]*=o,i[8]*=c,i[1]*=s,i[5]*=o,i[9]*=c,i[2]*=s,i[6]*=o,i[10]*=c,i[3]*=s,i[7]*=o,i[11]*=c,this}getMaxScaleOnAxis(){const e=this.elements,i=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],o=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(i,s,o))}makeTranslation(e,i,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,i,0,0,1,s,0,0,0,1),this}makeRotationX(e){const i=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,i,-s,0,0,s,i,0,0,0,0,1),this}makeRotationY(e){const i=Math.cos(e),s=Math.sin(e);return this.set(i,0,s,0,0,1,0,0,-s,0,i,0,0,0,0,1),this}makeRotationZ(e){const i=Math.cos(e),s=Math.sin(e);return this.set(i,-s,0,0,s,i,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,i){const s=Math.cos(i),o=Math.sin(i),c=1-s,d=e.x,h=e.y,g=e.z,_=c*d,b=c*h;return this.set(_*d+s,_*h-o*g,_*g+o*h,0,_*h+o*g,b*h+s,b*g-o*d,0,_*g-o*h,b*g+o*d,c*g*g+s,0,0,0,0,1),this}makeScale(e,i,s){return this.set(e,0,0,0,0,i,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,i,s,o,c,d){return this.set(1,s,c,0,e,1,d,0,i,o,1,0,0,0,0,1),this}compose(e,i,s){const o=this.elements,c=i._x,d=i._y,h=i._z,g=i._w,_=c+c,b=d+d,$=h+h,j=c*_,_e=c*b,tt=c*$,et=d*b,nt=d*$,rt=h*$,it=g*_,at=g*b,st=g*$,ot=s.x,ct=s.y,lt=s.z;return o[0]=(1-(et+rt))*ot,o[1]=(_e+st)*ot,o[2]=(tt-at)*ot,o[3]=0,o[4]=(_e-st)*ct,o[5]=(1-(j+rt))*ct,o[6]=(nt+it)*ct,o[7]=0,o[8]=(tt+at)*lt,o[9]=(nt-it)*lt,o[10]=(1-(j+et))*lt,o[11]=0,o[12]=e.x,o[13]=e.y,o[14]=e.z,o[15]=1,this}decompose(e,i,s){const o=this.elements;let c=_v1$5.set(o[0],o[1],o[2]).length();const d=_v1$5.set(o[4],o[5],o[6]).length(),h=_v1$5.set(o[8],o[9],o[10]).length();this.determinant()<0&&(c=-c),e.x=o[12],e.y=o[13],e.z=o[14],_m1$4.copy(this);const _=1/c,b=1/d,$=1/h;return _m1$4.elements[0]*=_,_m1$4.elements[1]*=_,_m1$4.elements[2]*=_,_m1$4.elements[4]*=b,_m1$4.elements[5]*=b,_m1$4.elements[6]*=b,_m1$4.elements[8]*=$,_m1$4.elements[9]*=$,_m1$4.elements[10]*=$,i.setFromRotationMatrix(_m1$4),s.x=c,s.y=d,s.z=h,this}makePerspective(e,i,s,o,c,d,h=WebGLCoordinateSystem){const g=this.elements,_=2*c/(i-e),b=2*c/(s-o),$=(i+e)/(i-e),j=(s+o)/(s-o);let _e,tt;if(h===WebGLCoordinateSystem)_e=-(d+c)/(d-c),tt=-2*d*c/(d-c);else if(h===WebGPUCoordinateSystem)_e=-d/(d-c),tt=-d*c/(d-c);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+h);return g[0]=_,g[4]=0,g[8]=$,g[12]=0,g[1]=0,g[5]=b,g[9]=j,g[13]=0,g[2]=0,g[6]=0,g[10]=_e,g[14]=tt,g[3]=0,g[7]=0,g[11]=-1,g[15]=0,this}makeOrthographic(e,i,s,o,c,d,h=WebGLCoordinateSystem){const g=this.elements,_=1/(i-e),b=1/(s-o),$=1/(d-c),j=(i+e)*_,_e=(s+o)*b;let tt,et;if(h===WebGLCoordinateSystem)tt=(d+c)*$,et=-2*$;else if(h===WebGPUCoordinateSystem)tt=c*$,et=-1*$;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+h);return g[0]=2*_,g[4]=0,g[8]=0,g[12]=-j,g[1]=0,g[5]=2*b,g[9]=0,g[13]=-_e,g[2]=0,g[6]=0,g[10]=et,g[14]=-tt,g[3]=0,g[7]=0,g[11]=0,g[15]=1,this}equals(e){const i=this.elements,s=e.elements;for(let o=0;o<16;o++)if(i[o]!==s[o])return!1;return!0}fromArray(e,i=0){for(let s=0;s<16;s++)this.elements[s]=e[s+i];return this}toArray(e=[],i=0){const s=this.elements;return e[i]=s[0],e[i+1]=s[1],e[i+2]=s[2],e[i+3]=s[3],e[i+4]=s[4],e[i+5]=s[5],e[i+6]=s[6],e[i+7]=s[7],e[i+8]=s[8],e[i+9]=s[9],e[i+10]=s[10],e[i+11]=s[11],e[i+12]=s[12],e[i+13]=s[13],e[i+14]=s[14],e[i+15]=s[15],e}}const _v1$5=new Vector3,_m1$4=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$2=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(e=0,i=0,s=0,o=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=i,this._z=s,this._order=o}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,i,s,o=this._order){return this._x=e,this._y=i,this._z=s,this._order=o,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,i=this._order,s=!0){const o=e.elements,c=o[0],d=o[4],h=o[8],g=o[1],_=o[5],b=o[9],$=o[2],j=o[6],_e=o[10];switch(i){case"XYZ":this._y=Math.asin(clamp$2(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-b,_e),this._z=Math.atan2(-d,c)):(this._x=Math.atan2(j,_),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp$2(b,-1,1)),Math.abs(b)<.9999999?(this._y=Math.atan2(h,_e),this._z=Math.atan2(g,_)):(this._y=Math.atan2(-$,c),this._z=0);break;case"ZXY":this._x=Math.asin(clamp$2(j,-1,1)),Math.abs(j)<.9999999?(this._y=Math.atan2(-$,_e),this._z=Math.atan2(-d,_)):(this._y=0,this._z=Math.atan2(g,c));break;case"ZYX":this._y=Math.asin(-clamp$2($,-1,1)),Math.abs($)<.9999999?(this._x=Math.atan2(j,_e),this._z=Math.atan2(g,c)):(this._x=0,this._z=Math.atan2(-d,_));break;case"YZX":this._z=Math.asin(clamp$2(g,-1,1)),Math.abs(g)<.9999999?(this._x=Math.atan2(-b,_),this._y=Math.atan2(-$,c)):(this._x=0,this._y=Math.atan2(h,_e));break;case"XZY":this._z=Math.asin(-clamp$2(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(j,_),this._y=Math.atan2(h,c)):(this._x=Math.atan2(-b,_e),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+i)}return this._order=i,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,i,s){return _matrix$2.makeRotationFromQuaternion(e),this.setFromRotationMatrix(_matrix$2,i,s)}setFromVector3(e,i=this._order){return this.set(e.x,e.y,e.z,i)}reorder(e){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],i=0){return e[i]=this._x,e[i+1]=this._y,e[i+2]=this._z,e[i+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$3=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const e=new Vector3,i=new Euler,s=new Quaternion,o=new Vector3(1,1,1);function c(){s.setFromEuler(i,!1)}function d(){i.setFromQuaternion(s,void 0,!1)}i._onChange(c),s._onChange(d),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:i},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:o},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,i){this.quaternion.setFromAxisAngle(e,i)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,i){return _q1.setFromAxisAngle(e,i),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(e,i){return _q1.setFromAxisAngle(e,i),this.quaternion.premultiply(_q1),this}rotateX(e){return this.rotateOnAxis(_xAxis,e)}rotateY(e){return this.rotateOnAxis(_yAxis,e)}rotateZ(e){return this.rotateOnAxis(_zAxis,e)}translateOnAxis(e,i){return _v1$4.copy(e).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(i)),this}translateX(e){return this.translateOnAxis(_xAxis,e)}translateY(e){return this.translateOnAxis(_yAxis,e)}translateZ(e){return this.translateOnAxis(_zAxis,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())}lookAt(e,i,s){e.isVector3?_target.copy(e):_target.set(e,i,s);const o=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$3.lookAt(_position$3,_target,this.up):_m1$3.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$3),o&&(_m1$3.extractRotation(o.matrixWorld),_q1.setFromRotationMatrix(_m1$3),this.quaternion.premultiply(_q1.invert()))}add(e){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.add(arguments[i]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(_addedEvent),_childaddedEvent.child=e,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const i=this.children.indexOf(e);return i!==-1&&(e.parent=null,this.children.splice(i,1),e.dispatchEvent(_removedEvent),_childremovedEvent.child=e,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),_m1$3.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),_m1$3.multiply(e.parent.matrixWorld)),e.applyMatrix4(_m1$3),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(_addedEvent),_childaddedEvent.child=e,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,i){if(this[e]===i)return this;for(let s=0,o=this.children.length;s<o;s++){const d=this.children[s].getObjectByProperty(e,i);if(d!==void 0)return d}}getObjectsByProperty(e,i,s=[]){this[e]===i&&s.push(this);const o=this.children;for(let c=0,d=o.length;c<d;c++)o[c].getObjectsByProperty(e,i,s);return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,e,_scale$2),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const i=this.matrixWorld.elements;return e.set(i[8],i[9],i[10]).normalize()}raycast(){}traverse(e){e(this);const i=this.children;for(let s=0,o=i.length;s<o;s++)i[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const i=this.children;for(let s=0,o=i.length;s<o;s++)i[s].traverseVisible(e)}traverseAncestors(e){const i=this.parent;i!==null&&(e(i),i.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const i=this.children;for(let s=0,o=i.length;s<o;s++){const c=i[s];(c.matrixWorldAutoUpdate===!0||e===!0)&&c.updateMatrixWorld(e)}}updateWorldMatrix(e,i){const s=this.parent;if(e===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),i===!0){const o=this.children;for(let c=0,d=o.length;c<d;c++){const h=o[c];h.matrixWorldAutoUpdate===!0&&h.updateWorldMatrix(!1,!0)}}}toJSON(e){const i=e===void 0||typeof e=="string",s={};i&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const o={};o.uuid=this.uuid,o.type=this.type,this.name!==""&&(o.name=this.name),this.castShadow===!0&&(o.castShadow=!0),this.receiveShadow===!0&&(o.receiveShadow=!0),this.visible===!1&&(o.visible=!1),this.frustumCulled===!1&&(o.frustumCulled=!1),this.renderOrder!==0&&(o.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(o.userData=this.userData),o.layers=this.layers.mask,o.matrix=this.matrix.toArray(),o.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(o.matrixAutoUpdate=!1),this.isInstancedMesh&&(o.type="InstancedMesh",o.count=this.count,o.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(o.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(o.type="BatchedMesh",o.perObjectFrustumCulled=this.perObjectFrustumCulled,o.sortObjects=this.sortObjects,o.drawRanges=this._drawRanges,o.reservedRanges=this._reservedRanges,o.visibility=this._visibility,o.active=this._active,o.bounds=this._bounds.map(h=>({boxInitialized:h.boxInitialized,boxMin:h.box.min.toArray(),boxMax:h.box.max.toArray(),sphereInitialized:h.sphereInitialized,sphereRadius:h.sphere.radius,sphereCenter:h.sphere.center.toArray()})),o.maxGeometryCount=this._maxGeometryCount,o.maxVertexCount=this._maxVertexCount,o.maxIndexCount=this._maxIndexCount,o.geometryInitialized=this._geometryInitialized,o.geometryCount=this._geometryCount,o.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(o.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(o.boundingSphere={center:o.boundingSphere.center.toArray(),radius:o.boundingSphere.radius}),this.boundingBox!==null&&(o.boundingBox={min:o.boundingBox.min.toArray(),max:o.boundingBox.max.toArray()}));function c(h,g){return h[g.uuid]===void 0&&(h[g.uuid]=g.toJSON(e)),g.uuid}if(this.isScene)this.background&&(this.background.isColor?o.background=this.background.toJSON():this.background.isTexture&&(o.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(o.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){o.geometry=c(e.geometries,this.geometry);const h=this.geometry.parameters;if(h!==void 0&&h.shapes!==void 0){const g=h.shapes;if(Array.isArray(g))for(let _=0,b=g.length;_<b;_++){const $=g[_];c(e.shapes,$)}else c(e.shapes,g)}}if(this.isSkinnedMesh&&(o.bindMode=this.bindMode,o.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(c(e.skeletons,this.skeleton),o.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const h=[];for(let g=0,_=this.material.length;g<_;g++)h.push(c(e.materials,this.material[g]));o.material=h}else o.material=c(e.materials,this.material);if(this.children.length>0){o.children=[];for(let h=0;h<this.children.length;h++)o.children.push(this.children[h].toJSON(e).object)}if(this.animations.length>0){o.animations=[];for(let h=0;h<this.animations.length;h++){const g=this.animations[h];o.animations.push(c(e.animations,g))}}if(i){const h=d(e.geometries),g=d(e.materials),_=d(e.textures),b=d(e.images),$=d(e.shapes),j=d(e.skeletons),_e=d(e.animations),tt=d(e.nodes);h.length>0&&(s.geometries=h),g.length>0&&(s.materials=g),_.length>0&&(s.textures=_),b.length>0&&(s.images=b),$.length>0&&(s.shapes=$),j.length>0&&(s.skeletons=j),_e.length>0&&(s.animations=_e),tt.length>0&&(s.nodes=tt)}return s.object=o,s;function d(h){const g=[];for(const _ in h){const b=h[_];delete b.metadata,g.push(b)}return g}}clone(e){return new this.constructor().copy(this,e)}copy(e,i=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),i===!0)for(let s=0;s<e.children.length;s++){const o=e.children[s];this.add(o.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$2=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3;class Triangle{constructor(e=new Vector3,i=new Vector3,s=new Vector3){this.a=e,this.b=i,this.c=s}static getNormal(e,i,s,o){o.subVectors(s,i),_v0$1.subVectors(e,i),o.cross(_v0$1);const c=o.lengthSq();return c>0?o.multiplyScalar(1/Math.sqrt(c)):o.set(0,0,0)}static getBarycoord(e,i,s,o,c){_v0$1.subVectors(o,i),_v1$3.subVectors(s,i),_v2$2.subVectors(e,i);const d=_v0$1.dot(_v0$1),h=_v0$1.dot(_v1$3),g=_v0$1.dot(_v2$2),_=_v1$3.dot(_v1$3),b=_v1$3.dot(_v2$2),$=d*_-h*h;if($===0)return c.set(0,0,0),null;const j=1/$,_e=(_*g-h*b)*j,tt=(d*b-h*g)*j;return c.set(1-_e-tt,tt,_e)}static containsPoint(e,i,s,o){return this.getBarycoord(e,i,s,o,_v3$2)===null?!1:_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1}static getInterpolation(e,i,s,o,c,d,h,g){return this.getBarycoord(e,i,s,o,_v3$2)===null?(g.x=0,g.y=0,"z"in g&&(g.z=0),"w"in g&&(g.w=0),null):(g.setScalar(0),g.addScaledVector(c,_v3$2.x),g.addScaledVector(d,_v3$2.y),g.addScaledVector(h,_v3$2.z),g)}static isFrontFacing(e,i,s,o){return _v0$1.subVectors(s,i),_v1$3.subVectors(e,i),_v0$1.cross(_v1$3).dot(o)<0}set(e,i,s){return this.a.copy(e),this.b.copy(i),this.c.copy(s),this}setFromPointsAndIndices(e,i,s,o){return this.a.copy(e[i]),this.b.copy(e[s]),this.c.copy(e[o]),this}setFromAttributeAndIndices(e,i,s,o){return this.a.fromBufferAttribute(e,i),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,o),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Triangle.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,i){return Triangle.getBarycoord(e,this.a,this.b,this.c,i)}getInterpolation(e,i,s,o,c){return Triangle.getInterpolation(e,this.a,this.b,this.c,i,s,o,c)}containsPoint(e){return Triangle.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Triangle.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,i){const s=this.a,o=this.b,c=this.c;let d,h;_vab.subVectors(o,s),_vac.subVectors(c,s),_vap.subVectors(e,s);const g=_vab.dot(_vap),_=_vac.dot(_vap);if(g<=0&&_<=0)return i.copy(s);_vbp.subVectors(e,o);const b=_vab.dot(_vbp),$=_vac.dot(_vbp);if(b>=0&&$<=b)return i.copy(o);const j=g*$-b*_;if(j<=0&&g>=0&&b<=0)return d=g/(g-b),i.copy(s).addScaledVector(_vab,d);_vcp.subVectors(e,c);const _e=_vab.dot(_vcp),tt=_vac.dot(_vcp);if(tt>=0&&_e<=tt)return i.copy(c);const et=_e*_-g*tt;if(et<=0&&_>=0&&tt<=0)return h=_/(_-tt),i.copy(s).addScaledVector(_vac,h);const nt=b*tt-_e*$;if(nt<=0&&$-b>=0&&_e-tt>=0)return _vbc.subVectors(c,o),h=($-b)/($-b+(_e-tt)),i.copy(o).addScaledVector(_vbc,h);const rt=1/(nt+et+j);return d=et*rt,h=j*rt,i.copy(s).addScaledVector(_vab,d).addScaledVector(_vac,h)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(a,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?a+(e-a)*6*i:i<1/2?e:i<2/3?a+(e-a)*6*(2/3-i):a}class Color{constructor(e,i,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,i,s)}set(e,i,s){if(i===void 0&&s===void 0){const o=e;o&&o.isColor?this.copy(o):typeof o=="number"?this.setHex(o):typeof o=="string"&&this.setStyle(o)}else this.setRGB(e,i,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,i=SRGBColorSpace){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,ColorManagement.toWorkingColorSpace(this,i),this}setRGB(e,i,s,o=ColorManagement.workingColorSpace){return this.r=e,this.g=i,this.b=s,ColorManagement.toWorkingColorSpace(this,o),this}setHSL(e,i,s,o=ColorManagement.workingColorSpace){if(e=euclideanModulo(e,1),i=clamp$2(i,0,1),s=clamp$2(s,0,1),i===0)this.r=this.g=this.b=s;else{const c=s<=.5?s*(1+i):s+i-s*i,d=2*s-c;this.r=hue2rgb(d,c,e+1/3),this.g=hue2rgb(d,c,e),this.b=hue2rgb(d,c,e-1/3)}return ColorManagement.toWorkingColorSpace(this,o),this}setStyle(e,i=SRGBColorSpace){function s(c){c!==void 0&&parseFloat(c)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let o;if(o=/^(\w+)\(([^\)]*)\)/.exec(e)){let c;const d=o[1],h=o[2];switch(d){case"rgb":case"rgba":if(c=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))return s(c[4]),this.setRGB(Math.min(255,parseInt(c[1],10))/255,Math.min(255,parseInt(c[2],10))/255,Math.min(255,parseInt(c[3],10))/255,i);if(c=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))return s(c[4]),this.setRGB(Math.min(100,parseInt(c[1],10))/100,Math.min(100,parseInt(c[2],10))/100,Math.min(100,parseInt(c[3],10))/100,i);break;case"hsl":case"hsla":if(c=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))return s(c[4]),this.setHSL(parseFloat(c[1])/360,parseFloat(c[2])/100,parseFloat(c[3])/100,i);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(o=/^\#([A-Fa-f\d]+)$/.exec(e)){const c=o[1],d=c.length;if(d===3)return this.setRGB(parseInt(c.charAt(0),16)/15,parseInt(c.charAt(1),16)/15,parseInt(c.charAt(2),16)/15,i);if(d===6)return this.setHex(parseInt(c,16),i);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,i);return this}setColorName(e,i=SRGBColorSpace){const s=_colorKeywords[e.toLowerCase()];return s!==void 0?this.setHex(s,i):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=SRGBToLinear(e.r),this.g=SRGBToLinear(e.g),this.b=SRGBToLinear(e.b),this}copyLinearToSRGB(e){return this.r=LinearToSRGB(e.r),this.g=LinearToSRGB(e.g),this.b=LinearToSRGB(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=SRGBColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),e),Math.round(clamp$2(_color.r*255,0,255))*65536+Math.round(clamp$2(_color.g*255,0,255))*256+Math.round(clamp$2(_color.b*255,0,255))}getHexString(e=SRGBColorSpace){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,i=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),i);const s=_color.r,o=_color.g,c=_color.b,d=Math.max(s,o,c),h=Math.min(s,o,c);let g,_;const b=(h+d)/2;if(h===d)g=0,_=0;else{const $=d-h;switch(_=b<=.5?$/(d+h):$/(2-d-h),d){case s:g=(o-c)/$+(o<c?6:0);break;case o:g=(c-s)/$+2;break;case c:g=(s-o)/$+4;break}g/=6}return e.h=g,e.s=_,e.l=b,e}getRGB(e,i=ColorManagement.workingColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),i),e.r=_color.r,e.g=_color.g,e.b=_color.b,e}getStyle(e=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),e);const i=_color.r,s=_color.g,o=_color.b;return e!==SRGBColorSpace?`color(${e} ${i.toFixed(3)} ${s.toFixed(3)} ${o.toFixed(3)})`:`rgb(${Math.round(i*255)},${Math.round(s*255)},${Math.round(o*255)})`}offsetHSL(e,i,s){return this.getHSL(_hslA),this.setHSL(_hslA.h+e,_hslA.s+i,_hslA.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,i){return this.r=e.r+i.r,this.g=e.g+i.g,this.b=e.b+i.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,i){return this.r+=(e.r-this.r)*i,this.g+=(e.g-this.g)*i,this.b+=(e.b-this.b)*i,this}lerpColors(e,i,s){return this.r=e.r+(i.r-e.r)*s,this.g=e.g+(i.g-e.g)*s,this.b=e.b+(i.b-e.b)*s,this}lerpHSL(e,i){this.getHSL(_hslA),e.getHSL(_hslB);const s=lerp(_hslA.h,_hslB.h,i),o=lerp(_hslA.s,_hslB.s,i),c=lerp(_hslA.l,_hslB.l,i);return this.setHSL(s,o,c),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const i=this.r,s=this.g,o=this.b,c=e.elements;return this.r=c[0]*i+c[3]*s+c[6]*o,this.g=c[1]*i+c[4]*s+c[7]*o,this.b=c[2]*i+c[5]*s+c[8]*o,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,i=0){return this.r=e[i],this.g=e[i+1],this.b=e[i+2],this}toArray(e=[],i=0){return e[i]=this.r,e[i+1]=this.g,e[i+2]=this.b,e}fromBufferAttribute(e,i){return this.r=e.getX(i),this.g=e.getY(i),this.b=e.getZ(i),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const _color=new Color;Color.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const i in e){const s=e[i];if(s===void 0){console.warn(`THREE.Material: parameter '${i}' has value of undefined.`);continue}const o=this[i];if(o===void 0){console.warn(`THREE.Material: '${i}' is not a property of THREE.${this.type}.`);continue}o&&o.isColor?o.set(s):o&&o.isVector3&&s&&s.isVector3?o.copy(s):this[i]=s}}toJSON(e){const i=e===void 0||typeof e=="string";i&&(e={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(s.blending=this.blending),this.side!==FrontSide&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(s.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(s.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(s.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function o(c){const d=[];for(const h in c){const g=c[h];delete g.metadata,d.push(g)}return d}if(i){const c=o(e.textures),d=o(e.images);c.length>0&&(s.textures=c),d.length>0&&(s.images=d)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const i=e.clippingPlanes;let s=null;if(i!==null){const o=i.length;s=new Array(o);for(let c=0;c!==o;++c)s[c]=i[c].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class MeshBasicMaterial extends Material{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const _tables=_generateTables();function _generateTables(){const a=new ArrayBuffer(4),e=new Float32Array(a),i=new Uint32Array(a),s=new Uint32Array(512),o=new Uint32Array(512);for(let g=0;g<256;++g){const _=g-127;_<-27?(s[g]=0,s[g|256]=32768,o[g]=24,o[g|256]=24):_<-14?(s[g]=1024>>-_-14,s[g|256]=1024>>-_-14|32768,o[g]=-_-1,o[g|256]=-_-1):_<=15?(s[g]=_+15<<10,s[g|256]=_+15<<10|32768,o[g]=13,o[g|256]=13):_<128?(s[g]=31744,s[g|256]=64512,o[g]=24,o[g|256]=24):(s[g]=31744,s[g|256]=64512,o[g]=13,o[g|256]=13)}const c=new Uint32Array(2048),d=new Uint32Array(64),h=new Uint32Array(64);for(let g=1;g<1024;++g){let _=g<<13,b=0;for(;!(_&8388608);)_<<=1,b-=8388608;_&=-8388609,b+=947912704,c[g]=_|b}for(let g=1024;g<2048;++g)c[g]=939524096+(g-1024<<13);for(let g=1;g<31;++g)d[g]=g<<23;d[31]=1199570944,d[32]=2147483648;for(let g=33;g<63;++g)d[g]=2147483648+(g-32<<23);d[63]=3347054592;for(let g=1;g<64;++g)g!==32&&(h[g]=1024);return{floatView:e,uint32View:i,baseTable:s,shiftTable:o,mantissaTable:c,exponentTable:d,offsetTable:h}}function toHalfFloat(a){Math.abs(a)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),a=clamp$2(a,-65504,65504),_tables.floatView[0]=a;const e=_tables.uint32View[0],i=e>>23&511;return _tables.baseTable[i]+((e&8388607)>>_tables.shiftTable[i])}function fromHalfFloat(a){const e=a>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[e]+(a&1023)]+_tables.exponentTable[e],_tables.floatView[0]}const DataUtils={toHalfFloat,fromHalfFloat},_vector$9=new Vector3,_vector2$1=new Vector2;class BufferAttribute{constructor(e,i,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=i,this.count=e!==void 0?e.length/i:0,this.normalized=s,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return warnOnce("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,i){this.updateRanges.push({start:e,count:i})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,i,s){e*=this.itemSize,s*=i.itemSize;for(let o=0,c=this.itemSize;o<c;o++)this.array[e+o]=i.array[s+o];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let i=0,s=this.count;i<s;i++)_vector2$1.fromBufferAttribute(this,i),_vector2$1.applyMatrix3(e),this.setXY(i,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let i=0,s=this.count;i<s;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.applyMatrix3(e),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(e){for(let i=0,s=this.count;i<s;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.applyMatrix4(e),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(e){for(let i=0,s=this.count;i<s;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.applyNormalMatrix(e),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(e){for(let i=0,s=this.count;i<s;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.transformDirection(e),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(e,i=0){return this.array.set(e,i),this}getComponent(e,i){let s=this.array[e*this.itemSize+i];return this.normalized&&(s=denormalize(s,this.array)),s}setComponent(e,i,s){return this.normalized&&(s=normalize(s,this.array)),this.array[e*this.itemSize+i]=s,this}getX(e){let i=this.array[e*this.itemSize];return this.normalized&&(i=denormalize(i,this.array)),i}setX(e,i){return this.normalized&&(i=normalize(i,this.array)),this.array[e*this.itemSize]=i,this}getY(e){let i=this.array[e*this.itemSize+1];return this.normalized&&(i=denormalize(i,this.array)),i}setY(e,i){return this.normalized&&(i=normalize(i,this.array)),this.array[e*this.itemSize+1]=i,this}getZ(e){let i=this.array[e*this.itemSize+2];return this.normalized&&(i=denormalize(i,this.array)),i}setZ(e,i){return this.normalized&&(i=normalize(i,this.array)),this.array[e*this.itemSize+2]=i,this}getW(e){let i=this.array[e*this.itemSize+3];return this.normalized&&(i=denormalize(i,this.array)),i}setW(e,i){return this.normalized&&(i=normalize(i,this.array)),this.array[e*this.itemSize+3]=i,this}setXY(e,i,s){return e*=this.itemSize,this.normalized&&(i=normalize(i,this.array),s=normalize(s,this.array)),this.array[e+0]=i,this.array[e+1]=s,this}setXYZ(e,i,s,o){return e*=this.itemSize,this.normalized&&(i=normalize(i,this.array),s=normalize(s,this.array),o=normalize(o,this.array)),this.array[e+0]=i,this.array[e+1]=s,this.array[e+2]=o,this}setXYZW(e,i,s,o,c){return e*=this.itemSize,this.normalized&&(i=normalize(i,this.array),s=normalize(s,this.array),o=normalize(o,this.array),c=normalize(c,this.array)),this.array[e+0]=i,this.array[e+1]=s,this.array[e+2]=o,this.array[e+3]=c,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==StaticDrawUsage&&(e.usage=this.usage),e}}class Uint16BufferAttribute extends BufferAttribute{constructor(e,i,s){super(new Uint16Array(e),i,s)}}class Uint32BufferAttribute extends BufferAttribute{constructor(e,i,s){super(new Uint32Array(e),i,s)}}class Float32BufferAttribute extends BufferAttribute{constructor(e,i,s){super(new Float32Array(e),i,s)}}let _id$2=0;const _m1$2=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$2=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(arrayNeedsUint32(e)?Uint32BufferAttribute:Uint16BufferAttribute)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,i){return this.attributes[e]=i,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,i,s=0){this.groups.push({start:e,count:i,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,i){this.drawRange.start=e,this.drawRange.count=i}applyMatrix4(e){const i=this.attributes.position;i!==void 0&&(i.applyMatrix4(e),i.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const c=new Matrix3().getNormalMatrix(e);s.applyNormalMatrix(c),s.needsUpdate=!0}const o=this.attributes.tangent;return o!==void 0&&(o.transformDirection(e),o.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return _m1$2.makeRotationFromQuaternion(e),this.applyMatrix4(_m1$2),this}rotateX(e){return _m1$2.makeRotationX(e),this.applyMatrix4(_m1$2),this}rotateY(e){return _m1$2.makeRotationY(e),this.applyMatrix4(_m1$2),this}rotateZ(e){return _m1$2.makeRotationZ(e),this.applyMatrix4(_m1$2),this}translate(e,i,s){return _m1$2.makeTranslation(e,i,s),this.applyMatrix4(_m1$2),this}scale(e,i,s){return _m1$2.makeScale(e,i,s),this.applyMatrix4(_m1$2),this}lookAt(e){return _obj.lookAt(e),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(e){const i=[];for(let s=0,o=e.length;s<o;s++){const c=e[s];i.push(c.x,c.y,c.z||0)}return this.setAttribute("position",new Float32BufferAttribute(i,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const e=this.attributes.position,i=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),i)for(let s=0,o=i.length;s<o;s++){const c=i[s];_box$2.setFromBufferAttribute(c),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const e=this.attributes.position,i=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Vector3,1/0);return}if(e){const s=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(e),i)for(let c=0,d=i.length;c<d;c++){const h=i[c];_boxMorphTargets.setFromBufferAttribute(h),this.morphTargetsRelative?(_vector$8.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$8),_vector$8.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$8)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(s);let o=0;for(let c=0,d=e.count;c<d;c++)_vector$8.fromBufferAttribute(e,c),o=Math.max(o,s.distanceToSquared(_vector$8));if(i)for(let c=0,d=i.length;c<d;c++){const h=i[c],g=this.morphTargetsRelative;for(let _=0,b=h.count;_<b;_++)_vector$8.fromBufferAttribute(h,_),g&&(_offset.fromBufferAttribute(e,_),_vector$8.add(_offset)),o=Math.max(o,s.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(o),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,i=this.attributes;if(e===null||i.position===void 0||i.normal===void 0||i.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=i.position,o=i.normal,c=i.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*s.count),4));const d=this.getAttribute("tangent"),h=[],g=[];for(let dt=0;dt<s.count;dt++)h[dt]=new Vector3,g[dt]=new Vector3;const _=new Vector3,b=new Vector3,$=new Vector3,j=new Vector2,_e=new Vector2,tt=new Vector2,et=new Vector3,nt=new Vector3;function rt(dt,xt,ut){_.fromBufferAttribute(s,dt),b.fromBufferAttribute(s,xt),$.fromBufferAttribute(s,ut),j.fromBufferAttribute(c,dt),_e.fromBufferAttribute(c,xt),tt.fromBufferAttribute(c,ut),b.sub(_),$.sub(_),_e.sub(j),tt.sub(j);const ft=1/(_e.x*tt.y-tt.x*_e.y);isFinite(ft)&&(et.copy(b).multiplyScalar(tt.y).addScaledVector($,-_e.y).multiplyScalar(ft),nt.copy($).multiplyScalar(_e.x).addScaledVector(b,-tt.x).multiplyScalar(ft),h[dt].add(et),h[xt].add(et),h[ut].add(et),g[dt].add(nt),g[xt].add(nt),g[ut].add(nt))}let it=this.groups;it.length===0&&(it=[{start:0,count:e.count}]);for(let dt=0,xt=it.length;dt<xt;++dt){const ut=it[dt],ft=ut.start,mt=ut.count;for(let yt=ft,St=ft+mt;yt<St;yt+=3)rt(e.getX(yt+0),e.getX(yt+1),e.getX(yt+2))}const at=new Vector3,st=new Vector3,ot=new Vector3,ct=new Vector3;function lt(dt){ot.fromBufferAttribute(o,dt),ct.copy(ot);const xt=h[dt];at.copy(xt),at.sub(ot.multiplyScalar(ot.dot(xt))).normalize(),st.crossVectors(ct,xt);const ft=st.dot(g[dt])<0?-1:1;d.setXYZW(dt,at.x,at.y,at.z,ft)}for(let dt=0,xt=it.length;dt<xt;++dt){const ut=it[dt],ft=ut.start,mt=ut.count;for(let yt=ft,St=ft+mt;yt<St;yt+=3)lt(e.getX(yt+0)),lt(e.getX(yt+1)),lt(e.getX(yt+2))}}computeVertexNormals(){const e=this.index,i=this.getAttribute("position");if(i!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new BufferAttribute(new Float32Array(i.count*3),3),this.setAttribute("normal",s);else for(let j=0,_e=s.count;j<_e;j++)s.setXYZ(j,0,0,0);const o=new Vector3,c=new Vector3,d=new Vector3,h=new Vector3,g=new Vector3,_=new Vector3,b=new Vector3,$=new Vector3;if(e)for(let j=0,_e=e.count;j<_e;j+=3){const tt=e.getX(j+0),et=e.getX(j+1),nt=e.getX(j+2);o.fromBufferAttribute(i,tt),c.fromBufferAttribute(i,et),d.fromBufferAttribute(i,nt),b.subVectors(d,c),$.subVectors(o,c),b.cross($),h.fromBufferAttribute(s,tt),g.fromBufferAttribute(s,et),_.fromBufferAttribute(s,nt),h.add(b),g.add(b),_.add(b),s.setXYZ(tt,h.x,h.y,h.z),s.setXYZ(et,g.x,g.y,g.z),s.setXYZ(nt,_.x,_.y,_.z)}else for(let j=0,_e=i.count;j<_e;j+=3)o.fromBufferAttribute(i,j+0),c.fromBufferAttribute(i,j+1),d.fromBufferAttribute(i,j+2),b.subVectors(d,c),$.subVectors(o,c),b.cross($),s.setXYZ(j+0,b.x,b.y,b.z),s.setXYZ(j+1,b.x,b.y,b.z),s.setXYZ(j+2,b.x,b.y,b.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let i=0,s=e.count;i<s;i++)_vector$8.fromBufferAttribute(e,i),_vector$8.normalize(),e.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function e(h,g){const _=h.array,b=h.itemSize,$=h.normalized,j=new _.constructor(g.length*b);let _e=0,tt=0;for(let et=0,nt=g.length;et<nt;et++){h.isInterleavedBufferAttribute?_e=g[et]*h.data.stride+h.offset:_e=g[et]*b;for(let rt=0;rt<b;rt++)j[tt++]=_[_e++]}return new BufferAttribute(j,b,$)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const i=new BufferGeometry,s=this.index.array,o=this.attributes;for(const h in o){const g=o[h],_=e(g,s);i.setAttribute(h,_)}const c=this.morphAttributes;for(const h in c){const g=[],_=c[h];for(let b=0,$=_.length;b<$;b++){const j=_[b],_e=e(j,s);g.push(_e)}i.morphAttributes[h]=g}i.morphTargetsRelative=this.morphTargetsRelative;const d=this.groups;for(let h=0,g=d.length;h<g;h++){const _=d[h];i.addGroup(_.start,_.count,_.materialIndex)}return i}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const g=this.parameters;for(const _ in g)g[_]!==void 0&&(e[_]=g[_]);return e}e.data={attributes:{}};const i=this.index;i!==null&&(e.data.index={type:i.array.constructor.name,array:Array.prototype.slice.call(i.array)});const s=this.attributes;for(const g in s){const _=s[g];e.data.attributes[g]=_.toJSON(e.data)}const o={};let c=!1;for(const g in this.morphAttributes){const _=this.morphAttributes[g],b=[];for(let $=0,j=_.length;$<j;$++){const _e=_[$];b.push(_e.toJSON(e.data))}b.length>0&&(o[g]=b,c=!0)}c&&(e.data.morphAttributes=o,e.data.morphTargetsRelative=this.morphTargetsRelative);const d=this.groups;d.length>0&&(e.data.groups=JSON.parse(JSON.stringify(d)));const h=this.boundingSphere;return h!==null&&(e.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const i={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(i));const o=e.attributes;for(const _ in o){const b=o[_];this.setAttribute(_,b.clone(i))}const c=e.morphAttributes;for(const _ in c){const b=[],$=c[_];for(let j=0,_e=$.length;j<_e;j++)b.push($[j].clone(i));this.morphAttributes[_]=b}this.morphTargetsRelative=e.morphTargetsRelative;const d=e.groups;for(let _=0,b=d.length;_<b;_++){const $=d[_];this.addGroup($.start,$.count,$.materialIndex)}const h=e.boundingBox;h!==null&&(this.boundingBox=h.clone());const g=e.boundingSphere;return g!==null&&(this.boundingSphere=g.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$6=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_uvA$1=new Vector2,_uvB$1=new Vector2,_uvC$1=new Vector2,_normalA=new Vector3,_normalB=new Vector3,_normalC=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(e=new BufferGeometry,i=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=i,this.updateMorphTargets()}copy(e,i){return super.copy(e,i),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const i=this.geometry.morphAttributes,s=Object.keys(i);if(s.length>0){const o=i[s[0]];if(o!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,d=o.length;c<d;c++){const h=o[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=c}}}}getVertexPosition(e,i){const s=this.geometry,o=s.attributes.position,c=s.morphAttributes.position,d=s.morphTargetsRelative;i.fromBufferAttribute(o,e);const h=this.morphTargetInfluences;if(c&&h){_morphA.set(0,0,0);for(let g=0,_=c.length;g<_;g++){const b=h[g],$=c[g];b!==0&&(_tempA.fromBufferAttribute($,e),d?_morphA.addScaledVector(_tempA,b):_morphA.addScaledVector(_tempA.sub(i),b))}i.add(_morphA)}return i}raycast(e,i){const s=this.geometry,o=this.material,c=this.matrixWorld;o!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),_sphere$6.copy(s.boundingSphere),_sphere$6.applyMatrix4(c),_ray$3.copy(e.ray).recast(e.near),!(_sphere$6.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$6,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(e.far-e.near)**2))&&(_inverseMatrix$3.copy(c).invert(),_ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3),!(s.boundingBox!==null&&_ray$3.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,i,_ray$3)))}_computeIntersections(e,i,s){let o;const c=this.geometry,d=this.material,h=c.index,g=c.attributes.position,_=c.attributes.uv,b=c.attributes.uv1,$=c.attributes.normal,j=c.groups,_e=c.drawRange;if(h!==null)if(Array.isArray(d))for(let tt=0,et=j.length;tt<et;tt++){const nt=j[tt],rt=d[nt.materialIndex],it=Math.max(nt.start,_e.start),at=Math.min(h.count,Math.min(nt.start+nt.count,_e.start+_e.count));for(let st=it,ot=at;st<ot;st+=3){const ct=h.getX(st),lt=h.getX(st+1),dt=h.getX(st+2);o=checkGeometryIntersection(this,rt,e,s,_,b,$,ct,lt,dt),o&&(o.faceIndex=Math.floor(st/3),o.face.materialIndex=nt.materialIndex,i.push(o))}}else{const tt=Math.max(0,_e.start),et=Math.min(h.count,_e.start+_e.count);for(let nt=tt,rt=et;nt<rt;nt+=3){const it=h.getX(nt),at=h.getX(nt+1),st=h.getX(nt+2);o=checkGeometryIntersection(this,d,e,s,_,b,$,it,at,st),o&&(o.faceIndex=Math.floor(nt/3),i.push(o))}}else if(g!==void 0)if(Array.isArray(d))for(let tt=0,et=j.length;tt<et;tt++){const nt=j[tt],rt=d[nt.materialIndex],it=Math.max(nt.start,_e.start),at=Math.min(g.count,Math.min(nt.start+nt.count,_e.start+_e.count));for(let st=it,ot=at;st<ot;st+=3){const ct=st,lt=st+1,dt=st+2;o=checkGeometryIntersection(this,rt,e,s,_,b,$,ct,lt,dt),o&&(o.faceIndex=Math.floor(st/3),o.face.materialIndex=nt.materialIndex,i.push(o))}}else{const tt=Math.max(0,_e.start),et=Math.min(g.count,_e.start+_e.count);for(let nt=tt,rt=et;nt<rt;nt+=3){const it=nt,at=nt+1,st=nt+2;o=checkGeometryIntersection(this,d,e,s,_,b,$,it,at,st),o&&(o.faceIndex=Math.floor(nt/3),i.push(o))}}}}function checkIntersection$1(a,e,i,s,o,c,d,h){let g;if(e.side===BackSide?g=s.intersectTriangle(d,c,o,!0,h):g=s.intersectTriangle(o,c,d,e.side===FrontSide,h),g===null)return null;_intersectionPointWorld.copy(h),_intersectionPointWorld.applyMatrix4(a.matrixWorld);const _=i.ray.origin.distanceTo(_intersectionPointWorld);return _<i.near||_>i.far?null:{distance:_,point:_intersectionPointWorld.clone(),object:a}}function checkGeometryIntersection(a,e,i,s,o,c,d,h,g,_){a.getVertexPosition(h,_vA$1),a.getVertexPosition(g,_vB$1),a.getVertexPosition(_,_vC$1);const b=checkIntersection$1(a,e,i,s,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(b){o&&(_uvA$1.fromBufferAttribute(o,h),_uvB$1.fromBufferAttribute(o,g),_uvC$1.fromBufferAttribute(o,_),b.uv=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),c&&(_uvA$1.fromBufferAttribute(c,h),_uvB$1.fromBufferAttribute(c,g),_uvC$1.fromBufferAttribute(c,_),b.uv1=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),d&&(_normalA.fromBufferAttribute(d,h),_normalB.fromBufferAttribute(d,g),_normalC.fromBufferAttribute(d,_),b.normal=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_normalA,_normalB,_normalC,new Vector3),b.normal.dot(s.direction)>0&&b.normal.multiplyScalar(-1));const $={a:h,b:g,c:_,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,$.normal),b.face=$}return b}class BoxGeometry extends BufferGeometry{constructor(e=1,i=1,s=1,o=1,c=1,d=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:i,depth:s,widthSegments:o,heightSegments:c,depthSegments:d};const h=this;o=Math.floor(o),c=Math.floor(c),d=Math.floor(d);const g=[],_=[],b=[],$=[];let j=0,_e=0;tt("z","y","x",-1,-1,s,i,e,d,c,0),tt("z","y","x",1,-1,s,i,-e,d,c,1),tt("x","z","y",1,1,e,s,i,o,d,2),tt("x","z","y",1,-1,e,s,-i,o,d,3),tt("x","y","z",1,-1,e,i,s,o,c,4),tt("x","y","z",-1,-1,e,i,-s,o,c,5),this.setIndex(g),this.setAttribute("position",new Float32BufferAttribute(_,3)),this.setAttribute("normal",new Float32BufferAttribute(b,3)),this.setAttribute("uv",new Float32BufferAttribute($,2));function tt(et,nt,rt,it,at,st,ot,ct,lt,dt,xt){const ut=st/lt,ft=ot/dt,mt=st/2,yt=ot/2,St=ct/2,Et=lt+1,vt=dt+1;let Nt=0,wt=0;const $t=new Vector3;for(let Ct=0;Ct<vt;Ct++){const Mt=Ct*ft-yt;for(let Ot=0;Ot<Et;Ot++){const Dt=Ot*ut-mt;$t[et]=Dt*it,$t[nt]=Mt*at,$t[rt]=St,_.push($t.x,$t.y,$t.z),$t[et]=0,$t[nt]=0,$t[rt]=ct>0?1:-1,b.push($t.x,$t.y,$t.z),$.push(Ot/lt),$.push(1-Ct/dt),Nt+=1}}for(let Ct=0;Ct<dt;Ct++)for(let Mt=0;Mt<lt;Mt++){const Ot=j+Mt+Et*Ct,Dt=j+Mt+Et*(Ct+1),At=j+(Mt+1)+Et*(Ct+1),kt=j+(Mt+1)+Et*Ct;g.push(Ot,Dt,kt),g.push(Dt,At,kt),wt+=6}h.addGroup(_e,wt,xt),_e+=wt,j+=Nt}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new BoxGeometry(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function cloneUniforms(a){const e={};for(const i in a){e[i]={};for(const s in a[i]){const o=a[i][s];o&&(o.isColor||o.isMatrix3||o.isMatrix4||o.isVector2||o.isVector3||o.isVector4||o.isTexture||o.isQuaternion)?o.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[i][s]=null):e[i][s]=o.clone():Array.isArray(o)?e[i][s]=o.slice():e[i][s]=o}}return e}function mergeUniforms(a){const e={};for(let i=0;i<a.length;i++){const s=cloneUniforms(a[i]);for(const o in s)e[o]=s[o]}return e}function cloneUniformsGroups(a){const e=[];for(let i=0;i<a.length;i++)e.push(a[i].clone());return e}function getUnlitUniformColorSpace(a){const e=a.getRenderTarget();return e===null?a.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=cloneUniforms(e.uniforms),this.uniformsGroups=cloneUniformsGroups(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const i=super.toJSON(e);i.glslVersion=this.glslVersion,i.uniforms={};for(const o in this.uniforms){const d=this.uniforms[o].value;d&&d.isTexture?i.uniforms[o]={type:"t",value:d.toJSON(e).uuid}:d&&d.isColor?i.uniforms[o]={type:"c",value:d.getHex()}:d&&d.isVector2?i.uniforms[o]={type:"v2",value:d.toArray()}:d&&d.isVector3?i.uniforms[o]={type:"v3",value:d.toArray()}:d&&d.isVector4?i.uniforms[o]={type:"v4",value:d.toArray()}:d&&d.isMatrix3?i.uniforms[o]={type:"m3",value:d.toArray()}:d&&d.isMatrix4?i.uniforms[o]={type:"m4",value:d.toArray()}:i.uniforms[o]={value:d}}Object.keys(this.defines).length>0&&(i.defines=this.defines),i.vertexShader=this.vertexShader,i.fragmentShader=this.fragmentShader,i.lights=this.lights,i.clipping=this.clipping;const s={};for(const o in this.extensions)this.extensions[o]===!0&&(s[o]=!0);return Object.keys(s).length>0&&(i.extensions=s),i}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem}copy(e,i){return super.copy(e,i),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,i){super.updateWorldMatrix(e,i),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const _v3$1=new Vector3,_minTarget=new Vector2,_maxTarget=new Vector2;class PerspectiveCamera extends Camera{constructor(e=50,i=1,s=.1,o=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=o,this.focus=10,this.aspect=i,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,i){return super.copy(e,i),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const i=.5*this.getFilmHeight()/e;this.fov=RAD2DEG*2*Math.atan(i),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,i,s){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),i.set(_v3$1.x,_v3$1.y).multiplyScalar(-e/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),s.set(_v3$1.x,_v3$1.y).multiplyScalar(-e/_v3$1.z)}getViewSize(e,i){return this.getViewBounds(e,_minTarget,_maxTarget),i.subVectors(_maxTarget,_minTarget)}setViewOffset(e,i,s,o,c,d){this.aspect=e/i,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=i,this.view.offsetX=s,this.view.offsetY=o,this.view.width=c,this.view.height=d,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let i=e*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,s=2*i,o=this.aspect*s,c=-.5*o;const d=this.view;if(this.view!==null&&this.view.enabled){const g=d.fullWidth,_=d.fullHeight;c+=d.offsetX*o/g,i-=d.offsetY*s/_,o*=d.width/g,s*=d.height/_}const h=this.filmOffset;h!==0&&(c+=e*h/this.getFilmWidth()),this.projectionMatrix.makePerspective(c,c+o,i,i-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const i=super.toJSON(e);return i.object.fov=this.fov,i.object.zoom=this.zoom,i.object.near=this.near,i.object.far=this.far,i.object.focus=this.focus,i.object.aspect=this.aspect,this.view!==null&&(i.object.view=Object.assign({},this.view)),i.object.filmGauge=this.filmGauge,i.object.filmOffset=this.filmOffset,i}}const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(e,i,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const o=new PerspectiveCamera(fov,aspect,e,i);o.layers=this.layers,this.add(o);const c=new PerspectiveCamera(fov,aspect,e,i);c.layers=this.layers,this.add(c);const d=new PerspectiveCamera(fov,aspect,e,i);d.layers=this.layers,this.add(d);const h=new PerspectiveCamera(fov,aspect,e,i);h.layers=this.layers,this.add(h);const g=new PerspectiveCamera(fov,aspect,e,i);g.layers=this.layers,this.add(g);const _=new PerspectiveCamera(fov,aspect,e,i);_.layers=this.layers,this.add(_)}updateCoordinateSystem(){const e=this.coordinateSystem,i=this.children.concat(),[s,o,c,d,h,g]=i;for(const _ of i)this.remove(_);if(e===WebGLCoordinateSystem)s.up.set(0,1,0),s.lookAt(1,0,0),o.up.set(0,1,0),o.lookAt(-1,0,0),c.up.set(0,0,-1),c.lookAt(0,1,0),d.up.set(0,0,1),d.lookAt(0,-1,0),h.up.set(0,1,0),h.lookAt(0,0,1),g.up.set(0,1,0),g.lookAt(0,0,-1);else if(e===WebGPUCoordinateSystem)s.up.set(0,-1,0),s.lookAt(-1,0,0),o.up.set(0,-1,0),o.lookAt(1,0,0),c.up.set(0,0,1),c.lookAt(0,1,0),d.up.set(0,0,-1),d.lookAt(0,-1,0),h.up.set(0,-1,0),h.lookAt(0,0,1),g.up.set(0,-1,0),g.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const _ of i)this.add(_),_.updateMatrixWorld()}update(e,i){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:o}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[c,d,h,g,_,b]=this.children,$=e.getRenderTarget(),j=e.getActiveCubeFace(),_e=e.getActiveMipmapLevel(),tt=e.xr.enabled;e.xr.enabled=!1;const et=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,o),e.render(i,c),e.setRenderTarget(s,1,o),e.render(i,d),e.setRenderTarget(s,2,o),e.render(i,h),e.setRenderTarget(s,3,o),e.render(i,g),e.setRenderTarget(s,4,o),e.render(i,_),s.texture.generateMipmaps=et,e.setRenderTarget(s,5,o),e.render(i,b),e.setRenderTarget($,j,_e),e.xr.enabled=tt,s.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(e,i,s,o,c,d,h,g,_,b){e=e!==void 0?e:[],i=i!==void 0?i:CubeReflectionMapping,super(e,i,s,o,c,d,h,g,_,b),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(e=1,i={}){super(e,e,i),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},o=[s,s,s,s,s,s];this.texture=new CubeTexture(o,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:LinearFilter}fromEquirectangularTexture(e,i){this.texture.type=i.type,this.texture.colorSpace=i.colorSpace,this.texture.generateMipmaps=i.generateMipmaps,this.texture.minFilter=i.minFilter,this.texture.magFilter=i.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},o=new BoxGeometry(5,5,5),c=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:BackSide,blending:NoBlending});c.uniforms.tEquirect.value=i;const d=new Mesh(o,c),h=i.minFilter;return i.minFilter===LinearMipmapLinearFilter&&(i.minFilter=LinearFilter),new CubeCamera(1,10,this).update(e,d),i.minFilter=h,d.geometry.dispose(),d.material.dispose(),this}clear(e,i,s,o){const c=e.getRenderTarget();for(let d=0;d<6;d++)e.setRenderTarget(this,d),e.clear(i,s,o);e.setRenderTarget(c)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(e=new Vector3(1,0,0),i=0){this.isPlane=!0,this.normal=e,this.constant=i}set(e,i){return this.normal.copy(e),this.constant=i,this}setComponents(e,i,s,o){return this.normal.set(e,i,s),this.constant=o,this}setFromNormalAndCoplanarPoint(e,i){return this.normal.copy(e),this.constant=-i.dot(this.normal),this}setFromCoplanarPoints(e,i,s){const o=_vector1.subVectors(s,i).cross(_vector2.subVectors(e,i)).normalize();return this.setFromNormalAndCoplanarPoint(o,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,i){return i.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,i){const s=e.delta(_vector1),o=this.normal.dot(s);if(o===0)return this.distanceToPoint(e.start)===0?i.copy(e.start):null;const c=-(e.start.dot(this.normal)+this.constant)/o;return c<0||c>1?null:i.copy(e.start).addScaledVector(s,c)}intersectsLine(e){const i=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return i<0&&s>0||s<0&&i>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,i){const s=i||_normalMatrix.getNormalMatrix(e),o=this.coplanarPoint(_vector1).applyMatrix4(e),c=this.normal.applyMatrix3(s).normalize();return this.constant=-o.dot(c),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$5=new Sphere,_vector$7=new Vector3;class Frustum{constructor(e=new Plane,i=new Plane,s=new Plane,o=new Plane,c=new Plane,d=new Plane){this.planes=[e,i,s,o,c,d]}set(e,i,s,o,c,d){const h=this.planes;return h[0].copy(e),h[1].copy(i),h[2].copy(s),h[3].copy(o),h[4].copy(c),h[5].copy(d),this}copy(e){const i=this.planes;for(let s=0;s<6;s++)i[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,i=WebGLCoordinateSystem){const s=this.planes,o=e.elements,c=o[0],d=o[1],h=o[2],g=o[3],_=o[4],b=o[5],$=o[6],j=o[7],_e=o[8],tt=o[9],et=o[10],nt=o[11],rt=o[12],it=o[13],at=o[14],st=o[15];if(s[0].setComponents(g-c,j-_,nt-_e,st-rt).normalize(),s[1].setComponents(g+c,j+_,nt+_e,st+rt).normalize(),s[2].setComponents(g+d,j+b,nt+tt,st+it).normalize(),s[3].setComponents(g-d,j-b,nt-tt,st-it).normalize(),s[4].setComponents(g-h,j-$,nt-et,st-at).normalize(),i===WebGLCoordinateSystem)s[5].setComponents(g+h,j+$,nt+et,st+at).normalize();else if(i===WebGPUCoordinateSystem)s[5].setComponents(h,$,et,at).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+i);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),_sphere$5.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const i=e.geometry;i.boundingSphere===null&&i.computeBoundingSphere(),_sphere$5.copy(i.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(_sphere$5)}intersectsSprite(e){return _sphere$5.center.set(0,0,0),_sphere$5.radius=.7071067811865476,_sphere$5.applyMatrix4(e.matrixWorld),this.intersectsSphere(_sphere$5)}intersectsSphere(e){const i=this.planes,s=e.center,o=-e.radius;for(let c=0;c<6;c++)if(i[c].distanceToPoint(s)<o)return!1;return!0}intersectsBox(e){const i=this.planes;for(let s=0;s<6;s++){const o=i[s];if(_vector$7.x=o.normal.x>0?e.max.x:e.min.x,_vector$7.y=o.normal.y>0?e.max.y:e.min.y,_vector$7.z=o.normal.z>0?e.max.z:e.min.z,o.distanceToPoint(_vector$7)<0)return!1}return!0}containsPoint(e){const i=this.planes;for(let s=0;s<6;s++)if(i[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function WebGLAnimation(){let a=null,e=!1,i=null,s=null;function o(c,d){i(c,d),s=a.requestAnimationFrame(o)}return{start:function(){e!==!0&&i!==null&&(s=a.requestAnimationFrame(o),e=!0)},stop:function(){a.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(c){i=c},setContext:function(c){a=c}}}function WebGLAttributes(a){const e=new WeakMap;function i(h,g){const _=h.array,b=h.usage,$=_.byteLength,j=a.createBuffer();a.bindBuffer(g,j),a.bufferData(g,_,b),h.onUploadCallback();let _e;if(_ instanceof Float32Array)_e=a.FLOAT;else if(_ instanceof Uint16Array)h.isFloat16BufferAttribute?_e=a.HALF_FLOAT:_e=a.UNSIGNED_SHORT;else if(_ instanceof Int16Array)_e=a.SHORT;else if(_ instanceof Uint32Array)_e=a.UNSIGNED_INT;else if(_ instanceof Int32Array)_e=a.INT;else if(_ instanceof Int8Array)_e=a.BYTE;else if(_ instanceof Uint8Array)_e=a.UNSIGNED_BYTE;else if(_ instanceof Uint8ClampedArray)_e=a.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+_);return{buffer:j,type:_e,bytesPerElement:_.BYTES_PER_ELEMENT,version:h.version,size:$}}function s(h,g,_){const b=g.array,$=g._updateRange,j=g.updateRanges;if(a.bindBuffer(_,h),$.count===-1&&j.length===0&&a.bufferSubData(_,0,b),j.length!==0){for(let _e=0,tt=j.length;_e<tt;_e++){const et=j[_e];a.bufferSubData(_,et.start*b.BYTES_PER_ELEMENT,b,et.start,et.count)}g.clearUpdateRanges()}$.count!==-1&&(a.bufferSubData(_,$.offset*b.BYTES_PER_ELEMENT,b,$.offset,$.count),$.count=-1),g.onUploadCallback()}function o(h){return h.isInterleavedBufferAttribute&&(h=h.data),e.get(h)}function c(h){h.isInterleavedBufferAttribute&&(h=h.data);const g=e.get(h);g&&(a.deleteBuffer(g.buffer),e.delete(h))}function d(h,g){if(h.isGLBufferAttribute){const b=e.get(h);(!b||b.version<h.version)&&e.set(h,{buffer:h.buffer,type:h.type,bytesPerElement:h.elementSize,version:h.version});return}h.isInterleavedBufferAttribute&&(h=h.data);const _=e.get(h);if(_===void 0)e.set(h,i(h,g));else if(_.version<h.version){if(_.size!==h.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");s(_.buffer,h,g),_.version=h.version}}return{get:o,remove:c,update:d}}class PlaneGeometry extends BufferGeometry{constructor(e=1,i=1,s=1,o=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:i,widthSegments:s,heightSegments:o};const c=e/2,d=i/2,h=Math.floor(s),g=Math.floor(o),_=h+1,b=g+1,$=e/h,j=i/g,_e=[],tt=[],et=[],nt=[];for(let rt=0;rt<b;rt++){const it=rt*j-d;for(let at=0;at<_;at++){const st=at*$-c;tt.push(st,-it,0),et.push(0,0,1),nt.push(at/h),nt.push(1-rt/g)}}for(let rt=0;rt<g;rt++)for(let it=0;it<h;it++){const at=it+_*rt,st=it+_*(rt+1),ot=it+1+_*(rt+1),ct=it+1+_*rt;_e.push(at,st,ct),_e.push(st,ot,ct)}this.setIndex(_e),this.setAttribute("position",new Float32BufferAttribute(tt,3)),this.setAttribute("normal",new Float32BufferAttribute(et,3)),this.setAttribute("uv",new Float32BufferAttribute(nt,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new PlaneGeometry(e.width,e.height,e.widthSegments,e.heightSegments)}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,batching_pars_vertex=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,batching_vertex=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( batchId );
	vColor.xyz *= batchingColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphinstance_vertex=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,batching_pars_vertex,batching_vertex,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphinstance_vertex,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},envMapRotation:{value:new Matrix3},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new Matrix3}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0},_e1$1=new Euler,_m1$1=new Matrix4;function WebGLBackground(a,e,i,s,o,c,d){const h=new Color(0);let g=c===!0?0:1,_,b,$=null,j=0,_e=null;function tt(it){let at=it.isScene===!0?it.background:null;return at&&at.isTexture&&(at=(it.backgroundBlurriness>0?i:e).get(at)),at}function et(it){let at=!1;const st=tt(it);st===null?rt(h,g):st&&st.isColor&&(rt(st,1),at=!0);const ot=a.xr.getEnvironmentBlendMode();ot==="additive"?s.buffers.color.setClear(0,0,0,1,d):ot==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,d),(a.autoClear||at)&&(s.buffers.depth.setTest(!0),s.buffers.depth.setMask(!0),s.buffers.color.setMask(!0),a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil))}function nt(it,at){const st=tt(at);st&&(st.isCubeTexture||st.mapping===CubeUVReflectionMapping)?(b===void 0&&(b=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1})),b.geometry.deleteAttribute("normal"),b.geometry.deleteAttribute("uv"),b.onBeforeRender=function(ot,ct,lt){this.matrixWorld.copyPosition(lt.matrixWorld)},Object.defineProperty(b.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),o.update(b)),_e1$1.copy(at.backgroundRotation),_e1$1.x*=-1,_e1$1.y*=-1,_e1$1.z*=-1,st.isCubeTexture&&st.isRenderTargetTexture===!1&&(_e1$1.y*=-1,_e1$1.z*=-1),b.material.uniforms.envMap.value=st,b.material.uniforms.flipEnvMap.value=st.isCubeTexture&&st.isRenderTargetTexture===!1?-1:1,b.material.uniforms.backgroundBlurriness.value=at.backgroundBlurriness,b.material.uniforms.backgroundIntensity.value=at.backgroundIntensity,b.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1)),b.material.toneMapped=ColorManagement.getTransfer(st.colorSpace)!==SRGBTransfer,($!==st||j!==st.version||_e!==a.toneMapping)&&(b.material.needsUpdate=!0,$=st,j=st.version,_e=a.toneMapping),b.layers.enableAll(),it.unshift(b,b.geometry,b.material,0,0,null)):st&&st.isTexture&&(_===void 0&&(_=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1})),_.geometry.deleteAttribute("normal"),Object.defineProperty(_.material,"map",{get:function(){return this.uniforms.t2D.value}}),o.update(_)),_.material.uniforms.t2D.value=st,_.material.uniforms.backgroundIntensity.value=at.backgroundIntensity,_.material.toneMapped=ColorManagement.getTransfer(st.colorSpace)!==SRGBTransfer,st.matrixAutoUpdate===!0&&st.updateMatrix(),_.material.uniforms.uvTransform.value.copy(st.matrix),($!==st||j!==st.version||_e!==a.toneMapping)&&(_.material.needsUpdate=!0,$=st,j=st.version,_e=a.toneMapping),_.layers.enableAll(),it.unshift(_,_.geometry,_.material,0,0,null))}function rt(it,at){it.getRGB(_rgb,getUnlitUniformColorSpace(a)),s.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,at,d)}return{getClearColor:function(){return h},setClearColor:function(it,at=1){h.set(it),g=at,rt(h,g)},getClearAlpha:function(){return g},setClearAlpha:function(it){g=it,rt(h,g)},render:et,addToRenderList:nt}}function WebGLBindingStates(a,e){const i=a.getParameter(a.MAX_VERTEX_ATTRIBS),s={},o=j(null);let c=o,d=!1;function h(ut,ft,mt,yt,St){let Et=!1;const vt=$(yt,mt,ft);c!==vt&&(c=vt,_(c.object)),Et=_e(ut,yt,mt,St),Et&&tt(ut,yt,mt,St),St!==null&&e.update(St,a.ELEMENT_ARRAY_BUFFER),(Et||d)&&(d=!1,st(ut,ft,mt,yt),St!==null&&a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,e.get(St).buffer))}function g(){return a.createVertexArray()}function _(ut){return a.bindVertexArray(ut)}function b(ut){return a.deleteVertexArray(ut)}function $(ut,ft,mt){const yt=mt.wireframe===!0;let St=s[ut.id];St===void 0&&(St={},s[ut.id]=St);let Et=St[ft.id];Et===void 0&&(Et={},St[ft.id]=Et);let vt=Et[yt];return vt===void 0&&(vt=j(g()),Et[yt]=vt),vt}function j(ut){const ft=[],mt=[],yt=[];for(let St=0;St<i;St++)ft[St]=0,mt[St]=0,yt[St]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:ft,enabledAttributes:mt,attributeDivisors:yt,object:ut,attributes:{},index:null}}function _e(ut,ft,mt,yt){const St=c.attributes,Et=ft.attributes;let vt=0;const Nt=mt.getAttributes();for(const wt in Nt)if(Nt[wt].location>=0){const Ct=St[wt];let Mt=Et[wt];if(Mt===void 0&&(wt==="instanceMatrix"&&ut.instanceMatrix&&(Mt=ut.instanceMatrix),wt==="instanceColor"&&ut.instanceColor&&(Mt=ut.instanceColor)),Ct===void 0||Ct.attribute!==Mt||Mt&&Ct.data!==Mt.data)return!0;vt++}return c.attributesNum!==vt||c.index!==yt}function tt(ut,ft,mt,yt){const St={},Et=ft.attributes;let vt=0;const Nt=mt.getAttributes();for(const wt in Nt)if(Nt[wt].location>=0){let Ct=Et[wt];Ct===void 0&&(wt==="instanceMatrix"&&ut.instanceMatrix&&(Ct=ut.instanceMatrix),wt==="instanceColor"&&ut.instanceColor&&(Ct=ut.instanceColor));const Mt={};Mt.attribute=Ct,Ct&&Ct.data&&(Mt.data=Ct.data),St[wt]=Mt,vt++}c.attributes=St,c.attributesNum=vt,c.index=yt}function et(){const ut=c.newAttributes;for(let ft=0,mt=ut.length;ft<mt;ft++)ut[ft]=0}function nt(ut){rt(ut,0)}function rt(ut,ft){const mt=c.newAttributes,yt=c.enabledAttributes,St=c.attributeDivisors;mt[ut]=1,yt[ut]===0&&(a.enableVertexAttribArray(ut),yt[ut]=1),St[ut]!==ft&&(a.vertexAttribDivisor(ut,ft),St[ut]=ft)}function it(){const ut=c.newAttributes,ft=c.enabledAttributes;for(let mt=0,yt=ft.length;mt<yt;mt++)ft[mt]!==ut[mt]&&(a.disableVertexAttribArray(mt),ft[mt]=0)}function at(ut,ft,mt,yt,St,Et,vt){vt===!0?a.vertexAttribIPointer(ut,ft,mt,St,Et):a.vertexAttribPointer(ut,ft,mt,yt,St,Et)}function st(ut,ft,mt,yt){et();const St=yt.attributes,Et=mt.getAttributes(),vt=ft.defaultAttributeValues;for(const Nt in Et){const wt=Et[Nt];if(wt.location>=0){let $t=St[Nt];if($t===void 0&&(Nt==="instanceMatrix"&&ut.instanceMatrix&&($t=ut.instanceMatrix),Nt==="instanceColor"&&ut.instanceColor&&($t=ut.instanceColor)),$t!==void 0){const Ct=$t.normalized,Mt=$t.itemSize,Ot=e.get($t);if(Ot===void 0)continue;const Dt=Ot.buffer,At=Ot.type,kt=Ot.bytesPerElement,Ft=At===a.INT||At===a.UNSIGNED_INT||$t.gpuType===IntType;if($t.isInterleavedBufferAttribute){const Bt=$t.data,Ht=Bt.stride,Wt=$t.offset;if(Bt.isInstancedInterleavedBuffer){for(let Ut=0;Ut<wt.locationSize;Ut++)rt(wt.location+Ut,Bt.meshPerAttribute);ut.isInstancedMesh!==!0&&yt._maxInstanceCount===void 0&&(yt._maxInstanceCount=Bt.meshPerAttribute*Bt.count)}else for(let Ut=0;Ut<wt.locationSize;Ut++)nt(wt.location+Ut);a.bindBuffer(a.ARRAY_BUFFER,Dt);for(let Ut=0;Ut<wt.locationSize;Ut++)at(wt.location+Ut,Mt/wt.locationSize,At,Ct,Ht*kt,(Wt+Mt/wt.locationSize*Ut)*kt,Ft)}else{if($t.isInstancedBufferAttribute){for(let Bt=0;Bt<wt.locationSize;Bt++)rt(wt.location+Bt,$t.meshPerAttribute);ut.isInstancedMesh!==!0&&yt._maxInstanceCount===void 0&&(yt._maxInstanceCount=$t.meshPerAttribute*$t.count)}else for(let Bt=0;Bt<wt.locationSize;Bt++)nt(wt.location+Bt);a.bindBuffer(a.ARRAY_BUFFER,Dt);for(let Bt=0;Bt<wt.locationSize;Bt++)at(wt.location+Bt,Mt/wt.locationSize,At,Ct,Mt*kt,Mt/wt.locationSize*Bt*kt,Ft)}}else if(vt!==void 0){const Ct=vt[Nt];if(Ct!==void 0)switch(Ct.length){case 2:a.vertexAttrib2fv(wt.location,Ct);break;case 3:a.vertexAttrib3fv(wt.location,Ct);break;case 4:a.vertexAttrib4fv(wt.location,Ct);break;default:a.vertexAttrib1fv(wt.location,Ct)}}}}it()}function ot(){dt();for(const ut in s){const ft=s[ut];for(const mt in ft){const yt=ft[mt];for(const St in yt)b(yt[St].object),delete yt[St];delete ft[mt]}delete s[ut]}}function ct(ut){if(s[ut.id]===void 0)return;const ft=s[ut.id];for(const mt in ft){const yt=ft[mt];for(const St in yt)b(yt[St].object),delete yt[St];delete ft[mt]}delete s[ut.id]}function lt(ut){for(const ft in s){const mt=s[ft];if(mt[ut.id]===void 0)continue;const yt=mt[ut.id];for(const St in yt)b(yt[St].object),delete yt[St];delete mt[ut.id]}}function dt(){xt(),d=!0,c!==o&&(c=o,_(c.object))}function xt(){o.geometry=null,o.program=null,o.wireframe=!1}return{setup:h,reset:dt,resetDefaultState:xt,dispose:ot,releaseStatesOfGeometry:ct,releaseStatesOfProgram:lt,initAttributes:et,enableAttribute:nt,disableUnusedAttributes:it}}function WebGLBufferRenderer(a,e,i){let s;function o(_){s=_}function c(_,b){a.drawArrays(s,_,b),i.update(b,s,1)}function d(_,b,$){$!==0&&(a.drawArraysInstanced(s,_,b,$),i.update(b,s,$))}function h(_,b,$){if($===0)return;const j=e.get("WEBGL_multi_draw");if(j===null)for(let _e=0;_e<$;_e++)this.render(_[_e],b[_e]);else{j.multiDrawArraysWEBGL(s,_,0,b,0,$);let _e=0;for(let tt=0;tt<$;tt++)_e+=b[tt];i.update(_e,s,1)}}function g(_,b,$,j){if($===0)return;const _e=e.get("WEBGL_multi_draw");if(_e===null)for(let tt=0;tt<_.length;tt++)d(_[tt],b[tt],j[tt]);else{_e.multiDrawArraysInstancedWEBGL(s,_,0,b,0,j,0,$);let tt=0;for(let et=0;et<$;et++)tt+=b[et];for(let et=0;et<j.length;et++)i.update(tt,s,j[et])}}this.setMode=o,this.render=c,this.renderInstances=d,this.renderMultiDraw=h,this.renderMultiDrawInstances=g}function WebGLCapabilities(a,e,i,s){let o;function c(){if(o!==void 0)return o;if(e.has("EXT_texture_filter_anisotropic")===!0){const ct=e.get("EXT_texture_filter_anisotropic");o=a.getParameter(ct.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else o=0;return o}function d(ct){return!(ct!==RGBAFormat&&s.convert(ct)!==a.getParameter(a.IMPLEMENTATION_COLOR_READ_FORMAT))}function h(ct){const lt=ct===HalfFloatType&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(ct!==UnsignedByteType&&s.convert(ct)!==a.getParameter(a.IMPLEMENTATION_COLOR_READ_TYPE)&&ct!==FloatType&&!lt)}function g(ct){if(ct==="highp"){if(a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.HIGH_FLOAT).precision>0&&a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.HIGH_FLOAT).precision>0)return"highp";ct="mediump"}return ct==="mediump"&&a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.MEDIUM_FLOAT).precision>0&&a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let _=i.precision!==void 0?i.precision:"highp";const b=g(_);b!==_&&(console.warn("THREE.WebGLRenderer:",_,"not supported, using",b,"instead."),_=b);const $=i.logarithmicDepthBuffer===!0,j=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),_e=a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),tt=a.getParameter(a.MAX_TEXTURE_SIZE),et=a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),nt=a.getParameter(a.MAX_VERTEX_ATTRIBS),rt=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),it=a.getParameter(a.MAX_VARYING_VECTORS),at=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),st=_e>0,ot=a.getParameter(a.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:c,getMaxPrecision:g,textureFormatReadable:d,textureTypeReadable:h,precision:_,logarithmicDepthBuffer:$,maxTextures:j,maxVertexTextures:_e,maxTextureSize:tt,maxCubemapSize:et,maxAttributes:nt,maxVertexUniforms:rt,maxVaryings:it,maxFragmentUniforms:at,vertexTextures:st,maxSamples:ot}}function WebGLClipping(a){const e=this;let i=null,s=0,o=!1,c=!1;const d=new Plane,h=new Matrix3,g={value:null,needsUpdate:!1};this.uniform=g,this.numPlanes=0,this.numIntersection=0,this.init=function($,j){const _e=$.length!==0||j||s!==0||o;return o=j,s=$.length,_e},this.beginShadows=function(){c=!0,b(null)},this.endShadows=function(){c=!1},this.setGlobalState=function($,j){i=b($,j,0)},this.setState=function($,j,_e){const tt=$.clippingPlanes,et=$.clipIntersection,nt=$.clipShadows,rt=a.get($);if(!o||tt===null||tt.length===0||c&&!nt)c?b(null):_();else{const it=c?0:s,at=it*4;let st=rt.clippingState||null;g.value=st,st=b(tt,j,at,_e);for(let ot=0;ot!==at;++ot)st[ot]=i[ot];rt.clippingState=st,this.numIntersection=et?this.numPlanes:0,this.numPlanes+=it}};function _(){g.value!==i&&(g.value=i,g.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function b($,j,_e,tt){const et=$!==null?$.length:0;let nt=null;if(et!==0){if(nt=g.value,tt!==!0||nt===null){const rt=_e+et*4,it=j.matrixWorldInverse;h.getNormalMatrix(it),(nt===null||nt.length<rt)&&(nt=new Float32Array(rt));for(let at=0,st=_e;at!==et;++at,st+=4)d.copy($[at]).applyMatrix4(it,h),d.normal.toArray(nt,st),nt[st+3]=d.constant}g.value=nt,g.needsUpdate=!0}return e.numPlanes=et,e.numIntersection=0,nt}}function WebGLCubeMaps(a){let e=new WeakMap;function i(d,h){return h===EquirectangularReflectionMapping?d.mapping=CubeReflectionMapping:h===EquirectangularRefractionMapping&&(d.mapping=CubeRefractionMapping),d}function s(d){if(d&&d.isTexture){const h=d.mapping;if(h===EquirectangularReflectionMapping||h===EquirectangularRefractionMapping)if(e.has(d)){const g=e.get(d).texture;return i(g,d.mapping)}else{const g=d.image;if(g&&g.height>0){const _=new WebGLCubeRenderTarget(g.height);return _.fromEquirectangularTexture(a,d),e.set(d,_),d.addEventListener("dispose",o),i(_.texture,d.mapping)}else return null}}return d}function o(d){const h=d.target;h.removeEventListener("dispose",o);const g=e.get(h);g!==void 0&&(e.delete(h),g.dispose())}function c(){e=new WeakMap}return{get:s,dispose:c}}class OrthographicCamera extends Camera{constructor(e=-1,i=1,s=1,o=-1,c=.1,d=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=i,this.top=s,this.bottom=o,this.near=c,this.far=d,this.updateProjectionMatrix()}copy(e,i){return super.copy(e,i),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,i,s,o,c,d){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=i,this.view.offsetX=s,this.view.offsetY=o,this.view.width=c,this.view.height=d,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),i=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,o=(this.top+this.bottom)/2;let c=s-e,d=s+e,h=o+i,g=o-i;if(this.view!==null&&this.view.enabled){const _=(this.right-this.left)/this.view.fullWidth/this.zoom,b=(this.top-this.bottom)/this.view.fullHeight/this.zoom;c+=_*this.view.offsetX,d=c+_*this.view.width,h-=b*this.view.offsetY,g=h-b*this.view.height}this.projectionMatrix.makeOrthographic(c,d,h,g,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const i=super.toJSON(e);return i.object.zoom=this.zoom,i.object.left=this.left,i.object.right=this.right,i.object.top=this.top,i.object.bottom=this.bottom,i.object.near=this.near,i.object.far=this.far,this.view!==null&&(i.object.view=Object.assign({},this.view)),i}}const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera,_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0,_oldXrEnabled=!1;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(-PHI,INV_PHI,0),new Vector3(PHI,INV_PHI,0),new Vector3(-INV_PHI,0,PHI),new Vector3(INV_PHI,0,PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(0,PHI,INV_PHI),new Vector3(-1,1,-1),new Vector3(1,1,-1),new Vector3(-1,1,1),new Vector3(1,1,1)];class PMREMGenerator{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,i=0,s=.1,o=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const c=this._allocateTargets();return c.depthBuffer=!0,this._sceneToCubeUV(e,s,o,c),i>0&&this._blur(c,0,0,i),this._applyPMREM(c),this._cleanup(c),c}fromEquirectangular(e,i=null){return this._fromTexture(e,i)}fromCubemap(e,i=null){return this._fromTexture(e,i)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),this._renderer.xr.enabled=_oldXrEnabled,e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)}_fromTexture(e,i){e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),_oldXrEnabled=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const s=i||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),i=4*this._cubeSize,s={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!1},o=_createRenderTarget(e,i,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==i){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(e,i,s);const{_lodMax:c}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes(c)),this._blurMaterial=_getBlurShader(c,e,i)}return o}_compileMaterial(e){const i=new Mesh(this._lodPlanes[0],e);this._renderer.compile(i,_flatCamera)}_sceneToCubeUV(e,i,s,o){const h=new PerspectiveCamera(90,1,i,s),g=[1,-1,1,1,1,1],_=[1,1,1,-1,-1,-1],b=this._renderer,$=b.autoClear,j=b.toneMapping;b.getClearColor(_clearColor),b.toneMapping=NoToneMapping,b.autoClear=!1;const _e=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1}),tt=new Mesh(new BoxGeometry,_e);let et=!1;const nt=e.background;nt?nt.isColor&&(_e.color.copy(nt),e.background=null,et=!0):(_e.color.copy(_clearColor),et=!0);for(let rt=0;rt<6;rt++){const it=rt%3;it===0?(h.up.set(0,g[rt],0),h.lookAt(_[rt],0,0)):it===1?(h.up.set(0,0,g[rt]),h.lookAt(0,_[rt],0)):(h.up.set(0,g[rt],0),h.lookAt(0,0,_[rt]));const at=this._cubeSize;_setViewport(o,it*at,rt>2?at:0,at,at),b.setRenderTarget(o),et&&b.render(tt,h),b.render(e,h)}tt.geometry.dispose(),tt.material.dispose(),b.toneMapping=j,b.autoClear=$,e.background=nt}_textureToCubeUV(e,i){const s=this._renderer,o=e.mapping===CubeReflectionMapping||e.mapping===CubeRefractionMapping;o?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const c=o?this._cubemapMaterial:this._equirectMaterial,d=new Mesh(this._lodPlanes[0],c),h=c.uniforms;h.envMap.value=e;const g=this._cubeSize;_setViewport(i,0,0,3*g,2*g),s.setRenderTarget(i),s.render(d,_flatCamera)}_applyPMREM(e){const i=this._renderer,s=i.autoClear;i.autoClear=!1;const o=this._lodPlanes.length;for(let c=1;c<o;c++){const d=Math.sqrt(this._sigmas[c]*this._sigmas[c]-this._sigmas[c-1]*this._sigmas[c-1]),h=_axisDirections[(o-c-1)%_axisDirections.length];this._blur(e,c-1,c,d,h)}i.autoClear=s}_blur(e,i,s,o,c){const d=this._pingPongRenderTarget;this._halfBlur(e,d,i,s,o,"latitudinal",c),this._halfBlur(d,e,s,s,o,"longitudinal",c)}_halfBlur(e,i,s,o,c,d,h){const g=this._renderer,_=this._blurMaterial;d!=="latitudinal"&&d!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const b=3,$=new Mesh(this._lodPlanes[o],_),j=_.uniforms,_e=this._sizeLods[s]-1,tt=isFinite(c)?Math.PI/(2*_e):2*Math.PI/(2*MAX_SAMPLES-1),et=c/tt,nt=isFinite(c)?1+Math.floor(b*et):MAX_SAMPLES;nt>MAX_SAMPLES&&console.warn(`sigmaRadians, ${c}, is too large and will clip, as it requested ${nt} samples when the maximum is set to ${MAX_SAMPLES}`);const rt=[];let it=0;for(let lt=0;lt<MAX_SAMPLES;++lt){const dt=lt/et,xt=Math.exp(-dt*dt/2);rt.push(xt),lt===0?it+=xt:lt<nt&&(it+=2*xt)}for(let lt=0;lt<rt.length;lt++)rt[lt]=rt[lt]/it;j.envMap.value=e.texture,j.samples.value=nt,j.weights.value=rt,j.latitudinal.value=d==="latitudinal",h&&(j.poleAxis.value=h);const{_lodMax:at}=this;j.dTheta.value=tt,j.mipInt.value=at-s;const st=this._sizeLods[o],ot=3*st*(o>at-LOD_MIN?o-at+LOD_MIN:0),ct=4*(this._cubeSize-st);_setViewport(i,ot,ct,3*st,2*st),g.setRenderTarget(i),g.render($,_flatCamera)}}function _createPlanes(a){const e=[],i=[],s=[];let o=a;const c=a-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let d=0;d<c;d++){const h=Math.pow(2,o);i.push(h);let g=1/h;d>a-LOD_MIN?g=EXTRA_LOD_SIGMA[d-a+LOD_MIN-1]:d===0&&(g=0),s.push(g);const _=1/(h-2),b=-_,$=1+_,j=[b,b,$,b,$,$,b,b,$,$,b,$],_e=6,tt=6,et=3,nt=2,rt=1,it=new Float32Array(et*tt*_e),at=new Float32Array(nt*tt*_e),st=new Float32Array(rt*tt*_e);for(let ct=0;ct<_e;ct++){const lt=ct%3*2/3-1,dt=ct>2?0:-1,xt=[lt,dt,0,lt+2/3,dt,0,lt+2/3,dt+1,0,lt,dt,0,lt+2/3,dt+1,0,lt,dt+1,0];it.set(xt,et*tt*ct),at.set(j,nt*tt*ct);const ut=[ct,ct,ct,ct,ct,ct];st.set(ut,rt*tt*ct)}const ot=new BufferGeometry;ot.setAttribute("position",new BufferAttribute(it,et)),ot.setAttribute("uv",new BufferAttribute(at,nt)),ot.setAttribute("faceIndex",new BufferAttribute(st,rt)),e.push(ot),o>LOD_MIN&&o--}return{lodPlanes:e,sizeLods:i,sigmas:s}}function _createRenderTarget(a,e,i){const s=new WebGLRenderTarget(a,e,i);return s.texture.mapping=CubeUVReflectionMapping,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function _setViewport(a,e,i,s,o){a.viewport.set(e,i,s,o),a.scissor.set(e,i,s,o)}function _getBlurShader(a,e,i){const s=new Float32Array(MAX_SAMPLES),o=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${a}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:o}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(a){let e=new WeakMap,i=null;function s(h){if(h&&h.isTexture){const g=h.mapping,_=g===EquirectangularReflectionMapping||g===EquirectangularRefractionMapping,b=g===CubeReflectionMapping||g===CubeRefractionMapping;if(_||b){let $=e.get(h);const j=$!==void 0?$.texture.pmremVersion:0;if(h.isRenderTargetTexture&&h.pmremVersion!==j)return i===null&&(i=new PMREMGenerator(a)),$=_?i.fromEquirectangular(h,$):i.fromCubemap(h,$),$.texture.pmremVersion=h.pmremVersion,e.set(h,$),$.texture;if($!==void 0)return $.texture;{const _e=h.image;return _&&_e&&_e.height>0||b&&_e&&o(_e)?(i===null&&(i=new PMREMGenerator(a)),$=_?i.fromEquirectangular(h):i.fromCubemap(h),$.texture.pmremVersion=h.pmremVersion,e.set(h,$),h.addEventListener("dispose",c),$.texture):null}}}return h}function o(h){let g=0;const _=6;for(let b=0;b<_;b++)h[b]!==void 0&&g++;return g===_}function c(h){const g=h.target;g.removeEventListener("dispose",c);const _=e.get(g);_!==void 0&&(e.delete(g),_.dispose())}function d(){e=new WeakMap,i!==null&&(i.dispose(),i=null)}return{get:s,dispose:d}}function WebGLExtensions(a){const e={};function i(s){if(e[s]!==void 0)return e[s];let o;switch(s){case"WEBGL_depth_texture":o=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=a.getExtension(s)}return e[s]=o,o}return{has:function(s){return i(s)!==null},init:function(){i("EXT_color_buffer_float"),i("WEBGL_clip_cull_distance"),i("OES_texture_float_linear"),i("EXT_color_buffer_half_float"),i("WEBGL_multisampled_render_to_texture"),i("WEBGL_render_shared_exponent")},get:function(s){const o=i(s);return o===null&&warnOnce("THREE.WebGLRenderer: "+s+" extension not supported."),o}}}function WebGLGeometries(a,e,i,s){const o={},c=new WeakMap;function d($){const j=$.target;j.index!==null&&e.remove(j.index);for(const tt in j.attributes)e.remove(j.attributes[tt]);for(const tt in j.morphAttributes){const et=j.morphAttributes[tt];for(let nt=0,rt=et.length;nt<rt;nt++)e.remove(et[nt])}j.removeEventListener("dispose",d),delete o[j.id];const _e=c.get(j);_e&&(e.remove(_e),c.delete(j)),s.releaseStatesOfGeometry(j),j.isInstancedBufferGeometry===!0&&delete j._maxInstanceCount,i.memory.geometries--}function h($,j){return o[j.id]===!0||(j.addEventListener("dispose",d),o[j.id]=!0,i.memory.geometries++),j}function g($){const j=$.attributes;for(const tt in j)e.update(j[tt],a.ARRAY_BUFFER);const _e=$.morphAttributes;for(const tt in _e){const et=_e[tt];for(let nt=0,rt=et.length;nt<rt;nt++)e.update(et[nt],a.ARRAY_BUFFER)}}function _($){const j=[],_e=$.index,tt=$.attributes.position;let et=0;if(_e!==null){const it=_e.array;et=_e.version;for(let at=0,st=it.length;at<st;at+=3){const ot=it[at+0],ct=it[at+1],lt=it[at+2];j.push(ot,ct,ct,lt,lt,ot)}}else if(tt!==void 0){const it=tt.array;et=tt.version;for(let at=0,st=it.length/3-1;at<st;at+=3){const ot=at+0,ct=at+1,lt=at+2;j.push(ot,ct,ct,lt,lt,ot)}}else return;const nt=new(arrayNeedsUint32(j)?Uint32BufferAttribute:Uint16BufferAttribute)(j,1);nt.version=et;const rt=c.get($);rt&&e.remove(rt),c.set($,nt)}function b($){const j=c.get($);if(j){const _e=$.index;_e!==null&&j.version<_e.version&&_($)}else _($);return c.get($)}return{get:h,update:g,getWireframeAttribute:b}}function WebGLIndexedBufferRenderer(a,e,i){let s;function o(j){s=j}let c,d;function h(j){c=j.type,d=j.bytesPerElement}function g(j,_e){a.drawElements(s,_e,c,j*d),i.update(_e,s,1)}function _(j,_e,tt){tt!==0&&(a.drawElementsInstanced(s,_e,c,j*d,tt),i.update(_e,s,tt))}function b(j,_e,tt){if(tt===0)return;const et=e.get("WEBGL_multi_draw");if(et===null)for(let nt=0;nt<tt;nt++)this.render(j[nt]/d,_e[nt]);else{et.multiDrawElementsWEBGL(s,_e,0,c,j,0,tt);let nt=0;for(let rt=0;rt<tt;rt++)nt+=_e[rt];i.update(nt,s,1)}}function $(j,_e,tt,et){if(tt===0)return;const nt=e.get("WEBGL_multi_draw");if(nt===null)for(let rt=0;rt<j.length;rt++)_(j[rt]/d,_e[rt],et[rt]);else{nt.multiDrawElementsInstancedWEBGL(s,_e,0,c,j,0,et,0,tt);let rt=0;for(let it=0;it<tt;it++)rt+=_e[it];for(let it=0;it<et.length;it++)i.update(rt,s,et[it])}}this.setMode=o,this.setIndex=h,this.render=g,this.renderInstances=_,this.renderMultiDraw=b,this.renderMultiDrawInstances=$}function WebGLInfo(a){const e={geometries:0,textures:0},i={frame:0,calls:0,triangles:0,points:0,lines:0};function s(c,d,h){switch(i.calls++,d){case a.TRIANGLES:i.triangles+=h*(c/3);break;case a.LINES:i.lines+=h*(c/2);break;case a.LINE_STRIP:i.lines+=h*(c-1);break;case a.LINE_LOOP:i.lines+=h*c;break;case a.POINTS:i.points+=h*c;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",d);break}}function o(){i.calls=0,i.triangles=0,i.points=0,i.lines=0}return{memory:e,render:i,programs:null,autoReset:!0,reset:o,update:s}}function WebGLMorphtargets(a,e,i){const s=new WeakMap,o=new Vector4;function c(d,h,g){const _=d.morphTargetInfluences,b=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,$=b!==void 0?b.length:0;let j=s.get(h);if(j===void 0||j.count!==$){let ut=function(){dt.dispose(),s.delete(h),h.removeEventListener("dispose",ut)};var _e=ut;j!==void 0&&j.texture.dispose();const tt=h.morphAttributes.position!==void 0,et=h.morphAttributes.normal!==void 0,nt=h.morphAttributes.color!==void 0,rt=h.morphAttributes.position||[],it=h.morphAttributes.normal||[],at=h.morphAttributes.color||[];let st=0;tt===!0&&(st=1),et===!0&&(st=2),nt===!0&&(st=3);let ot=h.attributes.position.count*st,ct=1;ot>e.maxTextureSize&&(ct=Math.ceil(ot/e.maxTextureSize),ot=e.maxTextureSize);const lt=new Float32Array(ot*ct*4*$),dt=new DataArrayTexture(lt,ot,ct,$);dt.type=FloatType,dt.needsUpdate=!0;const xt=st*4;for(let ft=0;ft<$;ft++){const mt=rt[ft],yt=it[ft],St=at[ft],Et=ot*ct*4*ft;for(let vt=0;vt<mt.count;vt++){const Nt=vt*xt;tt===!0&&(o.fromBufferAttribute(mt,vt),lt[Et+Nt+0]=o.x,lt[Et+Nt+1]=o.y,lt[Et+Nt+2]=o.z,lt[Et+Nt+3]=0),et===!0&&(o.fromBufferAttribute(yt,vt),lt[Et+Nt+4]=o.x,lt[Et+Nt+5]=o.y,lt[Et+Nt+6]=o.z,lt[Et+Nt+7]=0),nt===!0&&(o.fromBufferAttribute(St,vt),lt[Et+Nt+8]=o.x,lt[Et+Nt+9]=o.y,lt[Et+Nt+10]=o.z,lt[Et+Nt+11]=St.itemSize===4?o.w:1)}}j={count:$,texture:dt,size:new Vector2(ot,ct)},s.set(h,j),h.addEventListener("dispose",ut)}if(d.isInstancedMesh===!0&&d.morphTexture!==null)g.getUniforms().setValue(a,"morphTexture",d.morphTexture,i);else{let tt=0;for(let nt=0;nt<_.length;nt++)tt+=_[nt];const et=h.morphTargetsRelative?1:1-tt;g.getUniforms().setValue(a,"morphTargetBaseInfluence",et),g.getUniforms().setValue(a,"morphTargetInfluences",_)}g.getUniforms().setValue(a,"morphTargetsTexture",j.texture,i),g.getUniforms().setValue(a,"morphTargetsTextureSize",j.size)}return{update:c}}function WebGLObjects(a,e,i,s){let o=new WeakMap;function c(g){const _=s.render.frame,b=g.geometry,$=e.get(g,b);if(o.get($)!==_&&(e.update($),o.set($,_)),g.isInstancedMesh&&(g.hasEventListener("dispose",h)===!1&&g.addEventListener("dispose",h),o.get(g)!==_&&(i.update(g.instanceMatrix,a.ARRAY_BUFFER),g.instanceColor!==null&&i.update(g.instanceColor,a.ARRAY_BUFFER),o.set(g,_))),g.isSkinnedMesh){const j=g.skeleton;o.get(j)!==_&&(j.update(),o.set(j,_))}return $}function d(){o=new WeakMap}function h(g){const _=g.target;_.removeEventListener("dispose",h),i.remove(_.instanceMatrix),_.instanceColor!==null&&i.remove(_.instanceColor)}return{update:c,dispose:d}}class DepthTexture extends Texture{constructor(e,i,s,o,c,d,h,g,_,b=DepthFormat){if(b!==DepthFormat&&b!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&b===DepthFormat&&(s=UnsignedIntType),s===void 0&&b===DepthStencilFormat&&(s=UnsignedInt248Type),super(null,o,c,d,h,g,b,s,_),this.isDepthTexture=!0,this.image={width:e,height:i},this.magFilter=h!==void 0?h:NearestFilter,this.minFilter=g!==void 0?g:NearestFilter,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const i=super.toJSON(e);return this.compareFunction!==null&&(i.compareFunction=this.compareFunction),i}}const emptyTexture=new Texture,emptyShadowTexture=new DepthTexture(1,1);emptyShadowTexture.compareFunction=LessEqualCompare;const emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten$5(a,e,i){const s=a[0];if(s<=0||s>0)return a;const o=e*i;let c=arrayCacheF32[o];if(c===void 0&&(c=new Float32Array(o),arrayCacheF32[o]=c),e!==0){s.toArray(c,0);for(let d=1,h=0;d!==e;++d)h+=i,a[d].toArray(c,h)}return c}function arraysEqual$1(a,e){if(a.length!==e.length)return!1;for(let i=0,s=a.length;i<s;i++)if(a[i]!==e[i])return!1;return!0}function copyArray(a,e){for(let i=0,s=e.length;i<s;i++)a[i]=e[i]}function allocTexUnits(a,e){let i=arrayCacheI32[e];i===void 0&&(i=new Int32Array(e),arrayCacheI32[e]=i);for(let s=0;s!==e;++s)i[s]=a.allocateTextureUnit();return i}function setValueV1f(a,e){const i=this.cache;i[0]!==e&&(a.uniform1f(this.addr,e),i[0]=e)}function setValueV2f(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y)&&(a.uniform2f(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(arraysEqual$1(i,e))return;a.uniform2fv(this.addr,e),copyArray(i,e)}}function setValueV3f(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z)&&(a.uniform3f(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else if(e.r!==void 0)(i[0]!==e.r||i[1]!==e.g||i[2]!==e.b)&&(a.uniform3f(this.addr,e.r,e.g,e.b),i[0]=e.r,i[1]=e.g,i[2]=e.b);else{if(arraysEqual$1(i,e))return;a.uniform3fv(this.addr,e),copyArray(i,e)}}function setValueV4f(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z||i[3]!==e.w)&&(a.uniform4f(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(arraysEqual$1(i,e))return;a.uniform4fv(this.addr,e),copyArray(i,e)}}function setValueM2(a,e){const i=this.cache,s=e.elements;if(s===void 0){if(arraysEqual$1(i,e))return;a.uniformMatrix2fv(this.addr,!1,e),copyArray(i,e)}else{if(arraysEqual$1(i,s))return;mat2array.set(s),a.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(i,s)}}function setValueM3(a,e){const i=this.cache,s=e.elements;if(s===void 0){if(arraysEqual$1(i,e))return;a.uniformMatrix3fv(this.addr,!1,e),copyArray(i,e)}else{if(arraysEqual$1(i,s))return;mat3array.set(s),a.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(i,s)}}function setValueM4(a,e){const i=this.cache,s=e.elements;if(s===void 0){if(arraysEqual$1(i,e))return;a.uniformMatrix4fv(this.addr,!1,e),copyArray(i,e)}else{if(arraysEqual$1(i,s))return;mat4array.set(s),a.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(i,s)}}function setValueV1i(a,e){const i=this.cache;i[0]!==e&&(a.uniform1i(this.addr,e),i[0]=e)}function setValueV2i(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y)&&(a.uniform2i(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(arraysEqual$1(i,e))return;a.uniform2iv(this.addr,e),copyArray(i,e)}}function setValueV3i(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z)&&(a.uniform3i(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else{if(arraysEqual$1(i,e))return;a.uniform3iv(this.addr,e),copyArray(i,e)}}function setValueV4i(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z||i[3]!==e.w)&&(a.uniform4i(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(arraysEqual$1(i,e))return;a.uniform4iv(this.addr,e),copyArray(i,e)}}function setValueV1ui(a,e){const i=this.cache;i[0]!==e&&(a.uniform1ui(this.addr,e),i[0]=e)}function setValueV2ui(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y)&&(a.uniform2ui(this.addr,e.x,e.y),i[0]=e.x,i[1]=e.y);else{if(arraysEqual$1(i,e))return;a.uniform2uiv(this.addr,e),copyArray(i,e)}}function setValueV3ui(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z)&&(a.uniform3ui(this.addr,e.x,e.y,e.z),i[0]=e.x,i[1]=e.y,i[2]=e.z);else{if(arraysEqual$1(i,e))return;a.uniform3uiv(this.addr,e),copyArray(i,e)}}function setValueV4ui(a,e){const i=this.cache;if(e.x!==void 0)(i[0]!==e.x||i[1]!==e.y||i[2]!==e.z||i[3]!==e.w)&&(a.uniform4ui(this.addr,e.x,e.y,e.z,e.w),i[0]=e.x,i[1]=e.y,i[2]=e.z,i[3]=e.w);else{if(arraysEqual$1(i,e))return;a.uniform4uiv(this.addr,e),copyArray(i,e)}}function setValueT1(a,e,i){const s=this.cache,o=i.allocateTextureUnit();s[0]!==o&&(a.uniform1i(this.addr,o),s[0]=o);const c=this.type===a.SAMPLER_2D_SHADOW?emptyShadowTexture:emptyTexture;i.setTexture2D(e||c,o)}function setValueT3D1(a,e,i){const s=this.cache,o=i.allocateTextureUnit();s[0]!==o&&(a.uniform1i(this.addr,o),s[0]=o),i.setTexture3D(e||empty3dTexture,o)}function setValueT6(a,e,i){const s=this.cache,o=i.allocateTextureUnit();s[0]!==o&&(a.uniform1i(this.addr,o),s[0]=o),i.setTextureCube(e||emptyCubeTexture,o)}function setValueT2DArray1(a,e,i){const s=this.cache,o=i.allocateTextureUnit();s[0]!==o&&(a.uniform1i(this.addr,o),s[0]=o),i.setTexture2DArray(e||emptyArrayTexture,o)}function getSingularSetter(a){switch(a){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(a,e){a.uniform1fv(this.addr,e)}function setValueV2fArray(a,e){const i=flatten$5(e,this.size,2);a.uniform2fv(this.addr,i)}function setValueV3fArray(a,e){const i=flatten$5(e,this.size,3);a.uniform3fv(this.addr,i)}function setValueV4fArray(a,e){const i=flatten$5(e,this.size,4);a.uniform4fv(this.addr,i)}function setValueM2Array(a,e){const i=flatten$5(e,this.size,4);a.uniformMatrix2fv(this.addr,!1,i)}function setValueM3Array(a,e){const i=flatten$5(e,this.size,9);a.uniformMatrix3fv(this.addr,!1,i)}function setValueM4Array(a,e){const i=flatten$5(e,this.size,16);a.uniformMatrix4fv(this.addr,!1,i)}function setValueV1iArray(a,e){a.uniform1iv(this.addr,e)}function setValueV2iArray(a,e){a.uniform2iv(this.addr,e)}function setValueV3iArray(a,e){a.uniform3iv(this.addr,e)}function setValueV4iArray(a,e){a.uniform4iv(this.addr,e)}function setValueV1uiArray(a,e){a.uniform1uiv(this.addr,e)}function setValueV2uiArray(a,e){a.uniform2uiv(this.addr,e)}function setValueV3uiArray(a,e){a.uniform3uiv(this.addr,e)}function setValueV4uiArray(a,e){a.uniform4uiv(this.addr,e)}function setValueT1Array(a,e,i){const s=this.cache,o=e.length,c=allocTexUnits(i,o);arraysEqual$1(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let d=0;d!==o;++d)i.setTexture2D(e[d]||emptyTexture,c[d])}function setValueT3DArray(a,e,i){const s=this.cache,o=e.length,c=allocTexUnits(i,o);arraysEqual$1(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let d=0;d!==o;++d)i.setTexture3D(e[d]||empty3dTexture,c[d])}function setValueT6Array(a,e,i){const s=this.cache,o=e.length,c=allocTexUnits(i,o);arraysEqual$1(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let d=0;d!==o;++d)i.setTextureCube(e[d]||emptyCubeTexture,c[d])}function setValueT2DArrayArray(a,e,i){const s=this.cache,o=e.length,c=allocTexUnits(i,o);arraysEqual$1(s,c)||(a.uniform1iv(this.addr,c),copyArray(s,c));for(let d=0;d!==o;++d)i.setTexture2DArray(e[d]||emptyArrayTexture,c[d])}function getPureArraySetter(a){switch(a){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(e,i,s){this.id=e,this.addr=s,this.cache=[],this.type=i.type,this.setValue=getSingularSetter(i.type)}}class PureArrayUniform{constructor(e,i,s){this.id=e,this.addr=s,this.cache=[],this.type=i.type,this.size=i.size,this.setValue=getPureArraySetter(i.type)}}class StructuredUniform{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,i,s){const o=this.seq;for(let c=0,d=o.length;c!==d;++c){const h=o[c];h.setValue(e,i[h.id],s)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(a,e){a.seq.push(e),a.map[e.id]=e}function parseUniform(a,e,i){const s=a.name,o=s.length;for(RePathPart.lastIndex=0;;){const c=RePathPart.exec(s),d=RePathPart.lastIndex;let h=c[1];const g=c[2]==="]",_=c[3];if(g&&(h=h|0),_===void 0||_==="["&&d+2===o){addUniform(i,_===void 0?new SingleUniform(h,a,e):new PureArrayUniform(h,a,e));break}else{let $=i.map[h];$===void 0&&($=new StructuredUniform(h),addUniform(i,$)),i=$}}}class WebGLUniforms{constructor(e,i){this.seq=[],this.map={};const s=e.getProgramParameter(i,e.ACTIVE_UNIFORMS);for(let o=0;o<s;++o){const c=e.getActiveUniform(i,o),d=e.getUniformLocation(i,c.name);parseUniform(c,d,this)}}setValue(e,i,s,o){const c=this.map[i];c!==void 0&&c.setValue(e,s,o)}setOptional(e,i,s){const o=i[s];o!==void 0&&this.setValue(e,s,o)}static upload(e,i,s,o){for(let c=0,d=i.length;c!==d;++c){const h=i[c],g=s[h.id];g.needsUpdate!==!1&&h.setValue(e,g.value,o)}}static seqWithValue(e,i){const s=[];for(let o=0,c=e.length;o!==c;++o){const d=e[o];d.id in i&&s.push(d)}return s}}function WebGLShader(a,e,i){const s=a.createShader(e);return a.shaderSource(s,i),a.compileShader(s),s}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(a,e){const i=a.split(`
`),s=[],o=Math.max(e-6,0),c=Math.min(e+6,i.length);for(let d=o;d<c;d++){const h=d+1;s.push(`${h===e?">":" "} ${h}: ${i[d]}`)}return s.join(`
`)}function getEncodingComponents(a){const e=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),i=ColorManagement.getPrimaries(a);let s;switch(e===i?s="":e===P3Primaries&&i===Rec709Primaries?s="LinearDisplayP3ToLinearSRGB":e===Rec709Primaries&&i===P3Primaries&&(s="LinearSRGBToLinearDisplayP3"),a){case LinearSRGBColorSpace:case LinearDisplayP3ColorSpace:return[s,"LinearTransferOETF"];case SRGBColorSpace:case DisplayP3ColorSpace:return[s,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",a),[s,"LinearTransferOETF"]}}function getShaderErrors(a,e,i){const s=a.getShaderParameter(e,a.COMPILE_STATUS),o=a.getShaderInfoLog(e).trim();if(s&&o==="")return"";const c=/ERROR: 0:(\d+)/.exec(o);if(c){const d=parseInt(c[1]);return i.toUpperCase()+`

`+o+`

`+handleSource(a.getShaderSource(e),d)}else return o}function getTexelEncodingFunction(a,e){const i=getEncodingComponents(e);return`vec4 ${a}( vec4 value ) { return ${i[0]}( ${i[1]}( value ) ); }`}function getToneMappingFunction(a,e){let i;switch(e){case LinearToneMapping:i="Linear";break;case ReinhardToneMapping:i="Reinhard";break;case CineonToneMapping:i="OptimizedCineon";break;case ACESFilmicToneMapping:i="ACESFilmic";break;case AgXToneMapping:i="AgX";break;case NeutralToneMapping:i="Neutral";break;case CustomToneMapping:i="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),i="Linear"}return"vec3 "+a+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}function generateVertexExtensions(a){return[a.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",a.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(filterEmptyLine).join(`
`)}function generateDefines(a){const e=[];for(const i in a){const s=a[i];s!==!1&&e.push("#define "+i+" "+s)}return e.join(`
`)}function fetchAttributeLocations(a,e){const i={},s=a.getProgramParameter(e,a.ACTIVE_ATTRIBUTES);for(let o=0;o<s;o++){const c=a.getActiveAttrib(e,o),d=c.name;let h=1;c.type===a.FLOAT_MAT2&&(h=2),c.type===a.FLOAT_MAT3&&(h=3),c.type===a.FLOAT_MAT4&&(h=4),i[d]={type:c.type,location:a.getAttribLocation(e,d),locationSize:h}}return i}function filterEmptyLine(a){return a!==""}function replaceLightNums(a,e){const i=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return a.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,i).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function replaceClippingPlaneNums(a,e){return a.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(a){return a.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map;function includeReplacer(a,e){let i=ShaderChunk[e];if(i===void 0){const s=shaderChunkMap.get(e);if(s!==void 0)i=ShaderChunk[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return resolveIncludes(i)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(a){return a.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(a,e,i,s){let o="";for(let c=parseInt(e);c<parseInt(i);c++)o+=s.replace(/\[\s*i\s*\]/g,"[ "+c+" ]").replace(/UNROLLED_LOOP_INDEX/g,c);return o}function generatePrecision(a){let e=`precision ${a.precision} float;
	precision ${a.precision} int;
	precision ${a.precision} sampler2D;
	precision ${a.precision} samplerCube;
	precision ${a.precision} sampler3D;
	precision ${a.precision} sampler2DArray;
	precision ${a.precision} sampler2DShadow;
	precision ${a.precision} samplerCubeShadow;
	precision ${a.precision} sampler2DArrayShadow;
	precision ${a.precision} isampler2D;
	precision ${a.precision} isampler3D;
	precision ${a.precision} isamplerCube;
	precision ${a.precision} isampler2DArray;
	precision ${a.precision} usampler2D;
	precision ${a.precision} usampler3D;
	precision ${a.precision} usamplerCube;
	precision ${a.precision} usampler2DArray;
	`;return a.precision==="highp"?e+=`
#define HIGH_PRECISION`:a.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:a.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function generateShadowMapTypeDefine(a){let e="SHADOWMAP_TYPE_BASIC";return a.shadowMapType===PCFShadowMap?e="SHADOWMAP_TYPE_PCF":a.shadowMapType===PCFSoftShadowMap?e="SHADOWMAP_TYPE_PCF_SOFT":a.shadowMapType===VSMShadowMap&&(e="SHADOWMAP_TYPE_VSM"),e}function generateEnvMapTypeDefine(a){let e="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:e="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:e="ENVMAP_TYPE_CUBE_UV";break}return e}function generateEnvMapModeDefine(a){let e="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case CubeRefractionMapping:e="ENVMAP_MODE_REFRACTION";break}return e}function generateEnvMapBlendingDefine(a){let e="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case MultiplyOperation:e="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:e="ENVMAP_BLENDING_MIX";break;case AddOperation:e="ENVMAP_BLENDING_ADD";break}return e}function generateCubeUVSize(a){const e=a.envMapCubeUVHeight;if(e===null)return null;const i=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,i),7*16)),texelHeight:s,maxMip:i}}function WebGLProgram(a,e,i,s){const o=a.getContext(),c=i.defines;let d=i.vertexShader,h=i.fragmentShader;const g=generateShadowMapTypeDefine(i),_=generateEnvMapTypeDefine(i),b=generateEnvMapModeDefine(i),$=generateEnvMapBlendingDefine(i),j=generateCubeUVSize(i),_e=generateVertexExtensions(i),tt=generateDefines(c),et=o.createProgram();let nt,rt,it=i.glslVersion?"#version "+i.glslVersion+`
`:"";i.isRawShaderMaterial?(nt=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,tt].filter(filterEmptyLine).join(`
`),nt.length>0&&(nt+=`
`),rt=["#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,tt].filter(filterEmptyLine).join(`
`),rt.length>0&&(rt+=`
`)):(nt=[generatePrecision(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,tt,i.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",i.batching?"#define USE_BATCHING":"",i.batchingColor?"#define USE_BATCHING_COLOR":"",i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.instancingMorph?"#define USE_INSTANCING_MORPH":"",i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+b:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.displacementMap?"#define USE_DISPLACEMENTMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.mapUv?"#define MAP_UV "+i.mapUv:"",i.alphaMapUv?"#define ALPHAMAP_UV "+i.alphaMapUv:"",i.lightMapUv?"#define LIGHTMAP_UV "+i.lightMapUv:"",i.aoMapUv?"#define AOMAP_UV "+i.aoMapUv:"",i.emissiveMapUv?"#define EMISSIVEMAP_UV "+i.emissiveMapUv:"",i.bumpMapUv?"#define BUMPMAP_UV "+i.bumpMapUv:"",i.normalMapUv?"#define NORMALMAP_UV "+i.normalMapUv:"",i.displacementMapUv?"#define DISPLACEMENTMAP_UV "+i.displacementMapUv:"",i.metalnessMapUv?"#define METALNESSMAP_UV "+i.metalnessMapUv:"",i.roughnessMapUv?"#define ROUGHNESSMAP_UV "+i.roughnessMapUv:"",i.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+i.anisotropyMapUv:"",i.clearcoatMapUv?"#define CLEARCOATMAP_UV "+i.clearcoatMapUv:"",i.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+i.clearcoatNormalMapUv:"",i.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+i.clearcoatRoughnessMapUv:"",i.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+i.iridescenceMapUv:"",i.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+i.iridescenceThicknessMapUv:"",i.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+i.sheenColorMapUv:"",i.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+i.sheenRoughnessMapUv:"",i.specularMapUv?"#define SPECULARMAP_UV "+i.specularMapUv:"",i.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+i.specularColorMapUv:"",i.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+i.specularIntensityMapUv:"",i.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+i.transmissionMapUv:"",i.thicknessMapUv?"#define THICKNESSMAP_UV "+i.thicknessMapUv:"",i.vertexTangents&&i.flatShading===!1?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&i.flatShading===!1?"#define USE_MORPHNORMALS":"",i.morphColors?"#define USE_MORPHCOLORS":"",i.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+i.morphTextureStride:"",i.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+i.morphTargetsCount:"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+g:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.numLightProbes>0?"#define USE_LIGHT_PROBES":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),rt=[generatePrecision(i),"#define SHADER_TYPE "+i.shaderType,"#define SHADER_NAME "+i.shaderName,tt,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+_:"",i.envMap?"#define "+b:"",i.envMap?"#define "+$:"",j?"#define CUBEUV_TEXEL_WIDTH "+j.texelWidth:"",j?"#define CUBEUV_TEXEL_HEIGHT "+j.texelHeight:"",j?"#define CUBEUV_MAX_MIP "+j.maxMip+".0":"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",i.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.anisotropy?"#define USE_ANISOTROPY":"",i.anisotropyMap?"#define USE_ANISOTROPYMAP":"",i.clearcoat?"#define USE_CLEARCOAT":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.dispersion?"#define USE_DISPERSION":"",i.iridescence?"#define USE_IRIDESCENCE":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",i.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaTest?"#define USE_ALPHATEST":"",i.alphaHash?"#define USE_ALPHAHASH":"",i.sheen?"#define USE_SHEEN":"",i.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.vertexTangents&&i.flatShading===!1?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor||i.batchingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUv1s?"#define USE_UV1":"",i.vertexUv2s?"#define USE_UV2":"",i.vertexUv3s?"#define USE_UV3":"",i.pointsUvs?"#define USE_POINTS_UV":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+g:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.numLightProbes>0?"#define USE_LIGHT_PROBES":"",i.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",i.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",i.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",i.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",i.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",i.outputColorSpace),i.useDepthPacking?"#define DEPTH_PACKING "+i.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),d=resolveIncludes(d),d=replaceLightNums(d,i),d=replaceClippingPlaneNums(d,i),h=resolveIncludes(h),h=replaceLightNums(h,i),h=replaceClippingPlaneNums(h,i),d=unrollLoops(d),h=unrollLoops(h),i.isRawShaderMaterial!==!0&&(it=`#version 300 es
`,nt=[_e,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+nt,rt=["#define varying in",i.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",i.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+rt);const at=it+nt+d,st=it+rt+h,ot=WebGLShader(o,o.VERTEX_SHADER,at),ct=WebGLShader(o,o.FRAGMENT_SHADER,st);o.attachShader(et,ot),o.attachShader(et,ct),i.index0AttributeName!==void 0?o.bindAttribLocation(et,0,i.index0AttributeName):i.morphTargets===!0&&o.bindAttribLocation(et,0,"position"),o.linkProgram(et);function lt(ft){if(a.debug.checkShaderErrors){const mt=o.getProgramInfoLog(et).trim(),yt=o.getShaderInfoLog(ot).trim(),St=o.getShaderInfoLog(ct).trim();let Et=!0,vt=!0;if(o.getProgramParameter(et,o.LINK_STATUS)===!1)if(Et=!1,typeof a.debug.onShaderError=="function")a.debug.onShaderError(o,et,ot,ct);else{const Nt=getShaderErrors(o,ot,"vertex"),wt=getShaderErrors(o,ct,"fragment");console.error("THREE.WebGLProgram: Shader Error "+o.getError()+" - VALIDATE_STATUS "+o.getProgramParameter(et,o.VALIDATE_STATUS)+`

Material Name: `+ft.name+`
Material Type: `+ft.type+`

Program Info Log: `+mt+`
`+Nt+`
`+wt)}else mt!==""?console.warn("THREE.WebGLProgram: Program Info Log:",mt):(yt===""||St==="")&&(vt=!1);vt&&(ft.diagnostics={runnable:Et,programLog:mt,vertexShader:{log:yt,prefix:nt},fragmentShader:{log:St,prefix:rt}})}o.deleteShader(ot),o.deleteShader(ct),dt=new WebGLUniforms(o,et),xt=fetchAttributeLocations(o,et)}let dt;this.getUniforms=function(){return dt===void 0&&lt(this),dt};let xt;this.getAttributes=function(){return xt===void 0&&lt(this),xt};let ut=i.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return ut===!1&&(ut=o.getProgramParameter(et,COMPLETION_STATUS_KHR)),ut},this.destroy=function(){s.releaseStatesOfProgram(this),o.deleteProgram(et),this.program=void 0},this.type=i.shaderType,this.name=i.shaderName,this.id=programIdCount++,this.cacheKey=e,this.usedTimes=1,this.program=et,this.vertexShader=ot,this.fragmentShader=ct,this}let _id$1=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const i=e.vertexShader,s=e.fragmentShader,o=this._getShaderStage(i),c=this._getShaderStage(s),d=this._getShaderCacheForMaterial(e);return d.has(o)===!1&&(d.add(o),o.usedTimes++),d.has(c)===!1&&(d.add(c),c.usedTimes++),this}remove(e){const i=this.materialCache.get(e);for(const s of i)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const i=this.materialCache;let s=i.get(e);return s===void 0&&(s=new Set,i.set(e,s)),s}_getShaderStage(e){const i=this.shaderCache;let s=i.get(e);return s===void 0&&(s=new WebGLShaderStage(e),i.set(e,s)),s}}class WebGLShaderStage{constructor(e){this.id=_id$1++,this.code=e,this.usedTimes=0}}function WebGLPrograms(a,e,i,s,o,c,d){const h=new Layers,g=new WebGLShaderCache,_=new Set,b=[],$=o.logarithmicDepthBuffer,j=o.vertexTextures;let _e=o.precision;const tt={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function et(xt){return _.add(xt),xt===0?"uv":`uv${xt}`}function nt(xt,ut,ft,mt,yt){const St=mt.fog,Et=yt.geometry,vt=xt.isMeshStandardMaterial?mt.environment:null,Nt=(xt.isMeshStandardMaterial?i:e).get(xt.envMap||vt),wt=Nt&&Nt.mapping===CubeUVReflectionMapping?Nt.image.height:null,$t=tt[xt.type];xt.precision!==null&&(_e=o.getMaxPrecision(xt.precision),_e!==xt.precision&&console.warn("THREE.WebGLProgram.getParameters:",xt.precision,"not supported, using",_e,"instead."));const Ct=Et.morphAttributes.position||Et.morphAttributes.normal||Et.morphAttributes.color,Mt=Ct!==void 0?Ct.length:0;let Ot=0;Et.morphAttributes.position!==void 0&&(Ot=1),Et.morphAttributes.normal!==void 0&&(Ot=2),Et.morphAttributes.color!==void 0&&(Ot=3);let Dt,At,kt,Ft;if($t){const qn=ShaderLib[$t];Dt=qn.vertexShader,At=qn.fragmentShader}else Dt=xt.vertexShader,At=xt.fragmentShader,g.update(xt),kt=g.getVertexShaderID(xt),Ft=g.getFragmentShaderID(xt);const Bt=a.getRenderTarget(),Ht=yt.isInstancedMesh===!0,Wt=yt.isBatchedMesh===!0,Ut=!!xt.map,Rt=!!xt.matcap,un=!!Nt,rn=!!xt.aoMap,mn=!!xt.lightMap,sn=!!xt.bumpMap,hn=!!xt.normalMap,gn=!!xt.displacementMap,Xt=!!xt.emissiveMap,En=!!xt.metalnessMap,bt=!!xt.roughnessMap,gt=xt.anisotropy>0,Pt=xt.clearcoat>0,Lt=xt.dispersion>0,Vt=xt.iridescence>0,jt=xt.sheen>0,cn=xt.transmission>0,en=gt&&!!xt.anisotropyMap,Zt=Pt&&!!xt.clearcoatMap,yn=Pt&&!!xt.clearcoatNormalMap,pn=Pt&&!!xt.clearcoatRoughnessMap,wn=Vt&&!!xt.iridescenceMap,Pn=Vt&&!!xt.iridescenceThicknessMap,Rn=jt&&!!xt.sheenColorMap,Sn=jt&&!!xt.sheenRoughnessMap,On=!!xt.specularMap,Nn=!!xt.specularColorMap,rr=!!xt.specularIntensityMap,Tt=cn&&!!xt.transmissionMap,Yt=cn&&!!xt.thicknessMap,Jt=!!xt.gradientMap,an=!!xt.alphaMap,fn=xt.alphaTest>0,Cn=!!xt.alphaHash,vn=!!xt.extensions;let or=NoToneMapping;xt.toneMapped&&(Bt===null||Bt.isXRRenderTarget===!0)&&(or=a.toneMapping);const lr={shaderID:$t,shaderType:xt.type,shaderName:xt.name,vertexShader:Dt,fragmentShader:At,defines:xt.defines,customVertexShaderID:kt,customFragmentShaderID:Ft,isRawShaderMaterial:xt.isRawShaderMaterial===!0,glslVersion:xt.glslVersion,precision:_e,batching:Wt,batchingColor:Wt&&yt._colorsTexture!==null,instancing:Ht,instancingColor:Ht&&yt.instanceColor!==null,instancingMorph:Ht&&yt.morphTexture!==null,supportsVertexTextures:j,outputColorSpace:Bt===null?a.outputColorSpace:Bt.isXRRenderTarget===!0?Bt.texture.colorSpace:LinearSRGBColorSpace,alphaToCoverage:!!xt.alphaToCoverage,map:Ut,matcap:Rt,envMap:un,envMapMode:un&&Nt.mapping,envMapCubeUVHeight:wt,aoMap:rn,lightMap:mn,bumpMap:sn,normalMap:hn,displacementMap:j&&gn,emissiveMap:Xt,normalMapObjectSpace:hn&&xt.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:hn&&xt.normalMapType===TangentSpaceNormalMap,metalnessMap:En,roughnessMap:bt,anisotropy:gt,anisotropyMap:en,clearcoat:Pt,clearcoatMap:Zt,clearcoatNormalMap:yn,clearcoatRoughnessMap:pn,dispersion:Lt,iridescence:Vt,iridescenceMap:wn,iridescenceThicknessMap:Pn,sheen:jt,sheenColorMap:Rn,sheenRoughnessMap:Sn,specularMap:On,specularColorMap:Nn,specularIntensityMap:rr,transmission:cn,transmissionMap:Tt,thicknessMap:Yt,gradientMap:Jt,opaque:xt.transparent===!1&&xt.blending===NormalBlending&&xt.alphaToCoverage===!1,alphaMap:an,alphaTest:fn,alphaHash:Cn,combine:xt.combine,mapUv:Ut&&et(xt.map.channel),aoMapUv:rn&&et(xt.aoMap.channel),lightMapUv:mn&&et(xt.lightMap.channel),bumpMapUv:sn&&et(xt.bumpMap.channel),normalMapUv:hn&&et(xt.normalMap.channel),displacementMapUv:gn&&et(xt.displacementMap.channel),emissiveMapUv:Xt&&et(xt.emissiveMap.channel),metalnessMapUv:En&&et(xt.metalnessMap.channel),roughnessMapUv:bt&&et(xt.roughnessMap.channel),anisotropyMapUv:en&&et(xt.anisotropyMap.channel),clearcoatMapUv:Zt&&et(xt.clearcoatMap.channel),clearcoatNormalMapUv:yn&&et(xt.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:pn&&et(xt.clearcoatRoughnessMap.channel),iridescenceMapUv:wn&&et(xt.iridescenceMap.channel),iridescenceThicknessMapUv:Pn&&et(xt.iridescenceThicknessMap.channel),sheenColorMapUv:Rn&&et(xt.sheenColorMap.channel),sheenRoughnessMapUv:Sn&&et(xt.sheenRoughnessMap.channel),specularMapUv:On&&et(xt.specularMap.channel),specularColorMapUv:Nn&&et(xt.specularColorMap.channel),specularIntensityMapUv:rr&&et(xt.specularIntensityMap.channel),transmissionMapUv:Tt&&et(xt.transmissionMap.channel),thicknessMapUv:Yt&&et(xt.thicknessMap.channel),alphaMapUv:an&&et(xt.alphaMap.channel),vertexTangents:!!Et.attributes.tangent&&(hn||gt),vertexColors:xt.vertexColors,vertexAlphas:xt.vertexColors===!0&&!!Et.attributes.color&&Et.attributes.color.itemSize===4,pointsUvs:yt.isPoints===!0&&!!Et.attributes.uv&&(Ut||an),fog:!!St,useFog:xt.fog===!0,fogExp2:!!St&&St.isFogExp2,flatShading:xt.flatShading===!0,sizeAttenuation:xt.sizeAttenuation===!0,logarithmicDepthBuffer:$,skinning:yt.isSkinnedMesh===!0,morphTargets:Et.morphAttributes.position!==void 0,morphNormals:Et.morphAttributes.normal!==void 0,morphColors:Et.morphAttributes.color!==void 0,morphTargetsCount:Mt,morphTextureStride:Ot,numDirLights:ut.directional.length,numPointLights:ut.point.length,numSpotLights:ut.spot.length,numSpotLightMaps:ut.spotLightMap.length,numRectAreaLights:ut.rectArea.length,numHemiLights:ut.hemi.length,numDirLightShadows:ut.directionalShadowMap.length,numPointLightShadows:ut.pointShadowMap.length,numSpotLightShadows:ut.spotShadowMap.length,numSpotLightShadowsWithMaps:ut.numSpotLightShadowsWithMaps,numLightProbes:ut.numLightProbes,numClippingPlanes:d.numPlanes,numClipIntersection:d.numIntersection,dithering:xt.dithering,shadowMapEnabled:a.shadowMap.enabled&&ft.length>0,shadowMapType:a.shadowMap.type,toneMapping:or,decodeVideoTexture:Ut&&xt.map.isVideoTexture===!0&&ColorManagement.getTransfer(xt.map.colorSpace)===SRGBTransfer,premultipliedAlpha:xt.premultipliedAlpha,doubleSided:xt.side===DoubleSide,flipSided:xt.side===BackSide,useDepthPacking:xt.depthPacking>=0,depthPacking:xt.depthPacking||0,index0AttributeName:xt.index0AttributeName,extensionClipCullDistance:vn&&xt.extensions.clipCullDistance===!0&&s.has("WEBGL_clip_cull_distance"),extensionMultiDraw:vn&&xt.extensions.multiDraw===!0&&s.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:xt.customProgramCacheKey()};return lr.vertexUv1s=_.has(1),lr.vertexUv2s=_.has(2),lr.vertexUv3s=_.has(3),_.clear(),lr}function rt(xt){const ut=[];if(xt.shaderID?ut.push(xt.shaderID):(ut.push(xt.customVertexShaderID),ut.push(xt.customFragmentShaderID)),xt.defines!==void 0)for(const ft in xt.defines)ut.push(ft),ut.push(xt.defines[ft]);return xt.isRawShaderMaterial===!1&&(it(ut,xt),at(ut,xt),ut.push(a.outputColorSpace)),ut.push(xt.customProgramCacheKey),ut.join()}function it(xt,ut){xt.push(ut.precision),xt.push(ut.outputColorSpace),xt.push(ut.envMapMode),xt.push(ut.envMapCubeUVHeight),xt.push(ut.mapUv),xt.push(ut.alphaMapUv),xt.push(ut.lightMapUv),xt.push(ut.aoMapUv),xt.push(ut.bumpMapUv),xt.push(ut.normalMapUv),xt.push(ut.displacementMapUv),xt.push(ut.emissiveMapUv),xt.push(ut.metalnessMapUv),xt.push(ut.roughnessMapUv),xt.push(ut.anisotropyMapUv),xt.push(ut.clearcoatMapUv),xt.push(ut.clearcoatNormalMapUv),xt.push(ut.clearcoatRoughnessMapUv),xt.push(ut.iridescenceMapUv),xt.push(ut.iridescenceThicknessMapUv),xt.push(ut.sheenColorMapUv),xt.push(ut.sheenRoughnessMapUv),xt.push(ut.specularMapUv),xt.push(ut.specularColorMapUv),xt.push(ut.specularIntensityMapUv),xt.push(ut.transmissionMapUv),xt.push(ut.thicknessMapUv),xt.push(ut.combine),xt.push(ut.fogExp2),xt.push(ut.sizeAttenuation),xt.push(ut.morphTargetsCount),xt.push(ut.morphAttributeCount),xt.push(ut.numDirLights),xt.push(ut.numPointLights),xt.push(ut.numSpotLights),xt.push(ut.numSpotLightMaps),xt.push(ut.numHemiLights),xt.push(ut.numRectAreaLights),xt.push(ut.numDirLightShadows),xt.push(ut.numPointLightShadows),xt.push(ut.numSpotLightShadows),xt.push(ut.numSpotLightShadowsWithMaps),xt.push(ut.numLightProbes),xt.push(ut.shadowMapType),xt.push(ut.toneMapping),xt.push(ut.numClippingPlanes),xt.push(ut.numClipIntersection),xt.push(ut.depthPacking)}function at(xt,ut){h.disableAll(),ut.supportsVertexTextures&&h.enable(0),ut.instancing&&h.enable(1),ut.instancingColor&&h.enable(2),ut.instancingMorph&&h.enable(3),ut.matcap&&h.enable(4),ut.envMap&&h.enable(5),ut.normalMapObjectSpace&&h.enable(6),ut.normalMapTangentSpace&&h.enable(7),ut.clearcoat&&h.enable(8),ut.iridescence&&h.enable(9),ut.alphaTest&&h.enable(10),ut.vertexColors&&h.enable(11),ut.vertexAlphas&&h.enable(12),ut.vertexUv1s&&h.enable(13),ut.vertexUv2s&&h.enable(14),ut.vertexUv3s&&h.enable(15),ut.vertexTangents&&h.enable(16),ut.anisotropy&&h.enable(17),ut.alphaHash&&h.enable(18),ut.batching&&h.enable(19),ut.dispersion&&h.enable(20),ut.batchingColor&&h.enable(21),xt.push(h.mask),h.disableAll(),ut.fog&&h.enable(0),ut.useFog&&h.enable(1),ut.flatShading&&h.enable(2),ut.logarithmicDepthBuffer&&h.enable(3),ut.skinning&&h.enable(4),ut.morphTargets&&h.enable(5),ut.morphNormals&&h.enable(6),ut.morphColors&&h.enable(7),ut.premultipliedAlpha&&h.enable(8),ut.shadowMapEnabled&&h.enable(9),ut.doubleSided&&h.enable(10),ut.flipSided&&h.enable(11),ut.useDepthPacking&&h.enable(12),ut.dithering&&h.enable(13),ut.transmission&&h.enable(14),ut.sheen&&h.enable(15),ut.opaque&&h.enable(16),ut.pointsUvs&&h.enable(17),ut.decodeVideoTexture&&h.enable(18),ut.alphaToCoverage&&h.enable(19),xt.push(h.mask)}function st(xt){const ut=tt[xt.type];let ft;if(ut){const mt=ShaderLib[ut];ft=UniformsUtils.clone(mt.uniforms)}else ft=xt.uniforms;return ft}function ot(xt,ut){let ft;for(let mt=0,yt=b.length;mt<yt;mt++){const St=b[mt];if(St.cacheKey===ut){ft=St,++ft.usedTimes;break}}return ft===void 0&&(ft=new WebGLProgram(a,ut,xt,c),b.push(ft)),ft}function ct(xt){if(--xt.usedTimes===0){const ut=b.indexOf(xt);b[ut]=b[b.length-1],b.pop(),xt.destroy()}}function lt(xt){g.remove(xt)}function dt(){g.dispose()}return{getParameters:nt,getProgramCacheKey:rt,getUniforms:st,acquireProgram:ot,releaseProgram:ct,releaseShaderCache:lt,programs:b,dispose:dt}}function WebGLProperties(){let a=new WeakMap;function e(c){let d=a.get(c);return d===void 0&&(d={},a.set(c,d)),d}function i(c){a.delete(c)}function s(c,d,h){a.get(c)[d]=h}function o(){a=new WeakMap}return{get:e,remove:i,update:s,dispose:o}}function painterSortStable(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.material.id!==e.material.id?a.material.id-e.material.id:a.z!==e.z?a.z-e.z:a.id-e.id}function reversePainterSortStable(a,e){return a.groupOrder!==e.groupOrder?a.groupOrder-e.groupOrder:a.renderOrder!==e.renderOrder?a.renderOrder-e.renderOrder:a.z!==e.z?e.z-a.z:a.id-e.id}function WebGLRenderList(){const a=[];let e=0;const i=[],s=[],o=[];function c(){e=0,i.length=0,s.length=0,o.length=0}function d($,j,_e,tt,et,nt){let rt=a[e];return rt===void 0?(rt={id:$.id,object:$,geometry:j,material:_e,groupOrder:tt,renderOrder:$.renderOrder,z:et,group:nt},a[e]=rt):(rt.id=$.id,rt.object=$,rt.geometry=j,rt.material=_e,rt.groupOrder=tt,rt.renderOrder=$.renderOrder,rt.z=et,rt.group=nt),e++,rt}function h($,j,_e,tt,et,nt){const rt=d($,j,_e,tt,et,nt);_e.transmission>0?s.push(rt):_e.transparent===!0?o.push(rt):i.push(rt)}function g($,j,_e,tt,et,nt){const rt=d($,j,_e,tt,et,nt);_e.transmission>0?s.unshift(rt):_e.transparent===!0?o.unshift(rt):i.unshift(rt)}function _($,j){i.length>1&&i.sort($||painterSortStable),s.length>1&&s.sort(j||reversePainterSortStable),o.length>1&&o.sort(j||reversePainterSortStable)}function b(){for(let $=e,j=a.length;$<j;$++){const _e=a[$];if(_e.id===null)break;_e.id=null,_e.object=null,_e.geometry=null,_e.material=null,_e.group=null}}return{opaque:i,transmissive:s,transparent:o,init:c,push:h,unshift:g,finish:b,sort:_}}function WebGLRenderLists(){let a=new WeakMap;function e(s,o){const c=a.get(s);let d;return c===void 0?(d=new WebGLRenderList,a.set(s,[d])):o>=c.length?(d=new WebGLRenderList,c.push(d)):d=c[o],d}function i(){a=new WeakMap}return{get:e,dispose:i}}function UniformsCache(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let i;switch(e.type){case"DirectionalLight":i={direction:new Vector3,color:new Color};break;case"SpotLight":i={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":i={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":i={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return a[e.id]=i,i}}}function ShadowUniformsCache(){const a={};return{get:function(e){if(a[e.id]!==void 0)return a[e.id];let i;switch(e.type){case"DirectionalLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return a[e.id]=i,i}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(a,e){return(e.castShadow?2:0)-(a.castShadow?2:0)+(e.map?1:0)-(a.map?1:0)}function WebGLLights(a){const e=new UniformsCache,i=ShadowUniformsCache(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let _=0;_<9;_++)s.probe.push(new Vector3);const o=new Vector3,c=new Matrix4,d=new Matrix4;function h(_){let b=0,$=0,j=0;for(let xt=0;xt<9;xt++)s.probe[xt].set(0,0,0);let _e=0,tt=0,et=0,nt=0,rt=0,it=0,at=0,st=0,ot=0,ct=0,lt=0;_.sort(shadowCastingAndTexturingLightsFirst);for(let xt=0,ut=_.length;xt<ut;xt++){const ft=_[xt],mt=ft.color,yt=ft.intensity,St=ft.distance,Et=ft.shadow&&ft.shadow.map?ft.shadow.map.texture:null;if(ft.isAmbientLight)b+=mt.r*yt,$+=mt.g*yt,j+=mt.b*yt;else if(ft.isLightProbe){for(let vt=0;vt<9;vt++)s.probe[vt].addScaledVector(ft.sh.coefficients[vt],yt);lt++}else if(ft.isDirectionalLight){const vt=e.get(ft);if(vt.color.copy(ft.color).multiplyScalar(ft.intensity),ft.castShadow){const Nt=ft.shadow,wt=i.get(ft);wt.shadowBias=Nt.bias,wt.shadowNormalBias=Nt.normalBias,wt.shadowRadius=Nt.radius,wt.shadowMapSize=Nt.mapSize,s.directionalShadow[_e]=wt,s.directionalShadowMap[_e]=Et,s.directionalShadowMatrix[_e]=ft.shadow.matrix,it++}s.directional[_e]=vt,_e++}else if(ft.isSpotLight){const vt=e.get(ft);vt.position.setFromMatrixPosition(ft.matrixWorld),vt.color.copy(mt).multiplyScalar(yt),vt.distance=St,vt.coneCos=Math.cos(ft.angle),vt.penumbraCos=Math.cos(ft.angle*(1-ft.penumbra)),vt.decay=ft.decay,s.spot[et]=vt;const Nt=ft.shadow;if(ft.map&&(s.spotLightMap[ot]=ft.map,ot++,Nt.updateMatrices(ft),ft.castShadow&&ct++),s.spotLightMatrix[et]=Nt.matrix,ft.castShadow){const wt=i.get(ft);wt.shadowBias=Nt.bias,wt.shadowNormalBias=Nt.normalBias,wt.shadowRadius=Nt.radius,wt.shadowMapSize=Nt.mapSize,s.spotShadow[et]=wt,s.spotShadowMap[et]=Et,st++}et++}else if(ft.isRectAreaLight){const vt=e.get(ft);vt.color.copy(mt).multiplyScalar(yt),vt.halfWidth.set(ft.width*.5,0,0),vt.halfHeight.set(0,ft.height*.5,0),s.rectArea[nt]=vt,nt++}else if(ft.isPointLight){const vt=e.get(ft);if(vt.color.copy(ft.color).multiplyScalar(ft.intensity),vt.distance=ft.distance,vt.decay=ft.decay,ft.castShadow){const Nt=ft.shadow,wt=i.get(ft);wt.shadowBias=Nt.bias,wt.shadowNormalBias=Nt.normalBias,wt.shadowRadius=Nt.radius,wt.shadowMapSize=Nt.mapSize,wt.shadowCameraNear=Nt.camera.near,wt.shadowCameraFar=Nt.camera.far,s.pointShadow[tt]=wt,s.pointShadowMap[tt]=Et,s.pointShadowMatrix[tt]=ft.shadow.matrix,at++}s.point[tt]=vt,tt++}else if(ft.isHemisphereLight){const vt=e.get(ft);vt.skyColor.copy(ft.color).multiplyScalar(yt),vt.groundColor.copy(ft.groundColor).multiplyScalar(yt),s.hemi[rt]=vt,rt++}}nt>0&&(a.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,s.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):(s.rectAreaLTC1=UniformsLib.LTC_HALF_1,s.rectAreaLTC2=UniformsLib.LTC_HALF_2)),s.ambient[0]=b,s.ambient[1]=$,s.ambient[2]=j;const dt=s.hash;(dt.directionalLength!==_e||dt.pointLength!==tt||dt.spotLength!==et||dt.rectAreaLength!==nt||dt.hemiLength!==rt||dt.numDirectionalShadows!==it||dt.numPointShadows!==at||dt.numSpotShadows!==st||dt.numSpotMaps!==ot||dt.numLightProbes!==lt)&&(s.directional.length=_e,s.spot.length=et,s.rectArea.length=nt,s.point.length=tt,s.hemi.length=rt,s.directionalShadow.length=it,s.directionalShadowMap.length=it,s.pointShadow.length=at,s.pointShadowMap.length=at,s.spotShadow.length=st,s.spotShadowMap.length=st,s.directionalShadowMatrix.length=it,s.pointShadowMatrix.length=at,s.spotLightMatrix.length=st+ot-ct,s.spotLightMap.length=ot,s.numSpotLightShadowsWithMaps=ct,s.numLightProbes=lt,dt.directionalLength=_e,dt.pointLength=tt,dt.spotLength=et,dt.rectAreaLength=nt,dt.hemiLength=rt,dt.numDirectionalShadows=it,dt.numPointShadows=at,dt.numSpotShadows=st,dt.numSpotMaps=ot,dt.numLightProbes=lt,s.version=nextVersion++)}function g(_,b){let $=0,j=0,_e=0,tt=0,et=0;const nt=b.matrixWorldInverse;for(let rt=0,it=_.length;rt<it;rt++){const at=_[rt];if(at.isDirectionalLight){const st=s.directional[$];st.direction.setFromMatrixPosition(at.matrixWorld),o.setFromMatrixPosition(at.target.matrixWorld),st.direction.sub(o),st.direction.transformDirection(nt),$++}else if(at.isSpotLight){const st=s.spot[_e];st.position.setFromMatrixPosition(at.matrixWorld),st.position.applyMatrix4(nt),st.direction.setFromMatrixPosition(at.matrixWorld),o.setFromMatrixPosition(at.target.matrixWorld),st.direction.sub(o),st.direction.transformDirection(nt),_e++}else if(at.isRectAreaLight){const st=s.rectArea[tt];st.position.setFromMatrixPosition(at.matrixWorld),st.position.applyMatrix4(nt),d.identity(),c.copy(at.matrixWorld),c.premultiply(nt),d.extractRotation(c),st.halfWidth.set(at.width*.5,0,0),st.halfHeight.set(0,at.height*.5,0),st.halfWidth.applyMatrix4(d),st.halfHeight.applyMatrix4(d),tt++}else if(at.isPointLight){const st=s.point[j];st.position.setFromMatrixPosition(at.matrixWorld),st.position.applyMatrix4(nt),j++}else if(at.isHemisphereLight){const st=s.hemi[et];st.direction.setFromMatrixPosition(at.matrixWorld),st.direction.transformDirection(nt),et++}}}return{setup:h,setupView:g,state:s}}function WebGLRenderState(a){const e=new WebGLLights(a),i=[],s=[];function o(b){_.camera=b,i.length=0,s.length=0}function c(b){i.push(b)}function d(b){s.push(b)}function h(){e.setup(i)}function g(b){e.setupView(i,b)}const _={lightsArray:i,shadowsArray:s,camera:null,lights:e,transmissionRenderTarget:{}};return{init:o,state:_,setupLights:h,setupLightsView:g,pushLight:c,pushShadow:d}}function WebGLRenderStates(a){let e=new WeakMap;function i(o,c=0){const d=e.get(o);let h;return d===void 0?(h=new WebGLRenderState(a),e.set(o,[h])):c>=d.length?(h=new WebGLRenderState(a),d.push(h)):h=d[c],h}function s(){e=new WeakMap}return{get:i,dispose:s}}class MeshDepthMaterial extends Material{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(a,e,i){let s=new Frustum;const o=new Vector2,c=new Vector2,d=new Vector4,h=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),g=new MeshDistanceMaterial,_={},b=i.maxTextureSize,$={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},j=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),_e=j.clone();_e.defines.HORIZONTAL_PASS=1;const tt=new BufferGeometry;tt.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const et=new Mesh(tt,j),nt=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let rt=this.type;this.render=function(ct,lt,dt){if(nt.enabled===!1||nt.autoUpdate===!1&&nt.needsUpdate===!1||ct.length===0)return;const xt=a.getRenderTarget(),ut=a.getActiveCubeFace(),ft=a.getActiveMipmapLevel(),mt=a.state;mt.setBlending(NoBlending),mt.buffers.color.setClear(1,1,1,1),mt.buffers.depth.setTest(!0),mt.setScissorTest(!1);const yt=rt!==VSMShadowMap&&this.type===VSMShadowMap,St=rt===VSMShadowMap&&this.type!==VSMShadowMap;for(let Et=0,vt=ct.length;Et<vt;Et++){const Nt=ct[Et],wt=Nt.shadow;if(wt===void 0){console.warn("THREE.WebGLShadowMap:",Nt,"has no shadow.");continue}if(wt.autoUpdate===!1&&wt.needsUpdate===!1)continue;o.copy(wt.mapSize);const $t=wt.getFrameExtents();if(o.multiply($t),c.copy(wt.mapSize),(o.x>b||o.y>b)&&(o.x>b&&(c.x=Math.floor(b/$t.x),o.x=c.x*$t.x,wt.mapSize.x=c.x),o.y>b&&(c.y=Math.floor(b/$t.y),o.y=c.y*$t.y,wt.mapSize.y=c.y)),wt.map===null||yt===!0||St===!0){const Mt=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};wt.map!==null&&wt.map.dispose(),wt.map=new WebGLRenderTarget(o.x,o.y,Mt),wt.map.texture.name=Nt.name+".shadowMap",wt.camera.updateProjectionMatrix()}a.setRenderTarget(wt.map),a.clear();const Ct=wt.getViewportCount();for(let Mt=0;Mt<Ct;Mt++){const Ot=wt.getViewport(Mt);d.set(c.x*Ot.x,c.y*Ot.y,c.x*Ot.z,c.y*Ot.w),mt.viewport(d),wt.updateMatrices(Nt,Mt),s=wt.getFrustum(),st(lt,dt,wt.camera,Nt,this.type)}wt.isPointLightShadow!==!0&&this.type===VSMShadowMap&&it(wt,dt),wt.needsUpdate=!1}rt=this.type,nt.needsUpdate=!1,a.setRenderTarget(xt,ut,ft)};function it(ct,lt){const dt=e.update(et);j.defines.VSM_SAMPLES!==ct.blurSamples&&(j.defines.VSM_SAMPLES=ct.blurSamples,_e.defines.VSM_SAMPLES=ct.blurSamples,j.needsUpdate=!0,_e.needsUpdate=!0),ct.mapPass===null&&(ct.mapPass=new WebGLRenderTarget(o.x,o.y)),j.uniforms.shadow_pass.value=ct.map.texture,j.uniforms.resolution.value=ct.mapSize,j.uniforms.radius.value=ct.radius,a.setRenderTarget(ct.mapPass),a.clear(),a.renderBufferDirect(lt,null,dt,j,et,null),_e.uniforms.shadow_pass.value=ct.mapPass.texture,_e.uniforms.resolution.value=ct.mapSize,_e.uniforms.radius.value=ct.radius,a.setRenderTarget(ct.map),a.clear(),a.renderBufferDirect(lt,null,dt,_e,et,null)}function at(ct,lt,dt,xt){let ut=null;const ft=dt.isPointLight===!0?ct.customDistanceMaterial:ct.customDepthMaterial;if(ft!==void 0)ut=ft;else if(ut=dt.isPointLight===!0?g:h,a.localClippingEnabled&&lt.clipShadows===!0&&Array.isArray(lt.clippingPlanes)&&lt.clippingPlanes.length!==0||lt.displacementMap&&lt.displacementScale!==0||lt.alphaMap&&lt.alphaTest>0||lt.map&&lt.alphaTest>0){const mt=ut.uuid,yt=lt.uuid;let St=_[mt];St===void 0&&(St={},_[mt]=St);let Et=St[yt];Et===void 0&&(Et=ut.clone(),St[yt]=Et,lt.addEventListener("dispose",ot)),ut=Et}if(ut.visible=lt.visible,ut.wireframe=lt.wireframe,xt===VSMShadowMap?ut.side=lt.shadowSide!==null?lt.shadowSide:lt.side:ut.side=lt.shadowSide!==null?lt.shadowSide:$[lt.side],ut.alphaMap=lt.alphaMap,ut.alphaTest=lt.alphaTest,ut.map=lt.map,ut.clipShadows=lt.clipShadows,ut.clippingPlanes=lt.clippingPlanes,ut.clipIntersection=lt.clipIntersection,ut.displacementMap=lt.displacementMap,ut.displacementScale=lt.displacementScale,ut.displacementBias=lt.displacementBias,ut.wireframeLinewidth=lt.wireframeLinewidth,ut.linewidth=lt.linewidth,dt.isPointLight===!0&&ut.isMeshDistanceMaterial===!0){const mt=a.properties.get(ut);mt.light=dt}return ut}function st(ct,lt,dt,xt,ut){if(ct.visible===!1)return;if(ct.layers.test(lt.layers)&&(ct.isMesh||ct.isLine||ct.isPoints)&&(ct.castShadow||ct.receiveShadow&&ut===VSMShadowMap)&&(!ct.frustumCulled||s.intersectsObject(ct))){ct.modelViewMatrix.multiplyMatrices(dt.matrixWorldInverse,ct.matrixWorld);const yt=e.update(ct),St=ct.material;if(Array.isArray(St)){const Et=yt.groups;for(let vt=0,Nt=Et.length;vt<Nt;vt++){const wt=Et[vt],$t=St[wt.materialIndex];if($t&&$t.visible){const Ct=at(ct,$t,xt,ut);ct.onBeforeShadow(a,ct,lt,dt,yt,Ct,wt),a.renderBufferDirect(dt,null,yt,Ct,ct,wt),ct.onAfterShadow(a,ct,lt,dt,yt,Ct,wt)}}}else if(St.visible){const Et=at(ct,St,xt,ut);ct.onBeforeShadow(a,ct,lt,dt,yt,Et,null),a.renderBufferDirect(dt,null,yt,Et,ct,null),ct.onAfterShadow(a,ct,lt,dt,yt,Et,null)}}const mt=ct.children;for(let yt=0,St=mt.length;yt<St;yt++)st(mt[yt],lt,dt,xt,ut)}function ot(ct){ct.target.removeEventListener("dispose",ot);for(const dt in _){const xt=_[dt],ut=ct.target.uuid;ut in xt&&(xt[ut].dispose(),delete xt[ut])}}}function WebGLState(a){function e(){let Tt=!1;const Yt=new Vector4;let Jt=null;const an=new Vector4(0,0,0,0);return{setMask:function(fn){Jt!==fn&&!Tt&&(a.colorMask(fn,fn,fn,fn),Jt=fn)},setLocked:function(fn){Tt=fn},setClear:function(fn,Cn,vn,or,lr){lr===!0&&(fn*=or,Cn*=or,vn*=or),Yt.set(fn,Cn,vn,or),an.equals(Yt)===!1&&(a.clearColor(fn,Cn,vn,or),an.copy(Yt))},reset:function(){Tt=!1,Jt=null,an.set(-1,0,0,0)}}}function i(){let Tt=!1,Yt=null,Jt=null,an=null;return{setTest:function(fn){fn?Ft(a.DEPTH_TEST):Bt(a.DEPTH_TEST)},setMask:function(fn){Yt!==fn&&!Tt&&(a.depthMask(fn),Yt=fn)},setFunc:function(fn){if(Jt!==fn){switch(fn){case NeverDepth:a.depthFunc(a.NEVER);break;case AlwaysDepth:a.depthFunc(a.ALWAYS);break;case LessDepth:a.depthFunc(a.LESS);break;case LessEqualDepth:a.depthFunc(a.LEQUAL);break;case EqualDepth:a.depthFunc(a.EQUAL);break;case GreaterEqualDepth:a.depthFunc(a.GEQUAL);break;case GreaterDepth:a.depthFunc(a.GREATER);break;case NotEqualDepth:a.depthFunc(a.NOTEQUAL);break;default:a.depthFunc(a.LEQUAL)}Jt=fn}},setLocked:function(fn){Tt=fn},setClear:function(fn){an!==fn&&(a.clearDepth(fn),an=fn)},reset:function(){Tt=!1,Yt=null,Jt=null,an=null}}}function s(){let Tt=!1,Yt=null,Jt=null,an=null,fn=null,Cn=null,vn=null,or=null,lr=null;return{setTest:function(qn){Tt||(qn?Ft(a.STENCIL_TEST):Bt(a.STENCIL_TEST))},setMask:function(qn){Yt!==qn&&!Tt&&(a.stencilMask(qn),Yt=qn)},setFunc:function(qn,ur,er){(Jt!==qn||an!==ur||fn!==er)&&(a.stencilFunc(qn,ur,er),Jt=qn,an=ur,fn=er)},setOp:function(qn,ur,er){(Cn!==qn||vn!==ur||or!==er)&&(a.stencilOp(qn,ur,er),Cn=qn,vn=ur,or=er)},setLocked:function(qn){Tt=qn},setClear:function(qn){lr!==qn&&(a.clearStencil(qn),lr=qn)},reset:function(){Tt=!1,Yt=null,Jt=null,an=null,fn=null,Cn=null,vn=null,or=null,lr=null}}}const o=new e,c=new i,d=new s,h=new WeakMap,g=new WeakMap;let _={},b={},$=new WeakMap,j=[],_e=null,tt=!1,et=null,nt=null,rt=null,it=null,at=null,st=null,ot=null,ct=new Color(0,0,0),lt=0,dt=!1,xt=null,ut=null,ft=null,mt=null,yt=null;const St=a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let Et=!1,vt=0;const Nt=a.getParameter(a.VERSION);Nt.indexOf("WebGL")!==-1?(vt=parseFloat(/^WebGL (\d)/.exec(Nt)[1]),Et=vt>=1):Nt.indexOf("OpenGL ES")!==-1&&(vt=parseFloat(/^OpenGL ES (\d)/.exec(Nt)[1]),Et=vt>=2);let wt=null,$t={};const Ct=a.getParameter(a.SCISSOR_BOX),Mt=a.getParameter(a.VIEWPORT),Ot=new Vector4().fromArray(Ct),Dt=new Vector4().fromArray(Mt);function At(Tt,Yt,Jt,an){const fn=new Uint8Array(4),Cn=a.createTexture();a.bindTexture(Tt,Cn),a.texParameteri(Tt,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(Tt,a.TEXTURE_MAG_FILTER,a.NEAREST);for(let vn=0;vn<Jt;vn++)Tt===a.TEXTURE_3D||Tt===a.TEXTURE_2D_ARRAY?a.texImage3D(Yt,0,a.RGBA,1,1,an,0,a.RGBA,a.UNSIGNED_BYTE,fn):a.texImage2D(Yt+vn,0,a.RGBA,1,1,0,a.RGBA,a.UNSIGNED_BYTE,fn);return Cn}const kt={};kt[a.TEXTURE_2D]=At(a.TEXTURE_2D,a.TEXTURE_2D,1),kt[a.TEXTURE_CUBE_MAP]=At(a.TEXTURE_CUBE_MAP,a.TEXTURE_CUBE_MAP_POSITIVE_X,6),kt[a.TEXTURE_2D_ARRAY]=At(a.TEXTURE_2D_ARRAY,a.TEXTURE_2D_ARRAY,1,1),kt[a.TEXTURE_3D]=At(a.TEXTURE_3D,a.TEXTURE_3D,1,1),o.setClear(0,0,0,1),c.setClear(1),d.setClear(0),Ft(a.DEPTH_TEST),c.setFunc(LessEqualDepth),sn(!1),hn(CullFaceBack),Ft(a.CULL_FACE),rn(NoBlending);function Ft(Tt){_[Tt]!==!0&&(a.enable(Tt),_[Tt]=!0)}function Bt(Tt){_[Tt]!==!1&&(a.disable(Tt),_[Tt]=!1)}function Ht(Tt,Yt){return b[Tt]!==Yt?(a.bindFramebuffer(Tt,Yt),b[Tt]=Yt,Tt===a.DRAW_FRAMEBUFFER&&(b[a.FRAMEBUFFER]=Yt),Tt===a.FRAMEBUFFER&&(b[a.DRAW_FRAMEBUFFER]=Yt),!0):!1}function Wt(Tt,Yt){let Jt=j,an=!1;if(Tt){Jt=$.get(Yt),Jt===void 0&&(Jt=[],$.set(Yt,Jt));const fn=Tt.textures;if(Jt.length!==fn.length||Jt[0]!==a.COLOR_ATTACHMENT0){for(let Cn=0,vn=fn.length;Cn<vn;Cn++)Jt[Cn]=a.COLOR_ATTACHMENT0+Cn;Jt.length=fn.length,an=!0}}else Jt[0]!==a.BACK&&(Jt[0]=a.BACK,an=!0);an&&a.drawBuffers(Jt)}function Ut(Tt){return _e!==Tt?(a.useProgram(Tt),_e=Tt,!0):!1}const Rt={[AddEquation]:a.FUNC_ADD,[SubtractEquation]:a.FUNC_SUBTRACT,[ReverseSubtractEquation]:a.FUNC_REVERSE_SUBTRACT};Rt[MinEquation]=a.MIN,Rt[MaxEquation]=a.MAX;const un={[ZeroFactor]:a.ZERO,[OneFactor]:a.ONE,[SrcColorFactor]:a.SRC_COLOR,[SrcAlphaFactor]:a.SRC_ALPHA,[SrcAlphaSaturateFactor]:a.SRC_ALPHA_SATURATE,[DstColorFactor]:a.DST_COLOR,[DstAlphaFactor]:a.DST_ALPHA,[OneMinusSrcColorFactor]:a.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:a.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:a.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:a.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:a.CONSTANT_COLOR,[OneMinusConstantColorFactor]:a.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:a.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:a.ONE_MINUS_CONSTANT_ALPHA};function rn(Tt,Yt,Jt,an,fn,Cn,vn,or,lr,qn){if(Tt===NoBlending){tt===!0&&(Bt(a.BLEND),tt=!1);return}if(tt===!1&&(Ft(a.BLEND),tt=!0),Tt!==CustomBlending){if(Tt!==et||qn!==dt){if((nt!==AddEquation||at!==AddEquation)&&(a.blendEquation(a.FUNC_ADD),nt=AddEquation,at=AddEquation),qn)switch(Tt){case NormalBlending:a.blendFuncSeparate(a.ONE,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:a.blendFunc(a.ONE,a.ONE);break;case SubtractiveBlending:a.blendFuncSeparate(a.ZERO,a.ONE_MINUS_SRC_COLOR,a.ZERO,a.ONE);break;case MultiplyBlending:a.blendFuncSeparate(a.ZERO,a.SRC_COLOR,a.ZERO,a.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",Tt);break}else switch(Tt){case NormalBlending:a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:a.blendFunc(a.SRC_ALPHA,a.ONE);break;case SubtractiveBlending:a.blendFuncSeparate(a.ZERO,a.ONE_MINUS_SRC_COLOR,a.ZERO,a.ONE);break;case MultiplyBlending:a.blendFunc(a.ZERO,a.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",Tt);break}rt=null,it=null,st=null,ot=null,ct.set(0,0,0),lt=0,et=Tt,dt=qn}return}fn=fn||Yt,Cn=Cn||Jt,vn=vn||an,(Yt!==nt||fn!==at)&&(a.blendEquationSeparate(Rt[Yt],Rt[fn]),nt=Yt,at=fn),(Jt!==rt||an!==it||Cn!==st||vn!==ot)&&(a.blendFuncSeparate(un[Jt],un[an],un[Cn],un[vn]),rt=Jt,it=an,st=Cn,ot=vn),(or.equals(ct)===!1||lr!==lt)&&(a.blendColor(or.r,or.g,or.b,lr),ct.copy(or),lt=lr),et=Tt,dt=!1}function mn(Tt,Yt){Tt.side===DoubleSide?Bt(a.CULL_FACE):Ft(a.CULL_FACE);let Jt=Tt.side===BackSide;Yt&&(Jt=!Jt),sn(Jt),Tt.blending===NormalBlending&&Tt.transparent===!1?rn(NoBlending):rn(Tt.blending,Tt.blendEquation,Tt.blendSrc,Tt.blendDst,Tt.blendEquationAlpha,Tt.blendSrcAlpha,Tt.blendDstAlpha,Tt.blendColor,Tt.blendAlpha,Tt.premultipliedAlpha),c.setFunc(Tt.depthFunc),c.setTest(Tt.depthTest),c.setMask(Tt.depthWrite),o.setMask(Tt.colorWrite);const an=Tt.stencilWrite;d.setTest(an),an&&(d.setMask(Tt.stencilWriteMask),d.setFunc(Tt.stencilFunc,Tt.stencilRef,Tt.stencilFuncMask),d.setOp(Tt.stencilFail,Tt.stencilZFail,Tt.stencilZPass)),Xt(Tt.polygonOffset,Tt.polygonOffsetFactor,Tt.polygonOffsetUnits),Tt.alphaToCoverage===!0?Ft(a.SAMPLE_ALPHA_TO_COVERAGE):Bt(a.SAMPLE_ALPHA_TO_COVERAGE)}function sn(Tt){xt!==Tt&&(Tt?a.frontFace(a.CW):a.frontFace(a.CCW),xt=Tt)}function hn(Tt){Tt!==CullFaceNone?(Ft(a.CULL_FACE),Tt!==ut&&(Tt===CullFaceBack?a.cullFace(a.BACK):Tt===CullFaceFront?a.cullFace(a.FRONT):a.cullFace(a.FRONT_AND_BACK))):Bt(a.CULL_FACE),ut=Tt}function gn(Tt){Tt!==ft&&(Et&&a.lineWidth(Tt),ft=Tt)}function Xt(Tt,Yt,Jt){Tt?(Ft(a.POLYGON_OFFSET_FILL),(mt!==Yt||yt!==Jt)&&(a.polygonOffset(Yt,Jt),mt=Yt,yt=Jt)):Bt(a.POLYGON_OFFSET_FILL)}function En(Tt){Tt?Ft(a.SCISSOR_TEST):Bt(a.SCISSOR_TEST)}function bt(Tt){Tt===void 0&&(Tt=a.TEXTURE0+St-1),wt!==Tt&&(a.activeTexture(Tt),wt=Tt)}function gt(Tt,Yt,Jt){Jt===void 0&&(wt===null?Jt=a.TEXTURE0+St-1:Jt=wt);let an=$t[Jt];an===void 0&&(an={type:void 0,texture:void 0},$t[Jt]=an),(an.type!==Tt||an.texture!==Yt)&&(wt!==Jt&&(a.activeTexture(Jt),wt=Jt),a.bindTexture(Tt,Yt||kt[Tt]),an.type=Tt,an.texture=Yt)}function Pt(){const Tt=$t[wt];Tt!==void 0&&Tt.type!==void 0&&(a.bindTexture(Tt.type,null),Tt.type=void 0,Tt.texture=void 0)}function Lt(){try{a.compressedTexImage2D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function Vt(){try{a.compressedTexImage3D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function jt(){try{a.texSubImage2D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function cn(){try{a.texSubImage3D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function en(){try{a.compressedTexSubImage2D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function Zt(){try{a.compressedTexSubImage3D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function yn(){try{a.texStorage2D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function pn(){try{a.texStorage3D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function wn(){try{a.texImage2D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function Pn(){try{a.texImage3D.apply(a,arguments)}catch(Tt){console.error("THREE.WebGLState:",Tt)}}function Rn(Tt){Ot.equals(Tt)===!1&&(a.scissor(Tt.x,Tt.y,Tt.z,Tt.w),Ot.copy(Tt))}function Sn(Tt){Dt.equals(Tt)===!1&&(a.viewport(Tt.x,Tt.y,Tt.z,Tt.w),Dt.copy(Tt))}function On(Tt,Yt){let Jt=g.get(Yt);Jt===void 0&&(Jt=new WeakMap,g.set(Yt,Jt));let an=Jt.get(Tt);an===void 0&&(an=a.getUniformBlockIndex(Yt,Tt.name),Jt.set(Tt,an))}function Nn(Tt,Yt){const an=g.get(Yt).get(Tt);h.get(Yt)!==an&&(a.uniformBlockBinding(Yt,an,Tt.__bindingPointIndex),h.set(Yt,an))}function rr(){a.disable(a.BLEND),a.disable(a.CULL_FACE),a.disable(a.DEPTH_TEST),a.disable(a.POLYGON_OFFSET_FILL),a.disable(a.SCISSOR_TEST),a.disable(a.STENCIL_TEST),a.disable(a.SAMPLE_ALPHA_TO_COVERAGE),a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ONE,a.ZERO),a.blendFuncSeparate(a.ONE,a.ZERO,a.ONE,a.ZERO),a.blendColor(0,0,0,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(a.LESS),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(a.ALWAYS,0,4294967295),a.stencilOp(a.KEEP,a.KEEP,a.KEEP),a.clearStencil(0),a.cullFace(a.BACK),a.frontFace(a.CCW),a.polygonOffset(0,0),a.activeTexture(a.TEXTURE0),a.bindFramebuffer(a.FRAMEBUFFER,null),a.bindFramebuffer(a.DRAW_FRAMEBUFFER,null),a.bindFramebuffer(a.READ_FRAMEBUFFER,null),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),_={},wt=null,$t={},b={},$=new WeakMap,j=[],_e=null,tt=!1,et=null,nt=null,rt=null,it=null,at=null,st=null,ot=null,ct=new Color(0,0,0),lt=0,dt=!1,xt=null,ut=null,ft=null,mt=null,yt=null,Ot.set(0,0,a.canvas.width,a.canvas.height),Dt.set(0,0,a.canvas.width,a.canvas.height),o.reset(),c.reset(),d.reset()}return{buffers:{color:o,depth:c,stencil:d},enable:Ft,disable:Bt,bindFramebuffer:Ht,drawBuffers:Wt,useProgram:Ut,setBlending:rn,setMaterial:mn,setFlipSided:sn,setCullFace:hn,setLineWidth:gn,setPolygonOffset:Xt,setScissorTest:En,activeTexture:bt,bindTexture:gt,unbindTexture:Pt,compressedTexImage2D:Lt,compressedTexImage3D:Vt,texImage2D:wn,texImage3D:Pn,updateUBOMapping:On,uniformBlockBinding:Nn,texStorage2D:yn,texStorage3D:pn,texSubImage2D:jt,texSubImage3D:cn,compressedTexSubImage2D:en,compressedTexSubImage3D:Zt,scissor:Rn,viewport:Sn,reset:rr}}function WebGLTextures(a,e,i,s,o,c,d){const h=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,g=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),_=new Vector2,b=new WeakMap;let $;const j=new WeakMap;let _e=!1;try{_e=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function tt(bt,gt){return _e?new OffscreenCanvas(bt,gt):createElementNS("canvas")}function et(bt,gt,Pt){let Lt=1;const Vt=En(bt);if((Vt.width>Pt||Vt.height>Pt)&&(Lt=Pt/Math.max(Vt.width,Vt.height)),Lt<1)if(typeof HTMLImageElement<"u"&&bt instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&bt instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&bt instanceof ImageBitmap||typeof VideoFrame<"u"&&bt instanceof VideoFrame){const jt=Math.floor(Lt*Vt.width),cn=Math.floor(Lt*Vt.height);$===void 0&&($=tt(jt,cn));const en=gt?tt(jt,cn):$;return en.width=jt,en.height=cn,en.getContext("2d").drawImage(bt,0,0,jt,cn),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Vt.width+"x"+Vt.height+") to ("+jt+"x"+cn+")."),en}else return"data"in bt&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Vt.width+"x"+Vt.height+")."),bt;return bt}function nt(bt){return bt.generateMipmaps&&bt.minFilter!==NearestFilter&&bt.minFilter!==LinearFilter}function rt(bt){a.generateMipmap(bt)}function it(bt,gt,Pt,Lt,Vt=!1){if(bt!==null){if(a[bt]!==void 0)return a[bt];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+bt+"'")}let jt=gt;if(gt===a.RED&&(Pt===a.FLOAT&&(jt=a.R32F),Pt===a.HALF_FLOAT&&(jt=a.R16F),Pt===a.UNSIGNED_BYTE&&(jt=a.R8)),gt===a.RED_INTEGER&&(Pt===a.UNSIGNED_BYTE&&(jt=a.R8UI),Pt===a.UNSIGNED_SHORT&&(jt=a.R16UI),Pt===a.UNSIGNED_INT&&(jt=a.R32UI),Pt===a.BYTE&&(jt=a.R8I),Pt===a.SHORT&&(jt=a.R16I),Pt===a.INT&&(jt=a.R32I)),gt===a.RG&&(Pt===a.FLOAT&&(jt=a.RG32F),Pt===a.HALF_FLOAT&&(jt=a.RG16F),Pt===a.UNSIGNED_BYTE&&(jt=a.RG8)),gt===a.RG_INTEGER&&(Pt===a.UNSIGNED_BYTE&&(jt=a.RG8UI),Pt===a.UNSIGNED_SHORT&&(jt=a.RG16UI),Pt===a.UNSIGNED_INT&&(jt=a.RG32UI),Pt===a.BYTE&&(jt=a.RG8I),Pt===a.SHORT&&(jt=a.RG16I),Pt===a.INT&&(jt=a.RG32I)),gt===a.RGB&&Pt===a.UNSIGNED_INT_5_9_9_9_REV&&(jt=a.RGB9_E5),gt===a.RGBA){const cn=Vt?LinearTransfer:ColorManagement.getTransfer(Lt);Pt===a.FLOAT&&(jt=a.RGBA32F),Pt===a.HALF_FLOAT&&(jt=a.RGBA16F),Pt===a.UNSIGNED_BYTE&&(jt=cn===SRGBTransfer?a.SRGB8_ALPHA8:a.RGBA8),Pt===a.UNSIGNED_SHORT_4_4_4_4&&(jt=a.RGBA4),Pt===a.UNSIGNED_SHORT_5_5_5_1&&(jt=a.RGB5_A1)}return(jt===a.R16F||jt===a.R32F||jt===a.RG16F||jt===a.RG32F||jt===a.RGBA16F||jt===a.RGBA32F)&&e.get("EXT_color_buffer_float"),jt}function at(bt,gt){let Pt;return bt?gt===null||gt===UnsignedIntType||gt===UnsignedInt248Type?Pt=a.DEPTH24_STENCIL8:gt===FloatType?Pt=a.DEPTH32F_STENCIL8:gt===UnsignedShortType&&(Pt=a.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):gt===null||gt===UnsignedIntType||gt===UnsignedInt248Type?Pt=a.DEPTH_COMPONENT24:gt===FloatType?Pt=a.DEPTH_COMPONENT32F:gt===UnsignedShortType&&(Pt=a.DEPTH_COMPONENT16),Pt}function st(bt,gt){return nt(bt)===!0||bt.isFramebufferTexture&&bt.minFilter!==NearestFilter&&bt.minFilter!==LinearFilter?Math.log2(Math.max(gt.width,gt.height))+1:bt.mipmaps!==void 0&&bt.mipmaps.length>0?bt.mipmaps.length:bt.isCompressedTexture&&Array.isArray(bt.image)?gt.mipmaps.length:1}function ot(bt){const gt=bt.target;gt.removeEventListener("dispose",ot),lt(gt),gt.isVideoTexture&&b.delete(gt)}function ct(bt){const gt=bt.target;gt.removeEventListener("dispose",ct),xt(gt)}function lt(bt){const gt=s.get(bt);if(gt.__webglInit===void 0)return;const Pt=bt.source,Lt=j.get(Pt);if(Lt){const Vt=Lt[gt.__cacheKey];Vt.usedTimes--,Vt.usedTimes===0&&dt(bt),Object.keys(Lt).length===0&&j.delete(Pt)}s.remove(bt)}function dt(bt){const gt=s.get(bt);a.deleteTexture(gt.__webglTexture);const Pt=bt.source,Lt=j.get(Pt);delete Lt[gt.__cacheKey],d.memory.textures--}function xt(bt){const gt=s.get(bt);if(bt.depthTexture&&bt.depthTexture.dispose(),bt.isWebGLCubeRenderTarget)for(let Lt=0;Lt<6;Lt++){if(Array.isArray(gt.__webglFramebuffer[Lt]))for(let Vt=0;Vt<gt.__webglFramebuffer[Lt].length;Vt++)a.deleteFramebuffer(gt.__webglFramebuffer[Lt][Vt]);else a.deleteFramebuffer(gt.__webglFramebuffer[Lt]);gt.__webglDepthbuffer&&a.deleteRenderbuffer(gt.__webglDepthbuffer[Lt])}else{if(Array.isArray(gt.__webglFramebuffer))for(let Lt=0;Lt<gt.__webglFramebuffer.length;Lt++)a.deleteFramebuffer(gt.__webglFramebuffer[Lt]);else a.deleteFramebuffer(gt.__webglFramebuffer);if(gt.__webglDepthbuffer&&a.deleteRenderbuffer(gt.__webglDepthbuffer),gt.__webglMultisampledFramebuffer&&a.deleteFramebuffer(gt.__webglMultisampledFramebuffer),gt.__webglColorRenderbuffer)for(let Lt=0;Lt<gt.__webglColorRenderbuffer.length;Lt++)gt.__webglColorRenderbuffer[Lt]&&a.deleteRenderbuffer(gt.__webglColorRenderbuffer[Lt]);gt.__webglDepthRenderbuffer&&a.deleteRenderbuffer(gt.__webglDepthRenderbuffer)}const Pt=bt.textures;for(let Lt=0,Vt=Pt.length;Lt<Vt;Lt++){const jt=s.get(Pt[Lt]);jt.__webglTexture&&(a.deleteTexture(jt.__webglTexture),d.memory.textures--),s.remove(Pt[Lt])}s.remove(bt)}let ut=0;function ft(){ut=0}function mt(){const bt=ut;return bt>=o.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+bt+" texture units while this GPU supports only "+o.maxTextures),ut+=1,bt}function yt(bt){const gt=[];return gt.push(bt.wrapS),gt.push(bt.wrapT),gt.push(bt.wrapR||0),gt.push(bt.magFilter),gt.push(bt.minFilter),gt.push(bt.anisotropy),gt.push(bt.internalFormat),gt.push(bt.format),gt.push(bt.type),gt.push(bt.generateMipmaps),gt.push(bt.premultiplyAlpha),gt.push(bt.flipY),gt.push(bt.unpackAlignment),gt.push(bt.colorSpace),gt.join()}function St(bt,gt){const Pt=s.get(bt);if(bt.isVideoTexture&&gn(bt),bt.isRenderTargetTexture===!1&&bt.version>0&&Pt.__version!==bt.version){const Lt=bt.image;if(Lt===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Lt.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Dt(Pt,bt,gt);return}}i.bindTexture(a.TEXTURE_2D,Pt.__webglTexture,a.TEXTURE0+gt)}function Et(bt,gt){const Pt=s.get(bt);if(bt.version>0&&Pt.__version!==bt.version){Dt(Pt,bt,gt);return}i.bindTexture(a.TEXTURE_2D_ARRAY,Pt.__webglTexture,a.TEXTURE0+gt)}function vt(bt,gt){const Pt=s.get(bt);if(bt.version>0&&Pt.__version!==bt.version){Dt(Pt,bt,gt);return}i.bindTexture(a.TEXTURE_3D,Pt.__webglTexture,a.TEXTURE0+gt)}function Nt(bt,gt){const Pt=s.get(bt);if(bt.version>0&&Pt.__version!==bt.version){At(Pt,bt,gt);return}i.bindTexture(a.TEXTURE_CUBE_MAP,Pt.__webglTexture,a.TEXTURE0+gt)}const wt={[RepeatWrapping]:a.REPEAT,[ClampToEdgeWrapping]:a.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:a.MIRRORED_REPEAT},$t={[NearestFilter]:a.NEAREST,[NearestMipmapNearestFilter]:a.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:a.NEAREST_MIPMAP_LINEAR,[LinearFilter]:a.LINEAR,[LinearMipmapNearestFilter]:a.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:a.LINEAR_MIPMAP_LINEAR},Ct={[NeverCompare]:a.NEVER,[AlwaysCompare]:a.ALWAYS,[LessCompare]:a.LESS,[LessEqualCompare]:a.LEQUAL,[EqualCompare]:a.EQUAL,[GreaterEqualCompare]:a.GEQUAL,[GreaterCompare]:a.GREATER,[NotEqualCompare]:a.NOTEQUAL};function Mt(bt,gt){if(gt.type===FloatType&&e.has("OES_texture_float_linear")===!1&&(gt.magFilter===LinearFilter||gt.magFilter===LinearMipmapNearestFilter||gt.magFilter===NearestMipmapLinearFilter||gt.magFilter===LinearMipmapLinearFilter||gt.minFilter===LinearFilter||gt.minFilter===LinearMipmapNearestFilter||gt.minFilter===NearestMipmapLinearFilter||gt.minFilter===LinearMipmapLinearFilter)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),a.texParameteri(bt,a.TEXTURE_WRAP_S,wt[gt.wrapS]),a.texParameteri(bt,a.TEXTURE_WRAP_T,wt[gt.wrapT]),(bt===a.TEXTURE_3D||bt===a.TEXTURE_2D_ARRAY)&&a.texParameteri(bt,a.TEXTURE_WRAP_R,wt[gt.wrapR]),a.texParameteri(bt,a.TEXTURE_MAG_FILTER,$t[gt.magFilter]),a.texParameteri(bt,a.TEXTURE_MIN_FILTER,$t[gt.minFilter]),gt.compareFunction&&(a.texParameteri(bt,a.TEXTURE_COMPARE_MODE,a.COMPARE_REF_TO_TEXTURE),a.texParameteri(bt,a.TEXTURE_COMPARE_FUNC,Ct[gt.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(gt.magFilter===NearestFilter||gt.minFilter!==NearestMipmapLinearFilter&&gt.minFilter!==LinearMipmapLinearFilter||gt.type===FloatType&&e.has("OES_texture_float_linear")===!1)return;if(gt.anisotropy>1||s.get(gt).__currentAnisotropy){const Pt=e.get("EXT_texture_filter_anisotropic");a.texParameterf(bt,Pt.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(gt.anisotropy,o.getMaxAnisotropy())),s.get(gt).__currentAnisotropy=gt.anisotropy}}}function Ot(bt,gt){let Pt=!1;bt.__webglInit===void 0&&(bt.__webglInit=!0,gt.addEventListener("dispose",ot));const Lt=gt.source;let Vt=j.get(Lt);Vt===void 0&&(Vt={},j.set(Lt,Vt));const jt=yt(gt);if(jt!==bt.__cacheKey){Vt[jt]===void 0&&(Vt[jt]={texture:a.createTexture(),usedTimes:0},d.memory.textures++,Pt=!0),Vt[jt].usedTimes++;const cn=Vt[bt.__cacheKey];cn!==void 0&&(Vt[bt.__cacheKey].usedTimes--,cn.usedTimes===0&&dt(gt)),bt.__cacheKey=jt,bt.__webglTexture=Vt[jt].texture}return Pt}function Dt(bt,gt,Pt){let Lt=a.TEXTURE_2D;(gt.isDataArrayTexture||gt.isCompressedArrayTexture)&&(Lt=a.TEXTURE_2D_ARRAY),gt.isData3DTexture&&(Lt=a.TEXTURE_3D);const Vt=Ot(bt,gt),jt=gt.source;i.bindTexture(Lt,bt.__webglTexture,a.TEXTURE0+Pt);const cn=s.get(jt);if(jt.version!==cn.__version||Vt===!0){i.activeTexture(a.TEXTURE0+Pt);const en=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),Zt=gt.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(gt.colorSpace),yn=gt.colorSpace===NoColorSpace||en===Zt?a.NONE:a.BROWSER_DEFAULT_WEBGL;a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,gt.flipY),a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,gt.premultiplyAlpha),a.pixelStorei(a.UNPACK_ALIGNMENT,gt.unpackAlignment),a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,yn);let pn=et(gt.image,!1,o.maxTextureSize);pn=Xt(gt,pn);const wn=c.convert(gt.format,gt.colorSpace),Pn=c.convert(gt.type);let Rn=it(gt.internalFormat,wn,Pn,gt.colorSpace,gt.isVideoTexture);Mt(Lt,gt);let Sn;const On=gt.mipmaps,Nn=gt.isVideoTexture!==!0,rr=cn.__version===void 0||Vt===!0,Tt=jt.dataReady,Yt=st(gt,pn);if(gt.isDepthTexture)Rn=at(gt.format===DepthStencilFormat,gt.type),rr&&(Nn?i.texStorage2D(a.TEXTURE_2D,1,Rn,pn.width,pn.height):i.texImage2D(a.TEXTURE_2D,0,Rn,pn.width,pn.height,0,wn,Pn,null));else if(gt.isDataTexture)if(On.length>0){Nn&&rr&&i.texStorage2D(a.TEXTURE_2D,Yt,Rn,On[0].width,On[0].height);for(let Jt=0,an=On.length;Jt<an;Jt++)Sn=On[Jt],Nn?Tt&&i.texSubImage2D(a.TEXTURE_2D,Jt,0,0,Sn.width,Sn.height,wn,Pn,Sn.data):i.texImage2D(a.TEXTURE_2D,Jt,Rn,Sn.width,Sn.height,0,wn,Pn,Sn.data);gt.generateMipmaps=!1}else Nn?(rr&&i.texStorage2D(a.TEXTURE_2D,Yt,Rn,pn.width,pn.height),Tt&&i.texSubImage2D(a.TEXTURE_2D,0,0,0,pn.width,pn.height,wn,Pn,pn.data)):i.texImage2D(a.TEXTURE_2D,0,Rn,pn.width,pn.height,0,wn,Pn,pn.data);else if(gt.isCompressedTexture)if(gt.isCompressedArrayTexture){Nn&&rr&&i.texStorage3D(a.TEXTURE_2D_ARRAY,Yt,Rn,On[0].width,On[0].height,pn.depth);for(let Jt=0,an=On.length;Jt<an;Jt++)if(Sn=On[Jt],gt.format!==RGBAFormat)if(wn!==null)if(Nn){if(Tt)if(gt.layerUpdates.size>0){for(const fn of gt.layerUpdates){const Cn=Sn.width*Sn.height;i.compressedTexSubImage3D(a.TEXTURE_2D_ARRAY,Jt,0,0,fn,Sn.width,Sn.height,1,wn,Sn.data.slice(Cn*fn,Cn*(fn+1)),0,0)}gt.clearLayerUpdates()}else i.compressedTexSubImage3D(a.TEXTURE_2D_ARRAY,Jt,0,0,0,Sn.width,Sn.height,pn.depth,wn,Sn.data,0,0)}else i.compressedTexImage3D(a.TEXTURE_2D_ARRAY,Jt,Rn,Sn.width,Sn.height,pn.depth,0,Sn.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else Nn?Tt&&i.texSubImage3D(a.TEXTURE_2D_ARRAY,Jt,0,0,0,Sn.width,Sn.height,pn.depth,wn,Pn,Sn.data):i.texImage3D(a.TEXTURE_2D_ARRAY,Jt,Rn,Sn.width,Sn.height,pn.depth,0,wn,Pn,Sn.data)}else{Nn&&rr&&i.texStorage2D(a.TEXTURE_2D,Yt,Rn,On[0].width,On[0].height);for(let Jt=0,an=On.length;Jt<an;Jt++)Sn=On[Jt],gt.format!==RGBAFormat?wn!==null?Nn?Tt&&i.compressedTexSubImage2D(a.TEXTURE_2D,Jt,0,0,Sn.width,Sn.height,wn,Sn.data):i.compressedTexImage2D(a.TEXTURE_2D,Jt,Rn,Sn.width,Sn.height,0,Sn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Nn?Tt&&i.texSubImage2D(a.TEXTURE_2D,Jt,0,0,Sn.width,Sn.height,wn,Pn,Sn.data):i.texImage2D(a.TEXTURE_2D,Jt,Rn,Sn.width,Sn.height,0,wn,Pn,Sn.data)}else if(gt.isDataArrayTexture)if(Nn){if(rr&&i.texStorage3D(a.TEXTURE_2D_ARRAY,Yt,Rn,pn.width,pn.height,pn.depth),Tt)if(gt.layerUpdates.size>0){let Jt;switch(Pn){case a.UNSIGNED_BYTE:switch(wn){case a.ALPHA:Jt=1;break;case a.LUMINANCE:Jt=1;break;case a.LUMINANCE_ALPHA:Jt=2;break;case a.RGB:Jt=3;break;case a.RGBA:Jt=4;break;default:throw new Error(`Unknown texel size for format ${wn}.`)}break;case a.UNSIGNED_SHORT_4_4_4_4:case a.UNSIGNED_SHORT_5_5_5_1:case a.UNSIGNED_SHORT_5_6_5:Jt=1;break;default:throw new Error(`Unknown texel size for type ${Pn}.`)}const an=pn.width*pn.height*Jt;for(const fn of gt.layerUpdates)i.texSubImage3D(a.TEXTURE_2D_ARRAY,0,0,0,fn,pn.width,pn.height,1,wn,Pn,pn.data.slice(an*fn,an*(fn+1)));gt.clearLayerUpdates()}else i.texSubImage3D(a.TEXTURE_2D_ARRAY,0,0,0,0,pn.width,pn.height,pn.depth,wn,Pn,pn.data)}else i.texImage3D(a.TEXTURE_2D_ARRAY,0,Rn,pn.width,pn.height,pn.depth,0,wn,Pn,pn.data);else if(gt.isData3DTexture)Nn?(rr&&i.texStorage3D(a.TEXTURE_3D,Yt,Rn,pn.width,pn.height,pn.depth),Tt&&i.texSubImage3D(a.TEXTURE_3D,0,0,0,0,pn.width,pn.height,pn.depth,wn,Pn,pn.data)):i.texImage3D(a.TEXTURE_3D,0,Rn,pn.width,pn.height,pn.depth,0,wn,Pn,pn.data);else if(gt.isFramebufferTexture){if(rr)if(Nn)i.texStorage2D(a.TEXTURE_2D,Yt,Rn,pn.width,pn.height);else{let Jt=pn.width,an=pn.height;for(let fn=0;fn<Yt;fn++)i.texImage2D(a.TEXTURE_2D,fn,Rn,Jt,an,0,wn,Pn,null),Jt>>=1,an>>=1}}else if(On.length>0){if(Nn&&rr){const Jt=En(On[0]);i.texStorage2D(a.TEXTURE_2D,Yt,Rn,Jt.width,Jt.height)}for(let Jt=0,an=On.length;Jt<an;Jt++)Sn=On[Jt],Nn?Tt&&i.texSubImage2D(a.TEXTURE_2D,Jt,0,0,wn,Pn,Sn):i.texImage2D(a.TEXTURE_2D,Jt,Rn,wn,Pn,Sn);gt.generateMipmaps=!1}else if(Nn){if(rr){const Jt=En(pn);i.texStorage2D(a.TEXTURE_2D,Yt,Rn,Jt.width,Jt.height)}Tt&&i.texSubImage2D(a.TEXTURE_2D,0,0,0,wn,Pn,pn)}else i.texImage2D(a.TEXTURE_2D,0,Rn,wn,Pn,pn);nt(gt)&&rt(Lt),cn.__version=jt.version,gt.onUpdate&&gt.onUpdate(gt)}bt.__version=gt.version}function At(bt,gt,Pt){if(gt.image.length!==6)return;const Lt=Ot(bt,gt),Vt=gt.source;i.bindTexture(a.TEXTURE_CUBE_MAP,bt.__webglTexture,a.TEXTURE0+Pt);const jt=s.get(Vt);if(Vt.version!==jt.__version||Lt===!0){i.activeTexture(a.TEXTURE0+Pt);const cn=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),en=gt.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(gt.colorSpace),Zt=gt.colorSpace===NoColorSpace||cn===en?a.NONE:a.BROWSER_DEFAULT_WEBGL;a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,gt.flipY),a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL,gt.premultiplyAlpha),a.pixelStorei(a.UNPACK_ALIGNMENT,gt.unpackAlignment),a.pixelStorei(a.UNPACK_COLORSPACE_CONVERSION_WEBGL,Zt);const yn=gt.isCompressedTexture||gt.image[0].isCompressedTexture,pn=gt.image[0]&&gt.image[0].isDataTexture,wn=[];for(let an=0;an<6;an++)!yn&&!pn?wn[an]=et(gt.image[an],!0,o.maxCubemapSize):wn[an]=pn?gt.image[an].image:gt.image[an],wn[an]=Xt(gt,wn[an]);const Pn=wn[0],Rn=c.convert(gt.format,gt.colorSpace),Sn=c.convert(gt.type),On=it(gt.internalFormat,Rn,Sn,gt.colorSpace),Nn=gt.isVideoTexture!==!0,rr=jt.__version===void 0||Lt===!0,Tt=Vt.dataReady;let Yt=st(gt,Pn);Mt(a.TEXTURE_CUBE_MAP,gt);let Jt;if(yn){Nn&&rr&&i.texStorage2D(a.TEXTURE_CUBE_MAP,Yt,On,Pn.width,Pn.height);for(let an=0;an<6;an++){Jt=wn[an].mipmaps;for(let fn=0;fn<Jt.length;fn++){const Cn=Jt[fn];gt.format!==RGBAFormat?Rn!==null?Nn?Tt&&i.compressedTexSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn,0,0,Cn.width,Cn.height,Rn,Cn.data):i.compressedTexImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn,On,Cn.width,Cn.height,0,Cn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Nn?Tt&&i.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn,0,0,Cn.width,Cn.height,Rn,Sn,Cn.data):i.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn,On,Cn.width,Cn.height,0,Rn,Sn,Cn.data)}}}else{if(Jt=gt.mipmaps,Nn&&rr){Jt.length>0&&Yt++;const an=En(wn[0]);i.texStorage2D(a.TEXTURE_CUBE_MAP,Yt,On,an.width,an.height)}for(let an=0;an<6;an++)if(pn){Nn?Tt&&i.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,0,0,0,wn[an].width,wn[an].height,Rn,Sn,wn[an].data):i.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,0,On,wn[an].width,wn[an].height,0,Rn,Sn,wn[an].data);for(let fn=0;fn<Jt.length;fn++){const vn=Jt[fn].image[an].image;Nn?Tt&&i.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn+1,0,0,vn.width,vn.height,Rn,Sn,vn.data):i.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn+1,On,vn.width,vn.height,0,Rn,Sn,vn.data)}}else{Nn?Tt&&i.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,0,0,0,Rn,Sn,wn[an]):i.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,0,On,Rn,Sn,wn[an]);for(let fn=0;fn<Jt.length;fn++){const Cn=Jt[fn];Nn?Tt&&i.texSubImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn+1,0,0,Rn,Sn,Cn.image[an]):i.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X+an,fn+1,On,Rn,Sn,Cn.image[an])}}}nt(gt)&&rt(a.TEXTURE_CUBE_MAP),jt.__version=Vt.version,gt.onUpdate&&gt.onUpdate(gt)}bt.__version=gt.version}function kt(bt,gt,Pt,Lt,Vt,jt){const cn=c.convert(Pt.format,Pt.colorSpace),en=c.convert(Pt.type),Zt=it(Pt.internalFormat,cn,en,Pt.colorSpace);if(!s.get(gt).__hasExternalTextures){const pn=Math.max(1,gt.width>>jt),wn=Math.max(1,gt.height>>jt);Vt===a.TEXTURE_3D||Vt===a.TEXTURE_2D_ARRAY?i.texImage3D(Vt,jt,Zt,pn,wn,gt.depth,0,cn,en,null):i.texImage2D(Vt,jt,Zt,pn,wn,0,cn,en,null)}i.bindFramebuffer(a.FRAMEBUFFER,bt),hn(gt)?h.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER,Lt,Vt,s.get(Pt).__webglTexture,0,sn(gt)):(Vt===a.TEXTURE_2D||Vt>=a.TEXTURE_CUBE_MAP_POSITIVE_X&&Vt<=a.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&a.framebufferTexture2D(a.FRAMEBUFFER,Lt,Vt,s.get(Pt).__webglTexture,jt),i.bindFramebuffer(a.FRAMEBUFFER,null)}function Ft(bt,gt,Pt){if(a.bindRenderbuffer(a.RENDERBUFFER,bt),gt.depthBuffer){const Lt=gt.depthTexture,Vt=Lt&&Lt.isDepthTexture?Lt.type:null,jt=at(gt.stencilBuffer,Vt),cn=gt.stencilBuffer?a.DEPTH_STENCIL_ATTACHMENT:a.DEPTH_ATTACHMENT,en=sn(gt);hn(gt)?h.renderbufferStorageMultisampleEXT(a.RENDERBUFFER,en,jt,gt.width,gt.height):Pt?a.renderbufferStorageMultisample(a.RENDERBUFFER,en,jt,gt.width,gt.height):a.renderbufferStorage(a.RENDERBUFFER,jt,gt.width,gt.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,cn,a.RENDERBUFFER,bt)}else{const Lt=gt.textures;for(let Vt=0;Vt<Lt.length;Vt++){const jt=Lt[Vt],cn=c.convert(jt.format,jt.colorSpace),en=c.convert(jt.type),Zt=it(jt.internalFormat,cn,en,jt.colorSpace),yn=sn(gt);Pt&&hn(gt)===!1?a.renderbufferStorageMultisample(a.RENDERBUFFER,yn,Zt,gt.width,gt.height):hn(gt)?h.renderbufferStorageMultisampleEXT(a.RENDERBUFFER,yn,Zt,gt.width,gt.height):a.renderbufferStorage(a.RENDERBUFFER,Zt,gt.width,gt.height)}}a.bindRenderbuffer(a.RENDERBUFFER,null)}function Bt(bt,gt){if(gt&&gt.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(a.FRAMEBUFFER,bt),!(gt.depthTexture&&gt.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(gt.depthTexture).__webglTexture||gt.depthTexture.image.width!==gt.width||gt.depthTexture.image.height!==gt.height)&&(gt.depthTexture.image.width=gt.width,gt.depthTexture.image.height=gt.height,gt.depthTexture.needsUpdate=!0),St(gt.depthTexture,0);const Lt=s.get(gt.depthTexture).__webglTexture,Vt=sn(gt);if(gt.depthTexture.format===DepthFormat)hn(gt)?h.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.TEXTURE_2D,Lt,0,Vt):a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.TEXTURE_2D,Lt,0);else if(gt.depthTexture.format===DepthStencilFormat)hn(gt)?h.framebufferTexture2DMultisampleEXT(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.TEXTURE_2D,Lt,0,Vt):a.framebufferTexture2D(a.FRAMEBUFFER,a.DEPTH_STENCIL_ATTACHMENT,a.TEXTURE_2D,Lt,0);else throw new Error("Unknown depthTexture format")}function Ht(bt){const gt=s.get(bt),Pt=bt.isWebGLCubeRenderTarget===!0;if(bt.depthTexture&&!gt.__autoAllocateDepthBuffer){if(Pt)throw new Error("target.depthTexture not supported in Cube render targets");Bt(gt.__webglFramebuffer,bt)}else if(Pt){gt.__webglDepthbuffer=[];for(let Lt=0;Lt<6;Lt++)i.bindFramebuffer(a.FRAMEBUFFER,gt.__webglFramebuffer[Lt]),gt.__webglDepthbuffer[Lt]=a.createRenderbuffer(),Ft(gt.__webglDepthbuffer[Lt],bt,!1)}else i.bindFramebuffer(a.FRAMEBUFFER,gt.__webglFramebuffer),gt.__webglDepthbuffer=a.createRenderbuffer(),Ft(gt.__webglDepthbuffer,bt,!1);i.bindFramebuffer(a.FRAMEBUFFER,null)}function Wt(bt,gt,Pt){const Lt=s.get(bt);gt!==void 0&&kt(Lt.__webglFramebuffer,bt,bt.texture,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,0),Pt!==void 0&&Ht(bt)}function Ut(bt){const gt=bt.texture,Pt=s.get(bt),Lt=s.get(gt);bt.addEventListener("dispose",ct);const Vt=bt.textures,jt=bt.isWebGLCubeRenderTarget===!0,cn=Vt.length>1;if(cn||(Lt.__webglTexture===void 0&&(Lt.__webglTexture=a.createTexture()),Lt.__version=gt.version,d.memory.textures++),jt){Pt.__webglFramebuffer=[];for(let en=0;en<6;en++)if(gt.mipmaps&&gt.mipmaps.length>0){Pt.__webglFramebuffer[en]=[];for(let Zt=0;Zt<gt.mipmaps.length;Zt++)Pt.__webglFramebuffer[en][Zt]=a.createFramebuffer()}else Pt.__webglFramebuffer[en]=a.createFramebuffer()}else{if(gt.mipmaps&&gt.mipmaps.length>0){Pt.__webglFramebuffer=[];for(let en=0;en<gt.mipmaps.length;en++)Pt.__webglFramebuffer[en]=a.createFramebuffer()}else Pt.__webglFramebuffer=a.createFramebuffer();if(cn)for(let en=0,Zt=Vt.length;en<Zt;en++){const yn=s.get(Vt[en]);yn.__webglTexture===void 0&&(yn.__webglTexture=a.createTexture(),d.memory.textures++)}if(bt.samples>0&&hn(bt)===!1){Pt.__webglMultisampledFramebuffer=a.createFramebuffer(),Pt.__webglColorRenderbuffer=[],i.bindFramebuffer(a.FRAMEBUFFER,Pt.__webglMultisampledFramebuffer);for(let en=0;en<Vt.length;en++){const Zt=Vt[en];Pt.__webglColorRenderbuffer[en]=a.createRenderbuffer(),a.bindRenderbuffer(a.RENDERBUFFER,Pt.__webglColorRenderbuffer[en]);const yn=c.convert(Zt.format,Zt.colorSpace),pn=c.convert(Zt.type),wn=it(Zt.internalFormat,yn,pn,Zt.colorSpace,bt.isXRRenderTarget===!0),Pn=sn(bt);a.renderbufferStorageMultisample(a.RENDERBUFFER,Pn,wn,bt.width,bt.height),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+en,a.RENDERBUFFER,Pt.__webglColorRenderbuffer[en])}a.bindRenderbuffer(a.RENDERBUFFER,null),bt.depthBuffer&&(Pt.__webglDepthRenderbuffer=a.createRenderbuffer(),Ft(Pt.__webglDepthRenderbuffer,bt,!0)),i.bindFramebuffer(a.FRAMEBUFFER,null)}}if(jt){i.bindTexture(a.TEXTURE_CUBE_MAP,Lt.__webglTexture),Mt(a.TEXTURE_CUBE_MAP,gt);for(let en=0;en<6;en++)if(gt.mipmaps&&gt.mipmaps.length>0)for(let Zt=0;Zt<gt.mipmaps.length;Zt++)kt(Pt.__webglFramebuffer[en][Zt],bt,gt,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+en,Zt);else kt(Pt.__webglFramebuffer[en],bt,gt,a.COLOR_ATTACHMENT0,a.TEXTURE_CUBE_MAP_POSITIVE_X+en,0);nt(gt)&&rt(a.TEXTURE_CUBE_MAP),i.unbindTexture()}else if(cn){for(let en=0,Zt=Vt.length;en<Zt;en++){const yn=Vt[en],pn=s.get(yn);i.bindTexture(a.TEXTURE_2D,pn.__webglTexture),Mt(a.TEXTURE_2D,yn),kt(Pt.__webglFramebuffer,bt,yn,a.COLOR_ATTACHMENT0+en,a.TEXTURE_2D,0),nt(yn)&&rt(a.TEXTURE_2D)}i.unbindTexture()}else{let en=a.TEXTURE_2D;if((bt.isWebGL3DRenderTarget||bt.isWebGLArrayRenderTarget)&&(en=bt.isWebGL3DRenderTarget?a.TEXTURE_3D:a.TEXTURE_2D_ARRAY),i.bindTexture(en,Lt.__webglTexture),Mt(en,gt),gt.mipmaps&&gt.mipmaps.length>0)for(let Zt=0;Zt<gt.mipmaps.length;Zt++)kt(Pt.__webglFramebuffer[Zt],bt,gt,a.COLOR_ATTACHMENT0,en,Zt);else kt(Pt.__webglFramebuffer,bt,gt,a.COLOR_ATTACHMENT0,en,0);nt(gt)&&rt(en),i.unbindTexture()}bt.depthBuffer&&Ht(bt)}function Rt(bt){const gt=bt.textures;for(let Pt=0,Lt=gt.length;Pt<Lt;Pt++){const Vt=gt[Pt];if(nt(Vt)){const jt=bt.isWebGLCubeRenderTarget?a.TEXTURE_CUBE_MAP:a.TEXTURE_2D,cn=s.get(Vt).__webglTexture;i.bindTexture(jt,cn),rt(jt),i.unbindTexture()}}}const un=[],rn=[];function mn(bt){if(bt.samples>0){if(hn(bt)===!1){const gt=bt.textures,Pt=bt.width,Lt=bt.height;let Vt=a.COLOR_BUFFER_BIT;const jt=bt.stencilBuffer?a.DEPTH_STENCIL_ATTACHMENT:a.DEPTH_ATTACHMENT,cn=s.get(bt),en=gt.length>1;if(en)for(let Zt=0;Zt<gt.length;Zt++)i.bindFramebuffer(a.FRAMEBUFFER,cn.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+Zt,a.RENDERBUFFER,null),i.bindFramebuffer(a.FRAMEBUFFER,cn.__webglFramebuffer),a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0+Zt,a.TEXTURE_2D,null,0);i.bindFramebuffer(a.READ_FRAMEBUFFER,cn.__webglMultisampledFramebuffer),i.bindFramebuffer(a.DRAW_FRAMEBUFFER,cn.__webglFramebuffer);for(let Zt=0;Zt<gt.length;Zt++){if(bt.resolveDepthBuffer&&(bt.depthBuffer&&(Vt|=a.DEPTH_BUFFER_BIT),bt.stencilBuffer&&bt.resolveStencilBuffer&&(Vt|=a.STENCIL_BUFFER_BIT)),en){a.framebufferRenderbuffer(a.READ_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.RENDERBUFFER,cn.__webglColorRenderbuffer[Zt]);const yn=s.get(gt[Zt]).__webglTexture;a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,yn,0)}a.blitFramebuffer(0,0,Pt,Lt,0,0,Pt,Lt,Vt,a.NEAREST),g===!0&&(un.length=0,rn.length=0,un.push(a.COLOR_ATTACHMENT0+Zt),bt.depthBuffer&&bt.resolveDepthBuffer===!1&&(un.push(jt),rn.push(jt),a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER,rn)),a.invalidateFramebuffer(a.READ_FRAMEBUFFER,un))}if(i.bindFramebuffer(a.READ_FRAMEBUFFER,null),i.bindFramebuffer(a.DRAW_FRAMEBUFFER,null),en)for(let Zt=0;Zt<gt.length;Zt++){i.bindFramebuffer(a.FRAMEBUFFER,cn.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0+Zt,a.RENDERBUFFER,cn.__webglColorRenderbuffer[Zt]);const yn=s.get(gt[Zt]).__webglTexture;i.bindFramebuffer(a.FRAMEBUFFER,cn.__webglFramebuffer),a.framebufferTexture2D(a.DRAW_FRAMEBUFFER,a.COLOR_ATTACHMENT0+Zt,a.TEXTURE_2D,yn,0)}i.bindFramebuffer(a.DRAW_FRAMEBUFFER,cn.__webglMultisampledFramebuffer)}else if(bt.depthBuffer&&bt.resolveDepthBuffer===!1&&g){const gt=bt.stencilBuffer?a.DEPTH_STENCIL_ATTACHMENT:a.DEPTH_ATTACHMENT;a.invalidateFramebuffer(a.DRAW_FRAMEBUFFER,[gt])}}}function sn(bt){return Math.min(o.maxSamples,bt.samples)}function hn(bt){const gt=s.get(bt);return bt.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&gt.__useRenderToTexture!==!1}function gn(bt){const gt=d.render.frame;b.get(bt)!==gt&&(b.set(bt,gt),bt.update())}function Xt(bt,gt){const Pt=bt.colorSpace,Lt=bt.format,Vt=bt.type;return bt.isCompressedTexture===!0||bt.isVideoTexture===!0||Pt!==LinearSRGBColorSpace&&Pt!==NoColorSpace&&(ColorManagement.getTransfer(Pt)===SRGBTransfer?(Lt!==RGBAFormat||Vt!==UnsignedByteType)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Pt)),gt}function En(bt){return typeof HTMLImageElement<"u"&&bt instanceof HTMLImageElement?(_.width=bt.naturalWidth||bt.width,_.height=bt.naturalHeight||bt.height):typeof VideoFrame<"u"&&bt instanceof VideoFrame?(_.width=bt.displayWidth,_.height=bt.displayHeight):(_.width=bt.width,_.height=bt.height),_}this.allocateTextureUnit=mt,this.resetTextureUnits=ft,this.setTexture2D=St,this.setTexture2DArray=Et,this.setTexture3D=vt,this.setTextureCube=Nt,this.rebindTextures=Wt,this.setupRenderTarget=Ut,this.updateRenderTargetMipmap=Rt,this.updateMultisampleRenderTarget=mn,this.setupDepthRenderbuffer=Ht,this.setupFrameBufferTexture=kt,this.useMultisampledRTT=hn}function WebGLUtils(a,e){function i(s,o=NoColorSpace){let c;const d=ColorManagement.getTransfer(o);if(s===UnsignedByteType)return a.UNSIGNED_BYTE;if(s===UnsignedShort4444Type)return a.UNSIGNED_SHORT_4_4_4_4;if(s===UnsignedShort5551Type)return a.UNSIGNED_SHORT_5_5_5_1;if(s===UnsignedInt5999Type)return a.UNSIGNED_INT_5_9_9_9_REV;if(s===ByteType)return a.BYTE;if(s===ShortType)return a.SHORT;if(s===UnsignedShortType)return a.UNSIGNED_SHORT;if(s===IntType)return a.INT;if(s===UnsignedIntType)return a.UNSIGNED_INT;if(s===FloatType)return a.FLOAT;if(s===HalfFloatType)return a.HALF_FLOAT;if(s===AlphaFormat)return a.ALPHA;if(s===RGBFormat)return a.RGB;if(s===RGBAFormat)return a.RGBA;if(s===LuminanceFormat)return a.LUMINANCE;if(s===LuminanceAlphaFormat)return a.LUMINANCE_ALPHA;if(s===DepthFormat)return a.DEPTH_COMPONENT;if(s===DepthStencilFormat)return a.DEPTH_STENCIL;if(s===RedFormat)return a.RED;if(s===RedIntegerFormat)return a.RED_INTEGER;if(s===RGFormat)return a.RG;if(s===RGIntegerFormat)return a.RG_INTEGER;if(s===RGBAIntegerFormat)return a.RGBA_INTEGER;if(s===RGB_S3TC_DXT1_Format||s===RGBA_S3TC_DXT1_Format||s===RGBA_S3TC_DXT3_Format||s===RGBA_S3TC_DXT5_Format)if(d===SRGBTransfer)if(c=e.get("WEBGL_compressed_texture_s3tc_srgb"),c!==null){if(s===RGB_S3TC_DXT1_Format)return c.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===RGBA_S3TC_DXT1_Format)return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===RGBA_S3TC_DXT3_Format)return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===RGBA_S3TC_DXT5_Format)return c.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(c=e.get("WEBGL_compressed_texture_s3tc"),c!==null){if(s===RGB_S3TC_DXT1_Format)return c.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===RGBA_S3TC_DXT1_Format)return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===RGBA_S3TC_DXT3_Format)return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===RGBA_S3TC_DXT5_Format)return c.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===RGB_PVRTC_4BPPV1_Format||s===RGB_PVRTC_2BPPV1_Format||s===RGBA_PVRTC_4BPPV1_Format||s===RGBA_PVRTC_2BPPV1_Format)if(c=e.get("WEBGL_compressed_texture_pvrtc"),c!==null){if(s===RGB_PVRTC_4BPPV1_Format)return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===RGB_PVRTC_2BPPV1_Format)return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===RGBA_PVRTC_4BPPV1_Format)return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===RGBA_PVRTC_2BPPV1_Format)return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===RGB_ETC1_Format||s===RGB_ETC2_Format||s===RGBA_ETC2_EAC_Format)if(c=e.get("WEBGL_compressed_texture_etc"),c!==null){if(s===RGB_ETC1_Format||s===RGB_ETC2_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ETC2:c.COMPRESSED_RGB8_ETC2;if(s===RGBA_ETC2_EAC_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:c.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===RGBA_ASTC_4x4_Format||s===RGBA_ASTC_5x4_Format||s===RGBA_ASTC_5x5_Format||s===RGBA_ASTC_6x5_Format||s===RGBA_ASTC_6x6_Format||s===RGBA_ASTC_8x5_Format||s===RGBA_ASTC_8x6_Format||s===RGBA_ASTC_8x8_Format||s===RGBA_ASTC_10x5_Format||s===RGBA_ASTC_10x6_Format||s===RGBA_ASTC_10x8_Format||s===RGBA_ASTC_10x10_Format||s===RGBA_ASTC_12x10_Format||s===RGBA_ASTC_12x12_Format)if(c=e.get("WEBGL_compressed_texture_astc"),c!==null){if(s===RGBA_ASTC_4x4_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:c.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===RGBA_ASTC_5x4_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:c.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===RGBA_ASTC_5x5_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:c.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===RGBA_ASTC_6x5_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:c.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===RGBA_ASTC_6x6_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:c.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===RGBA_ASTC_8x5_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:c.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===RGBA_ASTC_8x6_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:c.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===RGBA_ASTC_8x8_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:c.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===RGBA_ASTC_10x5_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:c.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===RGBA_ASTC_10x6_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:c.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===RGBA_ASTC_10x8_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:c.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===RGBA_ASTC_10x10_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:c.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===RGBA_ASTC_12x10_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:c.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===RGBA_ASTC_12x12_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:c.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===RGBA_BPTC_Format||s===RGB_BPTC_SIGNED_Format||s===RGB_BPTC_UNSIGNED_Format)if(c=e.get("EXT_texture_compression_bptc"),c!==null){if(s===RGBA_BPTC_Format)return d===SRGBTransfer?c.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:c.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(s===RGB_BPTC_SIGNED_Format)return c.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(s===RGB_BPTC_UNSIGNED_Format)return c.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(s===RED_RGTC1_Format||s===SIGNED_RED_RGTC1_Format||s===RED_GREEN_RGTC2_Format||s===SIGNED_RED_GREEN_RGTC2_Format)if(c=e.get("EXT_texture_compression_rgtc"),c!==null){if(s===RGBA_BPTC_Format)return c.COMPRESSED_RED_RGTC1_EXT;if(s===SIGNED_RED_RGTC1_Format)return c.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===RED_GREEN_RGTC2_Format)return c.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===SIGNED_RED_GREEN_RGTC2_Format)return c.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===UnsignedInt248Type?a.UNSIGNED_INT_24_8:a[s]!==void 0?a[s]:null}return{convert:i}}class ArrayCamera extends PerspectiveCamera{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const i=this._hand;if(i)for(const s of e.hand.values())this._getHandJoint(i,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,i,s){let o=null,c=null,d=null;const h=this._targetRay,g=this._grip,_=this._hand;if(e&&i.session.visibilityState!=="visible-blurred"){if(_&&e.hand){d=!0;for(const et of e.hand.values()){const nt=i.getJointPose(et,s),rt=this._getHandJoint(_,et);nt!==null&&(rt.matrix.fromArray(nt.transform.matrix),rt.matrix.decompose(rt.position,rt.rotation,rt.scale),rt.matrixWorldNeedsUpdate=!0,rt.jointRadius=nt.radius),rt.visible=nt!==null}const b=_.joints["index-finger-tip"],$=_.joints["thumb-tip"],j=b.position.distanceTo($.position),_e=.02,tt=.005;_.inputState.pinching&&j>_e+tt?(_.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!_.inputState.pinching&&j<=_e-tt&&(_.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else g!==null&&e.gripSpace&&(c=i.getPose(e.gripSpace,s),c!==null&&(g.matrix.fromArray(c.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.matrixWorldNeedsUpdate=!0,c.linearVelocity?(g.hasLinearVelocity=!0,g.linearVelocity.copy(c.linearVelocity)):g.hasLinearVelocity=!1,c.angularVelocity?(g.hasAngularVelocity=!0,g.angularVelocity.copy(c.angularVelocity)):g.hasAngularVelocity=!1));h!==null&&(o=i.getPose(e.targetRaySpace,s),o===null&&c!==null&&(o=c),o!==null&&(h.matrix.fromArray(o.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),h.matrixWorldNeedsUpdate=!0,o.linearVelocity?(h.hasLinearVelocity=!0,h.linearVelocity.copy(o.linearVelocity)):h.hasLinearVelocity=!1,o.angularVelocity?(h.hasAngularVelocity=!0,h.angularVelocity.copy(o.angularVelocity)):h.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return h!==null&&(h.visible=o!==null),g!==null&&(g.visible=c!==null),_!==null&&(_.visible=d!==null),this}_getHandJoint(e,i){if(e.joints[i.jointName]===void 0){const s=new Group;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[i.jointName]=s,e.add(s)}return e.joints[i.jointName]}}const _occlusion_vertex=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,_occlusion_fragment=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class WebXRDepthSensing{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,i,s){if(this.texture===null){const o=new Texture,c=e.properties.get(o);c.__webglTexture=i.texture,(i.depthNear!=s.depthNear||i.depthFar!=s.depthFar)&&(this.depthNear=i.depthNear,this.depthFar=i.depthFar),this.texture=o}}getMesh(e){if(this.texture!==null&&this.mesh===null){const i=e.cameras[0].viewport,s=new ShaderMaterial({vertexShader:_occlusion_vertex,fragmentShader:_occlusion_fragment,uniforms:{depthColor:{value:this.texture},depthWidth:{value:i.z},depthHeight:{value:i.w}}});this.mesh=new Mesh(new PlaneGeometry(20,20),s)}return this.mesh}reset(){this.texture=null,this.mesh=null}}class WebXRManager extends EventDispatcher{constructor(e,i){super();const s=this;let o=null,c=1,d=null,h="local-floor",g=1,_=null,b=null,$=null,j=null,_e=null,tt=null;const et=new WebXRDepthSensing,nt=i.getContextAttributes();let rt=null,it=null;const at=[],st=[],ot=new Vector2;let ct=null;const lt=new PerspectiveCamera;lt.layers.enable(1),lt.viewport=new Vector4;const dt=new PerspectiveCamera;dt.layers.enable(2),dt.viewport=new Vector4;const xt=[lt,dt],ut=new ArrayCamera;ut.layers.enable(1),ut.layers.enable(2);let ft=null,mt=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(At){let kt=at[At];return kt===void 0&&(kt=new WebXRController,at[At]=kt),kt.getTargetRaySpace()},this.getControllerGrip=function(At){let kt=at[At];return kt===void 0&&(kt=new WebXRController,at[At]=kt),kt.getGripSpace()},this.getHand=function(At){let kt=at[At];return kt===void 0&&(kt=new WebXRController,at[At]=kt),kt.getHandSpace()};function yt(At){const kt=st.indexOf(At.inputSource);if(kt===-1)return;const Ft=at[kt];Ft!==void 0&&(Ft.update(At.inputSource,At.frame,_||d),Ft.dispatchEvent({type:At.type,data:At.inputSource}))}function St(){o.removeEventListener("select",yt),o.removeEventListener("selectstart",yt),o.removeEventListener("selectend",yt),o.removeEventListener("squeeze",yt),o.removeEventListener("squeezestart",yt),o.removeEventListener("squeezeend",yt),o.removeEventListener("end",St),o.removeEventListener("inputsourceschange",Et);for(let At=0;At<at.length;At++){const kt=st[At];kt!==null&&(st[At]=null,at[At].disconnect(kt))}ft=null,mt=null,et.reset(),e.setRenderTarget(rt),_e=null,j=null,$=null,o=null,it=null,Dt.stop(),s.isPresenting=!1,e.setPixelRatio(ct),e.setSize(ot.width,ot.height,!1),s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(At){c=At,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(At){h=At,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return _||d},this.setReferenceSpace=function(At){_=At},this.getBaseLayer=function(){return j!==null?j:_e},this.getBinding=function(){return $},this.getFrame=function(){return tt},this.getSession=function(){return o},this.setSession=async function(At){if(o=At,o!==null){if(rt=e.getRenderTarget(),o.addEventListener("select",yt),o.addEventListener("selectstart",yt),o.addEventListener("selectend",yt),o.addEventListener("squeeze",yt),o.addEventListener("squeezestart",yt),o.addEventListener("squeezeend",yt),o.addEventListener("end",St),o.addEventListener("inputsourceschange",Et),nt.xrCompatible!==!0&&await i.makeXRCompatible(),ct=e.getPixelRatio(),e.getSize(ot),o.renderState.layers===void 0){const kt={antialias:nt.antialias,alpha:!0,depth:nt.depth,stencil:nt.stencil,framebufferScaleFactor:c};_e=new XRWebGLLayer(o,i,kt),o.updateRenderState({baseLayer:_e}),e.setPixelRatio(1),e.setSize(_e.framebufferWidth,_e.framebufferHeight,!1),it=new WebGLRenderTarget(_e.framebufferWidth,_e.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:e.outputColorSpace,stencilBuffer:nt.stencil})}else{let kt=null,Ft=null,Bt=null;nt.depth&&(Bt=nt.stencil?i.DEPTH24_STENCIL8:i.DEPTH_COMPONENT24,kt=nt.stencil?DepthStencilFormat:DepthFormat,Ft=nt.stencil?UnsignedInt248Type:UnsignedIntType);const Ht={colorFormat:i.RGBA8,depthFormat:Bt,scaleFactor:c};$=new XRWebGLBinding(o,i),j=$.createProjectionLayer(Ht),o.updateRenderState({layers:[j]}),e.setPixelRatio(1),e.setSize(j.textureWidth,j.textureHeight,!1),it=new WebGLRenderTarget(j.textureWidth,j.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(j.textureWidth,j.textureHeight,Ft,void 0,void 0,void 0,void 0,void 0,void 0,kt),stencilBuffer:nt.stencil,colorSpace:e.outputColorSpace,samples:nt.antialias?4:0,resolveDepthBuffer:j.ignoreDepthValues===!1})}it.isXRRenderTarget=!0,this.setFoveation(g),_=null,d=await o.requestReferenceSpace(h),Dt.setContext(o),Dt.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(o!==null)return o.environmentBlendMode};function Et(At){for(let kt=0;kt<At.removed.length;kt++){const Ft=At.removed[kt],Bt=st.indexOf(Ft);Bt>=0&&(st[Bt]=null,at[Bt].disconnect(Ft))}for(let kt=0;kt<At.added.length;kt++){const Ft=At.added[kt];let Bt=st.indexOf(Ft);if(Bt===-1){for(let Wt=0;Wt<at.length;Wt++)if(Wt>=st.length){st.push(Ft),Bt=Wt;break}else if(st[Wt]===null){st[Wt]=Ft,Bt=Wt;break}if(Bt===-1)break}const Ht=at[Bt];Ht&&Ht.connect(Ft)}}const vt=new Vector3,Nt=new Vector3;function wt(At,kt,Ft){vt.setFromMatrixPosition(kt.matrixWorld),Nt.setFromMatrixPosition(Ft.matrixWorld);const Bt=vt.distanceTo(Nt),Ht=kt.projectionMatrix.elements,Wt=Ft.projectionMatrix.elements,Ut=Ht[14]/(Ht[10]-1),Rt=Ht[14]/(Ht[10]+1),un=(Ht[9]+1)/Ht[5],rn=(Ht[9]-1)/Ht[5],mn=(Ht[8]-1)/Ht[0],sn=(Wt[8]+1)/Wt[0],hn=Ut*mn,gn=Ut*sn,Xt=Bt/(-mn+sn),En=Xt*-mn;kt.matrixWorld.decompose(At.position,At.quaternion,At.scale),At.translateX(En),At.translateZ(Xt),At.matrixWorld.compose(At.position,At.quaternion,At.scale),At.matrixWorldInverse.copy(At.matrixWorld).invert();const bt=Ut+Xt,gt=Rt+Xt,Pt=hn-En,Lt=gn+(Bt-En),Vt=un*Rt/gt*bt,jt=rn*Rt/gt*bt;At.projectionMatrix.makePerspective(Pt,Lt,Vt,jt,bt,gt),At.projectionMatrixInverse.copy(At.projectionMatrix).invert()}function $t(At,kt){kt===null?At.matrixWorld.copy(At.matrix):At.matrixWorld.multiplyMatrices(kt.matrixWorld,At.matrix),At.matrixWorldInverse.copy(At.matrixWorld).invert()}this.updateCamera=function(At){if(o===null)return;et.texture!==null&&(At.near=et.depthNear,At.far=et.depthFar),ut.near=dt.near=lt.near=At.near,ut.far=dt.far=lt.far=At.far,(ft!==ut.near||mt!==ut.far)&&(o.updateRenderState({depthNear:ut.near,depthFar:ut.far}),ft=ut.near,mt=ut.far,lt.near=ft,lt.far=mt,dt.near=ft,dt.far=mt,lt.updateProjectionMatrix(),dt.updateProjectionMatrix(),At.updateProjectionMatrix());const kt=At.parent,Ft=ut.cameras;$t(ut,kt);for(let Bt=0;Bt<Ft.length;Bt++)$t(Ft[Bt],kt);Ft.length===2?wt(ut,lt,dt):ut.projectionMatrix.copy(lt.projectionMatrix),Ct(At,ut,kt)};function Ct(At,kt,Ft){Ft===null?At.matrix.copy(kt.matrixWorld):(At.matrix.copy(Ft.matrixWorld),At.matrix.invert(),At.matrix.multiply(kt.matrixWorld)),At.matrix.decompose(At.position,At.quaternion,At.scale),At.updateMatrixWorld(!0),At.projectionMatrix.copy(kt.projectionMatrix),At.projectionMatrixInverse.copy(kt.projectionMatrixInverse),At.isPerspectiveCamera&&(At.fov=RAD2DEG*2*Math.atan(1/At.projectionMatrix.elements[5]),At.zoom=1)}this.getCamera=function(){return ut},this.getFoveation=function(){if(!(j===null&&_e===null))return g},this.setFoveation=function(At){g=At,j!==null&&(j.fixedFoveation=At),_e!==null&&_e.fixedFoveation!==void 0&&(_e.fixedFoveation=At)},this.hasDepthSensing=function(){return et.texture!==null},this.getDepthSensingMesh=function(){return et.getMesh(ut)};let Mt=null;function Ot(At,kt){if(b=kt.getViewerPose(_||d),tt=kt,b!==null){const Ft=b.views;_e!==null&&(e.setRenderTargetFramebuffer(it,_e.framebuffer),e.setRenderTarget(it));let Bt=!1;Ft.length!==ut.cameras.length&&(ut.cameras.length=0,Bt=!0);for(let Wt=0;Wt<Ft.length;Wt++){const Ut=Ft[Wt];let Rt=null;if(_e!==null)Rt=_e.getViewport(Ut);else{const rn=$.getViewSubImage(j,Ut);Rt=rn.viewport,Wt===0&&(e.setRenderTargetTextures(it,rn.colorTexture,j.ignoreDepthValues?void 0:rn.depthStencilTexture),e.setRenderTarget(it))}let un=xt[Wt];un===void 0&&(un=new PerspectiveCamera,un.layers.enable(Wt),un.viewport=new Vector4,xt[Wt]=un),un.matrix.fromArray(Ut.transform.matrix),un.matrix.decompose(un.position,un.quaternion,un.scale),un.projectionMatrix.fromArray(Ut.projectionMatrix),un.projectionMatrixInverse.copy(un.projectionMatrix).invert(),un.viewport.set(Rt.x,Rt.y,Rt.width,Rt.height),Wt===0&&(ut.matrix.copy(un.matrix),ut.matrix.decompose(ut.position,ut.quaternion,ut.scale)),Bt===!0&&ut.cameras.push(un)}const Ht=o.enabledFeatures;if(Ht&&Ht.includes("depth-sensing")){const Wt=$.getDepthInformation(Ft[0]);Wt&&Wt.isValid&&Wt.texture&&et.init(e,Wt,o.renderState)}}for(let Ft=0;Ft<at.length;Ft++){const Bt=st[Ft],Ht=at[Ft];Bt!==null&&Ht!==void 0&&Ht.update(Bt,kt,_||d)}Mt&&Mt(At,kt),kt.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:kt}),tt=null}const Dt=new WebGLAnimation;Dt.setAnimationLoop(Ot),this.setAnimationLoop=function(At){Mt=At},this.dispose=function(){}}}const _e1=new Euler,_m1=new Matrix4;function WebGLMaterials(a,e){function i(nt,rt){nt.matrixAutoUpdate===!0&&nt.updateMatrix(),rt.value.copy(nt.matrix)}function s(nt,rt){rt.color.getRGB(nt.fogColor.value,getUnlitUniformColorSpace(a)),rt.isFog?(nt.fogNear.value=rt.near,nt.fogFar.value=rt.far):rt.isFogExp2&&(nt.fogDensity.value=rt.density)}function o(nt,rt,it,at,st){rt.isMeshBasicMaterial||rt.isMeshLambertMaterial?c(nt,rt):rt.isMeshToonMaterial?(c(nt,rt),$(nt,rt)):rt.isMeshPhongMaterial?(c(nt,rt),b(nt,rt)):rt.isMeshStandardMaterial?(c(nt,rt),j(nt,rt),rt.isMeshPhysicalMaterial&&_e(nt,rt,st)):rt.isMeshMatcapMaterial?(c(nt,rt),tt(nt,rt)):rt.isMeshDepthMaterial?c(nt,rt):rt.isMeshDistanceMaterial?(c(nt,rt),et(nt,rt)):rt.isMeshNormalMaterial?c(nt,rt):rt.isLineBasicMaterial?(d(nt,rt),rt.isLineDashedMaterial&&h(nt,rt)):rt.isPointsMaterial?g(nt,rt,it,at):rt.isSpriteMaterial?_(nt,rt):rt.isShadowMaterial?(nt.color.value.copy(rt.color),nt.opacity.value=rt.opacity):rt.isShaderMaterial&&(rt.uniformsNeedUpdate=!1)}function c(nt,rt){nt.opacity.value=rt.opacity,rt.color&&nt.diffuse.value.copy(rt.color),rt.emissive&&nt.emissive.value.copy(rt.emissive).multiplyScalar(rt.emissiveIntensity),rt.map&&(nt.map.value=rt.map,i(rt.map,nt.mapTransform)),rt.alphaMap&&(nt.alphaMap.value=rt.alphaMap,i(rt.alphaMap,nt.alphaMapTransform)),rt.bumpMap&&(nt.bumpMap.value=rt.bumpMap,i(rt.bumpMap,nt.bumpMapTransform),nt.bumpScale.value=rt.bumpScale,rt.side===BackSide&&(nt.bumpScale.value*=-1)),rt.normalMap&&(nt.normalMap.value=rt.normalMap,i(rt.normalMap,nt.normalMapTransform),nt.normalScale.value.copy(rt.normalScale),rt.side===BackSide&&nt.normalScale.value.negate()),rt.displacementMap&&(nt.displacementMap.value=rt.displacementMap,i(rt.displacementMap,nt.displacementMapTransform),nt.displacementScale.value=rt.displacementScale,nt.displacementBias.value=rt.displacementBias),rt.emissiveMap&&(nt.emissiveMap.value=rt.emissiveMap,i(rt.emissiveMap,nt.emissiveMapTransform)),rt.specularMap&&(nt.specularMap.value=rt.specularMap,i(rt.specularMap,nt.specularMapTransform)),rt.alphaTest>0&&(nt.alphaTest.value=rt.alphaTest);const it=e.get(rt),at=it.envMap,st=it.envMapRotation;at&&(nt.envMap.value=at,_e1.copy(st),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,at.isCubeTexture&&at.isRenderTargetTexture===!1&&(_e1.y*=-1,_e1.z*=-1),nt.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1)),nt.flipEnvMap.value=at.isCubeTexture&&at.isRenderTargetTexture===!1?-1:1,nt.reflectivity.value=rt.reflectivity,nt.ior.value=rt.ior,nt.refractionRatio.value=rt.refractionRatio),rt.lightMap&&(nt.lightMap.value=rt.lightMap,nt.lightMapIntensity.value=rt.lightMapIntensity,i(rt.lightMap,nt.lightMapTransform)),rt.aoMap&&(nt.aoMap.value=rt.aoMap,nt.aoMapIntensity.value=rt.aoMapIntensity,i(rt.aoMap,nt.aoMapTransform))}function d(nt,rt){nt.diffuse.value.copy(rt.color),nt.opacity.value=rt.opacity,rt.map&&(nt.map.value=rt.map,i(rt.map,nt.mapTransform))}function h(nt,rt){nt.dashSize.value=rt.dashSize,nt.totalSize.value=rt.dashSize+rt.gapSize,nt.scale.value=rt.scale}function g(nt,rt,it,at){nt.diffuse.value.copy(rt.color),nt.opacity.value=rt.opacity,nt.size.value=rt.size*it,nt.scale.value=at*.5,rt.map&&(nt.map.value=rt.map,i(rt.map,nt.uvTransform)),rt.alphaMap&&(nt.alphaMap.value=rt.alphaMap,i(rt.alphaMap,nt.alphaMapTransform)),rt.alphaTest>0&&(nt.alphaTest.value=rt.alphaTest)}function _(nt,rt){nt.diffuse.value.copy(rt.color),nt.opacity.value=rt.opacity,nt.rotation.value=rt.rotation,rt.map&&(nt.map.value=rt.map,i(rt.map,nt.mapTransform)),rt.alphaMap&&(nt.alphaMap.value=rt.alphaMap,i(rt.alphaMap,nt.alphaMapTransform)),rt.alphaTest>0&&(nt.alphaTest.value=rt.alphaTest)}function b(nt,rt){nt.specular.value.copy(rt.specular),nt.shininess.value=Math.max(rt.shininess,1e-4)}function $(nt,rt){rt.gradientMap&&(nt.gradientMap.value=rt.gradientMap)}function j(nt,rt){nt.metalness.value=rt.metalness,rt.metalnessMap&&(nt.metalnessMap.value=rt.metalnessMap,i(rt.metalnessMap,nt.metalnessMapTransform)),nt.roughness.value=rt.roughness,rt.roughnessMap&&(nt.roughnessMap.value=rt.roughnessMap,i(rt.roughnessMap,nt.roughnessMapTransform)),rt.envMap&&(nt.envMapIntensity.value=rt.envMapIntensity)}function _e(nt,rt,it){nt.ior.value=rt.ior,rt.sheen>0&&(nt.sheenColor.value.copy(rt.sheenColor).multiplyScalar(rt.sheen),nt.sheenRoughness.value=rt.sheenRoughness,rt.sheenColorMap&&(nt.sheenColorMap.value=rt.sheenColorMap,i(rt.sheenColorMap,nt.sheenColorMapTransform)),rt.sheenRoughnessMap&&(nt.sheenRoughnessMap.value=rt.sheenRoughnessMap,i(rt.sheenRoughnessMap,nt.sheenRoughnessMapTransform))),rt.clearcoat>0&&(nt.clearcoat.value=rt.clearcoat,nt.clearcoatRoughness.value=rt.clearcoatRoughness,rt.clearcoatMap&&(nt.clearcoatMap.value=rt.clearcoatMap,i(rt.clearcoatMap,nt.clearcoatMapTransform)),rt.clearcoatRoughnessMap&&(nt.clearcoatRoughnessMap.value=rt.clearcoatRoughnessMap,i(rt.clearcoatRoughnessMap,nt.clearcoatRoughnessMapTransform)),rt.clearcoatNormalMap&&(nt.clearcoatNormalMap.value=rt.clearcoatNormalMap,i(rt.clearcoatNormalMap,nt.clearcoatNormalMapTransform),nt.clearcoatNormalScale.value.copy(rt.clearcoatNormalScale),rt.side===BackSide&&nt.clearcoatNormalScale.value.negate())),rt.dispersion>0&&(nt.dispersion.value=rt.dispersion),rt.iridescence>0&&(nt.iridescence.value=rt.iridescence,nt.iridescenceIOR.value=rt.iridescenceIOR,nt.iridescenceThicknessMinimum.value=rt.iridescenceThicknessRange[0],nt.iridescenceThicknessMaximum.value=rt.iridescenceThicknessRange[1],rt.iridescenceMap&&(nt.iridescenceMap.value=rt.iridescenceMap,i(rt.iridescenceMap,nt.iridescenceMapTransform)),rt.iridescenceThicknessMap&&(nt.iridescenceThicknessMap.value=rt.iridescenceThicknessMap,i(rt.iridescenceThicknessMap,nt.iridescenceThicknessMapTransform))),rt.transmission>0&&(nt.transmission.value=rt.transmission,nt.transmissionSamplerMap.value=it.texture,nt.transmissionSamplerSize.value.set(it.width,it.height),rt.transmissionMap&&(nt.transmissionMap.value=rt.transmissionMap,i(rt.transmissionMap,nt.transmissionMapTransform)),nt.thickness.value=rt.thickness,rt.thicknessMap&&(nt.thicknessMap.value=rt.thicknessMap,i(rt.thicknessMap,nt.thicknessMapTransform)),nt.attenuationDistance.value=rt.attenuationDistance,nt.attenuationColor.value.copy(rt.attenuationColor)),rt.anisotropy>0&&(nt.anisotropyVector.value.set(rt.anisotropy*Math.cos(rt.anisotropyRotation),rt.anisotropy*Math.sin(rt.anisotropyRotation)),rt.anisotropyMap&&(nt.anisotropyMap.value=rt.anisotropyMap,i(rt.anisotropyMap,nt.anisotropyMapTransform))),nt.specularIntensity.value=rt.specularIntensity,nt.specularColor.value.copy(rt.specularColor),rt.specularColorMap&&(nt.specularColorMap.value=rt.specularColorMap,i(rt.specularColorMap,nt.specularColorMapTransform)),rt.specularIntensityMap&&(nt.specularIntensityMap.value=rt.specularIntensityMap,i(rt.specularIntensityMap,nt.specularIntensityMapTransform))}function tt(nt,rt){rt.matcap&&(nt.matcap.value=rt.matcap)}function et(nt,rt){const it=e.get(rt).light;nt.referencePosition.value.setFromMatrixPosition(it.matrixWorld),nt.nearDistance.value=it.shadow.camera.near,nt.farDistance.value=it.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:o}}function WebGLUniformsGroups(a,e,i,s){let o={},c={},d=[];const h=a.getParameter(a.MAX_UNIFORM_BUFFER_BINDINGS);function g(it,at){const st=at.program;s.uniformBlockBinding(it,st)}function _(it,at){let st=o[it.id];st===void 0&&(tt(it),st=b(it),o[it.id]=st,it.addEventListener("dispose",nt));const ot=at.program;s.updateUBOMapping(it,ot);const ct=e.render.frame;c[it.id]!==ct&&(j(it),c[it.id]=ct)}function b(it){const at=$();it.__bindingPointIndex=at;const st=a.createBuffer(),ot=it.__size,ct=it.usage;return a.bindBuffer(a.UNIFORM_BUFFER,st),a.bufferData(a.UNIFORM_BUFFER,ot,ct),a.bindBuffer(a.UNIFORM_BUFFER,null),a.bindBufferBase(a.UNIFORM_BUFFER,at,st),st}function $(){for(let it=0;it<h;it++)if(d.indexOf(it)===-1)return d.push(it),it;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function j(it){const at=o[it.id],st=it.uniforms,ot=it.__cache;a.bindBuffer(a.UNIFORM_BUFFER,at);for(let ct=0,lt=st.length;ct<lt;ct++){const dt=Array.isArray(st[ct])?st[ct]:[st[ct]];for(let xt=0,ut=dt.length;xt<ut;xt++){const ft=dt[xt];if(_e(ft,ct,xt,ot)===!0){const mt=ft.__offset,yt=Array.isArray(ft.value)?ft.value:[ft.value];let St=0;for(let Et=0;Et<yt.length;Et++){const vt=yt[Et],Nt=et(vt);typeof vt=="number"||typeof vt=="boolean"?(ft.__data[0]=vt,a.bufferSubData(a.UNIFORM_BUFFER,mt+St,ft.__data)):vt.isMatrix3?(ft.__data[0]=vt.elements[0],ft.__data[1]=vt.elements[1],ft.__data[2]=vt.elements[2],ft.__data[3]=0,ft.__data[4]=vt.elements[3],ft.__data[5]=vt.elements[4],ft.__data[6]=vt.elements[5],ft.__data[7]=0,ft.__data[8]=vt.elements[6],ft.__data[9]=vt.elements[7],ft.__data[10]=vt.elements[8],ft.__data[11]=0):(vt.toArray(ft.__data,St),St+=Nt.storage/Float32Array.BYTES_PER_ELEMENT)}a.bufferSubData(a.UNIFORM_BUFFER,mt,ft.__data)}}}a.bindBuffer(a.UNIFORM_BUFFER,null)}function _e(it,at,st,ot){const ct=it.value,lt=at+"_"+st;if(ot[lt]===void 0)return typeof ct=="number"||typeof ct=="boolean"?ot[lt]=ct:ot[lt]=ct.clone(),!0;{const dt=ot[lt];if(typeof ct=="number"||typeof ct=="boolean"){if(dt!==ct)return ot[lt]=ct,!0}else if(dt.equals(ct)===!1)return dt.copy(ct),!0}return!1}function tt(it){const at=it.uniforms;let st=0;const ot=16;for(let lt=0,dt=at.length;lt<dt;lt++){const xt=Array.isArray(at[lt])?at[lt]:[at[lt]];for(let ut=0,ft=xt.length;ut<ft;ut++){const mt=xt[ut],yt=Array.isArray(mt.value)?mt.value:[mt.value];for(let St=0,Et=yt.length;St<Et;St++){const vt=yt[St],Nt=et(vt),wt=st%ot;wt!==0&&ot-wt<Nt.boundary&&(st+=ot-wt),mt.__data=new Float32Array(Nt.storage/Float32Array.BYTES_PER_ELEMENT),mt.__offset=st,st+=Nt.storage}}}const ct=st%ot;return ct>0&&(st+=ot-ct),it.__size=st,it.__cache={},this}function et(it){const at={boundary:0,storage:0};return typeof it=="number"||typeof it=="boolean"?(at.boundary=4,at.storage=4):it.isVector2?(at.boundary=8,at.storage=8):it.isVector3||it.isColor?(at.boundary=16,at.storage=12):it.isVector4?(at.boundary=16,at.storage=16):it.isMatrix3?(at.boundary=48,at.storage=48):it.isMatrix4?(at.boundary=64,at.storage=64):it.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",it),at}function nt(it){const at=it.target;at.removeEventListener("dispose",nt);const st=d.indexOf(at.__bindingPointIndex);d.splice(st,1),a.deleteBuffer(o[at.id]),delete o[at.id],delete c[at.id]}function rt(){for(const it in o)a.deleteBuffer(o[it]);d=[],o={},c={}}return{bind:g,update:_,dispose:rt}}class WebGLRenderer{constructor(e={}){const{canvas:i=createCanvasElement(),context:s=null,depth:o=!0,stencil:c=!1,alpha:d=!1,antialias:h=!1,premultipliedAlpha:g=!0,preserveDrawingBuffer:_=!1,powerPreference:b="default",failIfMajorPerformanceCaveat:$=!1}=e;this.isWebGLRenderer=!0;let j;if(s!==null){if(typeof WebGLRenderingContext<"u"&&s instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");j=s.getContextAttributes().alpha}else j=d;const _e=new Uint32Array(4),tt=new Int32Array(4);let et=null,nt=null;const rt=[],it=[];this.domElement=i,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=SRGBColorSpace,this.toneMapping=NoToneMapping,this.toneMappingExposure=1;const at=this;let st=!1,ot=0,ct=0,lt=null,dt=-1,xt=null;const ut=new Vector4,ft=new Vector4;let mt=null;const yt=new Color(0);let St=0,Et=i.width,vt=i.height,Nt=1,wt=null,$t=null;const Ct=new Vector4(0,0,Et,vt),Mt=new Vector4(0,0,Et,vt);let Ot=!1;const Dt=new Frustum;let At=!1,kt=!1;const Ft=new Matrix4,Bt=new Vector3,Ht={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Wt=!1;function Ut(){return lt===null?Nt:1}let Rt=s;function un(It,Gt){return i.getContext(It,Gt)}try{const It={alpha:!0,depth:o,stencil:c,antialias:h,premultipliedAlpha:g,preserveDrawingBuffer:_,powerPreference:b,failIfMajorPerformanceCaveat:$};if("setAttribute"in i&&i.setAttribute("data-engine",`three.js r${REVISION}`),i.addEventListener("webglcontextlost",Yt,!1),i.addEventListener("webglcontextrestored",Jt,!1),i.addEventListener("webglcontextcreationerror",an,!1),Rt===null){const Gt="webgl2";if(Rt=un(Gt,It),Rt===null)throw un(Gt)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(It){throw console.error("THREE.WebGLRenderer: "+It.message),It}let rn,mn,sn,hn,gn,Xt,En,bt,gt,Pt,Lt,Vt,jt,cn,en,Zt,yn,pn,wn,Pn,Rn,Sn,On,Nn;function rr(){rn=new WebGLExtensions(Rt),rn.init(),Sn=new WebGLUtils(Rt,rn),mn=new WebGLCapabilities(Rt,rn,e,Sn),sn=new WebGLState(Rt),hn=new WebGLInfo(Rt),gn=new WebGLProperties,Xt=new WebGLTextures(Rt,rn,sn,gn,mn,Sn,hn),En=new WebGLCubeMaps(at),bt=new WebGLCubeUVMaps(at),gt=new WebGLAttributes(Rt),On=new WebGLBindingStates(Rt,gt),Pt=new WebGLGeometries(Rt,gt,hn,On),Lt=new WebGLObjects(Rt,Pt,gt,hn),wn=new WebGLMorphtargets(Rt,mn,Xt),Zt=new WebGLClipping(gn),Vt=new WebGLPrograms(at,En,bt,rn,mn,On,Zt),jt=new WebGLMaterials(at,gn),cn=new WebGLRenderLists,en=new WebGLRenderStates(rn),pn=new WebGLBackground(at,En,bt,sn,Lt,j,g),yn=new WebGLShadowMap(at,Lt,mn),Nn=new WebGLUniformsGroups(Rt,hn,mn,sn),Pn=new WebGLBufferRenderer(Rt,rn,hn),Rn=new WebGLIndexedBufferRenderer(Rt,rn,hn),hn.programs=Vt.programs,at.capabilities=mn,at.extensions=rn,at.properties=gn,at.renderLists=cn,at.shadowMap=yn,at.state=sn,at.info=hn}rr();const Tt=new WebXRManager(at,Rt);this.xr=Tt,this.getContext=function(){return Rt},this.getContextAttributes=function(){return Rt.getContextAttributes()},this.forceContextLoss=function(){const It=rn.get("WEBGL_lose_context");It&&It.loseContext()},this.forceContextRestore=function(){const It=rn.get("WEBGL_lose_context");It&&It.restoreContext()},this.getPixelRatio=function(){return Nt},this.setPixelRatio=function(It){It!==void 0&&(Nt=It,this.setSize(Et,vt,!1))},this.getSize=function(It){return It.set(Et,vt)},this.setSize=function(It,Gt,tn=!0){if(Tt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}Et=It,vt=Gt,i.width=Math.floor(It*Nt),i.height=Math.floor(Gt*Nt),tn===!0&&(i.style.width=It+"px",i.style.height=Gt+"px"),this.setViewport(0,0,It,Gt)},this.getDrawingBufferSize=function(It){return It.set(Et*Nt,vt*Nt).floor()},this.setDrawingBufferSize=function(It,Gt,tn){Et=It,vt=Gt,Nt=tn,i.width=Math.floor(It*tn),i.height=Math.floor(Gt*tn),this.setViewport(0,0,It,Gt)},this.getCurrentViewport=function(It){return It.copy(ut)},this.getViewport=function(It){return It.copy(Ct)},this.setViewport=function(It,Gt,tn,nn){It.isVector4?Ct.set(It.x,It.y,It.z,It.w):Ct.set(It,Gt,tn,nn),sn.viewport(ut.copy(Ct).multiplyScalar(Nt).round())},this.getScissor=function(It){return It.copy(Mt)},this.setScissor=function(It,Gt,tn,nn){It.isVector4?Mt.set(It.x,It.y,It.z,It.w):Mt.set(It,Gt,tn,nn),sn.scissor(ft.copy(Mt).multiplyScalar(Nt).round())},this.getScissorTest=function(){return Ot},this.setScissorTest=function(It){sn.setScissorTest(Ot=It)},this.setOpaqueSort=function(It){wt=It},this.setTransparentSort=function(It){$t=It},this.getClearColor=function(It){return It.copy(pn.getClearColor())},this.setClearColor=function(){pn.setClearColor.apply(pn,arguments)},this.getClearAlpha=function(){return pn.getClearAlpha()},this.setClearAlpha=function(){pn.setClearAlpha.apply(pn,arguments)},this.clear=function(It=!0,Gt=!0,tn=!0){let nn=0;if(It){let qt=!1;if(lt!==null){const bn=lt.texture.format;qt=bn===RGBAIntegerFormat||bn===RGIntegerFormat||bn===RedIntegerFormat}if(qt){const bn=lt.texture.type,Tn=bn===UnsignedByteType||bn===UnsignedIntType||bn===UnsignedShortType||bn===UnsignedInt248Type||bn===UnsignedShort4444Type||bn===UnsignedShort5551Type,$n=pn.getClearColor(),In=pn.getClearAlpha(),Ln=$n.r,Fn=$n.g,Dn=$n.b;Tn?(_e[0]=Ln,_e[1]=Fn,_e[2]=Dn,_e[3]=In,Rt.clearBufferuiv(Rt.COLOR,0,_e)):(tt[0]=Ln,tt[1]=Fn,tt[2]=Dn,tt[3]=In,Rt.clearBufferiv(Rt.COLOR,0,tt))}else nn|=Rt.COLOR_BUFFER_BIT}Gt&&(nn|=Rt.DEPTH_BUFFER_BIT),tn&&(nn|=Rt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Rt.clear(nn)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){i.removeEventListener("webglcontextlost",Yt,!1),i.removeEventListener("webglcontextrestored",Jt,!1),i.removeEventListener("webglcontextcreationerror",an,!1),cn.dispose(),en.dispose(),gn.dispose(),En.dispose(),bt.dispose(),Lt.dispose(),On.dispose(),Nn.dispose(),Vt.dispose(),Tt.dispose(),Tt.removeEventListener("sessionstart",ur),Tt.removeEventListener("sessionend",er),mr.stop()};function Yt(It){It.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),st=!0}function Jt(){console.log("THREE.WebGLRenderer: Context Restored."),st=!1;const It=hn.autoReset,Gt=yn.enabled,tn=yn.autoUpdate,nn=yn.needsUpdate,qt=yn.type;rr(),hn.autoReset=It,yn.enabled=Gt,yn.autoUpdate=tn,yn.needsUpdate=nn,yn.type=qt}function an(It){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",It.statusMessage)}function fn(It){const Gt=It.target;Gt.removeEventListener("dispose",fn),Cn(Gt)}function Cn(It){vn(It),gn.remove(It)}function vn(It){const Gt=gn.get(It).programs;Gt!==void 0&&(Gt.forEach(function(tn){Vt.releaseProgram(tn)}),It.isShaderMaterial&&Vt.releaseShaderCache(It))}this.renderBufferDirect=function(It,Gt,tn,nn,qt,bn){Gt===null&&(Gt=Ht);const Tn=qt.isMesh&&qt.matrixWorld.determinant()<0,$n=Dr(It,Gt,tn,nn,qt);sn.setMaterial(nn,Tn);let In=tn.index,Ln=1;if(nn.wireframe===!0){if(In=Pt.getWireframeAttribute(tn),In===void 0)return;Ln=2}const Fn=tn.drawRange,Dn=tn.attributes.position;let Kn=Fn.start*Ln,cr=(Fn.start+Fn.count)*Ln;bn!==null&&(Kn=Math.max(Kn,bn.start*Ln),cr=Math.min(cr,(bn.start+bn.count)*Ln)),In!==null?(Kn=Math.max(Kn,0),cr=Math.min(cr,In.count)):Dn!=null&&(Kn=Math.max(Kn,0),cr=Math.min(cr,Dn.count));const dr=cr-Kn;if(dr<0||dr===1/0)return;On.setup(qt,nn,$n,tn,In);let _r,Qn=Pn;if(In!==null&&(_r=gt.get(In),Qn=Rn,Qn.setIndex(_r)),qt.isMesh)nn.wireframe===!0?(sn.setLineWidth(nn.wireframeLinewidth*Ut()),Qn.setMode(Rt.LINES)):Qn.setMode(Rt.TRIANGLES);else if(qt.isLine){let kn=nn.linewidth;kn===void 0&&(kn=1),sn.setLineWidth(kn*Ut()),qt.isLineSegments?Qn.setMode(Rt.LINES):qt.isLineLoop?Qn.setMode(Rt.LINE_LOOP):Qn.setMode(Rt.LINE_STRIP)}else qt.isPoints?Qn.setMode(Rt.POINTS):qt.isSprite&&Qn.setMode(Rt.TRIANGLES);if(qt.isBatchedMesh)qt._multiDrawInstances!==null?Qn.renderMultiDrawInstances(qt._multiDrawStarts,qt._multiDrawCounts,qt._multiDrawCount,qt._multiDrawInstances):Qn.renderMultiDraw(qt._multiDrawStarts,qt._multiDrawCounts,qt._multiDrawCount);else if(qt.isInstancedMesh)Qn.renderInstances(Kn,dr,qt.count);else if(tn.isInstancedBufferGeometry){const kn=tn._maxInstanceCount!==void 0?tn._maxInstanceCount:1/0,yr=Math.min(tn.instanceCount,kn);Qn.renderInstances(Kn,dr,yr)}else Qn.render(Kn,dr)};function or(It,Gt,tn){It.transparent===!0&&It.side===DoubleSide&&It.forceSinglePass===!1?(It.side=BackSide,It.needsUpdate=!0,wr(It,Gt,tn),It.side=FrontSide,It.needsUpdate=!0,wr(It,Gt,tn),It.side=DoubleSide):wr(It,Gt,tn)}this.compile=function(It,Gt,tn=null){tn===null&&(tn=It),nt=en.get(tn),nt.init(Gt),it.push(nt),tn.traverseVisible(function(qt){qt.isLight&&qt.layers.test(Gt.layers)&&(nt.pushLight(qt),qt.castShadow&&nt.pushShadow(qt))}),It!==tn&&It.traverseVisible(function(qt){qt.isLight&&qt.layers.test(Gt.layers)&&(nt.pushLight(qt),qt.castShadow&&nt.pushShadow(qt))}),nt.setupLights();const nn=new Set;return It.traverse(function(qt){const bn=qt.material;if(bn)if(Array.isArray(bn))for(let Tn=0;Tn<bn.length;Tn++){const $n=bn[Tn];or($n,tn,qt),nn.add($n)}else or(bn,tn,qt),nn.add(bn)}),it.pop(),nt=null,nn},this.compileAsync=function(It,Gt,tn=null){const nn=this.compile(It,Gt,tn);return new Promise(qt=>{function bn(){if(nn.forEach(function(Tn){gn.get(Tn).currentProgram.isReady()&&nn.delete(Tn)}),nn.size===0){qt(It);return}setTimeout(bn,10)}rn.get("KHR_parallel_shader_compile")!==null?bn():setTimeout(bn,10)})};let lr=null;function qn(It){lr&&lr(It)}function ur(){mr.stop()}function er(){mr.start()}const mr=new WebGLAnimation;mr.setAnimationLoop(qn),typeof self<"u"&&mr.setContext(self),this.setAnimationLoop=function(It){lr=It,Tt.setAnimationLoop(It),It===null?mr.stop():mr.start()},Tt.addEventListener("sessionstart",ur),Tt.addEventListener("sessionend",er),this.render=function(It,Gt){if(Gt!==void 0&&Gt.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(st===!0)return;if(It.matrixWorldAutoUpdate===!0&&It.updateMatrixWorld(),Gt.parent===null&&Gt.matrixWorldAutoUpdate===!0&&Gt.updateMatrixWorld(),Tt.enabled===!0&&Tt.isPresenting===!0&&(Tt.cameraAutoUpdate===!0&&Tt.updateCamera(Gt),Gt=Tt.getCamera()),It.isScene===!0&&It.onBeforeRender(at,It,Gt,lt),nt=en.get(It,it.length),nt.init(Gt),it.push(nt),Ft.multiplyMatrices(Gt.projectionMatrix,Gt.matrixWorldInverse),Dt.setFromProjectionMatrix(Ft),kt=this.localClippingEnabled,At=Zt.init(this.clippingPlanes,kt),et=cn.get(It,rt.length),et.init(),rt.push(et),Tt.enabled===!0&&Tt.isPresenting===!0){const bn=at.xr.getDepthSensingMesh();bn!==null&&xr(bn,Gt,-1/0,at.sortObjects)}xr(It,Gt,0,at.sortObjects),et.finish(),at.sortObjects===!0&&et.sort(wt,$t),Wt=Tt.enabled===!1||Tt.isPresenting===!1||Tt.hasDepthSensing()===!1,Wt&&pn.addToRenderList(et,It),this.info.render.frame++,At===!0&&Zt.beginShadows();const tn=nt.state.shadowsArray;yn.render(tn,It,Gt),At===!0&&Zt.endShadows(),this.info.autoReset===!0&&this.info.reset();const nn=et.opaque,qt=et.transmissive;if(nt.setupLights(),Gt.isArrayCamera){const bn=Gt.cameras;if(qt.length>0)for(let Tn=0,$n=bn.length;Tn<$n;Tn++){const In=bn[Tn];Tr(nn,qt,It,In)}Wt&&pn.render(It);for(let Tn=0,$n=bn.length;Tn<$n;Tn++){const In=bn[Tn];gr(et,It,In,In.viewport)}}else qt.length>0&&Tr(nn,qt,It,Gt),Wt&&pn.render(It),gr(et,It,Gt);lt!==null&&(Xt.updateMultisampleRenderTarget(lt),Xt.updateRenderTargetMipmap(lt)),It.isScene===!0&&It.onAfterRender(at,It,Gt),On.resetDefaultState(),dt=-1,xt=null,it.pop(),it.length>0?(nt=it[it.length-1],At===!0&&Zt.setGlobalState(at.clippingPlanes,nt.state.camera)):nt=null,rt.pop(),rt.length>0?et=rt[rt.length-1]:et=null};function xr(It,Gt,tn,nn){if(It.visible===!1)return;if(It.layers.test(Gt.layers)){if(It.isGroup)tn=It.renderOrder;else if(It.isLOD)It.autoUpdate===!0&&It.update(Gt);else if(It.isLight)nt.pushLight(It),It.castShadow&&nt.pushShadow(It);else if(It.isSprite){if(!It.frustumCulled||Dt.intersectsSprite(It)){nn&&Bt.setFromMatrixPosition(It.matrixWorld).applyMatrix4(Ft);const Tn=Lt.update(It),$n=It.material;$n.visible&&et.push(It,Tn,$n,tn,Bt.z,null)}}else if((It.isMesh||It.isLine||It.isPoints)&&(!It.frustumCulled||Dt.intersectsObject(It))){const Tn=Lt.update(It),$n=It.material;if(nn&&(It.boundingSphere!==void 0?(It.boundingSphere===null&&It.computeBoundingSphere(),Bt.copy(It.boundingSphere.center)):(Tn.boundingSphere===null&&Tn.computeBoundingSphere(),Bt.copy(Tn.boundingSphere.center)),Bt.applyMatrix4(It.matrixWorld).applyMatrix4(Ft)),Array.isArray($n)){const In=Tn.groups;for(let Ln=0,Fn=In.length;Ln<Fn;Ln++){const Dn=In[Ln],Kn=$n[Dn.materialIndex];Kn&&Kn.visible&&et.push(It,Tn,Kn,tn,Bt.z,Dn)}}else $n.visible&&et.push(It,Tn,$n,tn,Bt.z,null)}}const bn=It.children;for(let Tn=0,$n=bn.length;Tn<$n;Tn++)xr(bn[Tn],Gt,tn,nn)}function gr(It,Gt,tn,nn){const qt=It.opaque,bn=It.transmissive,Tn=It.transparent;nt.setupLightsView(tn),At===!0&&Zt.setGlobalState(at.clippingPlanes,tn),nn&&sn.viewport(ut.copy(nn)),qt.length>0&&Cr(qt,Gt,tn),bn.length>0&&Cr(bn,Gt,tn),Tn.length>0&&Cr(Tn,Gt,tn),sn.buffers.depth.setTest(!0),sn.buffers.depth.setMask(!0),sn.buffers.color.setMask(!0),sn.setPolygonOffset(!1)}function Tr(It,Gt,tn,nn){if((tn.isScene===!0?tn.overrideMaterial:null)!==null)return;nt.state.transmissionRenderTarget[nn.id]===void 0&&(nt.state.transmissionRenderTarget[nn.id]=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:rn.has("EXT_color_buffer_half_float")||rn.has("EXT_color_buffer_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:4,stencilBuffer:c,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:ColorManagement.workingColorSpace}));const bn=nt.state.transmissionRenderTarget[nn.id],Tn=nn.viewport||ut;bn.setSize(Tn.z,Tn.w);const $n=at.getRenderTarget();at.setRenderTarget(bn),at.getClearColor(yt),St=at.getClearAlpha(),St<1&&at.setClearColor(16777215,.5),Wt?pn.render(tn):at.clear();const In=at.toneMapping;at.toneMapping=NoToneMapping;const Ln=nn.viewport;if(nn.viewport!==void 0&&(nn.viewport=void 0),nt.setupLightsView(nn),At===!0&&Zt.setGlobalState(at.clippingPlanes,nn),Cr(It,tn,nn),Xt.updateMultisampleRenderTarget(bn),Xt.updateRenderTargetMipmap(bn),rn.has("WEBGL_multisampled_render_to_texture")===!1){let Fn=!1;for(let Dn=0,Kn=Gt.length;Dn<Kn;Dn++){const cr=Gt[Dn],dr=cr.object,_r=cr.geometry,Qn=cr.material,kn=cr.group;if(Qn.side===DoubleSide&&dr.layers.test(nn.layers)){const yr=Qn.side;Qn.side=BackSide,Qn.needsUpdate=!0,fr(dr,tn,nn,_r,Qn,kn),Qn.side=yr,Qn.needsUpdate=!0,Fn=!0}}Fn===!0&&(Xt.updateMultisampleRenderTarget(bn),Xt.updateRenderTargetMipmap(bn))}at.setRenderTarget($n),at.setClearColor(yt,St),Ln!==void 0&&(nn.viewport=Ln),at.toneMapping=In}function Cr(It,Gt,tn){const nn=Gt.isScene===!0?Gt.overrideMaterial:null;for(let qt=0,bn=It.length;qt<bn;qt++){const Tn=It[qt],$n=Tn.object,In=Tn.geometry,Ln=nn===null?Tn.material:nn,Fn=Tn.group;$n.layers.test(tn.layers)&&fr($n,Gt,tn,In,Ln,Fn)}}function fr(It,Gt,tn,nn,qt,bn){It.onBeforeRender(at,Gt,tn,nn,qt,bn),It.modelViewMatrix.multiplyMatrices(tn.matrixWorldInverse,It.matrixWorld),It.normalMatrix.getNormalMatrix(It.modelViewMatrix),qt.onBeforeRender(at,Gt,tn,nn,It,bn),qt.transparent===!0&&qt.side===DoubleSide&&qt.forceSinglePass===!1?(qt.side=BackSide,qt.needsUpdate=!0,at.renderBufferDirect(tn,Gt,nn,qt,It,bn),qt.side=FrontSide,qt.needsUpdate=!0,at.renderBufferDirect(tn,Gt,nn,qt,It,bn),qt.side=DoubleSide):at.renderBufferDirect(tn,Gt,nn,qt,It,bn),It.onAfterRender(at,Gt,tn,nn,qt,bn)}function wr(It,Gt,tn){Gt.isScene!==!0&&(Gt=Ht);const nn=gn.get(It),qt=nt.state.lights,bn=nt.state.shadowsArray,Tn=qt.state.version,$n=Vt.getParameters(It,qt.state,bn,Gt,tn),In=Vt.getProgramCacheKey($n);let Ln=nn.programs;nn.environment=It.isMeshStandardMaterial?Gt.environment:null,nn.fog=Gt.fog,nn.envMap=(It.isMeshStandardMaterial?bt:En).get(It.envMap||nn.environment),nn.envMapRotation=nn.environment!==null&&It.envMap===null?Gt.environmentRotation:It.envMapRotation,Ln===void 0&&(It.addEventListener("dispose",fn),Ln=new Map,nn.programs=Ln);let Fn=Ln.get(In);if(Fn!==void 0){if(nn.currentProgram===Fn&&nn.lightsStateVersion===Tn)return Ir(It,$n),Fn}else $n.uniforms=Vt.getUniforms(It),It.onBuild(tn,$n,at),It.onBeforeCompile($n,at),Fn=Vt.acquireProgram($n,In),Ln.set(In,Fn),nn.uniforms=$n.uniforms;const Dn=nn.uniforms;return(!It.isShaderMaterial&&!It.isRawShaderMaterial||It.clipping===!0)&&(Dn.clippingPlanes=Zt.uniform),Ir(It,$n),nn.needsLights=ir(It),nn.lightsStateVersion=Tn,nn.needsLights&&(Dn.ambientLightColor.value=qt.state.ambient,Dn.lightProbe.value=qt.state.probe,Dn.directionalLights.value=qt.state.directional,Dn.directionalLightShadows.value=qt.state.directionalShadow,Dn.spotLights.value=qt.state.spot,Dn.spotLightShadows.value=qt.state.spotShadow,Dn.rectAreaLights.value=qt.state.rectArea,Dn.ltc_1.value=qt.state.rectAreaLTC1,Dn.ltc_2.value=qt.state.rectAreaLTC2,Dn.pointLights.value=qt.state.point,Dn.pointLightShadows.value=qt.state.pointShadow,Dn.hemisphereLights.value=qt.state.hemi,Dn.directionalShadowMap.value=qt.state.directionalShadowMap,Dn.directionalShadowMatrix.value=qt.state.directionalShadowMatrix,Dn.spotShadowMap.value=qt.state.spotShadowMap,Dn.spotLightMatrix.value=qt.state.spotLightMatrix,Dn.spotLightMap.value=qt.state.spotLightMap,Dn.pointShadowMap.value=qt.state.pointShadowMap,Dn.pointShadowMatrix.value=qt.state.pointShadowMatrix),nn.currentProgram=Fn,nn.uniformsList=null,Fn}function kr(It){if(It.uniformsList===null){const Gt=It.currentProgram.getUniforms();It.uniformsList=WebGLUniforms.seqWithValue(Gt.seq,It.uniforms)}return It.uniformsList}function Ir(It,Gt){const tn=gn.get(It);tn.outputColorSpace=Gt.outputColorSpace,tn.batching=Gt.batching,tn.batchingColor=Gt.batchingColor,tn.instancing=Gt.instancing,tn.instancingColor=Gt.instancingColor,tn.instancingMorph=Gt.instancingMorph,tn.skinning=Gt.skinning,tn.morphTargets=Gt.morphTargets,tn.morphNormals=Gt.morphNormals,tn.morphColors=Gt.morphColors,tn.morphTargetsCount=Gt.morphTargetsCount,tn.numClippingPlanes=Gt.numClippingPlanes,tn.numIntersection=Gt.numClipIntersection,tn.vertexAlphas=Gt.vertexAlphas,tn.vertexTangents=Gt.vertexTangents,tn.toneMapping=Gt.toneMapping}function Dr(It,Gt,tn,nn,qt){Gt.isScene!==!0&&(Gt=Ht),Xt.resetTextureUnits();const bn=Gt.fog,Tn=nn.isMeshStandardMaterial?Gt.environment:null,$n=lt===null?at.outputColorSpace:lt.isXRRenderTarget===!0?lt.texture.colorSpace:LinearSRGBColorSpace,In=(nn.isMeshStandardMaterial?bt:En).get(nn.envMap||Tn),Ln=nn.vertexColors===!0&&!!tn.attributes.color&&tn.attributes.color.itemSize===4,Fn=!!tn.attributes.tangent&&(!!nn.normalMap||nn.anisotropy>0),Dn=!!tn.morphAttributes.position,Kn=!!tn.morphAttributes.normal,cr=!!tn.morphAttributes.color;let dr=NoToneMapping;nn.toneMapped&&(lt===null||lt.isXRRenderTarget===!0)&&(dr=at.toneMapping);const _r=tn.morphAttributes.position||tn.morphAttributes.normal||tn.morphAttributes.color,Qn=_r!==void 0?_r.length:0,kn=gn.get(nn),yr=nt.state.lights;if(At===!0&&(kt===!0||It!==xt)){const Sr=It===xt&&nn.id===dt;Zt.setState(nn,It,Sr)}let tr=!1;nn.version===kn.__version?(kn.needsLights&&kn.lightsStateVersion!==yr.state.version||kn.outputColorSpace!==$n||qt.isBatchedMesh&&kn.batching===!1||!qt.isBatchedMesh&&kn.batching===!0||qt.isBatchedMesh&&kn.batchingColor===!0&&qt.colorTexture===null||qt.isBatchedMesh&&kn.batchingColor===!1&&qt.colorTexture!==null||qt.isInstancedMesh&&kn.instancing===!1||!qt.isInstancedMesh&&kn.instancing===!0||qt.isSkinnedMesh&&kn.skinning===!1||!qt.isSkinnedMesh&&kn.skinning===!0||qt.isInstancedMesh&&kn.instancingColor===!0&&qt.instanceColor===null||qt.isInstancedMesh&&kn.instancingColor===!1&&qt.instanceColor!==null||qt.isInstancedMesh&&kn.instancingMorph===!0&&qt.morphTexture===null||qt.isInstancedMesh&&kn.instancingMorph===!1&&qt.morphTexture!==null||kn.envMap!==In||nn.fog===!0&&kn.fog!==bn||kn.numClippingPlanes!==void 0&&(kn.numClippingPlanes!==Zt.numPlanes||kn.numIntersection!==Zt.numIntersection)||kn.vertexAlphas!==Ln||kn.vertexTangents!==Fn||kn.morphTargets!==Dn||kn.morphNormals!==Kn||kn.morphColors!==cr||kn.toneMapping!==dr||kn.morphTargetsCount!==Qn)&&(tr=!0):(tr=!0,kn.__version=nn.version);let $r=kn.currentProgram;tr===!0&&($r=wr(nn,Gt,qt));let Mr=!1,Nr=!1,Lr=!1;const pr=$r.getUniforms(),Ar=kn.uniforms;if(sn.useProgram($r.program)&&(Mr=!0,Nr=!0,Lr=!0),nn.id!==dt&&(dt=nn.id,Nr=!0),Mr||xt!==It){pr.setValue(Rt,"projectionMatrix",It.projectionMatrix),pr.setValue(Rt,"viewMatrix",It.matrixWorldInverse);const Sr=pr.map.cameraPosition;Sr!==void 0&&Sr.setValue(Rt,Bt.setFromMatrixPosition(It.matrixWorld)),mn.logarithmicDepthBuffer&&pr.setValue(Rt,"logDepthBufFC",2/(Math.log(It.far+1)/Math.LN2)),(nn.isMeshPhongMaterial||nn.isMeshToonMaterial||nn.isMeshLambertMaterial||nn.isMeshBasicMaterial||nn.isMeshStandardMaterial||nn.isShaderMaterial)&&pr.setValue(Rt,"isOrthographic",It.isOrthographicCamera===!0),xt!==It&&(xt=It,Nr=!0,Lr=!0)}if(qt.isSkinnedMesh){pr.setOptional(Rt,qt,"bindMatrix"),pr.setOptional(Rt,qt,"bindMatrixInverse");const Sr=qt.skeleton;Sr&&(Sr.boneTexture===null&&Sr.computeBoneTexture(),pr.setValue(Rt,"boneTexture",Sr.boneTexture,Xt))}qt.isBatchedMesh&&(pr.setOptional(Rt,qt,"batchingTexture"),pr.setValue(Rt,"batchingTexture",qt._matricesTexture,Xt),pr.setOptional(Rt,qt,"batchingColorTexture"),qt._colorsTexture!==null&&pr.setValue(Rt,"batchingColorTexture",qt._colorsTexture,Xt));const Rr=tn.morphAttributes;if((Rr.position!==void 0||Rr.normal!==void 0||Rr.color!==void 0)&&wn.update(qt,tn,$r),(Nr||kn.receiveShadow!==qt.receiveShadow)&&(kn.receiveShadow=qt.receiveShadow,pr.setValue(Rt,"receiveShadow",qt.receiveShadow)),nn.isMeshGouraudMaterial&&nn.envMap!==null&&(Ar.envMap.value=In,Ar.flipEnvMap.value=In.isCubeTexture&&In.isRenderTargetTexture===!1?-1:1),nn.isMeshStandardMaterial&&nn.envMap===null&&Gt.environment!==null&&(Ar.envMapIntensity.value=Gt.environmentIntensity),Nr&&(pr.setValue(Rt,"toneMappingExposure",at.toneMappingExposure),kn.needsLights&&Er(Ar,Lr),bn&&nn.fog===!0&&jt.refreshFogUniforms(Ar,bn),jt.refreshMaterialUniforms(Ar,nn,Nt,vt,nt.state.transmissionRenderTarget[It.id]),WebGLUniforms.upload(Rt,kr(kn),Ar,Xt)),nn.isShaderMaterial&&nn.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(Rt,kr(kn),Ar,Xt),nn.uniformsNeedUpdate=!1),nn.isSpriteMaterial&&pr.setValue(Rt,"center",qt.center),pr.setValue(Rt,"modelViewMatrix",qt.modelViewMatrix),pr.setValue(Rt,"normalMatrix",qt.normalMatrix),pr.setValue(Rt,"modelMatrix",qt.matrixWorld),nn.isShaderMaterial||nn.isRawShaderMaterial){const Sr=nn.uniformsGroups;for(let Or=0,Br=Sr.length;Or<Br;Or++){const zr=Sr[Or];Nn.update(zr,$r),Nn.bind(zr,$r)}}return $r}function Er(It,Gt){It.ambientLightColor.needsUpdate=Gt,It.lightProbe.needsUpdate=Gt,It.directionalLights.needsUpdate=Gt,It.directionalLightShadows.needsUpdate=Gt,It.pointLights.needsUpdate=Gt,It.pointLightShadows.needsUpdate=Gt,It.spotLights.needsUpdate=Gt,It.spotLightShadows.needsUpdate=Gt,It.rectAreaLights.needsUpdate=Gt,It.hemisphereLights.needsUpdate=Gt}function ir(It){return It.isMeshLambertMaterial||It.isMeshToonMaterial||It.isMeshPhongMaterial||It.isMeshStandardMaterial||It.isShadowMaterial||It.isShaderMaterial&&It.lights===!0}this.getActiveCubeFace=function(){return ot},this.getActiveMipmapLevel=function(){return ct},this.getRenderTarget=function(){return lt},this.setRenderTargetTextures=function(It,Gt,tn){gn.get(It.texture).__webglTexture=Gt,gn.get(It.depthTexture).__webglTexture=tn;const nn=gn.get(It);nn.__hasExternalTextures=!0,nn.__autoAllocateDepthBuffer=tn===void 0,nn.__autoAllocateDepthBuffer||rn.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),nn.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(It,Gt){const tn=gn.get(It);tn.__webglFramebuffer=Gt,tn.__useDefaultFramebuffer=Gt===void 0},this.setRenderTarget=function(It,Gt=0,tn=0){lt=It,ot=Gt,ct=tn;let nn=!0,qt=null,bn=!1,Tn=!1;if(It){const In=gn.get(It);In.__useDefaultFramebuffer!==void 0?(sn.bindFramebuffer(Rt.FRAMEBUFFER,null),nn=!1):In.__webglFramebuffer===void 0?Xt.setupRenderTarget(It):In.__hasExternalTextures&&Xt.rebindTextures(It,gn.get(It.texture).__webglTexture,gn.get(It.depthTexture).__webglTexture);const Ln=It.texture;(Ln.isData3DTexture||Ln.isDataArrayTexture||Ln.isCompressedArrayTexture)&&(Tn=!0);const Fn=gn.get(It).__webglFramebuffer;It.isWebGLCubeRenderTarget?(Array.isArray(Fn[Gt])?qt=Fn[Gt][tn]:qt=Fn[Gt],bn=!0):It.samples>0&&Xt.useMultisampledRTT(It)===!1?qt=gn.get(It).__webglMultisampledFramebuffer:Array.isArray(Fn)?qt=Fn[tn]:qt=Fn,ut.copy(It.viewport),ft.copy(It.scissor),mt=It.scissorTest}else ut.copy(Ct).multiplyScalar(Nt).floor(),ft.copy(Mt).multiplyScalar(Nt).floor(),mt=Ot;if(sn.bindFramebuffer(Rt.FRAMEBUFFER,qt)&&nn&&sn.drawBuffers(It,qt),sn.viewport(ut),sn.scissor(ft),sn.setScissorTest(mt),bn){const In=gn.get(It.texture);Rt.framebufferTexture2D(Rt.FRAMEBUFFER,Rt.COLOR_ATTACHMENT0,Rt.TEXTURE_CUBE_MAP_POSITIVE_X+Gt,In.__webglTexture,tn)}else if(Tn){const In=gn.get(It.texture),Ln=Gt||0;Rt.framebufferTextureLayer(Rt.FRAMEBUFFER,Rt.COLOR_ATTACHMENT0,In.__webglTexture,tn||0,Ln)}dt=-1},this.readRenderTargetPixels=function(It,Gt,tn,nn,qt,bn,Tn){if(!(It&&It.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let $n=gn.get(It).__webglFramebuffer;if(It.isWebGLCubeRenderTarget&&Tn!==void 0&&($n=$n[Tn]),$n){sn.bindFramebuffer(Rt.FRAMEBUFFER,$n);try{const In=It.texture,Ln=In.format,Fn=In.type;if(!mn.textureFormatReadable(Ln)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!mn.textureTypeReadable(Fn)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Gt>=0&&Gt<=It.width-nn&&tn>=0&&tn<=It.height-qt&&Rt.readPixels(Gt,tn,nn,qt,Sn.convert(Ln),Sn.convert(Fn),bn)}finally{const In=lt!==null?gn.get(lt).__webglFramebuffer:null;sn.bindFramebuffer(Rt.FRAMEBUFFER,In)}}},this.readRenderTargetPixelsAsync=async function(It,Gt,tn,nn,qt,bn,Tn){if(!(It&&It.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let $n=gn.get(It).__webglFramebuffer;if(It.isWebGLCubeRenderTarget&&Tn!==void 0&&($n=$n[Tn]),$n){sn.bindFramebuffer(Rt.FRAMEBUFFER,$n);try{const In=It.texture,Ln=In.format,Fn=In.type;if(!mn.textureFormatReadable(Ln))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!mn.textureTypeReadable(Fn))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(Gt>=0&&Gt<=It.width-nn&&tn>=0&&tn<=It.height-qt){const Dn=Rt.createBuffer();Rt.bindBuffer(Rt.PIXEL_PACK_BUFFER,Dn),Rt.bufferData(Rt.PIXEL_PACK_BUFFER,bn.byteLength,Rt.STREAM_READ),Rt.readPixels(Gt,tn,nn,qt,Sn.convert(Ln),Sn.convert(Fn),0),Rt.flush();const Kn=Rt.fenceSync(Rt.SYNC_GPU_COMMANDS_COMPLETE,0);await probeAsync(Rt,Kn,4);try{Rt.bindBuffer(Rt.PIXEL_PACK_BUFFER,Dn),Rt.getBufferSubData(Rt.PIXEL_PACK_BUFFER,0,bn)}finally{Rt.deleteBuffer(Dn),Rt.deleteSync(Kn)}return bn}}finally{const In=lt!==null?gn.get(lt).__webglFramebuffer:null;sn.bindFramebuffer(Rt.FRAMEBUFFER,In)}}},this.copyFramebufferToTexture=function(It,Gt=null,tn=0){It.isTexture!==!0&&(console.warn("WebGLRenderer: copyFramebufferToTexture function signature has changed."),Gt=arguments[0]||null,It=arguments[1]);const nn=Math.pow(2,-tn),qt=Math.floor(It.image.width*nn),bn=Math.floor(It.image.height*nn),Tn=Gt!==null?Gt.x:0,$n=Gt!==null?Gt.y:0;Xt.setTexture2D(It,0),Rt.copyTexSubImage2D(Rt.TEXTURE_2D,tn,0,0,Tn,$n,qt,bn),sn.unbindTexture()},this.copyTextureToTexture=function(It,Gt,tn=null,nn=null,qt=0){It.isTexture!==!0&&(console.warn("WebGLRenderer: copyTextureToTexture function signature has changed."),nn=arguments[0]||null,It=arguments[1],Gt=arguments[2],qt=arguments[3]||0,tn=null);let bn,Tn,$n,In,Ln,Fn;tn!==null?(bn=tn.max.x-tn.min.x,Tn=tn.max.y-tn.min.y,$n=tn.min.x,In=tn.min.y):(bn=It.image.width,Tn=It.image.height,$n=0,In=0),nn!==null?(Ln=nn.x,Fn=nn.y):(Ln=0,Fn=0);const Dn=Sn.convert(Gt.format),Kn=Sn.convert(Gt.type);Xt.setTexture2D(Gt,0),Rt.pixelStorei(Rt.UNPACK_FLIP_Y_WEBGL,Gt.flipY),Rt.pixelStorei(Rt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Gt.premultiplyAlpha),Rt.pixelStorei(Rt.UNPACK_ALIGNMENT,Gt.unpackAlignment);const cr=Rt.getParameter(Rt.UNPACK_ROW_LENGTH),dr=Rt.getParameter(Rt.UNPACK_IMAGE_HEIGHT),_r=Rt.getParameter(Rt.UNPACK_SKIP_PIXELS),Qn=Rt.getParameter(Rt.UNPACK_SKIP_ROWS),kn=Rt.getParameter(Rt.UNPACK_SKIP_IMAGES),yr=It.isCompressedTexture?It.mipmaps[qt]:It.image;Rt.pixelStorei(Rt.UNPACK_ROW_LENGTH,yr.width),Rt.pixelStorei(Rt.UNPACK_IMAGE_HEIGHT,yr.height),Rt.pixelStorei(Rt.UNPACK_SKIP_PIXELS,$n),Rt.pixelStorei(Rt.UNPACK_SKIP_ROWS,In),It.isDataTexture?Rt.texSubImage2D(Rt.TEXTURE_2D,qt,Ln,Fn,bn,Tn,Dn,Kn,yr.data):It.isCompressedTexture?Rt.compressedTexSubImage2D(Rt.TEXTURE_2D,qt,Ln,Fn,yr.width,yr.height,Dn,yr.data):Rt.texSubImage2D(Rt.TEXTURE_2D,qt,Ln,Fn,Dn,Kn,yr),Rt.pixelStorei(Rt.UNPACK_ROW_LENGTH,cr),Rt.pixelStorei(Rt.UNPACK_IMAGE_HEIGHT,dr),Rt.pixelStorei(Rt.UNPACK_SKIP_PIXELS,_r),Rt.pixelStorei(Rt.UNPACK_SKIP_ROWS,Qn),Rt.pixelStorei(Rt.UNPACK_SKIP_IMAGES,kn),qt===0&&Gt.generateMipmaps&&Rt.generateMipmap(Rt.TEXTURE_2D),sn.unbindTexture()},this.copyTextureToTexture3D=function(It,Gt,tn=null,nn=null,qt=0){It.isTexture!==!0&&(console.warn("WebGLRenderer: copyTextureToTexture3D function signature has changed."),tn=arguments[0]||null,nn=arguments[1]||null,It=arguments[2],Gt=arguments[3],qt=arguments[4]||0);let bn,Tn,$n,In,Ln,Fn,Dn,Kn,cr;const dr=It.isCompressedTexture?It.mipmaps[qt]:It.image;tn!==null?(bn=tn.max.x-tn.min.x,Tn=tn.max.y-tn.min.y,$n=tn.max.z-tn.min.z,In=tn.min.x,Ln=tn.min.y,Fn=tn.min.z):(bn=dr.width,Tn=dr.height,$n=dr.depth,In=0,Ln=0,Fn=0),nn!==null?(Dn=nn.x,Kn=nn.y,cr=nn.z):(Dn=0,Kn=0,cr=0);const _r=Sn.convert(Gt.format),Qn=Sn.convert(Gt.type);let kn;if(Gt.isData3DTexture)Xt.setTexture3D(Gt,0),kn=Rt.TEXTURE_3D;else if(Gt.isDataArrayTexture||Gt.isCompressedArrayTexture)Xt.setTexture2DArray(Gt,0),kn=Rt.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Rt.pixelStorei(Rt.UNPACK_FLIP_Y_WEBGL,Gt.flipY),Rt.pixelStorei(Rt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Gt.premultiplyAlpha),Rt.pixelStorei(Rt.UNPACK_ALIGNMENT,Gt.unpackAlignment);const yr=Rt.getParameter(Rt.UNPACK_ROW_LENGTH),tr=Rt.getParameter(Rt.UNPACK_IMAGE_HEIGHT),$r=Rt.getParameter(Rt.UNPACK_SKIP_PIXELS),Mr=Rt.getParameter(Rt.UNPACK_SKIP_ROWS),Nr=Rt.getParameter(Rt.UNPACK_SKIP_IMAGES);Rt.pixelStorei(Rt.UNPACK_ROW_LENGTH,dr.width),Rt.pixelStorei(Rt.UNPACK_IMAGE_HEIGHT,dr.height),Rt.pixelStorei(Rt.UNPACK_SKIP_PIXELS,In),Rt.pixelStorei(Rt.UNPACK_SKIP_ROWS,Ln),Rt.pixelStorei(Rt.UNPACK_SKIP_IMAGES,Fn),It.isDataTexture||It.isData3DTexture?Rt.texSubImage3D(kn,qt,Dn,Kn,cr,bn,Tn,$n,_r,Qn,dr.data):Gt.isCompressedArrayTexture?Rt.compressedTexSubImage3D(kn,qt,Dn,Kn,cr,bn,Tn,$n,_r,dr.data):Rt.texSubImage3D(kn,qt,Dn,Kn,cr,bn,Tn,$n,_r,Qn,dr),Rt.pixelStorei(Rt.UNPACK_ROW_LENGTH,yr),Rt.pixelStorei(Rt.UNPACK_IMAGE_HEIGHT,tr),Rt.pixelStorei(Rt.UNPACK_SKIP_PIXELS,$r),Rt.pixelStorei(Rt.UNPACK_SKIP_ROWS,Mr),Rt.pixelStorei(Rt.UNPACK_SKIP_IMAGES,Nr),qt===0&&Gt.generateMipmaps&&Rt.generateMipmap(kn),sn.unbindTexture()},this.initRenderTarget=function(It){gn.get(It).__webglFramebuffer===void 0&&Xt.setupRenderTarget(It)},this.initTexture=function(It){It.isCubeTexture?Xt.setTextureCube(It,0):It.isData3DTexture?Xt.setTexture3D(It,0):It.isDataArrayTexture||It.isCompressedArrayTexture?Xt.setTexture2DArray(It,0):Xt.setTexture2D(It,0),sn.unbindTexture()},this.resetState=function(){ot=0,ct=0,lt=null,sn.reset(),On.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const i=this.getContext();i.drawingBufferColorSpace=e===DisplayP3ColorSpace?"display-p3":"srgb",i.unpackColorSpace=ColorManagement.workingColorSpace===LinearDisplayP3ColorSpace?"display-p3":"srgb"}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentIntensity=1,this.environmentRotation=new Euler,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,i){return super.copy(e,i),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const i=super.toJSON(e);return this.fog!==null&&(i.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(i.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(i.object.backgroundIntensity=this.backgroundIntensity),i.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(i.object.environmentIntensity=this.environmentIntensity),i.object.environmentRotation=this.environmentRotation.toArray(),i}}class InterleavedBuffer{constructor(e,i){this.isInterleavedBuffer=!0,this.array=e,this.stride=i,this.count=e!==void 0?e.length/i:0,this.usage=StaticDrawUsage,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return warnOnce("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,i){this.updateRanges.push({start:e,count:i})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,i,s){e*=this.stride,s*=i.stride;for(let o=0,c=this.stride;o<c;o++)this.array[e+o]=i.array[s+o];return this}set(e,i=0){return this.array.set(e,i),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const i=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(i,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$6=new Vector3;class InterleavedBufferAttribute{constructor(e,i,s,o=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=i,this.offset=s,this.normalized=o}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let i=0,s=this.data.count;i<s;i++)_vector$6.fromBufferAttribute(this,i),_vector$6.applyMatrix4(e),this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);return this}applyNormalMatrix(e){for(let i=0,s=this.count;i<s;i++)_vector$6.fromBufferAttribute(this,i),_vector$6.applyNormalMatrix(e),this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);return this}transformDirection(e){for(let i=0,s=this.count;i<s;i++)_vector$6.fromBufferAttribute(this,i),_vector$6.transformDirection(e),this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);return this}getComponent(e,i){let s=this.array[e*this.data.stride+this.offset+i];return this.normalized&&(s=denormalize(s,this.array)),s}setComponent(e,i,s){return this.normalized&&(s=normalize(s,this.array)),this.data.array[e*this.data.stride+this.offset+i]=s,this}setX(e,i){return this.normalized&&(i=normalize(i,this.array)),this.data.array[e*this.data.stride+this.offset]=i,this}setY(e,i){return this.normalized&&(i=normalize(i,this.array)),this.data.array[e*this.data.stride+this.offset+1]=i,this}setZ(e,i){return this.normalized&&(i=normalize(i,this.array)),this.data.array[e*this.data.stride+this.offset+2]=i,this}setW(e,i){return this.normalized&&(i=normalize(i,this.array)),this.data.array[e*this.data.stride+this.offset+3]=i,this}getX(e){let i=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(i=denormalize(i,this.array)),i}getY(e){let i=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(i=denormalize(i,this.array)),i}getZ(e){let i=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(i=denormalize(i,this.array)),i}getW(e){let i=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(i=denormalize(i,this.array)),i}setXY(e,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(i=normalize(i,this.array),s=normalize(s,this.array)),this.data.array[e+0]=i,this.data.array[e+1]=s,this}setXYZ(e,i,s,o){return e=e*this.data.stride+this.offset,this.normalized&&(i=normalize(i,this.array),s=normalize(s,this.array),o=normalize(o,this.array)),this.data.array[e+0]=i,this.data.array[e+1]=s,this.data.array[e+2]=o,this}setXYZW(e,i,s,o,c){return e=e*this.data.stride+this.offset,this.normalized&&(i=normalize(i,this.array),s=normalize(s,this.array),o=normalize(o,this.array),c=normalize(c,this.array)),this.data.array[e+0]=i,this.data.array[e+1]=s,this.data.array[e+2]=o,this.data.array[e+3]=c,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const i=[];for(let s=0;s<this.count;s++){const o=s*this.data.stride+this.offset;for(let c=0;c<this.itemSize;c++)i.push(this.data.array[o+c])}return new BufferAttribute(new this.array.constructor(i),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const i=[];for(let s=0;s<this.count;s++){const o=s*this.data.stride+this.offset;for(let c=0;c<this.itemSize;c++)i.push(this.data.array[o+c])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:i,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$4=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(e,i){super(e,i),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const i=e.getAttribute("position");for(let s=0;s<i.count;s++)this.getVertexPosition(s,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const i=e.getAttribute("position");for(let s=0;s<i.count;s++)this.getVertexPosition(s,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(e,i){return super.copy(e,i),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,i){const s=this.material,o=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(o),e.ray.intersectsSphere(_sphere$4)!==!1&&(_inverseMatrix$2.copy(o).invert(),_ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,i,_ray$2)))}getVertexPosition(e,i){return super.getVertexPosition(e,i),this.applyBoneTransform(e,i),i}bind(e,i){this.skeleton=e,i===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),i=this.matrixWorld),this.bindMatrix.copy(i),this.bindMatrixInverse.copy(i).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Vector4,i=this.geometry.attributes.skinWeight;for(let s=0,o=i.count;s<o;s++){e.fromBufferAttribute(i,s);const c=1/e.manhattanLength();c!==1/0?e.multiplyScalar(c):e.set(1,0,0,0),i.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,i){const s=this.skeleton,o=this.geometry;_skinIndex.fromBufferAttribute(o.attributes.skinIndex,e),_skinWeight.fromBufferAttribute(o.attributes.skinWeight,e),_basePosition.copy(i).applyMatrix4(this.bindMatrix),i.set(0,0,0);for(let c=0;c<4;c++){const d=_skinWeight.getComponent(c);if(d!==0){const h=_skinIndex.getComponent(c);_matrix4.multiplyMatrices(s.bones[h].matrixWorld,s.boneInverses[h]),i.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),d)}}return i.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(e=null,i=1,s=1,o,c,d,h,g,_=NearestFilter,b=NearestFilter,$,j){super(null,d,h,g,_,b,o,c,$,j),this.isDataTexture=!0,this.image={data:e,width:i,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix$1=new Matrix4;class Skeleton{constructor(e=[],i=[]){this.uuid=generateUUID(),this.bones=e.slice(0),this.boneInverses=i,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,i=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),i.length===0)this.calculateInverses();else if(e.length!==i.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,o=this.bones.length;s<o;s++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,i=this.bones.length;e<i;e++){const s=new Matrix4;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,i=this.bones.length;e<i;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,i=this.bones.length;e<i;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,i=this.boneInverses,s=this.boneMatrices,o=this.boneTexture;for(let c=0,d=e.length;c<d;c++){const h=e[c]?e[c].matrixWorld:_identityMatrix$1;_offsetMatrix.multiplyMatrices(h,i[c]),_offsetMatrix.toArray(s,c*16)}o!==null&&(o.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const i=new Float32Array(e*e*4);i.set(this.boneMatrices);const s=new DataTexture(i,e,e,RGBAFormat,FloatType);return s.needsUpdate=!0,this.boneMatrices=i,this.boneTexture=s,this}getBoneByName(e){for(let i=0,s=this.bones.length;i<s;i++){const o=this.bones[i];if(o.name===e)return o}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,i){this.uuid=e.uuid;for(let s=0,o=e.bones.length;s<o;s++){const c=e.bones[s];let d=i[c];d===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",c),d=new Bone),this.bones.push(d),this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const i=this.bones,s=this.boneInverses;for(let o=0,c=i.length;o<c;o++){const d=i[o];e.bones.push(d.uuid);const h=s[o];e.boneInverses.push(h.toArray())}return e}}class InstancedBufferAttribute extends BufferAttribute{constructor(e,i,s,o=1){super(e,i,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=o}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh$1=new Mesh,_sphere$3=new Sphere;class InstancedMesh extends Mesh{constructor(e,i,s){super(e,i),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(s*16),16),this.instanceColor=null,this.morphTexture=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let o=0;o<s;o++)this.setMatrixAt(o,_identity)}computeBoundingBox(){const e=this.geometry,i=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<i;s++)this.getMatrixAt(s,_instanceLocalMatrix),_box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const e=this.geometry,i=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<i;s++)this.getMatrixAt(s,_instanceLocalMatrix),_sphere$3.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$3)}copy(e,i){return super.copy(e,i),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,i){i.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,i){i.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,i){const s=i.morphTargetInfluences,o=this.morphTexture.source.data.data,c=s.length+1,d=e*c+1;for(let h=0;h<s.length;h++)s[h]=o[d+h]}raycast(e,i){const s=this.matrixWorld,o=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,_mesh$1.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$3.copy(this.boundingSphere),_sphere$3.applyMatrix4(s),e.ray.intersectsSphere(_sphere$3)!==!1))for(let c=0;c<o;c++){this.getMatrixAt(c,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(s,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(e,_instanceIntersects);for(let d=0,h=_instanceIntersects.length;d<h;d++){const g=_instanceIntersects[d];g.instanceId=c,g.object=this,i.push(g)}_instanceIntersects.length=0}}setColorAt(e,i){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3),3)),i.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,i){i.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,i){const s=i.morphTargetInfluences,o=s.length+1;this.morphTexture===null&&(this.morphTexture=new DataTexture(new Float32Array(o*this.count),o,this.count,RedFormat,FloatType));const c=this.morphTexture.source.data.data;let d=0;for(let _=0;_<s.length;_++)d+=s[_];const h=this.geometry.morphTargetsRelative?1:1-d,g=o*e;c[g]=h,c.set(s,g+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}class LineBasicMaterial extends Material{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const _vStart=new Vector3,_vEnd=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere,_intersectPointOnRay=new Vector3,_intersectPointOnSegment=new Vector3;class Line extends Object3D{constructor(e=new BufferGeometry,i=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=i,this.updateMorphTargets()}copy(e,i){return super.copy(e,i),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const i=e.attributes.position,s=[0];for(let o=1,c=i.count;o<c;o++)_vStart.fromBufferAttribute(i,o-1),_vEnd.fromBufferAttribute(i,o),s[o]=s[o-1],s[o]+=_vStart.distanceTo(_vEnd);e.setAttribute("lineDistance",new Float32BufferAttribute(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,i){const s=this.geometry,o=this.matrixWorld,c=e.params.Line.threshold,d=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),_sphere$1.copy(s.boundingSphere),_sphere$1.applyMatrix4(o),_sphere$1.radius+=c,e.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(o).invert(),_ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1);const h=c/((this.scale.x+this.scale.y+this.scale.z)/3),g=h*h,_=this.isLineSegments?2:1,b=s.index,j=s.attributes.position;if(b!==null){const _e=Math.max(0,d.start),tt=Math.min(b.count,d.start+d.count);for(let et=_e,nt=tt-1;et<nt;et+=_){const rt=b.getX(et),it=b.getX(et+1),at=checkIntersection(this,e,_ray$1,g,rt,it);at&&i.push(at)}if(this.isLineLoop){const et=b.getX(tt-1),nt=b.getX(_e),rt=checkIntersection(this,e,_ray$1,g,et,nt);rt&&i.push(rt)}}else{const _e=Math.max(0,d.start),tt=Math.min(j.count,d.start+d.count);for(let et=_e,nt=tt-1;et<nt;et+=_){const rt=checkIntersection(this,e,_ray$1,g,et,et+1);rt&&i.push(rt)}if(this.isLineLoop){const et=checkIntersection(this,e,_ray$1,g,tt-1,_e);et&&i.push(et)}}}updateMorphTargets(){const i=this.geometry.morphAttributes,s=Object.keys(i);if(s.length>0){const o=i[s[0]];if(o!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,d=o.length;c<d;c++){const h=o[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=c}}}}}function checkIntersection(a,e,i,s,o,c){const d=a.geometry.attributes.position;if(_vStart.fromBufferAttribute(d,o),_vEnd.fromBufferAttribute(d,c),i.distanceSqToSegment(_vStart,_vEnd,_intersectPointOnRay,_intersectPointOnSegment)>s)return;_intersectPointOnRay.applyMatrix4(a.matrixWorld);const g=e.ray.origin.distanceTo(_intersectPointOnRay);if(!(g<e.near||g>e.far))return{distance:g,point:_intersectPointOnSegment.clone().applyMatrix4(a.matrixWorld),index:o,face:null,faceIndex:null,object:a}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(e,i){super(e,i),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const i=e.attributes.position,s=[];for(let o=0,c=i.count;o<c;o+=2)_start.fromBufferAttribute(i,o),_end.fromBufferAttribute(i,o+1),s[o]=o===0?0:s[o-1],s[o+1]=s[o]+_start.distanceTo(_end);e.setAttribute("lineDistance",new Float32BufferAttribute(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(e,i){super(e,i),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const _inverseMatrix=new Matrix4,_ray$4=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(e=new BufferGeometry,i=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=i,this.updateMorphTargets()}copy(e,i){return super.copy(e,i),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,i){const s=this.geometry,o=this.matrixWorld,c=e.params.Points.threshold,d=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),_sphere.copy(s.boundingSphere),_sphere.applyMatrix4(o),_sphere.radius+=c,e.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(o).invert(),_ray$4.copy(e.ray).applyMatrix4(_inverseMatrix);const h=c/((this.scale.x+this.scale.y+this.scale.z)/3),g=h*h,_=s.index,$=s.attributes.position;if(_!==null){const j=Math.max(0,d.start),_e=Math.min(_.count,d.start+d.count);for(let tt=j,et=_e;tt<et;tt++){const nt=_.getX(tt);_position$2.fromBufferAttribute($,nt),testPoint(_position$2,nt,g,o,e,i,this)}}else{const j=Math.max(0,d.start),_e=Math.min($.count,d.start+d.count);for(let tt=j,et=_e;tt<et;tt++)_position$2.fromBufferAttribute($,tt),testPoint(_position$2,tt,g,o,e,i,this)}}updateMorphTargets(){const i=this.geometry.morphAttributes,s=Object.keys(i);if(s.length>0){const o=i[s[0]];if(o!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let c=0,d=o.length;c<d;c++){const h=o[c].name||String(c);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=c}}}}}function testPoint(a,e,i,s,o,c,d){const h=_ray$4.distanceSqToPoint(a);if(h<i){const g=new Vector3;_ray$4.closestPointToPoint(a,g),g.applyMatrix4(s);const _=o.ray.origin.distanceTo(g);if(_<o.near||_>o.far)return;c.push({distance:_,distanceToRay:Math.sqrt(h),point:g,index:e,face:null,object:d})}}class MeshStandardMaterial extends Material{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp$2(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(i){this.ior=(1+.4*i)/(1-.4*i)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}function convertArray(a,e,i){return!a||!i&&a.constructor===e?a:typeof e.BYTES_PER_ELEMENT=="number"?new e(a):Array.prototype.slice.call(a)}function isTypedArray$1(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)}function getKeyframeOrder(a){function e(o,c){return a[o]-a[c]}const i=a.length,s=new Array(i);for(let o=0;o!==i;++o)s[o]=o;return s.sort(e),s}function sortedArray(a,e,i){const s=a.length,o=new a.constructor(s);for(let c=0,d=0;d!==s;++c){const h=i[c]*e;for(let g=0;g!==e;++g)o[d++]=a[h+g]}return o}function flattenJSON(a,e,i,s){let o=1,c=a[0];for(;c!==void 0&&c[s]===void 0;)c=a[o++];if(c===void 0)return;let d=c[s];if(d!==void 0)if(Array.isArray(d))do d=c[s],d!==void 0&&(e.push(c.time),i.push.apply(i,d)),c=a[o++];while(c!==void 0);else if(d.toArray!==void 0)do d=c[s],d!==void 0&&(e.push(c.time),d.toArray(i,i.length)),c=a[o++];while(c!==void 0);else do d=c[s],d!==void 0&&(e.push(c.time),i.push(d)),c=a[o++];while(c!==void 0)}class Interpolant{constructor(e,i,s,o){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=o!==void 0?o:new i.constructor(s),this.sampleValues=i,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const i=this.parameterPositions;let s=this._cachedIndex,o=i[s],c=i[s-1];e:{t:{let d;n:{r:if(!(e<o)){for(let h=s+2;;){if(o===void 0){if(e<c)break r;return s=i.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===h)break;if(c=o,o=i[++s],e<o)break t}d=i.length;break n}if(!(e>=c)){const h=i[1];e<h&&(s=2,c=h);for(let g=s-2;;){if(c===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===g)break;if(o=c,c=i[--s-1],e>=c)break t}d=s,s=0;break n}break e}for(;s<d;){const h=s+d>>>1;e<i[h]?d=h:s=h+1}if(o=i[s],c=i[s-1],c===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(o===void 0)return s=i.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,c,o)}return this.interpolate_(s,c,e,o)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,c=e*o;for(let d=0;d!==o;++d)i[d]=s[c+d];return i}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(e,i,s,o){super(e,i,s,o),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(e,i,s){const o=this.parameterPositions;let c=e-2,d=e+1,h=o[c],g=o[d];if(h===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:c=e,h=2*i-s;break;case WrapAroundEnding:c=o.length-2,h=i+o[c]-o[c+1];break;default:c=e,h=s}if(g===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:d=e,g=2*s-i;break;case WrapAroundEnding:d=1,g=s+o[1]-o[0];break;default:d=e-1,g=i}const _=(s-i)*.5,b=this.valueSize;this._weightPrev=_/(i-h),this._weightNext=_/(g-s),this._offsetPrev=c*b,this._offsetNext=d*b}interpolate_(e,i,s,o){const c=this.resultBuffer,d=this.sampleValues,h=this.valueSize,g=e*h,_=g-h,b=this._offsetPrev,$=this._offsetNext,j=this._weightPrev,_e=this._weightNext,tt=(s-i)/(o-i),et=tt*tt,nt=et*tt,rt=-j*nt+2*j*et-j*tt,it=(1+j)*nt+(-1.5-2*j)*et+(-.5+j)*tt+1,at=(-1-_e)*nt+(1.5+_e)*et+.5*tt,st=_e*nt-_e*et;for(let ot=0;ot!==h;++ot)c[ot]=rt*d[b+ot]+it*d[_+ot]+at*d[g+ot]+st*d[$+ot];return c}}class LinearInterpolant extends Interpolant{constructor(e,i,s,o){super(e,i,s,o)}interpolate_(e,i,s,o){const c=this.resultBuffer,d=this.sampleValues,h=this.valueSize,g=e*h,_=g-h,b=(s-i)/(o-i),$=1-b;for(let j=0;j!==h;++j)c[j]=d[_+j]*$+d[g+j]*b;return c}}class DiscreteInterpolant extends Interpolant{constructor(e,i,s,o){super(e,i,s,o)}interpolate_(e){return this.copySampleValue_(e-1)}}class KeyframeTrack{constructor(e,i,s,o){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(i===void 0||i.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=convertArray(i,this.TimeBufferType),this.values=convertArray(s,this.ValueBufferType),this.setInterpolation(o||this.DefaultInterpolation)}static toJSON(e){const i=e.constructor;let s;if(i.toJSON!==this.toJSON)s=i.toJSON(e);else{s={name:e.name,times:convertArray(e.times,Array),values:convertArray(e.values,Array)};const o=e.getInterpolation();o!==e.DefaultInterpolation&&(s.interpolation=o)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let i;switch(e){case InterpolateDiscrete:i=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:i=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:i=this.InterpolantFactoryMethodSmooth;break}if(i===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=i,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const i=this.times;for(let s=0,o=i.length;s!==o;++s)i[s]+=e}return this}scale(e){if(e!==1){const i=this.times;for(let s=0,o=i.length;s!==o;++s)i[s]*=e}return this}trim(e,i){const s=this.times,o=s.length;let c=0,d=o-1;for(;c!==o&&s[c]<e;)++c;for(;d!==-1&&s[d]>i;)--d;if(++d,c!==0||d!==o){c>=d&&(d=Math.max(d,1),c=d-1);const h=this.getValueSize();this.times=s.slice(c,d),this.values=this.values.slice(c*h,d*h)}return this}validate(){let e=!0;const i=this.getValueSize();i-Math.floor(i)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,o=this.values,c=s.length;c===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let d=null;for(let h=0;h!==c;h++){const g=s[h];if(typeof g=="number"&&isNaN(g)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,h,g),e=!1;break}if(d!==null&&d>g){console.error("THREE.KeyframeTrack: Out of order keys.",this,h,g,d),e=!1;break}d=g}if(o!==void 0&&isTypedArray$1(o))for(let h=0,g=o.length;h!==g;++h){const _=o[h];if(isNaN(_)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,h,_),e=!1;break}}return e}optimize(){const e=this.times.slice(),i=this.values.slice(),s=this.getValueSize(),o=this.getInterpolation()===InterpolateSmooth,c=e.length-1;let d=1;for(let h=1;h<c;++h){let g=!1;const _=e[h],b=e[h+1];if(_!==b&&(h!==1||_!==e[0]))if(o)g=!0;else{const $=h*s,j=$-s,_e=$+s;for(let tt=0;tt!==s;++tt){const et=i[$+tt];if(et!==i[j+tt]||et!==i[_e+tt]){g=!0;break}}}if(g){if(h!==d){e[d]=e[h];const $=h*s,j=d*s;for(let _e=0;_e!==s;++_e)i[j+_e]=i[$+_e]}++d}}if(c>0){e[d]=e[c];for(let h=c*s,g=d*s,_=0;_!==s;++_)i[g+_]=i[h+_];++d}return d!==e.length?(this.times=e.slice(0,d),this.values=i.slice(0,d*s)):(this.times=e,this.values=i),this}clone(){const e=this.times.slice(),i=this.values.slice(),s=this.constructor,o=new s(this.name,e,i);return o.createInterpolant=this.createInterpolant,o}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{constructor(e,i,s){super(e,i,s)}}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(e,i,s,o){super(e,i,s,o)}interpolate_(e,i,s,o){const c=this.resultBuffer,d=this.sampleValues,h=this.valueSize,g=(s-i)/(o-i);let _=e*h;for(let b=_+h;_!==b;_+=4)Quaternion.slerpFlat(c,0,d,_-h,d,_,g);return c}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(e){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{constructor(e,i,s){super(e,i,s)}}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(e="",i=-1,s=[],o=NormalAnimationBlendMode){this.name=e,this.tracks=s,this.duration=i,this.blendMode=o,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(e){const i=[],s=e.tracks,o=1/(e.fps||1);for(let d=0,h=s.length;d!==h;++d)i.push(parseKeyframeTrack(s[d]).scale(o));const c=new this(e.name,e.duration,i,e.blendMode);return c.uuid=e.uuid,c}static toJSON(e){const i=[],s=e.tracks,o={name:e.name,duration:e.duration,tracks:i,uuid:e.uuid,blendMode:e.blendMode};for(let c=0,d=s.length;c!==d;++c)i.push(KeyframeTrack.toJSON(s[c]));return o}static CreateFromMorphTargetSequence(e,i,s,o){const c=i.length,d=[];for(let h=0;h<c;h++){let g=[],_=[];g.push((h+c-1)%c,h,(h+1)%c),_.push(0,1,0);const b=getKeyframeOrder(g);g=sortedArray(g,1,b),_=sortedArray(_,1,b),!o&&g[0]===0&&(g.push(c),_.push(_[0])),d.push(new NumberKeyframeTrack(".morphTargetInfluences["+i[h].name+"]",g,_).scale(1/s))}return new this(e,-1,d)}static findByName(e,i){let s=e;if(!Array.isArray(e)){const o=e;s=o.geometry&&o.geometry.animations||o.animations}for(let o=0;o<s.length;o++)if(s[o].name===i)return s[o];return null}static CreateClipsFromMorphTargetSequences(e,i,s){const o={},c=/^([\w-]*?)([\d]+)$/;for(let h=0,g=e.length;h<g;h++){const _=e[h],b=_.name.match(c);if(b&&b.length>1){const $=b[1];let j=o[$];j||(o[$]=j=[]),j.push(_)}}const d=[];for(const h in o)d.push(this.CreateFromMorphTargetSequence(h,o[h],i,s));return d}static parseAnimation(e,i){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function($,j,_e,tt,et){if(_e.length!==0){const nt=[],rt=[];flattenJSON(_e,nt,rt,tt),nt.length!==0&&et.push(new $(j,nt,rt))}},o=[],c=e.name||"default",d=e.fps||30,h=e.blendMode;let g=e.length||-1;const _=e.hierarchy||[];for(let $=0;$<_.length;$++){const j=_[$].keys;if(!(!j||j.length===0))if(j[0].morphTargets){const _e={};let tt;for(tt=0;tt<j.length;tt++)if(j[tt].morphTargets)for(let et=0;et<j[tt].morphTargets.length;et++)_e[j[tt].morphTargets[et]]=-1;for(const et in _e){const nt=[],rt=[];for(let it=0;it!==j[tt].morphTargets.length;++it){const at=j[tt];nt.push(at.time),rt.push(at.morphTarget===et?1:0)}o.push(new NumberKeyframeTrack(".morphTargetInfluence["+et+"]",nt,rt))}g=_e.length*d}else{const _e=".bones["+i[$].name+"]";s(VectorKeyframeTrack,_e+".position",j,"pos",o),s(QuaternionKeyframeTrack,_e+".quaternion",j,"rot",o),s(VectorKeyframeTrack,_e+".scale",j,"scl",o)}}return o.length===0?null:new this(c,g,o,h)}resetDuration(){const e=this.tracks;let i=0;for(let s=0,o=e.length;s!==o;++s){const c=this.tracks[s];i=Math.max(i,c.times[c.times.length-1])}return this.duration=i,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let i=0;i<this.tracks.length;i++)e=e&&this.tracks[i].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let i=0;i<this.tracks.length;i++)e.push(this.tracks[i].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}function parseKeyframeTrack(a){if(a.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=getTrackTypeForValueTypeName(a.type);if(a.times===void 0){const i=[],s=[];flattenJSON(a.keys,i,s,"value"),a.times=i,a.values=s}return e.parse!==void 0?e.parse(a):new e(a.name,a.times,a.values,a.interpolation)}const Cache={enabled:!1,files:{},add:function(a,e){this.enabled!==!1&&(this.files[a]=e)},get:function(a){if(this.enabled!==!1)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};class LoadingManager{constructor(e,i,s){const o=this;let c=!1,d=0,h=0,g;const _=[];this.onStart=void 0,this.onLoad=e,this.onProgress=i,this.onError=s,this.itemStart=function(b){h++,c===!1&&o.onStart!==void 0&&o.onStart(b,d,h),c=!0},this.itemEnd=function(b){d++,o.onProgress!==void 0&&o.onProgress(b,d,h),d===h&&(c=!1,o.onLoad!==void 0&&o.onLoad())},this.itemError=function(b){o.onError!==void 0&&o.onError(b)},this.resolveURL=function(b){return g?g(b):b},this.setURLModifier=function(b){return g=b,this},this.addHandler=function(b,$){return _.push(b,$),this},this.removeHandler=function(b){const $=_.indexOf(b);return $!==-1&&_.splice($,2),this},this.getHandler=function(b){for(let $=0,j=_.length;$<j;$+=2){const _e=_[$],tt=_[$+1];if(_e.global&&(_e.lastIndex=0),_e.test(b))return tt}return null}}}const DefaultLoadingManager=new LoadingManager;class Loader{constructor(e){this.manager=e!==void 0?e:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,i){const s=this;return new Promise(function(o,c){s.load(e,o,i,c)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Loader.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(e,i){super(e),this.response=i}}class FileLoader extends Loader{constructor(e){super(e)}load(e,i,s,o){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const c=Cache.get(e);if(c!==void 0)return this.manager.itemStart(e),setTimeout(()=>{i&&i(c),this.manager.itemEnd(e)},0),c;if(loading[e]!==void 0){loading[e].push({onLoad:i,onProgress:s,onError:o});return}loading[e]=[],loading[e].push({onLoad:i,onProgress:s,onError:o});const d=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),h=this.mimeType,g=this.responseType;fetch(d).then(_=>{if(_.status===200||_.status===0){if(_.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||_.body===void 0||_.body.getReader===void 0)return _;const b=loading[e],$=_.body.getReader(),j=_.headers.get("X-File-Size")||_.headers.get("Content-Length"),_e=j?parseInt(j):0,tt=_e!==0;let et=0;const nt=new ReadableStream({start(rt){it();function it(){$.read().then(({done:at,value:st})=>{if(at)rt.close();else{et+=st.byteLength;const ot=new ProgressEvent("progress",{lengthComputable:tt,loaded:et,total:_e});for(let ct=0,lt=b.length;ct<lt;ct++){const dt=b[ct];dt.onProgress&&dt.onProgress(ot)}rt.enqueue(st),it()}},at=>{rt.error(at)})}}});return new Response(nt)}else throw new HttpError(`fetch for "${_.url}" responded with ${_.status}: ${_.statusText}`,_)}).then(_=>{switch(g){case"arraybuffer":return _.arrayBuffer();case"blob":return _.blob();case"document":return _.text().then(b=>new DOMParser().parseFromString(b,h));case"json":return _.json();default:if(h===void 0)return _.text();{const $=/charset="?([^;"\s]*)"?/i.exec(h),j=$&&$[1]?$[1].toLowerCase():void 0,_e=new TextDecoder(j);return _.arrayBuffer().then(tt=>_e.decode(tt))}}}).then(_=>{Cache.add(e,_);const b=loading[e];delete loading[e];for(let $=0,j=b.length;$<j;$++){const _e=b[$];_e.onLoad&&_e.onLoad(_)}}).catch(_=>{const b=loading[e];if(b===void 0)throw this.manager.itemError(e),_;delete loading[e];for(let $=0,j=b.length;$<j;$++){const _e=b[$];_e.onError&&_e.onError(_)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class ImageLoader extends Loader{constructor(e){super(e)}load(e,i,s,o){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,d=Cache.get(e);if(d!==void 0)return c.manager.itemStart(e),setTimeout(function(){i&&i(d),c.manager.itemEnd(e)},0),d;const h=createElementNS("img");function g(){b(),Cache.add(e,this),i&&i(this),c.manager.itemEnd(e)}function _($){b(),o&&o($),c.manager.itemError(e),c.manager.itemEnd(e)}function b(){h.removeEventListener("load",g,!1),h.removeEventListener("error",_,!1)}return h.addEventListener("load",g,!1),h.addEventListener("error",_,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(h.crossOrigin=this.crossOrigin),c.manager.itemStart(e),h.src=e,h}}class DataTextureLoader extends Loader{constructor(e){super(e)}load(e,i,s,o){const c=this,d=new DataTexture,h=new FileLoader(this.manager);return h.setResponseType("arraybuffer"),h.setRequestHeader(this.requestHeader),h.setPath(this.path),h.setWithCredentials(c.withCredentials),h.load(e,function(g){let _;try{_=c.parse(g)}catch(b){if(o!==void 0)o(b);else{console.error(b);return}}_.image!==void 0?d.image=_.image:_.data!==void 0&&(d.image.width=_.width,d.image.height=_.height,d.image.data=_.data),d.wrapS=_.wrapS!==void 0?_.wrapS:ClampToEdgeWrapping,d.wrapT=_.wrapT!==void 0?_.wrapT:ClampToEdgeWrapping,d.magFilter=_.magFilter!==void 0?_.magFilter:LinearFilter,d.minFilter=_.minFilter!==void 0?_.minFilter:LinearFilter,d.anisotropy=_.anisotropy!==void 0?_.anisotropy:1,_.colorSpace!==void 0&&(d.colorSpace=_.colorSpace),_.flipY!==void 0&&(d.flipY=_.flipY),_.format!==void 0&&(d.format=_.format),_.type!==void 0&&(d.type=_.type),_.mipmaps!==void 0&&(d.mipmaps=_.mipmaps,d.minFilter=LinearMipmapLinearFilter),_.mipmapCount===1&&(d.minFilter=LinearFilter),_.generateMipmaps!==void 0&&(d.generateMipmaps=_.generateMipmaps),d.needsUpdate=!0,i&&i(d,_)},s,o),d}}class TextureLoader extends Loader{constructor(e){super(e)}load(e,i,s,o){const c=new Texture,d=new ImageLoader(this.manager);return d.setCrossOrigin(this.crossOrigin),d.setPath(this.path),d.load(e,function(h){c.image=h,c.needsUpdate=!0,i!==void 0&&i(c)},s,o),c}}class Light extends Object3D{constructor(e,i=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(e),this.intensity=i}dispose(){}copy(e,i){return super.copy(e,i),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const i=super.toJSON(e);return i.object.color=this.color.getHex(),i.object.intensity=this.intensity,this.groundColor!==void 0&&(i.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(i.object.distance=this.distance),this.angle!==void 0&&(i.object.angle=this.angle),this.decay!==void 0&&(i.object.decay=this.decay),this.penumbra!==void 0&&(i.object.penumbra=this.penumbra),this.shadow!==void 0&&(i.object.shadow=this.shadow.toJSON()),i}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const i=this.camera,s=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),i.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),i.lookAt(_lookTarget$1),i.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(_projScreenMatrix$1)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const i=this.camera,s=RAD2DEG*2*e.angle*this.focus,o=this.mapSize.width/this.mapSize.height,c=e.distance||i.far;(s!==i.fov||o!==i.aspect||c!==i.far)&&(i.fov=s,i.aspect=o,i.far=c,i.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class SpotLight extends Light{constructor(e,i,s=0,o=Math.PI/3,c=0,d=2){super(e,i),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=s,this.angle=o,this.penumbra=c,this.decay=d,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,i){return super.copy(e,i),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(e,i=0){const s=this.camera,o=this.matrix,c=e.distance||s.far;c!==s.far&&(s.far=c,s.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(e.matrixWorld),s.position.copy(_lightPositionWorld),_lookTarget.copy(s.position),_lookTarget.add(this._cubeDirections[i]),s.up.copy(this._cubeUps[i]),s.lookAt(_lookTarget),s.updateMatrixWorld(),o.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(e,i,s=0,o=2){super(e,i),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=o,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,i){return super.copy(e,i),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(e,i){super(e,i),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class LoaderUtils{static decodeText(e){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(e);let i="";for(let s=0,o=e.length;s<o;s++)i+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(i))}catch{return i}}static extractUrlBase(e){const i=e.lastIndexOf("/");return i===-1?"./":e.slice(0,i+1)}static resolveURL(e,i){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(i)&&/^\//.test(e)&&(i=i.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:i+e)}}class ImageBitmapLoader extends Loader{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,i,s,o){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const c=this,d=Cache.get(e);if(d!==void 0){if(c.manager.itemStart(e),d.then){d.then(_=>{i&&i(_),c.manager.itemEnd(e)}).catch(_=>{o&&o(_)});return}return setTimeout(function(){i&&i(d),c.manager.itemEnd(e)},0),d}const h={};h.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",h.headers=this.requestHeader;const g=fetch(e,h).then(function(_){return _.blob()}).then(function(_){return createImageBitmap(_,Object.assign(c.options,{colorSpaceConversion:"none"}))}).then(function(_){return Cache.add(e,_),i&&i(_),c.manager.itemEnd(e),_}).catch(function(_){o&&o(_),Cache.remove(e),c.manager.itemError(e),c.manager.itemEnd(e)});Cache.add(e,g),c.manager.itemStart(e)}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(e,i,s){const o=s||PropertyBinding.parseTrackName(i);this._targetGroup=e,this._bindings=e.subscribe_(i,o)}getValue(e,i){this.bind();const s=this._targetGroup.nCachedObjects_,o=this._bindings[s];o!==void 0&&o.getValue(e,i)}setValue(e,i){const s=this._bindings;for(let o=this._targetGroup.nCachedObjects_,c=s.length;o!==c;++o)s[o].setValue(e,i)}bind(){const e=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=e.length;i!==s;++i)e[i].bind()}unbind(){const e=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=e.length;i!==s;++i)e[i].unbind()}}class PropertyBinding{constructor(e,i,s){this.path=i,this.parsedPath=s||PropertyBinding.parseTrackName(i),this.node=PropertyBinding.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,i,s){return e&&e.isAnimationObjectGroup?new PropertyBinding.Composite(e,i,s):new PropertyBinding(e,i,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(e){const i=_trackRe.exec(e);if(i===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:i[2],objectName:i[3],objectIndex:i[4],propertyName:i[5],propertyIndex:i[6]},o=s.nodeName&&s.nodeName.lastIndexOf(".");if(o!==void 0&&o!==-1){const c=s.nodeName.substring(o+1);_supportedObjectNames.indexOf(c)!==-1&&(s.nodeName=s.nodeName.substring(0,o),s.objectName=c)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,i){if(i===void 0||i===""||i==="."||i===-1||i===e.name||i===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(i);if(s!==void 0)return s}if(e.children){const s=function(c){for(let d=0;d<c.length;d++){const h=c[d];if(h.name===i||h.uuid===i)return h;const g=s(h.children);if(g)return g}return null},o=s(e.children);if(o)return o}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,i){e[i]=this.targetObject[this.propertyName]}_getValue_array(e,i){const s=this.resolvedProperty;for(let o=0,c=s.length;o!==c;++o)e[i++]=s[o]}_getValue_arrayElement(e,i){e[i]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,i){this.resolvedProperty.toArray(e,i)}_setValue_direct(e,i){this.targetObject[this.propertyName]=e[i]}_setValue_direct_setNeedsUpdate(e,i){this.targetObject[this.propertyName]=e[i],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,i){this.targetObject[this.propertyName]=e[i],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,i){const s=this.resolvedProperty;for(let o=0,c=s.length;o!==c;++o)s[o]=e[i++]}_setValue_array_setNeedsUpdate(e,i){const s=this.resolvedProperty;for(let o=0,c=s.length;o!==c;++o)s[o]=e[i++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,i){const s=this.resolvedProperty;for(let o=0,c=s.length;o!==c;++o)s[o]=e[i++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,i){this.resolvedProperty[this.propertyIndex]=e[i]}_setValue_arrayElement_setNeedsUpdate(e,i){this.resolvedProperty[this.propertyIndex]=e[i],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,i){this.resolvedProperty[this.propertyIndex]=e[i],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,i){this.resolvedProperty.fromArray(e,i)}_setValue_fromArray_setNeedsUpdate(e,i){this.resolvedProperty.fromArray(e,i),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,i){this.resolvedProperty.fromArray(e,i),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,i){this.bind(),this.getValue(e,i)}_setValue_unbound(e,i){this.bind(),this.setValue(e,i)}bind(){let e=this.node;const i=this.parsedPath,s=i.objectName,o=i.propertyName;let c=i.propertyIndex;if(e||(e=PropertyBinding.findNode(this.rootNode,i.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let _=i.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let b=0;b<e.length;b++)if(e[b].name===_){_=b;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(_!==void 0){if(e[_]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[_]}}const d=e[o];if(d===void 0){const _=i.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+_+"."+o+" but it wasn't found.",e);return}let h=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?h=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(h=this.Versioning.MatrixWorldNeedsUpdate);let g=this.BindingType.Direct;if(c!==void 0){if(o==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[c]!==void 0&&(c=e.morphTargetDictionary[c])}g=this.BindingType.ArrayElement,this.resolvedProperty=d,this.propertyIndex=c}else d.fromArray!==void 0&&d.toArray!==void 0?(g=this.BindingType.HasFromToArray,this.resolvedProperty=d):Array.isArray(d)?(g=this.BindingType.EntireArray,this.resolvedProperty=d):this.propertyName=o;this.getValue=this.GetterByBindingType[g],this.setValue=this.SetterByBindingTypeAndVersioning[g][h]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Spherical{constructor(e=1,i=0,s=0){return this.radius=e,this.phi=i,this.theta=s,this}set(e,i,s){return this.radius=e,this.phi=i,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,i,s){return this.radius=Math.sqrt(e*e+i*i+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(clamp$2(i/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);const _changeEvent={type:"change"},_startEvent={type:"start"},_endEvent={type:"end"},_ray=new Ray,_plane=new Plane,TILT_LIMIT=Math.cos(70*MathUtils.DEG2RAD);class OrbitControls extends EventDispatcher{constructor(e,i){super(),this.object=e,this.domElement=i,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new Vector3,this.cursor=new Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.PAN},this.touches={ONE:TOUCH.ROTATE,TWO:TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return h.phi},this.getAzimuthalAngle=function(){return h.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(Tt){Tt.addEventListener("keydown",Zt),this._domElementKeyEvents=Tt},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Zt),this._domElementKeyEvents=null},this.saveState=function(){s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=function(){s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(_changeEvent),s.update(),c=o.NONE},this.update=function(){const Tt=new Vector3,Yt=new Quaternion().setFromUnitVectors(e.up,new Vector3(0,1,0)),Jt=Yt.clone().invert(),an=new Vector3,fn=new Quaternion,Cn=new Vector3,vn=2*Math.PI;return function(lr=null){const qn=s.object.position;Tt.copy(qn).sub(s.target),Tt.applyQuaternion(Yt),h.setFromVector3(Tt),s.autoRotate&&c===o.NONE&&mt(ut(lr)),s.enableDamping?(h.theta+=g.theta*s.dampingFactor,h.phi+=g.phi*s.dampingFactor):(h.theta+=g.theta,h.phi+=g.phi);let ur=s.minAzimuthAngle,er=s.maxAzimuthAngle;isFinite(ur)&&isFinite(er)&&(ur<-Math.PI?ur+=vn:ur>Math.PI&&(ur-=vn),er<-Math.PI?er+=vn:er>Math.PI&&(er-=vn),ur<=er?h.theta=Math.max(ur,Math.min(er,h.theta)):h.theta=h.theta>(ur+er)/2?Math.max(ur,h.theta):Math.min(er,h.theta)),h.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,h.phi)),h.makeSafe(),s.enableDamping===!0?s.target.addScaledVector(b,s.dampingFactor):s.target.add(b),s.target.sub(s.cursor),s.target.clampLength(s.minTargetRadius,s.maxTargetRadius),s.target.add(s.cursor);let mr=!1;if(s.zoomToCursor&&ct||s.object.isOrthographicCamera)h.radius=Ct(h.radius);else{const xr=h.radius;h.radius=Ct(h.radius*_),mr=xr!=h.radius}if(Tt.setFromSpherical(h),Tt.applyQuaternion(Jt),qn.copy(s.target).add(Tt),s.object.lookAt(s.target),s.enableDamping===!0?(g.theta*=1-s.dampingFactor,g.phi*=1-s.dampingFactor,b.multiplyScalar(1-s.dampingFactor)):(g.set(0,0,0),b.set(0,0,0)),s.zoomToCursor&&ct){let xr=null;if(s.object.isPerspectiveCamera){const gr=Tt.length();xr=Ct(gr*_);const Tr=gr-xr;s.object.position.addScaledVector(st,Tr),s.object.updateMatrixWorld(),mr=!!Tr}else if(s.object.isOrthographicCamera){const gr=new Vector3(ot.x,ot.y,0);gr.unproject(s.object);const Tr=s.object.zoom;s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/_)),s.object.updateProjectionMatrix(),mr=Tr!==s.object.zoom;const Cr=new Vector3(ot.x,ot.y,0);Cr.unproject(s.object),s.object.position.sub(Cr).add(gr),s.object.updateMatrixWorld(),xr=Tt.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;xr!==null&&(this.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(xr).add(s.object.position):(_ray.origin.copy(s.object.position),_ray.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot(_ray.direction))<TILT_LIMIT?e.lookAt(s.target):(_plane.setFromNormalAndCoplanarPoint(s.object.up,s.target),_ray.intersectPlane(_plane,s.target))))}else if(s.object.isOrthographicCamera){const xr=s.object.zoom;s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/_)),xr!==s.object.zoom&&(s.object.updateProjectionMatrix(),mr=!0)}return _=1,ct=!1,mr||an.distanceToSquared(s.object.position)>d||8*(1-fn.dot(s.object.quaternion))>d||Cn.distanceToSquared(s.target)>d?(s.dispatchEvent(_changeEvent),an.copy(s.object.position),fn.copy(s.object.quaternion),Cn.copy(s.target),!0):!1}}(),this.dispose=function(){s.domElement.removeEventListener("contextmenu",wn),s.domElement.removeEventListener("pointerdown",En),s.domElement.removeEventListener("pointercancel",gt),s.domElement.removeEventListener("wheel",Vt),s.domElement.removeEventListener("pointermove",bt),s.domElement.removeEventListener("pointerup",gt),s.domElement.getRootNode().removeEventListener("keydown",cn,{capture:!0}),s._domElementKeyEvents!==null&&(s._domElementKeyEvents.removeEventListener("keydown",Zt),s._domElementKeyEvents=null)};const s=this,o={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let c=o.NONE;const d=1e-6,h=new Spherical,g=new Spherical;let _=1;const b=new Vector3,$=new Vector2,j=new Vector2,_e=new Vector2,tt=new Vector2,et=new Vector2,nt=new Vector2,rt=new Vector2,it=new Vector2,at=new Vector2,st=new Vector3,ot=new Vector2;let ct=!1;const lt=[],dt={};let xt=!1;function ut(Tt){return Tt!==null?2*Math.PI/60*s.autoRotateSpeed*Tt:2*Math.PI/60/60*s.autoRotateSpeed}function ft(Tt){const Yt=Math.abs(Tt*.01);return Math.pow(.95,s.zoomSpeed*Yt)}function mt(Tt){g.theta-=Tt}function yt(Tt){g.phi-=Tt}const St=function(){const Tt=new Vector3;return function(Jt,an){Tt.setFromMatrixColumn(an,0),Tt.multiplyScalar(-Jt),b.add(Tt)}}(),Et=function(){const Tt=new Vector3;return function(Jt,an){s.screenSpacePanning===!0?Tt.setFromMatrixColumn(an,1):(Tt.setFromMatrixColumn(an,0),Tt.crossVectors(s.object.up,Tt)),Tt.multiplyScalar(Jt),b.add(Tt)}}(),vt=function(){const Tt=new Vector3;return function(Jt,an){const fn=s.domElement;if(s.object.isPerspectiveCamera){const Cn=s.object.position;Tt.copy(Cn).sub(s.target);let vn=Tt.length();vn*=Math.tan(s.object.fov/2*Math.PI/180),St(2*Jt*vn/fn.clientHeight,s.object.matrix),Et(2*an*vn/fn.clientHeight,s.object.matrix)}else s.object.isOrthographicCamera?(St(Jt*(s.object.right-s.object.left)/s.object.zoom/fn.clientWidth,s.object.matrix),Et(an*(s.object.top-s.object.bottom)/s.object.zoom/fn.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}}();function Nt(Tt){s.object.isPerspectiveCamera||s.object.isOrthographicCamera?_/=Tt:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function wt(Tt){s.object.isPerspectiveCamera||s.object.isOrthographicCamera?_*=Tt:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function $t(Tt,Yt){if(!s.zoomToCursor)return;ct=!0;const Jt=s.domElement.getBoundingClientRect(),an=Tt-Jt.left,fn=Yt-Jt.top,Cn=Jt.width,vn=Jt.height;ot.x=an/Cn*2-1,ot.y=-(fn/vn)*2+1,st.set(ot.x,ot.y,1).unproject(s.object).sub(s.object.position).normalize()}function Ct(Tt){return Math.max(s.minDistance,Math.min(s.maxDistance,Tt))}function Mt(Tt){$.set(Tt.clientX,Tt.clientY)}function Ot(Tt){$t(Tt.clientX,Tt.clientX),rt.set(Tt.clientX,Tt.clientY)}function Dt(Tt){tt.set(Tt.clientX,Tt.clientY)}function At(Tt){j.set(Tt.clientX,Tt.clientY),_e.subVectors(j,$).multiplyScalar(s.rotateSpeed);const Yt=s.domElement;mt(2*Math.PI*_e.x/Yt.clientHeight),yt(2*Math.PI*_e.y/Yt.clientHeight),$.copy(j),s.update()}function kt(Tt){it.set(Tt.clientX,Tt.clientY),at.subVectors(it,rt),at.y>0?Nt(ft(at.y)):at.y<0&&wt(ft(at.y)),rt.copy(it),s.update()}function Ft(Tt){et.set(Tt.clientX,Tt.clientY),nt.subVectors(et,tt).multiplyScalar(s.panSpeed),vt(nt.x,nt.y),tt.copy(et),s.update()}function Bt(Tt){$t(Tt.clientX,Tt.clientY),Tt.deltaY<0?wt(ft(Tt.deltaY)):Tt.deltaY>0&&Nt(ft(Tt.deltaY)),s.update()}function Ht(Tt){let Yt=!1;switch(Tt.code){case s.keys.UP:Tt.ctrlKey||Tt.metaKey||Tt.shiftKey?yt(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):vt(0,s.keyPanSpeed),Yt=!0;break;case s.keys.BOTTOM:Tt.ctrlKey||Tt.metaKey||Tt.shiftKey?yt(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):vt(0,-s.keyPanSpeed),Yt=!0;break;case s.keys.LEFT:Tt.ctrlKey||Tt.metaKey||Tt.shiftKey?mt(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):vt(s.keyPanSpeed,0),Yt=!0;break;case s.keys.RIGHT:Tt.ctrlKey||Tt.metaKey||Tt.shiftKey?mt(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):vt(-s.keyPanSpeed,0),Yt=!0;break}Yt&&(Tt.preventDefault(),s.update())}function Wt(Tt){if(lt.length===1)$.set(Tt.pageX,Tt.pageY);else{const Yt=Nn(Tt),Jt=.5*(Tt.pageX+Yt.x),an=.5*(Tt.pageY+Yt.y);$.set(Jt,an)}}function Ut(Tt){if(lt.length===1)tt.set(Tt.pageX,Tt.pageY);else{const Yt=Nn(Tt),Jt=.5*(Tt.pageX+Yt.x),an=.5*(Tt.pageY+Yt.y);tt.set(Jt,an)}}function Rt(Tt){const Yt=Nn(Tt),Jt=Tt.pageX-Yt.x,an=Tt.pageY-Yt.y,fn=Math.sqrt(Jt*Jt+an*an);rt.set(0,fn)}function un(Tt){s.enableZoom&&Rt(Tt),s.enablePan&&Ut(Tt)}function rn(Tt){s.enableZoom&&Rt(Tt),s.enableRotate&&Wt(Tt)}function mn(Tt){if(lt.length==1)j.set(Tt.pageX,Tt.pageY);else{const Jt=Nn(Tt),an=.5*(Tt.pageX+Jt.x),fn=.5*(Tt.pageY+Jt.y);j.set(an,fn)}_e.subVectors(j,$).multiplyScalar(s.rotateSpeed);const Yt=s.domElement;mt(2*Math.PI*_e.x/Yt.clientHeight),yt(2*Math.PI*_e.y/Yt.clientHeight),$.copy(j)}function sn(Tt){if(lt.length===1)et.set(Tt.pageX,Tt.pageY);else{const Yt=Nn(Tt),Jt=.5*(Tt.pageX+Yt.x),an=.5*(Tt.pageY+Yt.y);et.set(Jt,an)}nt.subVectors(et,tt).multiplyScalar(s.panSpeed),vt(nt.x,nt.y),tt.copy(et)}function hn(Tt){const Yt=Nn(Tt),Jt=Tt.pageX-Yt.x,an=Tt.pageY-Yt.y,fn=Math.sqrt(Jt*Jt+an*an);it.set(0,fn),at.set(0,Math.pow(it.y/rt.y,s.zoomSpeed)),Nt(at.y),rt.copy(it);const Cn=(Tt.pageX+Yt.x)*.5,vn=(Tt.pageY+Yt.y)*.5;$t(Cn,vn)}function gn(Tt){s.enableZoom&&hn(Tt),s.enablePan&&sn(Tt)}function Xt(Tt){s.enableZoom&&hn(Tt),s.enableRotate&&mn(Tt)}function En(Tt){s.enabled!==!1&&(lt.length===0&&(s.domElement.setPointerCapture(Tt.pointerId),s.domElement.addEventListener("pointermove",bt),s.domElement.addEventListener("pointerup",gt)),!Sn(Tt)&&(Pn(Tt),Tt.pointerType==="touch"?yn(Tt):Pt(Tt)))}function bt(Tt){s.enabled!==!1&&(Tt.pointerType==="touch"?pn(Tt):Lt(Tt))}function gt(Tt){switch(Rn(Tt),lt.length){case 0:s.domElement.releasePointerCapture(Tt.pointerId),s.domElement.removeEventListener("pointermove",bt),s.domElement.removeEventListener("pointerup",gt),s.dispatchEvent(_endEvent),c=o.NONE;break;case 1:const Yt=lt[0],Jt=dt[Yt];yn({pointerId:Yt,pageX:Jt.x,pageY:Jt.y});break}}function Pt(Tt){let Yt;switch(Tt.button){case 0:Yt=s.mouseButtons.LEFT;break;case 1:Yt=s.mouseButtons.MIDDLE;break;case 2:Yt=s.mouseButtons.RIGHT;break;default:Yt=-1}switch(Yt){case MOUSE.DOLLY:if(s.enableZoom===!1)return;Ot(Tt),c=o.DOLLY;break;case MOUSE.ROTATE:if(Tt.ctrlKey||Tt.metaKey||Tt.shiftKey){if(s.enablePan===!1)return;Dt(Tt),c=o.PAN}else{if(s.enableRotate===!1)return;Mt(Tt),c=o.ROTATE}break;case MOUSE.PAN:if(Tt.ctrlKey||Tt.metaKey||Tt.shiftKey){if(s.enableRotate===!1)return;Mt(Tt),c=o.ROTATE}else{if(s.enablePan===!1)return;Dt(Tt),c=o.PAN}break;default:c=o.NONE}c!==o.NONE&&s.dispatchEvent(_startEvent)}function Lt(Tt){switch(c){case o.ROTATE:if(s.enableRotate===!1)return;At(Tt);break;case o.DOLLY:if(s.enableZoom===!1)return;kt(Tt);break;case o.PAN:if(s.enablePan===!1)return;Ft(Tt);break}}function Vt(Tt){s.enabled===!1||s.enableZoom===!1||c!==o.NONE||(Tt.preventDefault(),s.dispatchEvent(_startEvent),Bt(jt(Tt)),s.dispatchEvent(_endEvent))}function jt(Tt){const Yt=Tt.deltaMode,Jt={clientX:Tt.clientX,clientY:Tt.clientY,deltaY:Tt.deltaY};switch(Yt){case 1:Jt.deltaY*=16;break;case 2:Jt.deltaY*=100;break}return Tt.ctrlKey&&!xt&&(Jt.deltaY*=10),Jt}function cn(Tt){Tt.key==="Control"&&(xt=!0,s.domElement.getRootNode().addEventListener("keyup",en,{passive:!0,capture:!0}))}function en(Tt){Tt.key==="Control"&&(xt=!1,s.domElement.getRootNode().removeEventListener("keyup",en,{passive:!0,capture:!0}))}function Zt(Tt){s.enabled===!1||s.enablePan===!1||Ht(Tt)}function yn(Tt){switch(On(Tt),lt.length){case 1:switch(s.touches.ONE){case TOUCH.ROTATE:if(s.enableRotate===!1)return;Wt(Tt),c=o.TOUCH_ROTATE;break;case TOUCH.PAN:if(s.enablePan===!1)return;Ut(Tt),c=o.TOUCH_PAN;break;default:c=o.NONE}break;case 2:switch(s.touches.TWO){case TOUCH.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;un(Tt),c=o.TOUCH_DOLLY_PAN;break;case TOUCH.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;rn(Tt),c=o.TOUCH_DOLLY_ROTATE;break;default:c=o.NONE}break;default:c=o.NONE}c!==o.NONE&&s.dispatchEvent(_startEvent)}function pn(Tt){switch(On(Tt),c){case o.TOUCH_ROTATE:if(s.enableRotate===!1)return;mn(Tt),s.update();break;case o.TOUCH_PAN:if(s.enablePan===!1)return;sn(Tt),s.update();break;case o.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;gn(Tt),s.update();break;case o.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Xt(Tt),s.update();break;default:c=o.NONE}}function wn(Tt){s.enabled!==!1&&Tt.preventDefault()}function Pn(Tt){lt.push(Tt.pointerId)}function Rn(Tt){delete dt[Tt.pointerId];for(let Yt=0;Yt<lt.length;Yt++)if(lt[Yt]==Tt.pointerId){lt.splice(Yt,1);return}}function Sn(Tt){for(let Yt=0;Yt<lt.length;Yt++)if(lt[Yt]==Tt.pointerId)return!0;return!1}function On(Tt){let Yt=dt[Tt.pointerId];Yt===void 0&&(Yt=new Vector2,dt[Tt.pointerId]=Yt),Yt.set(Tt.pageX,Tt.pageY)}function Nn(Tt){const Yt=Tt.pointerId===lt[0]?lt[1]:lt[0];return dt[Yt]}s.domElement.addEventListener("contextmenu",wn),s.domElement.addEventListener("pointerdown",En),s.domElement.addEventListener("pointercancel",gt),s.domElement.addEventListener("wheel",Vt,{passive:!1}),s.domElement.getRootNode().addEventListener("keydown",cn,{passive:!0,capture:!0}),this.update()}}function toTrianglesDrawMode(a,e){if(e===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),a;if(e===TriangleFanDrawMode||e===TriangleStripDrawMode){let i=a.getIndex();if(i===null){const d=[],h=a.getAttribute("position");if(h!==void 0){for(let g=0;g<h.count;g++)d.push(g);a.setIndex(d),i=a.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),a}const s=i.count-2,o=[];if(e===TriangleFanDrawMode)for(let d=1;d<=s;d++)o.push(i.getX(0)),o.push(i.getX(d)),o.push(i.getX(d+1));else for(let d=0;d<s;d++)d%2===0?(o.push(i.getX(d)),o.push(i.getX(d+1)),o.push(i.getX(d+2))):(o.push(i.getX(d+2)),o.push(i.getX(d+1)),o.push(i.getX(d)));o.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const c=a.clone();return c.setIndex(o),c.clearGroups(),c}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),a}class GLTFLoader extends Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(i){return new GLTFMaterialsClearcoatExtension(i)}),this.register(function(i){return new GLTFMaterialsDispersionExtension(i)}),this.register(function(i){return new GLTFTextureBasisUExtension(i)}),this.register(function(i){return new GLTFTextureWebPExtension(i)}),this.register(function(i){return new GLTFTextureAVIFExtension(i)}),this.register(function(i){return new GLTFMaterialsSheenExtension(i)}),this.register(function(i){return new GLTFMaterialsTransmissionExtension(i)}),this.register(function(i){return new GLTFMaterialsVolumeExtension(i)}),this.register(function(i){return new GLTFMaterialsIorExtension(i)}),this.register(function(i){return new GLTFMaterialsEmissiveStrengthExtension(i)}),this.register(function(i){return new GLTFMaterialsSpecularExtension(i)}),this.register(function(i){return new GLTFMaterialsIridescenceExtension(i)}),this.register(function(i){return new GLTFMaterialsAnisotropyExtension(i)}),this.register(function(i){return new GLTFMaterialsBumpExtension(i)}),this.register(function(i){return new GLTFLightsExtension(i)}),this.register(function(i){return new GLTFMeshoptCompression(i)}),this.register(function(i){return new GLTFMeshGpuInstancing(i)})}load(e,i,s,o){const c=this;let d;if(this.resourcePath!=="")d=this.resourcePath;else if(this.path!==""){const _=LoaderUtils.extractUrlBase(e);d=LoaderUtils.resolveURL(_,this.path)}else d=LoaderUtils.extractUrlBase(e);this.manager.itemStart(e);const h=function(_){o?o(_):console.error(_),c.manager.itemError(e),c.manager.itemEnd(e)},g=new FileLoader(this.manager);g.setPath(this.path),g.setResponseType("arraybuffer"),g.setRequestHeader(this.requestHeader),g.setWithCredentials(this.withCredentials),g.load(e,function(_){try{c.parse(_,d,function(b){i(b),c.manager.itemEnd(e)},h)}catch(b){h(b)}},s,h)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,i,s,o){let c;const d={},h={},g=new TextDecoder;if(typeof e=="string")c=JSON.parse(e);else if(e instanceof ArrayBuffer)if(g.decode(new Uint8Array(e,0,4))===BINARY_EXTENSION_HEADER_MAGIC){try{d[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(e)}catch($){o&&o($);return}c=JSON.parse(d[EXTENSIONS.KHR_BINARY_GLTF].content)}else c=JSON.parse(g.decode(e));else c=e;if(c.asset===void 0||c.asset.version[0]<2){o&&o(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const _=new GLTFParser(c,{path:i||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});_.fileLoader.setRequestHeader(this.requestHeader);for(let b=0;b<this.pluginCallbacks.length;b++){const $=this.pluginCallbacks[b](_);$.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),h[$.name]=$,d[$.name]=!0}if(c.extensionsUsed)for(let b=0;b<c.extensionsUsed.length;++b){const $=c.extensionsUsed[b],j=c.extensionsRequired||[];switch($){case EXTENSIONS.KHR_MATERIALS_UNLIT:d[$]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:d[$]=new GLTFDracoMeshCompressionExtension(c,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:d[$]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:d[$]=new GLTFMeshQuantizationExtension;break;default:j.indexOf($)>=0&&h[$]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+$+'".')}}_.setExtensions(d),_.setPlugins(h),_.parse(s,o)}parseAsync(e,i){const s=this;return new Promise(function(o,c){s.parse(e,i,o,c)})}}function GLTFRegistry(){let a={};return{get:function(e){return a[e]},add:function(e,i){a[e]=i},remove:function(e){delete a[e]},removeAll:function(){a={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,i=this.parser.json.nodes||[];for(let s=0,o=i.length;s<o;s++){const c=i[s];c.extensions&&c.extensions[this.name]&&c.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,c.extensions[this.name].light)}}_loadLight(e){const i=this.parser,s="light:"+e;let o=i.cache.get(s);if(o)return o;const c=i.json,g=((c.extensions&&c.extensions[this.name]||{}).lights||[])[e];let _;const b=new Color(16777215);g.color!==void 0&&b.setRGB(g.color[0],g.color[1],g.color[2],LinearSRGBColorSpace);const $=g.range!==void 0?g.range:0;switch(g.type){case"directional":_=new DirectionalLight(b),_.target.position.set(0,0,-1),_.add(_.target);break;case"point":_=new PointLight(b),_.distance=$;break;case"spot":_=new SpotLight(b),_.distance=$,g.spot=g.spot||{},g.spot.innerConeAngle=g.spot.innerConeAngle!==void 0?g.spot.innerConeAngle:0,g.spot.outerConeAngle=g.spot.outerConeAngle!==void 0?g.spot.outerConeAngle:Math.PI/4,_.angle=g.spot.outerConeAngle,_.penumbra=1-g.spot.innerConeAngle/g.spot.outerConeAngle,_.target.position.set(0,0,-1),_.add(_.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+g.type)}return _.position.set(0,0,0),_.decay=2,assignExtrasToUserData(_,g),g.intensity!==void 0&&(_.intensity=g.intensity),_.name=i.createUniqueName(g.name||"light_"+e),o=Promise.resolve(_),i.cache.add(s,o),o}getDependency(e,i){if(e==="light")return this._loadLight(i)}createNodeAttachment(e){const i=this,s=this.parser,c=s.json.nodes[e],h=(c.extensions&&c.extensions[this.name]||{}).light;return h===void 0?null:this._loadLight(h).then(function(g){return s._getNodeRef(i.cache,h,g)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return MeshBasicMaterial}extendParams(e,i,s){const o=[];e.color=new Color(1,1,1),e.opacity=1;const c=i.pbrMetallicRoughness;if(c){if(Array.isArray(c.baseColorFactor)){const d=c.baseColorFactor;e.color.setRGB(d[0],d[1],d[2],LinearSRGBColorSpace),e.opacity=d[3]}c.baseColorTexture!==void 0&&o.push(s.assignTexture(e,"map",c.baseColorTexture,SRGBColorSpace))}return Promise.all(o)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,i){const o=this.parser.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=o.extensions[this.name].emissiveStrength;return c!==void 0&&(i.emissiveIntensity=c),Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];if(d.clearcoatFactor!==void 0&&(i.clearcoat=d.clearcoatFactor),d.clearcoatTexture!==void 0&&c.push(s.assignTexture(i,"clearcoatMap",d.clearcoatTexture)),d.clearcoatRoughnessFactor!==void 0&&(i.clearcoatRoughness=d.clearcoatRoughnessFactor),d.clearcoatRoughnessTexture!==void 0&&c.push(s.assignTexture(i,"clearcoatRoughnessMap",d.clearcoatRoughnessTexture)),d.clearcoatNormalTexture!==void 0&&(c.push(s.assignTexture(i,"clearcoatNormalMap",d.clearcoatNormalTexture)),d.clearcoatNormalTexture.scale!==void 0)){const h=d.clearcoatNormalTexture.scale;i.clearcoatNormalScale=new Vector2(h,h)}return Promise.all(c)}}class GLTFMaterialsDispersionExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const o=this.parser.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=o.extensions[this.name];return i.dispersion=c.dispersion!==void 0?c.dispersion:0,Promise.resolve()}}class GLTFMaterialsIridescenceExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];return d.iridescenceFactor!==void 0&&(i.iridescence=d.iridescenceFactor),d.iridescenceTexture!==void 0&&c.push(s.assignTexture(i,"iridescenceMap",d.iridescenceTexture)),d.iridescenceIor!==void 0&&(i.iridescenceIOR=d.iridescenceIor),i.iridescenceThicknessRange===void 0&&(i.iridescenceThicknessRange=[100,400]),d.iridescenceThicknessMinimum!==void 0&&(i.iridescenceThicknessRange[0]=d.iridescenceThicknessMinimum),d.iridescenceThicknessMaximum!==void 0&&(i.iridescenceThicknessRange[1]=d.iridescenceThicknessMaximum),d.iridescenceThicknessTexture!==void 0&&c.push(s.assignTexture(i,"iridescenceThicknessMap",d.iridescenceThicknessTexture)),Promise.all(c)}}class GLTFMaterialsSheenExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[];i.sheenColor=new Color(0,0,0),i.sheenRoughness=0,i.sheen=1;const d=o.extensions[this.name];if(d.sheenColorFactor!==void 0){const h=d.sheenColorFactor;i.sheenColor.setRGB(h[0],h[1],h[2],LinearSRGBColorSpace)}return d.sheenRoughnessFactor!==void 0&&(i.sheenRoughness=d.sheenRoughnessFactor),d.sheenColorTexture!==void 0&&c.push(s.assignTexture(i,"sheenColorMap",d.sheenColorTexture,SRGBColorSpace)),d.sheenRoughnessTexture!==void 0&&c.push(s.assignTexture(i,"sheenRoughnessMap",d.sheenRoughnessTexture)),Promise.all(c)}}class GLTFMaterialsTransmissionExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];return d.transmissionFactor!==void 0&&(i.transmission=d.transmissionFactor),d.transmissionTexture!==void 0&&c.push(s.assignTexture(i,"transmissionMap",d.transmissionTexture)),Promise.all(c)}}class GLTFMaterialsVolumeExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];i.thickness=d.thicknessFactor!==void 0?d.thicknessFactor:0,d.thicknessTexture!==void 0&&c.push(s.assignTexture(i,"thicknessMap",d.thicknessTexture)),i.attenuationDistance=d.attenuationDistance||1/0;const h=d.attenuationColor||[1,1,1];return i.attenuationColor=new Color().setRGB(h[0],h[1],h[2],LinearSRGBColorSpace),Promise.all(c)}}class GLTFMaterialsIorExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const o=this.parser.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=o.extensions[this.name];return i.ior=c.ior!==void 0?c.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];i.specularIntensity=d.specularFactor!==void 0?d.specularFactor:1,d.specularTexture!==void 0&&c.push(s.assignTexture(i,"specularIntensityMap",d.specularTexture));const h=d.specularColorFactor||[1,1,1];return i.specularColor=new Color().setRGB(h[0],h[1],h[2],LinearSRGBColorSpace),d.specularColorTexture!==void 0&&c.push(s.assignTexture(i,"specularColorMap",d.specularColorTexture,SRGBColorSpace)),Promise.all(c)}}class GLTFMaterialsBumpExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];return i.bumpScale=d.bumpFactor!==void 0?d.bumpFactor:1,d.bumpTexture!==void 0&&c.push(s.assignTexture(i,"bumpMap",d.bumpTexture)),Promise.all(c)}}class GLTFMaterialsAnisotropyExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(e,i){const s=this.parser,o=s.json.materials[e];if(!o.extensions||!o.extensions[this.name])return Promise.resolve();const c=[],d=o.extensions[this.name];return d.anisotropyStrength!==void 0&&(i.anisotropy=d.anisotropyStrength),d.anisotropyRotation!==void 0&&(i.anisotropyRotation=d.anisotropyRotation),d.anisotropyTexture!==void 0&&c.push(s.assignTexture(i,"anisotropyMap",d.anisotropyTexture)),Promise.all(c)}}class GLTFTextureBasisUExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(e){const i=this.parser,s=i.json,o=s.textures[e];if(!o.extensions||!o.extensions[this.name])return null;const c=o.extensions[this.name],d=i.options.ktx2Loader;if(!d){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return i.loadTextureImage(e,c.source,d)}}class GLTFTextureWebPExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const i=this.name,s=this.parser,o=s.json,c=o.textures[e];if(!c.extensions||!c.extensions[i])return null;const d=c.extensions[i],h=o.images[d.source];let g=s.textureLoader;if(h.uri){const _=s.options.manager.getHandler(h.uri);_!==null&&(g=_)}return this.detectSupport().then(function(_){if(_)return s.loadTextureImage(e,d.source,g);if(o.extensionsRequired&&o.extensionsRequired.indexOf(i)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const i=new Image;i.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",i.onload=i.onerror=function(){e(i.height===1)}})),this.isSupported}}class GLTFTextureAVIFExtension{constructor(e){this.parser=e,this.name=EXTENSIONS.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const i=this.name,s=this.parser,o=s.json,c=o.textures[e];if(!c.extensions||!c.extensions[i])return null;const d=c.extensions[i],h=o.images[d.source];let g=s.textureLoader;if(h.uri){const _=s.options.manager.getHandler(h.uri);_!==null&&(g=_)}return this.detectSupport().then(function(_){if(_)return s.loadTextureImage(e,d.source,g);if(o.extensionsRequired&&o.extensionsRequired.indexOf(i)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const i=new Image;i.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",i.onload=i.onerror=function(){e(i.height===1)}})),this.isSupported}}class GLTFMeshoptCompression{constructor(e){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const i=this.parser.json,s=i.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const o=s.extensions[this.name],c=this.parser.getDependency("buffer",o.buffer),d=this.parser.options.meshoptDecoder;if(!d||!d.supported){if(i.extensionsRequired&&i.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return c.then(function(h){const g=o.byteOffset||0,_=o.byteLength||0,b=o.count,$=o.byteStride,j=new Uint8Array(h,g,_);return d.decodeGltfBufferAsync?d.decodeGltfBufferAsync(b,$,j,o.mode,o.filter).then(function(_e){return _e.buffer}):d.ready.then(function(){const _e=new ArrayBuffer(b*$);return d.decodeGltfBuffer(new Uint8Array(_e),b,$,j,o.mode,o.filter),_e})})}else return null}}class GLTFMeshGpuInstancing{constructor(e){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const i=this.parser.json,s=i.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const o=i.meshes[s.mesh];for(const _ of o.primitives)if(_.mode!==WEBGL_CONSTANTS.TRIANGLES&&_.mode!==WEBGL_CONSTANTS.TRIANGLE_STRIP&&_.mode!==WEBGL_CONSTANTS.TRIANGLE_FAN&&_.mode!==void 0)return null;const d=s.extensions[this.name].attributes,h=[],g={};for(const _ in d)h.push(this.parser.getDependency("accessor",d[_]).then(b=>(g[_]=b,g[_])));return h.length<1?null:(h.push(this.parser.createNodeMesh(e)),Promise.all(h).then(_=>{const b=_.pop(),$=b.isGroup?b.children:[b],j=_[0].count,_e=[];for(const tt of $){const et=new Matrix4,nt=new Vector3,rt=new Quaternion,it=new Vector3(1,1,1),at=new InstancedMesh(tt.geometry,tt.material,j);for(let st=0;st<j;st++)g.TRANSLATION&&nt.fromBufferAttribute(g.TRANSLATION,st),g.ROTATION&&rt.fromBufferAttribute(g.ROTATION,st),g.SCALE&&it.fromBufferAttribute(g.SCALE,st),at.setMatrixAt(st,et.compose(nt,rt,it));for(const st in g)if(st==="_COLOR_0"){const ot=g[st];at.instanceColor=new InstancedBufferAttribute(ot.array,ot.itemSize,ot.normalized)}else st!=="TRANSLATION"&&st!=="ROTATION"&&st!=="SCALE"&&tt.geometry.setAttribute(st,g[st]);Object3D.prototype.copy.call(at,tt),this.parser.assignFinalMaterial(at),_e.push(at)}return b.isGroup?(b.clear(),b.add(..._e),b):_e[0]}))}}const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_HEADER_LENGTH=12,BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(e){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const i=new DataView(e,0,BINARY_EXTENSION_HEADER_LENGTH),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:i.getUint32(4,!0),length:i.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const o=this.header.length-BINARY_EXTENSION_HEADER_LENGTH,c=new DataView(e,BINARY_EXTENSION_HEADER_LENGTH);let d=0;for(;d<o;){const h=c.getUint32(d,!0);d+=4;const g=c.getUint32(d,!0);if(d+=4,g===BINARY_EXTENSION_CHUNK_TYPES.JSON){const _=new Uint8Array(e,BINARY_EXTENSION_HEADER_LENGTH+d,h);this.content=s.decode(_)}else if(g===BINARY_EXTENSION_CHUNK_TYPES.BIN){const _=BINARY_EXTENSION_HEADER_LENGTH+d;this.body=e.slice(_,_+h)}d+=h}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(e,i){if(!i)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=i,this.dracoLoader.preload()}decodePrimitive(e,i){const s=this.json,o=this.dracoLoader,c=e.extensions[this.name].bufferView,d=e.extensions[this.name].attributes,h={},g={},_={};for(const b in d){const $=ATTRIBUTES[b]||b.toLowerCase();h[$]=d[b]}for(const b in e.attributes){const $=ATTRIBUTES[b]||b.toLowerCase();if(d[b]!==void 0){const j=s.accessors[e.attributes[b]],_e=WEBGL_COMPONENT_TYPES[j.componentType];_[$]=_e.name,g[$]=j.normalized===!0}}return i.getDependency("bufferView",c).then(function(b){return new Promise(function($,j){o.decodeDracoFile(b,function(_e){for(const tt in _e.attributes){const et=_e.attributes[tt],nt=g[tt];nt!==void 0&&(et.normalized=nt)}$(_e)},h,_,LinearSRGBColorSpace,j)})})}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(e,i){return(i.texCoord===void 0||i.texCoord===e.channel)&&i.offset===void 0&&i.rotation===void 0&&i.scale===void 0||(e=e.clone(),i.texCoord!==void 0&&(e.channel=i.texCoord),i.offset!==void 0&&e.offset.fromArray(i.offset),i.rotation!==void 0&&(e.rotation=i.rotation),i.scale!==void 0&&e.repeat.fromArray(i.scale),e.needsUpdate=!0),e}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends Interpolant{constructor(e,i,s,o){super(e,i,s,o)}copySampleValue_(e){const i=this.resultBuffer,s=this.sampleValues,o=this.valueSize,c=e*o*3+o;for(let d=0;d!==o;d++)i[d]=s[c+d];return i}interpolate_(e,i,s,o){const c=this.resultBuffer,d=this.sampleValues,h=this.valueSize,g=h*2,_=h*3,b=o-i,$=(s-i)/b,j=$*$,_e=j*$,tt=e*_,et=tt-_,nt=-2*_e+3*j,rt=_e-j,it=1-nt,at=rt-j+$;for(let st=0;st!==h;st++){const ot=d[et+st+h],ct=d[et+st+g]*b,lt=d[tt+st+h],dt=d[tt+st]*b;c[st]=it*ot+at*ct+nt*lt+rt*dt}return c}}const _q=new Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(e,i,s,o){const c=super.interpolate_(e,i,s,o);return _q.fromArray(c).normalize().toArray(c),c}}const WEBGL_CONSTANTS={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:NearestFilter,9729:LinearFilter,9984:NearestMipmapNearestFilter,9985:LinearMipmapNearestFilter,9986:NearestMipmapLinearFilter,9987:LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:ClampToEdgeWrapping,33648:MirroredRepeatWrapping,10497:RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:InterpolateLinear,STEP:InterpolateDiscrete},ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(a){return a.DefaultMaterial===void 0&&(a.DefaultMaterial=new MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:FrontSide})),a.DefaultMaterial}function addUnknownExtensionsToUserData(a,e,i){for(const s in i.extensions)a[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=i.extensions[s])}function assignExtrasToUserData(a,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(a.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function addMorphTargets(a,e,i){let s=!1,o=!1,c=!1;for(let _=0,b=e.length;_<b;_++){const $=e[_];if($.POSITION!==void 0&&(s=!0),$.NORMAL!==void 0&&(o=!0),$.COLOR_0!==void 0&&(c=!0),s&&o&&c)break}if(!s&&!o&&!c)return Promise.resolve(a);const d=[],h=[],g=[];for(let _=0,b=e.length;_<b;_++){const $=e[_];if(s){const j=$.POSITION!==void 0?i.getDependency("accessor",$.POSITION):a.attributes.position;d.push(j)}if(o){const j=$.NORMAL!==void 0?i.getDependency("accessor",$.NORMAL):a.attributes.normal;h.push(j)}if(c){const j=$.COLOR_0!==void 0?i.getDependency("accessor",$.COLOR_0):a.attributes.color;g.push(j)}}return Promise.all([Promise.all(d),Promise.all(h),Promise.all(g)]).then(function(_){const b=_[0],$=_[1],j=_[2];return s&&(a.morphAttributes.position=b),o&&(a.morphAttributes.normal=$),c&&(a.morphAttributes.color=j),a.morphTargetsRelative=!0,a})}function updateMorphTargets(a,e){if(a.updateMorphTargets(),e.weights!==void 0)for(let i=0,s=e.weights.length;i<s;i++)a.morphTargetInfluences[i]=e.weights[i];if(e.extras&&Array.isArray(e.extras.targetNames)){const i=e.extras.targetNames;if(a.morphTargetInfluences.length===i.length){a.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++)a.morphTargetDictionary[i[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(a){let e;const i=a.extensions&&a.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(i?e="draco:"+i.bufferView+":"+i.indices+":"+createAttributesKey(i.attributes):e=a.indices+":"+createAttributesKey(a.attributes)+":"+a.mode,a.targets!==void 0)for(let s=0,o=a.targets.length;s<o;s++)e+=":"+createAttributesKey(a.targets[s]);return e}function createAttributesKey(a){let e="";const i=Object.keys(a).sort();for(let s=0,o=i.length;s<o;s++)e+=i[s]+":"+a[i[s]]+";";return e}function getNormalizedComponentScale(a){switch(a){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(a){return a.search(/\.jpe?g($|\?)/i)>0||a.search(/^data\:image\/jpeg/)===0?"image/jpeg":a.search(/\.webp($|\?)/i)>0||a.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const _identityMatrix=new Matrix4;class GLTFParser{constructor(e={},i={}){this.json=e,this.extensions={},this.plugins={},this.options=i,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,o=!1,c=-1;typeof navigator<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,o=navigator.userAgent.indexOf("Firefox")>-1,c=o?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||o&&c<98?this.textureLoader=new TextureLoader(this.options.manager):this.textureLoader=new ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,i){const s=this,o=this.json,c=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(d){return d._markDefs&&d._markDefs()}),Promise.all(this._invokeAll(function(d){return d.beforeRoot&&d.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(d){const h={scene:d[0][o.scene||0],scenes:d[0],animations:d[1],cameras:d[2],asset:o.asset,parser:s,userData:{}};return addUnknownExtensionsToUserData(c,h,o),assignExtrasToUserData(h,o),Promise.all(s._invokeAll(function(g){return g.afterRoot&&g.afterRoot(h)})).then(function(){for(const g of h.scenes)g.updateMatrixWorld();e(h)})}).catch(i)}_markDefs(){const e=this.json.nodes||[],i=this.json.skins||[],s=this.json.meshes||[];for(let o=0,c=i.length;o<c;o++){const d=i[o].joints;for(let h=0,g=d.length;h<g;h++)e[d[h]].isBone=!0}for(let o=0,c=e.length;o<c;o++){const d=e[o];d.mesh!==void 0&&(this._addNodeRef(this.meshCache,d.mesh),d.skin!==void 0&&(s[d.mesh].isSkinnedMesh=!0)),d.camera!==void 0&&this._addNodeRef(this.cameraCache,d.camera)}}_addNodeRef(e,i){i!==void 0&&(e.refs[i]===void 0&&(e.refs[i]=e.uses[i]=0),e.refs[i]++)}_getNodeRef(e,i,s){if(e.refs[i]<=1)return s;const o=s.clone(),c=(d,h)=>{const g=this.associations.get(d);g!=null&&this.associations.set(h,g);for(const[_,b]of d.children.entries())c(b,h.children[_])};return c(s,o),o.name+="_instance_"+e.uses[i]++,o}_invokeOne(e){const i=Object.values(this.plugins);i.push(this);for(let s=0;s<i.length;s++){const o=e(i[s]);if(o)return o}return null}_invokeAll(e){const i=Object.values(this.plugins);i.unshift(this);const s=[];for(let o=0;o<i.length;o++){const c=e(i[o]);c&&s.push(c)}return s}getDependency(e,i){const s=e+":"+i;let o=this.cache.get(s);if(!o){switch(e){case"scene":o=this.loadScene(i);break;case"node":o=this._invokeOne(function(c){return c.loadNode&&c.loadNode(i)});break;case"mesh":o=this._invokeOne(function(c){return c.loadMesh&&c.loadMesh(i)});break;case"accessor":o=this.loadAccessor(i);break;case"bufferView":o=this._invokeOne(function(c){return c.loadBufferView&&c.loadBufferView(i)});break;case"buffer":o=this.loadBuffer(i);break;case"material":o=this._invokeOne(function(c){return c.loadMaterial&&c.loadMaterial(i)});break;case"texture":o=this._invokeOne(function(c){return c.loadTexture&&c.loadTexture(i)});break;case"skin":o=this.loadSkin(i);break;case"animation":o=this._invokeOne(function(c){return c.loadAnimation&&c.loadAnimation(i)});break;case"camera":o=this.loadCamera(i);break;default:if(o=this._invokeOne(function(c){return c!=this&&c.getDependency&&c.getDependency(e,i)}),!o)throw new Error("Unknown type: "+e);break}this.cache.add(s,o)}return o}getDependencies(e){let i=this.cache.get(e);if(!i){const s=this,o=this.json[e+(e==="mesh"?"es":"s")]||[];i=Promise.all(o.map(function(c,d){return s.getDependency(e,d)})),this.cache.add(e,i)}return i}loadBuffer(e){const i=this.json.buffers[e],s=this.fileLoader;if(i.type&&i.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+i.type+" buffer type is not supported.");if(i.uri===void 0&&e===0)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const o=this.options;return new Promise(function(c,d){s.load(LoaderUtils.resolveURL(i.uri,o.path),c,void 0,function(){d(new Error('THREE.GLTFLoader: Failed to load buffer "'+i.uri+'".'))})})}loadBufferView(e){const i=this.json.bufferViews[e];return this.getDependency("buffer",i.buffer).then(function(s){const o=i.byteLength||0,c=i.byteOffset||0;return s.slice(c,c+o)})}loadAccessor(e){const i=this,s=this.json,o=this.json.accessors[e];if(o.bufferView===void 0&&o.sparse===void 0){const d=WEBGL_TYPE_SIZES[o.type],h=WEBGL_COMPONENT_TYPES[o.componentType],g=o.normalized===!0,_=new h(o.count*d);return Promise.resolve(new BufferAttribute(_,d,g))}const c=[];return o.bufferView!==void 0?c.push(this.getDependency("bufferView",o.bufferView)):c.push(null),o.sparse!==void 0&&(c.push(this.getDependency("bufferView",o.sparse.indices.bufferView)),c.push(this.getDependency("bufferView",o.sparse.values.bufferView))),Promise.all(c).then(function(d){const h=d[0],g=WEBGL_TYPE_SIZES[o.type],_=WEBGL_COMPONENT_TYPES[o.componentType],b=_.BYTES_PER_ELEMENT,$=b*g,j=o.byteOffset||0,_e=o.bufferView!==void 0?s.bufferViews[o.bufferView].byteStride:void 0,tt=o.normalized===!0;let et,nt;if(_e&&_e!==$){const rt=Math.floor(j/_e),it="InterleavedBuffer:"+o.bufferView+":"+o.componentType+":"+rt+":"+o.count;let at=i.cache.get(it);at||(et=new _(h,rt*_e,o.count*_e/b),at=new InterleavedBuffer(et,_e/b),i.cache.add(it,at)),nt=new InterleavedBufferAttribute(at,g,j%_e/b,tt)}else h===null?et=new _(o.count*g):et=new _(h,j,o.count*g),nt=new BufferAttribute(et,g,tt);if(o.sparse!==void 0){const rt=WEBGL_TYPE_SIZES.SCALAR,it=WEBGL_COMPONENT_TYPES[o.sparse.indices.componentType],at=o.sparse.indices.byteOffset||0,st=o.sparse.values.byteOffset||0,ot=new it(d[1],at,o.sparse.count*rt),ct=new _(d[2],st,o.sparse.count*g);h!==null&&(nt=new BufferAttribute(nt.array.slice(),nt.itemSize,nt.normalized));for(let lt=0,dt=ot.length;lt<dt;lt++){const xt=ot[lt];if(nt.setX(xt,ct[lt*g]),g>=2&&nt.setY(xt,ct[lt*g+1]),g>=3&&nt.setZ(xt,ct[lt*g+2]),g>=4&&nt.setW(xt,ct[lt*g+3]),g>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return nt})}loadTexture(e){const i=this.json,s=this.options,c=i.textures[e].source,d=i.images[c];let h=this.textureLoader;if(d.uri){const g=s.manager.getHandler(d.uri);g!==null&&(h=g)}return this.loadTextureImage(e,c,h)}loadTextureImage(e,i,s){const o=this,c=this.json,d=c.textures[e],h=c.images[i],g=(h.uri||h.bufferView)+":"+d.sampler;if(this.textureCache[g])return this.textureCache[g];const _=this.loadImageSource(i,s).then(function(b){b.flipY=!1,b.name=d.name||h.name||"",b.name===""&&typeof h.uri=="string"&&h.uri.startsWith("data:image/")===!1&&(b.name=h.uri);const j=(c.samplers||{})[d.sampler]||{};return b.magFilter=WEBGL_FILTERS[j.magFilter]||LinearFilter,b.minFilter=WEBGL_FILTERS[j.minFilter]||LinearMipmapLinearFilter,b.wrapS=WEBGL_WRAPPINGS[j.wrapS]||RepeatWrapping,b.wrapT=WEBGL_WRAPPINGS[j.wrapT]||RepeatWrapping,o.associations.set(b,{textures:e}),b}).catch(function(){return null});return this.textureCache[g]=_,_}loadImageSource(e,i){const s=this,o=this.json,c=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then($=>$.clone());const d=o.images[e],h=self.URL||self.webkitURL;let g=d.uri||"",_=!1;if(d.bufferView!==void 0)g=s.getDependency("bufferView",d.bufferView).then(function($){_=!0;const j=new Blob([$],{type:d.mimeType});return g=h.createObjectURL(j),g});else if(d.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const b=Promise.resolve(g).then(function($){return new Promise(function(j,_e){let tt=j;i.isImageBitmapLoader===!0&&(tt=function(et){const nt=new Texture(et);nt.needsUpdate=!0,j(nt)}),i.load(LoaderUtils.resolveURL($,c.path),tt,void 0,_e)})}).then(function($){return _===!0&&h.revokeObjectURL(g),assignExtrasToUserData($,d),$.userData.mimeType=d.mimeType||getImageURIMimeType(d.uri),$}).catch(function($){throw console.error("THREE.GLTFLoader: Couldn't load texture",g),$});return this.sourceCache[e]=b,b}assignTexture(e,i,s,o){const c=this;return this.getDependency("texture",s.index).then(function(d){if(!d)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(d=d.clone(),d.channel=s.texCoord),c.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const h=s.extensions!==void 0?s.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(h){const g=c.associations.get(d);d=c.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(d,h),c.associations.set(d,g)}}return o!==void 0&&(d.colorSpace=o),e[i]=d,d})}assignFinalMaterial(e){const i=e.geometry;let s=e.material;const o=i.attributes.tangent===void 0,c=i.attributes.color!==void 0,d=i.attributes.normal===void 0;if(e.isPoints){const h="PointsMaterial:"+s.uuid;let g=this.cache.get(h);g||(g=new PointsMaterial,Material.prototype.copy.call(g,s),g.color.copy(s.color),g.map=s.map,g.sizeAttenuation=!1,this.cache.add(h,g)),s=g}else if(e.isLine){const h="LineBasicMaterial:"+s.uuid;let g=this.cache.get(h);g||(g=new LineBasicMaterial,Material.prototype.copy.call(g,s),g.color.copy(s.color),g.map=s.map,this.cache.add(h,g)),s=g}if(o||c||d){let h="ClonedMaterial:"+s.uuid+":";o&&(h+="derivative-tangents:"),c&&(h+="vertex-colors:"),d&&(h+="flat-shading:");let g=this.cache.get(h);g||(g=s.clone(),c&&(g.vertexColors=!0),d&&(g.flatShading=!0),o&&(g.normalScale&&(g.normalScale.y*=-1),g.clearcoatNormalScale&&(g.clearcoatNormalScale.y*=-1)),this.cache.add(h,g),this.associations.set(g,this.associations.get(s))),s=g}e.material=s}getMaterialType(){return MeshStandardMaterial}loadMaterial(e){const i=this,s=this.json,o=this.extensions,c=s.materials[e];let d;const h={},g=c.extensions||{},_=[];if(g[EXTENSIONS.KHR_MATERIALS_UNLIT]){const $=o[EXTENSIONS.KHR_MATERIALS_UNLIT];d=$.getMaterialType(),_.push($.extendParams(h,c,i))}else{const $=c.pbrMetallicRoughness||{};if(h.color=new Color(1,1,1),h.opacity=1,Array.isArray($.baseColorFactor)){const j=$.baseColorFactor;h.color.setRGB(j[0],j[1],j[2],LinearSRGBColorSpace),h.opacity=j[3]}$.baseColorTexture!==void 0&&_.push(i.assignTexture(h,"map",$.baseColorTexture,SRGBColorSpace)),h.metalness=$.metallicFactor!==void 0?$.metallicFactor:1,h.roughness=$.roughnessFactor!==void 0?$.roughnessFactor:1,$.metallicRoughnessTexture!==void 0&&(_.push(i.assignTexture(h,"metalnessMap",$.metallicRoughnessTexture)),_.push(i.assignTexture(h,"roughnessMap",$.metallicRoughnessTexture))),d=this._invokeOne(function(j){return j.getMaterialType&&j.getMaterialType(e)}),_.push(Promise.all(this._invokeAll(function(j){return j.extendMaterialParams&&j.extendMaterialParams(e,h)})))}c.doubleSided===!0&&(h.side=DoubleSide);const b=c.alphaMode||ALPHA_MODES.OPAQUE;if(b===ALPHA_MODES.BLEND?(h.transparent=!0,h.depthWrite=!1):(h.transparent=!1,b===ALPHA_MODES.MASK&&(h.alphaTest=c.alphaCutoff!==void 0?c.alphaCutoff:.5)),c.normalTexture!==void 0&&d!==MeshBasicMaterial&&(_.push(i.assignTexture(h,"normalMap",c.normalTexture)),h.normalScale=new Vector2(1,1),c.normalTexture.scale!==void 0)){const $=c.normalTexture.scale;h.normalScale.set($,$)}if(c.occlusionTexture!==void 0&&d!==MeshBasicMaterial&&(_.push(i.assignTexture(h,"aoMap",c.occlusionTexture)),c.occlusionTexture.strength!==void 0&&(h.aoMapIntensity=c.occlusionTexture.strength)),c.emissiveFactor!==void 0&&d!==MeshBasicMaterial){const $=c.emissiveFactor;h.emissive=new Color().setRGB($[0],$[1],$[2],LinearSRGBColorSpace)}return c.emissiveTexture!==void 0&&d!==MeshBasicMaterial&&_.push(i.assignTexture(h,"emissiveMap",c.emissiveTexture,SRGBColorSpace)),Promise.all(_).then(function(){const $=new d(h);return c.name&&($.name=c.name),assignExtrasToUserData($,c),i.associations.set($,{materials:e}),c.extensions&&addUnknownExtensionsToUserData(o,$,c),$})}createUniqueName(e){const i=PropertyBinding.sanitizeNodeName(e||"");return i in this.nodeNamesUsed?i+"_"+ ++this.nodeNamesUsed[i]:(this.nodeNamesUsed[i]=0,i)}loadGeometries(e){const i=this,s=this.extensions,o=this.primitiveCache;function c(h){return s[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(h,i).then(function(g){return addPrimitiveAttributes(g,h,i)})}const d=[];for(let h=0,g=e.length;h<g;h++){const _=e[h],b=createPrimitiveKey(_),$=o[b];if($)d.push($.promise);else{let j;_.extensions&&_.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?j=c(_):j=addPrimitiveAttributes(new BufferGeometry,_,i),o[b]={primitive:_,promise:j},d.push(j)}}return Promise.all(d)}loadMesh(e){const i=this,s=this.json,o=this.extensions,c=s.meshes[e],d=c.primitives,h=[];for(let g=0,_=d.length;g<_;g++){const b=d[g].material===void 0?createDefaultMaterial(this.cache):this.getDependency("material",d[g].material);h.push(b)}return h.push(i.loadGeometries(d)),Promise.all(h).then(function(g){const _=g.slice(0,g.length-1),b=g[g.length-1],$=[];for(let _e=0,tt=b.length;_e<tt;_e++){const et=b[_e],nt=d[_e];let rt;const it=_[_e];if(nt.mode===WEBGL_CONSTANTS.TRIANGLES||nt.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||nt.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||nt.mode===void 0)rt=c.isSkinnedMesh===!0?new SkinnedMesh(et,it):new Mesh(et,it),rt.isSkinnedMesh===!0&&rt.normalizeSkinWeights(),nt.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP?rt.geometry=toTrianglesDrawMode(rt.geometry,TriangleStripDrawMode):nt.mode===WEBGL_CONSTANTS.TRIANGLE_FAN&&(rt.geometry=toTrianglesDrawMode(rt.geometry,TriangleFanDrawMode));else if(nt.mode===WEBGL_CONSTANTS.LINES)rt=new LineSegments(et,it);else if(nt.mode===WEBGL_CONSTANTS.LINE_STRIP)rt=new Line(et,it);else if(nt.mode===WEBGL_CONSTANTS.LINE_LOOP)rt=new LineLoop(et,it);else if(nt.mode===WEBGL_CONSTANTS.POINTS)rt=new Points(et,it);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+nt.mode);Object.keys(rt.geometry.morphAttributes).length>0&&updateMorphTargets(rt,c),rt.name=i.createUniqueName(c.name||"mesh_"+e),assignExtrasToUserData(rt,c),nt.extensions&&addUnknownExtensionsToUserData(o,rt,nt),i.assignFinalMaterial(rt),$.push(rt)}for(let _e=0,tt=$.length;_e<tt;_e++)i.associations.set($[_e],{meshes:e,primitives:_e});if($.length===1)return c.extensions&&addUnknownExtensionsToUserData(o,$[0],c),$[0];const j=new Group;c.extensions&&addUnknownExtensionsToUserData(o,j,c),i.associations.set(j,{meshes:e});for(let _e=0,tt=$.length;_e<tt;_e++)j.add($[_e]);return j})}loadCamera(e){let i;const s=this.json.cameras[e],o=s[s.type];if(!o){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?i=new PerspectiveCamera(MathUtils.radToDeg(o.yfov),o.aspectRatio||1,o.znear||1,o.zfar||2e6):s.type==="orthographic"&&(i=new OrthographicCamera(-o.xmag,o.xmag,o.ymag,-o.ymag,o.znear,o.zfar)),s.name&&(i.name=this.createUniqueName(s.name)),assignExtrasToUserData(i,s),Promise.resolve(i)}loadSkin(e){const i=this.json.skins[e],s=[];for(let o=0,c=i.joints.length;o<c;o++)s.push(this._loadNodeShallow(i.joints[o]));return i.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",i.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(o){const c=o.pop(),d=o,h=[],g=[];for(let _=0,b=d.length;_<b;_++){const $=d[_];if($){h.push($);const j=new Matrix4;c!==null&&j.fromArray(c.array,_*16),g.push(j)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',i.joints[_])}return new Skeleton(h,g)})}loadAnimation(e){const i=this.json,s=this,o=i.animations[e],c=o.name?o.name:"animation_"+e,d=[],h=[],g=[],_=[],b=[];for(let $=0,j=o.channels.length;$<j;$++){const _e=o.channels[$],tt=o.samplers[_e.sampler],et=_e.target,nt=et.node,rt=o.parameters!==void 0?o.parameters[tt.input]:tt.input,it=o.parameters!==void 0?o.parameters[tt.output]:tt.output;et.node!==void 0&&(d.push(this.getDependency("node",nt)),h.push(this.getDependency("accessor",rt)),g.push(this.getDependency("accessor",it)),_.push(tt),b.push(et))}return Promise.all([Promise.all(d),Promise.all(h),Promise.all(g),Promise.all(_),Promise.all(b)]).then(function($){const j=$[0],_e=$[1],tt=$[2],et=$[3],nt=$[4],rt=[];for(let it=0,at=j.length;it<at;it++){const st=j[it],ot=_e[it],ct=tt[it],lt=et[it],dt=nt[it];if(st===void 0)continue;st.updateMatrix&&st.updateMatrix();const xt=s._createAnimationTracks(st,ot,ct,lt,dt);if(xt)for(let ut=0;ut<xt.length;ut++)rt.push(xt[ut])}return new AnimationClip(c,void 0,rt)})}createNodeMesh(e){const i=this.json,s=this,o=i.nodes[e];return o.mesh===void 0?null:s.getDependency("mesh",o.mesh).then(function(c){const d=s._getNodeRef(s.meshCache,o.mesh,c);return o.weights!==void 0&&d.traverse(function(h){if(h.isMesh)for(let g=0,_=o.weights.length;g<_;g++)h.morphTargetInfluences[g]=o.weights[g]}),d})}loadNode(e){const i=this.json,s=this,o=i.nodes[e],c=s._loadNodeShallow(e),d=[],h=o.children||[];for(let _=0,b=h.length;_<b;_++)d.push(s.getDependency("node",h[_]));const g=o.skin===void 0?Promise.resolve(null):s.getDependency("skin",o.skin);return Promise.all([c,Promise.all(d),g]).then(function(_){const b=_[0],$=_[1],j=_[2];j!==null&&b.traverse(function(_e){_e.isSkinnedMesh&&_e.bind(j,_identityMatrix)});for(let _e=0,tt=$.length;_e<tt;_e++)b.add($[_e]);return b})}_loadNodeShallow(e){const i=this.json,s=this.extensions,o=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const c=i.nodes[e],d=c.name?o.createUniqueName(c.name):"",h=[],g=o._invokeOne(function(_){return _.createNodeMesh&&_.createNodeMesh(e)});return g&&h.push(g),c.camera!==void 0&&h.push(o.getDependency("camera",c.camera).then(function(_){return o._getNodeRef(o.cameraCache,c.camera,_)})),o._invokeAll(function(_){return _.createNodeAttachment&&_.createNodeAttachment(e)}).forEach(function(_){h.push(_)}),this.nodeCache[e]=Promise.all(h).then(function(_){let b;if(c.isBone===!0?b=new Bone:_.length>1?b=new Group:_.length===1?b=_[0]:b=new Object3D,b!==_[0])for(let $=0,j=_.length;$<j;$++)b.add(_[$]);if(c.name&&(b.userData.name=c.name,b.name=d),assignExtrasToUserData(b,c),c.extensions&&addUnknownExtensionsToUserData(s,b,c),c.matrix!==void 0){const $=new Matrix4;$.fromArray(c.matrix),b.applyMatrix4($)}else c.translation!==void 0&&b.position.fromArray(c.translation),c.rotation!==void 0&&b.quaternion.fromArray(c.rotation),c.scale!==void 0&&b.scale.fromArray(c.scale);return o.associations.has(b)||o.associations.set(b,{}),o.associations.get(b).nodes=e,b}),this.nodeCache[e]}loadScene(e){const i=this.extensions,s=this.json.scenes[e],o=this,c=new Group;s.name&&(c.name=o.createUniqueName(s.name)),assignExtrasToUserData(c,s),s.extensions&&addUnknownExtensionsToUserData(i,c,s);const d=s.nodes||[],h=[];for(let g=0,_=d.length;g<_;g++)h.push(o.getDependency("node",d[g]));return Promise.all(h).then(function(g){for(let b=0,$=g.length;b<$;b++)c.add(g[b]);const _=b=>{const $=new Map;for(const[j,_e]of o.associations)(j instanceof Material||j instanceof Texture)&&$.set(j,_e);return b.traverse(j=>{const _e=o.associations.get(j);_e!=null&&$.set(j,_e)}),$};return o.associations=_(c),c})}_createAnimationTracks(e,i,s,o,c){const d=[],h=e.name?e.name:e.uuid,g=[];PATH_PROPERTIES[c.path]===PATH_PROPERTIES.weights?e.traverse(function(j){j.morphTargetInfluences&&g.push(j.name?j.name:j.uuid)}):g.push(h);let _;switch(PATH_PROPERTIES[c.path]){case PATH_PROPERTIES.weights:_=NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:_=QuaternionKeyframeTrack;break;case PATH_PROPERTIES.position:case PATH_PROPERTIES.scale:_=VectorKeyframeTrack;break;default:switch(s.itemSize){case 1:_=NumberKeyframeTrack;break;case 2:case 3:default:_=VectorKeyframeTrack;break}break}const b=o.interpolation!==void 0?INTERPOLATION[o.interpolation]:InterpolateLinear,$=this._getArrayFromAccessor(s);for(let j=0,_e=g.length;j<_e;j++){const tt=new _(g[j]+"."+PATH_PROPERTIES[c.path],i.array,$,b);o.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(tt),d.push(tt)}return d}_getArrayFromAccessor(e){let i=e.array;if(e.normalized){const s=getNormalizedComponentScale(i.constructor),o=new Float32Array(i.length);for(let c=0,d=i.length;c<d;c++)o[c]=i[c]*s;i=o}return i}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const o=this instanceof QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new o(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function computeBounds(a,e,i){const s=e.attributes,o=new Box3;if(s.POSITION!==void 0){const h=i.json.accessors[s.POSITION],g=h.min,_=h.max;if(g!==void 0&&_!==void 0){if(o.set(new Vector3(g[0],g[1],g[2]),new Vector3(_[0],_[1],_[2])),h.normalized){const b=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[h.componentType]);o.min.multiplyScalar(b),o.max.multiplyScalar(b)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const c=e.targets;if(c!==void 0){const h=new Vector3,g=new Vector3;for(let _=0,b=c.length;_<b;_++){const $=c[_];if($.POSITION!==void 0){const j=i.json.accessors[$.POSITION],_e=j.min,tt=j.max;if(_e!==void 0&&tt!==void 0){if(g.setX(Math.max(Math.abs(_e[0]),Math.abs(tt[0]))),g.setY(Math.max(Math.abs(_e[1]),Math.abs(tt[1]))),g.setZ(Math.max(Math.abs(_e[2]),Math.abs(tt[2]))),j.normalized){const et=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[j.componentType]);g.multiplyScalar(et)}h.max(g)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}o.expandByVector(h)}a.boundingBox=o;const d=new Sphere;o.getCenter(d.center),d.radius=o.min.distanceTo(o.max)/2,a.boundingSphere=d}function addPrimitiveAttributes(a,e,i){const s=e.attributes,o=[];function c(d,h){return i.getDependency("accessor",d).then(function(g){a.setAttribute(h,g)})}for(const d in s){const h=ATTRIBUTES[d]||d.toLowerCase();h in a.attributes||o.push(c(s[d],h))}if(e.indices!==void 0&&!a.index){const d=i.getDependency("accessor",e.indices).then(function(h){a.setIndex(h)});o.push(d)}return ColorManagement.workingColorSpace!==LinearSRGBColorSpace&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`),assignExtrasToUserData(a,e),computeBounds(a,e,i),Promise.all(o).then(function(){return e.targets!==void 0?addMorphTargets(a,e.targets,i):a})}/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var extendStatics=function(a,e){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(i,s){i.__proto__=s}||function(i,s){for(var o in s)Object.prototype.hasOwnProperty.call(s,o)&&(i[o]=s[o])},extendStatics(a,e)};function __extends(a,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");extendStatics(a,e);function i(){this.constructor=a}a.prototype=e===null?Object.create(e):(i.prototype=e.prototype,new i)}function __values(a){var e=typeof Symbol=="function"&&Symbol.iterator,i=e&&a[e],s=0;if(i)return i.call(a);if(a&&typeof a.length=="number")return{next:function(){return a&&s>=a.length&&(a=void 0),{value:a&&a[s++],done:!a}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function __read(a,e){var i=typeof Symbol=="function"&&a[Symbol.iterator];if(!i)return a;var s=i.call(a),o,c=[],d;try{for(;(e===void 0||e-- >0)&&!(o=s.next()).done;)c.push(o.value)}catch(h){d={error:h}}finally{try{o&&!o.done&&(i=s.return)&&i.call(s)}finally{if(d)throw d.error}}return c}function __spreadArray(a,e){for(var i=0,s=e.length,o=a.length;i<s;i++,o++)a[o]=e[i];return a}function isFunction$3(a){return typeof a=="function"}function createErrorClass(a){var e=function(s){Error.call(s),s.stack=new Error().stack},i=a(e);return i.prototype=Object.create(Error.prototype),i.prototype.constructor=i,i}var UnsubscriptionError=createErrorClass(function(a){return function(i){a(this),this.message=i?i.length+` errors occurred during unsubscription:
`+i.map(function(s,o){return o+1+") "+s.toString()}).join(`
  `):"",this.name="UnsubscriptionError",this.errors=i}});function arrRemove(a,e){if(a){var i=a.indexOf(e);0<=i&&a.splice(i,1)}}var Subscription=function(){function a(e){this.initialTeardown=e,this.closed=!1,this._parentage=null,this._teardowns=null}return a.prototype.unsubscribe=function(){var e,i,s,o,c;if(!this.closed){this.closed=!0;var d=this._parentage;if(Array.isArray(d))try{for(var h=__values(d),g=h.next();!g.done;g=h.next()){var _=g.value;_.remove(this)}}catch(et){e={error:et}}finally{try{g&&!g.done&&(i=h.return)&&i.call(h)}finally{if(e)throw e.error}}else d==null||d.remove(this);var b=this.initialTeardown;if(isFunction$3(b))try{b()}catch(et){c=et instanceof UnsubscriptionError?et.errors:[et]}var $=this._teardowns;if($){this._teardowns=null;try{for(var j=__values($),_e=j.next();!_e.done;_e=j.next()){var tt=_e.value;try{execTeardown(tt)}catch(et){c=c??[],et instanceof UnsubscriptionError?c=__spreadArray(__spreadArray([],__read(c)),__read(et.errors)):c.push(et)}}}catch(et){s={error:et}}finally{try{_e&&!_e.done&&(o=j.return)&&o.call(j)}finally{if(s)throw s.error}}}if(c)throw new UnsubscriptionError(c)}},a.prototype.add=function(e){var i;if(e&&e!==this)if(this.closed)execTeardown(e);else{if(e instanceof a){if(e.closed||e._hasParent(this))return;e._addParent(this)}(this._teardowns=(i=this._teardowns)!==null&&i!==void 0?i:[]).push(e)}},a.prototype._hasParent=function(e){var i=this._parentage;return i===e||Array.isArray(i)&&i.includes(e)},a.prototype._addParent=function(e){var i=this._parentage;this._parentage=Array.isArray(i)?(i.push(e),i):i?[i,e]:e},a.prototype._removeParent=function(e){var i=this._parentage;i===e?this._parentage=null:Array.isArray(i)&&arrRemove(i,e)},a.prototype.remove=function(e){var i=this._teardowns;i&&arrRemove(i,e),e instanceof a&&e._removeParent(this)},a.EMPTY=function(){var e=new a;return e.closed=!0,e}(),a}(),EMPTY_SUBSCRIPTION=Subscription.EMPTY;function isSubscription(a){return a instanceof Subscription||a&&"closed"in a&&isFunction$3(a.remove)&&isFunction$3(a.add)&&isFunction$3(a.unsubscribe)}function execTeardown(a){isFunction$3(a)?a():a.unsubscribe()}var config$3={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},timeoutProvider={setTimeout:function(){for(var a=[],e=0;e<arguments.length;e++)a[e]=arguments[e];return setTimeout.apply(void 0,__spreadArray([],__read(a)))},clearTimeout:function(a){var e=timeoutProvider.delegate;return((e==null?void 0:e.clearTimeout)||clearTimeout)(a)},delegate:void 0};function reportUnhandledError(a){timeoutProvider.setTimeout(function(){throw a})}function noop$2(){}var Subscriber=function(a){__extends(e,a);function e(i){var s=a.call(this)||this;return s.isStopped=!1,i?(s.destination=i,isSubscription(i)&&i.add(s)):s.destination=EMPTY_OBSERVER,s}return e.create=function(i,s,o){return new SafeSubscriber(i,s,o)},e.prototype.next=function(i){this.isStopped||this._next(i)},e.prototype.error=function(i){this.isStopped||(this.isStopped=!0,this._error(i))},e.prototype.complete=function(){this.isStopped||(this.isStopped=!0,this._complete())},e.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,a.prototype.unsubscribe.call(this),this.destination=null)},e.prototype._next=function(i){this.destination.next(i)},e.prototype._error=function(i){try{this.destination.error(i)}finally{this.unsubscribe()}},e.prototype._complete=function(){try{this.destination.complete()}finally{this.unsubscribe()}},e}(Subscription),SafeSubscriber=function(a){__extends(e,a);function e(i,s,o){var c=a.call(this)||this,d;if(isFunction$3(i))d=i;else if(i){d=i.next,s=i.error,o=i.complete;var h;c&&config$3.useDeprecatedNextContext?(h=Object.create(i),h.unsubscribe=function(){return c.unsubscribe()}):h=i,d=d==null?void 0:d.bind(h),s=s==null?void 0:s.bind(h),o=o==null?void 0:o.bind(h)}return c.destination={next:d?wrapForErrorHandling(d):noop$2,error:wrapForErrorHandling(s??defaultErrorHandler),complete:o?wrapForErrorHandling(o):noop$2},c}return e}(Subscriber);function wrapForErrorHandling(a,e){return function(){for(var i=[],s=0;s<arguments.length;s++)i[s]=arguments[s];try{a.apply(void 0,__spreadArray([],__read(i)))}catch(o){reportUnhandledError(o)}}}function defaultErrorHandler(a){throw a}var EMPTY_OBSERVER={closed:!0,next:noop$2,error:defaultErrorHandler,complete:noop$2},observable=function(){return typeof Symbol=="function"&&Symbol.observable||"@@observable"}();function identity$4(a){return a}function pipeFromArray(a){return a.length===0?identity$4:a.length===1?a[0]:function(i){return a.reduce(function(s,o){return o(s)},i)}}var Observable=function(){function a(e){e&&(this._subscribe=e)}return a.prototype.lift=function(e){var i=new a;return i.source=this,i.operator=e,i},a.prototype.subscribe=function(e,i,s){var o=isSubscriber(e)?e:new SafeSubscriber(e,i,s);{var c=this,d=c.operator,h=c.source;o.add(d?d.call(o,h):h?this._subscribe(o):this._trySubscribe(o))}return o},a.prototype._deprecatedSyncErrorSubscribe=function(e){var i=e;i._syncErrorHack_isSubscribing=!0;var s=this.operator;if(s)e.add(s.call(e,this.source));else try{this._subscribe(e)}catch(c){i.__syncError=c}for(var o=i;o;){if("__syncError"in o)try{throw o.__syncError}finally{e.unsubscribe()}o=o.destination}i._syncErrorHack_isSubscribing=!1},a.prototype._trySubscribe=function(e){try{return this._subscribe(e)}catch(i){e.error(i)}},a.prototype.forEach=function(e,i){var s=this;return i=getPromiseCtor(i),new i(function(o,c){var d;d=s.subscribe(function(h){try{e(h)}catch(g){c(g),d==null||d.unsubscribe()}},c,o)})},a.prototype._subscribe=function(e){var i;return(i=this.source)===null||i===void 0?void 0:i.subscribe(e)},a.prototype[observable]=function(){return this},a.prototype.pipe=function(){for(var e=[],i=0;i<arguments.length;i++)e[i]=arguments[i];return e.length?pipeFromArray(e)(this):this},a.prototype.toPromise=function(e){var i=this;return e=getPromiseCtor(e),new e(function(s,o){var c;i.subscribe(function(d){return c=d},function(d){return o(d)},function(){return s(c)})})},a.create=function(e){return new a(e)},a}();function getPromiseCtor(a){var e;return(e=a??config$3.Promise)!==null&&e!==void 0?e:Promise}function isObserver(a){return a&&isFunction$3(a.next)&&isFunction$3(a.error)&&isFunction$3(a.complete)}function isSubscriber(a){return a&&a instanceof Subscriber||isObserver(a)&&isSubscription(a)}var ObjectUnsubscribedError=createErrorClass(function(a){return function(){a(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"}}),Subject=function(a){__extends(e,a);function e(){var i=a.call(this)||this;return i.closed=!1,i.observers=[],i.isStopped=!1,i.hasError=!1,i.thrownError=null,i}return e.prototype.lift=function(i){var s=new AnonymousSubject(this,this);return s.operator=i,s},e.prototype._throwIfClosed=function(){if(this.closed)throw new ObjectUnsubscribedError},e.prototype.next=function(i){var s,o;if(this._throwIfClosed(),!this.isStopped){var c=this.observers.slice();try{for(var d=__values(c),h=d.next();!h.done;h=d.next()){var g=h.value;g.next(i)}}catch(_){s={error:_}}finally{try{h&&!h.done&&(o=d.return)&&o.call(d)}finally{if(s)throw s.error}}}},e.prototype.error=function(i){if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=i;for(var s=this.observers;s.length;)s.shift().error(i)}},e.prototype.complete=function(){if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;for(var i=this.observers;i.length;)i.shift().complete()}},e.prototype.unsubscribe=function(){this.isStopped=this.closed=!0,this.observers=null},e.prototype._trySubscribe=function(i){return this._throwIfClosed(),a.prototype._trySubscribe.call(this,i)},e.prototype._subscribe=function(i){return this._throwIfClosed(),this._checkFinalizedStatuses(i),this._innerSubscribe(i)},e.prototype._innerSubscribe=function(i){var s=this,o=s.hasError,c=s.isStopped,d=s.observers;return o||c?EMPTY_SUBSCRIPTION:(d.push(i),new Subscription(function(){return arrRemove(d,i)}))},e.prototype._checkFinalizedStatuses=function(i){var s=this,o=s.hasError,c=s.thrownError,d=s.isStopped;o?i.error(c):d&&i.complete()},e.prototype.asObservable=function(){var i=new Observable;return i.source=this,i},e.create=function(i,s){return new AnonymousSubject(i,s)},e}(Observable),AnonymousSubject=function(a){__extends(e,a);function e(i,s){var o=a.call(this)||this;return o.destination=i,o.source=s,o}return e.prototype.next=function(i){var s,o;(o=(s=this.destination)===null||s===void 0?void 0:s.next)===null||o===void 0||o.call(s,i)},e.prototype.error=function(i){var s,o;(o=(s=this.destination)===null||s===void 0?void 0:s.error)===null||o===void 0||o.call(s,i)},e.prototype.complete=function(){var i,s;(s=(i=this.destination)===null||i===void 0?void 0:i.complete)===null||s===void 0||s.call(i)},e.prototype._subscribe=function(i){var s,o;return(o=(s=this.source)===null||s===void 0?void 0:s.subscribe(i))!==null&&o!==void 0?o:EMPTY_SUBSCRIPTION},e}(Subject),axios$2={exports:{}},bind$2=function(e,i){return function(){for(var o=new Array(arguments.length),c=0;c<o.length;c++)o[c]=arguments[c];return e.apply(i,o)}},bind$1=bind$2,toString=Object.prototype.toString;function isArray$1(a){return Array.isArray(a)}function isUndefined$1(a){return typeof a>"u"}function isBuffer(a){return a!==null&&!isUndefined$1(a)&&a.constructor!==null&&!isUndefined$1(a.constructor)&&typeof a.constructor.isBuffer=="function"&&a.constructor.isBuffer(a)}function isArrayBuffer(a){return toString.call(a)==="[object ArrayBuffer]"}function isFormData(a){return toString.call(a)==="[object FormData]"}function isArrayBufferView(a){var e;return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?e=ArrayBuffer.isView(a):e=a&&a.buffer&&isArrayBuffer(a.buffer),e}function isString$2(a){return typeof a=="string"}function isNumber$2(a){return typeof a=="number"}function isObject$2(a){return a!==null&&typeof a=="object"}function isPlainObject$1(a){if(toString.call(a)!=="[object Object]")return!1;var e=Object.getPrototypeOf(a);return e===null||e===Object.prototype}function isDate$1(a){return toString.call(a)==="[object Date]"}function isFile(a){return toString.call(a)==="[object File]"}function isBlob(a){return toString.call(a)==="[object Blob]"}function isFunction$2(a){return toString.call(a)==="[object Function]"}function isStream(a){return isObject$2(a)&&isFunction$2(a.pipe)}function isURLSearchParams(a){return toString.call(a)==="[object URLSearchParams]"}function trim(a){return a.trim?a.trim():a.replace(/^\s+|\s+$/g,"")}function isStandardBrowserEnv(){return typeof navigator<"u"&&(navigator.product==="ReactNative"||navigator.product==="NativeScript"||navigator.product==="NS")?!1:typeof window<"u"&&typeof document<"u"}function forEach(a,e){if(!(a===null||typeof a>"u"))if(typeof a!="object"&&(a=[a]),isArray$1(a))for(var i=0,s=a.length;i<s;i++)e.call(null,a[i],i,a);else for(var o in a)Object.prototype.hasOwnProperty.call(a,o)&&e.call(null,a[o],o,a)}function merge(){var a={};function e(o,c){isPlainObject$1(a[c])&&isPlainObject$1(o)?a[c]=merge(a[c],o):isPlainObject$1(o)?a[c]=merge({},o):isArray$1(o)?a[c]=o.slice():a[c]=o}for(var i=0,s=arguments.length;i<s;i++)forEach(arguments[i],e);return a}function extend$1(a,e,i){return forEach(e,function(o,c){i&&typeof o=="function"?a[c]=bind$1(o,i):a[c]=o}),a}function stripBOM(a){return a.charCodeAt(0)===65279&&(a=a.slice(1)),a}var utils$8={isArray:isArray$1,isArrayBuffer,isBuffer,isFormData,isArrayBufferView,isString:isString$2,isNumber:isNumber$2,isObject:isObject$2,isPlainObject:isPlainObject$1,isUndefined:isUndefined$1,isDate:isDate$1,isFile,isBlob,isFunction:isFunction$2,isStream,isURLSearchParams,isStandardBrowserEnv,forEach,merge,extend:extend$1,trim,stripBOM},utils$7=utils$8;function encode(a){return encodeURIComponent(a).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var buildURL$1=function(e,i,s){if(!i)return e;var o;if(s)o=s(i);else if(utils$7.isURLSearchParams(i))o=i.toString();else{var c=[];utils$7.forEach(i,function(g,_){g===null||typeof g>"u"||(utils$7.isArray(g)?_=_+"[]":g=[g],utils$7.forEach(g,function($){utils$7.isDate($)?$=$.toISOString():utils$7.isObject($)&&($=JSON.stringify($)),c.push(encode(_)+"="+encode($))}))}),o=c.join("&")}if(o){var d=e.indexOf("#");d!==-1&&(e=e.slice(0,d)),e+=(e.indexOf("?")===-1?"?":"&")+o}return e},utils$6=utils$8;function InterceptorManager$1(){this.handlers=[]}InterceptorManager$1.prototype.use=function(e,i,s){return this.handlers.push({fulfilled:e,rejected:i,synchronous:s?s.synchronous:!1,runWhen:s?s.runWhen:null}),this.handlers.length-1};InterceptorManager$1.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null)};InterceptorManager$1.prototype.forEach=function(e){utils$6.forEach(this.handlers,function(s){s!==null&&e(s)})};var InterceptorManager_1=InterceptorManager$1,utils$5=utils$8,normalizeHeaderName=function(e,i){utils$5.forEach(e,function(o,c){c!==i&&c.toUpperCase()===i.toUpperCase()&&(e[i]=o,delete e[c])})},enhanceError=function(e,i,s,o,c){return e.config=i,s&&(e.code=s),e.request=o,e.response=c,e.isAxiosError=!0,e.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}},e},createError,hasRequiredCreateError;function requireCreateError(){if(hasRequiredCreateError)return createError;hasRequiredCreateError=1;var a=enhanceError;return createError=function(i,s,o,c,d){var h=new Error(i);return a(h,s,o,c,d)},createError}var settle,hasRequiredSettle;function requireSettle(){if(hasRequiredSettle)return settle;hasRequiredSettle=1;var a=requireCreateError();return settle=function(i,s,o){var c=o.config.validateStatus;!o.status||!c||c(o.status)?i(o):s(a("Request failed with status code "+o.status,o.config,null,o.request,o))},settle}var cookies,hasRequiredCookies;function requireCookies(){if(hasRequiredCookies)return cookies;hasRequiredCookies=1;var a=utils$8;return cookies=a.isStandardBrowserEnv()?function(){return{write:function(s,o,c,d,h,g){var _=[];_.push(s+"="+encodeURIComponent(o)),a.isNumber(c)&&_.push("expires="+new Date(c).toGMTString()),a.isString(d)&&_.push("path="+d),a.isString(h)&&_.push("domain="+h),g===!0&&_.push("secure"),document.cookie=_.join("; ")},read:function(s){var o=document.cookie.match(new RegExp("(^|;\\s*)("+s+")=([^;]*)"));return o?decodeURIComponent(o[3]):null},remove:function(s){this.write(s,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}(),cookies}var isAbsoluteURL,hasRequiredIsAbsoluteURL;function requireIsAbsoluteURL(){return hasRequiredIsAbsoluteURL||(hasRequiredIsAbsoluteURL=1,isAbsoluteURL=function(e){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)}),isAbsoluteURL}var combineURLs,hasRequiredCombineURLs;function requireCombineURLs(){return hasRequiredCombineURLs||(hasRequiredCombineURLs=1,combineURLs=function(e,i){return i?e.replace(/\/+$/,"")+"/"+i.replace(/^\/+/,""):e}),combineURLs}var buildFullPath,hasRequiredBuildFullPath;function requireBuildFullPath(){if(hasRequiredBuildFullPath)return buildFullPath;hasRequiredBuildFullPath=1;var a=requireIsAbsoluteURL(),e=requireCombineURLs();return buildFullPath=function(s,o){return s&&!a(o)?e(s,o):o},buildFullPath}var parseHeaders,hasRequiredParseHeaders;function requireParseHeaders(){if(hasRequiredParseHeaders)return parseHeaders;hasRequiredParseHeaders=1;var a=utils$8,e=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];return parseHeaders=function(s){var o={},c,d,h;return s&&a.forEach(s.split(`
`),function(_){if(h=_.indexOf(":"),c=a.trim(_.substr(0,h)).toLowerCase(),d=a.trim(_.substr(h+1)),c){if(o[c]&&e.indexOf(c)>=0)return;c==="set-cookie"?o[c]=(o[c]?o[c]:[]).concat([d]):o[c]=o[c]?o[c]+", "+d:d}}),o},parseHeaders}var isURLSameOrigin,hasRequiredIsURLSameOrigin;function requireIsURLSameOrigin(){if(hasRequiredIsURLSameOrigin)return isURLSameOrigin;hasRequiredIsURLSameOrigin=1;var a=utils$8;return isURLSameOrigin=a.isStandardBrowserEnv()?function(){var i=/(msie|trident)/i.test(navigator.userAgent),s=document.createElement("a"),o;function c(d){var h=d;return i&&(s.setAttribute("href",h),h=s.href),s.setAttribute("href",h),{href:s.href,protocol:s.protocol?s.protocol.replace(/:$/,""):"",host:s.host,search:s.search?s.search.replace(/^\?/,""):"",hash:s.hash?s.hash.replace(/^#/,""):"",hostname:s.hostname,port:s.port,pathname:s.pathname.charAt(0)==="/"?s.pathname:"/"+s.pathname}}return o=c(window.location.href),function(h){var g=a.isString(h)?c(h):h;return g.protocol===o.protocol&&g.host===o.host}}():function(){return function(){return!0}}(),isURLSameOrigin}var Cancel_1,hasRequiredCancel;function requireCancel(){if(hasRequiredCancel)return Cancel_1;hasRequiredCancel=1;function a(e){this.message=e}return a.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},a.prototype.__CANCEL__=!0,Cancel_1=a,Cancel_1}var xhr,hasRequiredXhr;function requireXhr(){if(hasRequiredXhr)return xhr;hasRequiredXhr=1;var a=utils$8,e=requireSettle(),i=requireCookies(),s=buildURL$1,o=requireBuildFullPath(),c=requireParseHeaders(),d=requireIsURLSameOrigin(),h=requireCreateError(),g=requireDefaults(),_=requireCancel();return xhr=function($){return new Promise(function(_e,tt){var et=$.data,nt=$.headers,rt=$.responseType,it;function at(){$.cancelToken&&$.cancelToken.unsubscribe(it),$.signal&&$.signal.removeEventListener("abort",it)}a.isFormData(et)&&delete nt["Content-Type"];var st=new XMLHttpRequest;if($.auth){var ot=$.auth.username||"",ct=$.auth.password?unescape(encodeURIComponent($.auth.password)):"";nt.Authorization="Basic "+btoa(ot+":"+ct)}var lt=o($.baseURL,$.url);st.open($.method.toUpperCase(),s(lt,$.params,$.paramsSerializer),!0),st.timeout=$.timeout;function dt(){if(st){var ut="getAllResponseHeaders"in st?c(st.getAllResponseHeaders()):null,ft=!rt||rt==="text"||rt==="json"?st.responseText:st.response,mt={data:ft,status:st.status,statusText:st.statusText,headers:ut,config:$,request:st};e(function(St){_e(St),at()},function(St){tt(St),at()},mt),st=null}}if("onloadend"in st?st.onloadend=dt:st.onreadystatechange=function(){!st||st.readyState!==4||st.status===0&&!(st.responseURL&&st.responseURL.indexOf("file:")===0)||setTimeout(dt)},st.onabort=function(){st&&(tt(h("Request aborted",$,"ECONNABORTED",st)),st=null)},st.onerror=function(){tt(h("Network Error",$,null,st)),st=null},st.ontimeout=function(){var ft=$.timeout?"timeout of "+$.timeout+"ms exceeded":"timeout exceeded",mt=$.transitional||g.transitional;$.timeoutErrorMessage&&(ft=$.timeoutErrorMessage),tt(h(ft,$,mt.clarifyTimeoutError?"ETIMEDOUT":"ECONNABORTED",st)),st=null},a.isStandardBrowserEnv()){var xt=($.withCredentials||d(lt))&&$.xsrfCookieName?i.read($.xsrfCookieName):void 0;xt&&(nt[$.xsrfHeaderName]=xt)}"setRequestHeader"in st&&a.forEach(nt,function(ft,mt){typeof et>"u"&&mt.toLowerCase()==="content-type"?delete nt[mt]:st.setRequestHeader(mt,ft)}),a.isUndefined($.withCredentials)||(st.withCredentials=!!$.withCredentials),rt&&rt!=="json"&&(st.responseType=$.responseType),typeof $.onDownloadProgress=="function"&&st.addEventListener("progress",$.onDownloadProgress),typeof $.onUploadProgress=="function"&&st.upload&&st.upload.addEventListener("progress",$.onUploadProgress),($.cancelToken||$.signal)&&(it=function(ut){st&&(tt(!ut||ut&&ut.type?new _("canceled"):ut),st.abort(),st=null)},$.cancelToken&&$.cancelToken.subscribe(it),$.signal&&($.signal.aborted?it():$.signal.addEventListener("abort",it))),et||(et=null),st.send(et)})},xhr}var defaults_1,hasRequiredDefaults;function requireDefaults(){if(hasRequiredDefaults)return defaults_1;hasRequiredDefaults=1;var a=utils$8,e=normalizeHeaderName,i=enhanceError,s={"Content-Type":"application/x-www-form-urlencoded"};function o(g,_){!a.isUndefined(g)&&a.isUndefined(g["Content-Type"])&&(g["Content-Type"]=_)}function c(){var g;return(typeof XMLHttpRequest<"u"||typeof process<"u"&&Object.prototype.toString.call(process)==="[object process]")&&(g=requireXhr()),g}function d(g,_,b){if(a.isString(g))try{return(_||JSON.parse)(g),a.trim(g)}catch($){if($.name!=="SyntaxError")throw $}return(0,JSON.stringify)(g)}var h={transitional:{silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},adapter:c(),transformRequest:[function(_,b){return e(b,"Accept"),e(b,"Content-Type"),a.isFormData(_)||a.isArrayBuffer(_)||a.isBuffer(_)||a.isStream(_)||a.isFile(_)||a.isBlob(_)?_:a.isArrayBufferView(_)?_.buffer:a.isURLSearchParams(_)?(o(b,"application/x-www-form-urlencoded;charset=utf-8"),_.toString()):a.isObject(_)||b&&b["Content-Type"]==="application/json"?(o(b,"application/json"),d(_)):_}],transformResponse:[function(_){var b=this.transitional||h.transitional,$=b&&b.silentJSONParsing,j=b&&b.forcedJSONParsing,_e=!$&&this.responseType==="json";if(_e||j&&a.isString(_)&&_.length)try{return JSON.parse(_)}catch(tt){if(_e)throw tt.name==="SyntaxError"?i(tt,this,"E_JSON_PARSE"):tt}return _}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,validateStatus:function(_){return _>=200&&_<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};return a.forEach(["delete","get","head"],function(_){h.headers[_]={}}),a.forEach(["post","put","patch"],function(_){h.headers[_]=a.merge(s)}),defaults_1=h,defaults_1}var utils$4=utils$8,defaults$2=requireDefaults(),transformData$1=function(e,i,s){var o=this||defaults$2;return utils$4.forEach(s,function(d){e=d.call(o,e,i)}),e},isCancel$1,hasRequiredIsCancel;function requireIsCancel(){return hasRequiredIsCancel||(hasRequiredIsCancel=1,isCancel$1=function(e){return!!(e&&e.__CANCEL__)}),isCancel$1}var utils$3=utils$8,transformData=transformData$1,isCancel=requireIsCancel(),defaults$1=requireDefaults(),Cancel=requireCancel();function throwIfCancellationRequested(a){if(a.cancelToken&&a.cancelToken.throwIfRequested(),a.signal&&a.signal.aborted)throw new Cancel("canceled")}var dispatchRequest$1=function(e){throwIfCancellationRequested(e),e.headers=e.headers||{},e.data=transformData.call(e,e.data,e.headers,e.transformRequest),e.headers=utils$3.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),utils$3.forEach(["delete","get","head","post","put","patch","common"],function(o){delete e.headers[o]});var i=e.adapter||defaults$1.adapter;return i(e).then(function(o){return throwIfCancellationRequested(e),o.data=transformData.call(e,o.data,o.headers,e.transformResponse),o},function(o){return isCancel(o)||(throwIfCancellationRequested(e),o&&o.response&&(o.response.data=transformData.call(e,o.response.data,o.response.headers,e.transformResponse))),Promise.reject(o)})},utils$2=utils$8,mergeConfig$2=function(e,i){i=i||{};var s={};function o(b,$){return utils$2.isPlainObject(b)&&utils$2.isPlainObject($)?utils$2.merge(b,$):utils$2.isPlainObject($)?utils$2.merge({},$):utils$2.isArray($)?$.slice():$}function c(b){if(utils$2.isUndefined(i[b])){if(!utils$2.isUndefined(e[b]))return o(void 0,e[b])}else return o(e[b],i[b])}function d(b){if(!utils$2.isUndefined(i[b]))return o(void 0,i[b])}function h(b){if(utils$2.isUndefined(i[b])){if(!utils$2.isUndefined(e[b]))return o(void 0,e[b])}else return o(void 0,i[b])}function g(b){if(b in i)return o(e[b],i[b]);if(b in e)return o(void 0,e[b])}var _={url:d,method:d,data:d,baseURL:h,transformRequest:h,transformResponse:h,paramsSerializer:h,timeout:h,timeoutMessage:h,withCredentials:h,adapter:h,responseType:h,xsrfCookieName:h,xsrfHeaderName:h,onUploadProgress:h,onDownloadProgress:h,decompress:h,maxContentLength:h,maxBodyLength:h,transport:h,httpAgent:h,httpsAgent:h,cancelToken:h,socketPath:h,responseEncoding:h,validateStatus:g};return utils$2.forEach(Object.keys(e).concat(Object.keys(i)),function($){var j=_[$]||c,_e=j($);utils$2.isUndefined(_e)&&j!==g||(s[$]=_e)}),s},data,hasRequiredData;function requireData(){return hasRequiredData||(hasRequiredData=1,data={version:"0.25.0"}),data}var VERSION=requireData().version,validators$1={};["object","boolean","number","function","string","symbol"].forEach(function(a,e){validators$1[a]=function(s){return typeof s===a||"a"+(e<1?"n ":" ")+a}});var deprecatedWarnings={};validators$1.transitional=function(e,i,s){function o(c,d){return"[Axios v"+VERSION+"] Transitional option '"+c+"'"+d+(s?". "+s:"")}return function(c,d,h){if(e===!1)throw new Error(o(d," has been removed"+(i?" in "+i:"")));return i&&!deprecatedWarnings[d]&&(deprecatedWarnings[d]=!0,console.warn(o(d," has been deprecated since v"+i+" and will be removed in the near future"))),e?e(c,d,h):!0}};function assertOptions(a,e,i){if(typeof a!="object")throw new TypeError("options must be an object");for(var s=Object.keys(a),o=s.length;o-- >0;){var c=s[o],d=e[c];if(d){var h=a[c],g=h===void 0||d(h,c,a);if(g!==!0)throw new TypeError("option "+c+" must be "+g);continue}if(i!==!0)throw Error("Unknown option "+c)}}var validator$1={assertOptions,validators:validators$1},utils$1=utils$8,buildURL=buildURL$1,InterceptorManager=InterceptorManager_1,dispatchRequest=dispatchRequest$1,mergeConfig$1=mergeConfig$2,validator=validator$1,validators=validator.validators;function Axios$1(a){this.defaults=a,this.interceptors={request:new InterceptorManager,response:new InterceptorManager}}Axios$1.prototype.request=function(e,i){if(typeof e=="string"?(i=i||{},i.url=e):i=e||{},!i.url)throw new Error("Provided config url is not valid");i=mergeConfig$1(this.defaults,i),i.method?i.method=i.method.toLowerCase():this.defaults.method?i.method=this.defaults.method.toLowerCase():i.method="get";var s=i.transitional;s!==void 0&&validator.assertOptions(s,{silentJSONParsing:validators.transitional(validators.boolean),forcedJSONParsing:validators.transitional(validators.boolean),clarifyTimeoutError:validators.transitional(validators.boolean)},!1);var o=[],c=!0;this.interceptors.request.forEach(function(_e){typeof _e.runWhen=="function"&&_e.runWhen(i)===!1||(c=c&&_e.synchronous,o.unshift(_e.fulfilled,_e.rejected))});var d=[];this.interceptors.response.forEach(function(_e){d.push(_e.fulfilled,_e.rejected)});var h;if(!c){var g=[dispatchRequest,void 0];for(Array.prototype.unshift.apply(g,o),g=g.concat(d),h=Promise.resolve(i);g.length;)h=h.then(g.shift(),g.shift());return h}for(var _=i;o.length;){var b=o.shift(),$=o.shift();try{_=b(_)}catch(j){$(j);break}}try{h=dispatchRequest(_)}catch(j){return Promise.reject(j)}for(;d.length;)h=h.then(d.shift(),d.shift());return h};Axios$1.prototype.getUri=function(e){if(!e.url)throw new Error("Provided config url is not valid");return e=mergeConfig$1(this.defaults,e),buildURL(e.url,e.params,e.paramsSerializer).replace(/^\?/,"")};utils$1.forEach(["delete","get","head","options"],function(e){Axios$1.prototype[e]=function(i,s){return this.request(mergeConfig$1(s||{},{method:e,url:i,data:(s||{}).data}))}});utils$1.forEach(["post","put","patch"],function(e){Axios$1.prototype[e]=function(i,s,o){return this.request(mergeConfig$1(o||{},{method:e,url:i,data:s}))}});var Axios_1=Axios$1,CancelToken_1,hasRequiredCancelToken;function requireCancelToken(){if(hasRequiredCancelToken)return CancelToken_1;hasRequiredCancelToken=1;var a=requireCancel();function e(i){if(typeof i!="function")throw new TypeError("executor must be a function.");var s;this.promise=new Promise(function(d){s=d});var o=this;this.promise.then(function(c){if(o._listeners){var d,h=o._listeners.length;for(d=0;d<h;d++)o._listeners[d](c);o._listeners=null}}),this.promise.then=function(c){var d,h=new Promise(function(g){o.subscribe(g),d=g}).then(c);return h.cancel=function(){o.unsubscribe(d)},h},i(function(d){o.reason||(o.reason=new a(d),s(o.reason))})}return e.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},e.prototype.subscribe=function(s){if(this.reason){s(this.reason);return}this._listeners?this._listeners.push(s):this._listeners=[s]},e.prototype.unsubscribe=function(s){if(this._listeners){var o=this._listeners.indexOf(s);o!==-1&&this._listeners.splice(o,1)}},e.source=function(){var s,o=new e(function(d){s=d});return{token:o,cancel:s}},CancelToken_1=e,CancelToken_1}var spread,hasRequiredSpread;function requireSpread(){return hasRequiredSpread||(hasRequiredSpread=1,spread=function(e){return function(s){return e.apply(null,s)}}),spread}var isAxiosError,hasRequiredIsAxiosError;function requireIsAxiosError(){if(hasRequiredIsAxiosError)return isAxiosError;hasRequiredIsAxiosError=1;var a=utils$8;return isAxiosError=function(i){return a.isObject(i)&&i.isAxiosError===!0},isAxiosError}var utils=utils$8,bind=bind$2,Axios=Axios_1,mergeConfig=mergeConfig$2,defaults=requireDefaults();function createInstance(a){var e=new Axios(a),i=bind(Axios.prototype.request,e);return utils.extend(i,Axios.prototype,e),utils.extend(i,e),i.create=function(o){return createInstance(mergeConfig(a,o))},i}var axios$1=createInstance(defaults);axios$1.Axios=Axios;axios$1.Cancel=requireCancel();axios$1.CancelToken=requireCancelToken();axios$1.isCancel=requireIsCancel();axios$1.VERSION=requireData().version;axios$1.all=function(e){return Promise.all(e)};axios$1.spread=requireSpread();axios$1.isAxiosError=requireIsAxiosError();axios$2.exports=axios$1;axios$2.exports.default=axios$1;var axiosExports=axios$2.exports,axios=axiosExports;const a1_0x436209=getDefaultExportFromCjs$1(axios);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EPSILON_FLOAT32$1=1e-7,EPSILON_FLOAT16$1=1e-4;class DataStorage{constructor(e,i){this.backend=e,this.dataMover=i,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,i){this.dataIdsCount++,this.data.set(e,i)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class KernelBackend{refCount(e){return notYetImplemented("refCount")}incRef(e){return notYetImplemented("incRef")}timerAvailable(){return!0}time(e){return notYetImplemented("time")}read(e){return notYetImplemented("read")}readSync(e){return notYetImplemented("readSync")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(e,i){return notYetImplemented("disposeData")}write(e,i,s){return notYetImplemented("write")}move(e,i,s,o,c){return notYetImplemented("move")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32$1:EPSILON_FLOAT16$1}dispose(){return notYetImplemented("dispose")}}function notYetImplemented(a){throw new Error(`'${a}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function shuffle(a){let e=a.length,i=0,s=0;for(;e>0;)s=Math.random()*e|0,e--,i=a[e],a[e]=a[s],a[s]=i}function shuffleCombo(a,e){if(a.length!==e.length)throw Error(`Array sizes must match to be shuffled together First array length was ${a.length}Second array length was ${e.length}`);let i=a.length,s,o,c=0;for(;i>0;)c=Math.random()*i|0,i--,s=a[i],o=e[i],a[i]=a[c],e[i]=e[c],a[c]=s,e[c]=o}function clamp$1(a,e,i){return Math.max(a,Math.min(e,i))}function nearestLargerEven(a){return a%2===0?a:a+1}function sum$4(a){let e=0;for(let i=0;i<a.length;i++)e+=a[i];return e}function randUniform(a,e){const i=Math.random();return e*i+(1-i)*a}function distSquared(a,e){let i=0;for(let s=0;s<a.length;s++){const o=Number(a[s])-Number(e[s]);i+=o*o}return i}function assert$1(a,e){if(!a)throw new Error(typeof e=="string"?e:e())}function assertShapesMatch(a,e,i=""){assert$1(arraysEqual(a,e),()=>i+` Shapes ${a} and ${e} must match`)}function assertNonNull(a){assert$1(a!=null,()=>"The input to the tensor constructor must be a non-null value.")}function flatten$4(a,e=[],i=!1){if(e==null&&(e=[]),Array.isArray(a)||isTypedArray(a)&&!i)for(let s=0;s<a.length;++s)flatten$4(a[s],e,i);else e.push(a);return e}function sizeFromShape(a){if(a.length===0)return 1;let e=a[0];for(let i=1;i<a.length;i++)e*=a[i];return e}function isScalarShape(a){return a.length===0}function arraysEqual(a,e){if(a===e)return!0;if(a==null||e==null||a.length!==e.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!==e[i])return!1;return!0}function isInt(a){return a%1===0}function tanh$4(a){if(Math.tanh!=null)return Math.tanh(a);if(a===1/0)return 1;if(a===-1/0)return-1;{const e=Math.exp(2*a);return(e-1)/(e+1)}}function sizeToSquarishShape(a){const e=Math.ceil(Math.sqrt(a));return[e,Math.ceil(a/e)]}function createShuffledIndices(a){const e=new Uint32Array(a);for(let i=0;i<a;++i)e[i]=i;return shuffle(e),e}function rightPad(a,e){return e<=a.length?a:a+" ".repeat(e-a.length)}function repeatedTry(a,e=s=>0,i){return new Promise((s,o)=>{let c=0;const d=()=>{if(a()){s();return}c++;const h=e(c);if(i!=null&&c>=i){o();return}setTimeout(d,h)};d()})}function inferFromImplicitShape(a,e){let i=1,s=-1;for(let c=0;c<a.length;++c)if(a[c]>=0)i*=a[c];else if(a[c]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${c}`);s=c}else if(a[c]<0)throw Error(`Shapes can not be < 0. Found ${a[c]} at dim ${c}`);if(s===-1){if(e>0&&e!==i)throw Error(`Size(${e}) must match the product of shape ${a}`);return a}if(i===0)throw Error(`Cannot infer the missing size in [${a}] when there are 0 elements`);if(e%i!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${i}`);const o=a.slice();return o[s]=e/i,o}function parseAxisParam(a,e){const i=e.length;return a=a==null?e.map((s,o)=>o):[].concat(a),assert$1(a.every(s=>s>=-i&&s<i),()=>`All values in axis param must be in range [-${i}, ${i}) but got axis ${a}`),assert$1(a.every(s=>isInt(s)),()=>`All values in axis param must be integers but got axis ${a}`),a.map(s=>s<0?i+s:s)}function squeezeShape(a,e){const i=[],s=[],o=e!=null&&Array.isArray(e)&&e.length===0,c=e==null||o?null:parseAxisParam(e,a).sort();let d=0;for(let h=0;h<a.length;++h){if(c!=null){if(c[d]===h&&a[h]!==1)throw new Error(`Can't squeeze axis ${h} since its dim '${a[h]}' is not 1`);(c[d]==null||c[d]>h)&&a[h]===1&&(i.push(a[h]),s.push(h)),c[d]<=h&&d++}a[h]!==1&&(i.push(a[h]),s.push(h))}return{newShape:i,keptDims:s}}function getTypedArrayFromDType(a,e){let i=null;if(a==null||a==="float32")i=new Float32Array(e);else if(a==="int32")i=new Int32Array(e);else if(a==="bool")i=new Uint8Array(e);else throw new Error(`Unknown data type ${a}`);return i}function getArrayFromDType(a,e){let i=null;if(a==null||a==="float32")i=new Float32Array(e);else if(a==="int32")i=new Int32Array(e);else if(a==="bool")i=new Uint8Array(e);else if(a==="string")i=new Array(e);else throw new Error(`Unknown data type ${a}`);return i}function checkConversionForErrors(a,e){for(let i=0;i<a.length;i++){const s=a[i];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function isValidDtype(a){return a==="bool"||a==="complex64"||a==="float32"||a==="int32"||a==="string"}function hasEncodingLoss(a,e){return!(e==="complex64"||e==="float32"&&a!=="complex64"||e==="int32"&&a!=="float32"&&a!=="complex64"||e==="bool"&&a==="bool")}function isTypedArray(a){return a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array}function bytesPerElement(a){if(a==="float32"||a==="int32")return 4;if(a==="complex64")return 8;if(a==="bool")return 1;throw new Error(`Unknown dtype ${a}`)}function bytesFromStringArray(a){if(a==null)return 0;let e=0;return a.forEach(i=>e+=i.length),e}function isString$1(a){return typeof a=="string"||a instanceof String}function isBoolean$1(a){return typeof a=="boolean"}function isNumber$1(a){return typeof a=="number"}function inferDtype(a){return Array.isArray(a)?inferDtype(a[0]):a instanceof Float32Array?"float32":a instanceof Int32Array||a instanceof Uint8Array?"int32":isNumber$1(a)?"float32":isString$1(a)?"string":isBoolean$1(a)?"bool":"float32"}function isFunction$1(a){return!!(a&&a.constructor&&a.call&&a.apply)}function nearestDivisor(a,e){for(let i=e;i<a;++i)if(a%i===0)return i;return a}function computeStrides(a){const e=a.length;if(e<2)return[];const i=new Array(e-1);i[e-2]=a[e-1];for(let s=e-3;s>=0;--s)i[s]=i[s+1]*a[s+1];return i}function createNestedArray(a,e,i){const s=new Array;if(e.length===1){const o=e[0];for(let c=0;c<o;c++)s[c]=i[a+c]}else{const o=e[0],c=e.slice(1),d=c.reduce((h,g)=>h*g);for(let h=0;h<o;h++)s[h]=createNestedArray(a+h*d,c,i)}return s}function toNestedArray(a,e){if(a.length===0)return e[0];const i=a.reduce((s,o)=>s*o);if(i===0)return[];if(i!==e.length)throw new Error(`[${a}] does not match the input size ${e.length}.`);return createNestedArray(0,a,e)}function makeOnesTypedArray(a,e){const i=makeZerosTypedArray(a,e);for(let s=0;s<i.length;s++)i[s]=1;return i}function makeZerosTypedArray(a,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(a);if(e==="int32")return new Int32Array(a);if(e==="bool")return new Uint8Array(a);throw new Error(`Unknown data type ${e}`)}function makeZerosNestedTypedArray(a,e){const i=a.reduce((s,o)=>s*o,1);if(e==null||e==="float32")return toNestedArray(a,new Float32Array(i));if(e==="int32")return toNestedArray(a,new Int32Array(i));if(e==="bool")return toNestedArray(a,new Uint8Array(i));throw new Error(`Unknown data type ${e}`)}function assertNonNegativeIntegerDimensions(a){a.forEach(e=>{assert$1(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${a}].`)})}function locToIndex(a,e,i){if(e===0)return 0;if(e===1)return a[0];let s=a[a.length-1];for(let o=0;o<a.length-1;++o)s+=i[o]*a[o];return s}function indexToLoc(a,e,i){if(e===0)return[];if(e===1)return[a];const s=new Array(e);for(let o=0;o<s.length-1;++o)s[o]=Math.floor(a/i[o]),a-=s[o]*i[o];return s[s.length-1]=a,s}function isPromise(a){return a&&a.then&&typeof a.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TENSORFLOWJS_FLAGS_PREFIX="tfjsflags";class Environment{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(e,i){this.platform!=null&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${i}.`),this.platformName=e,this.platform=i}registerFlag(e,i,s){if(this.flagRegistry[e]={evaluationFn:i,setHook:s},this.urlFlags[e]!=null){const o=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const i=this.evaluateFlag(e);if(isPromise(i))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=i,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,i){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=i,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(i)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=getQueryParams(this.global.location.search);TENSORFLOWJS_FLAGS_PREFIX in e&&e[TENSORFLOWJS_FLAGS_PREFIX].split(",").forEach(s=>{const[o,c]=s.split(":");this.urlFlags[o]=parseValue(o,c)})}}function getQueryParams(a){const e={};return a.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(i,...s)=>(decodeParam(e,s[0],s[1]),s.join("="))),e}function decodeParam(a,e,i){a[decodeURIComponent(e)]=decodeURIComponent(i||"")}function parseValue(a,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${a}.`)}function env$1(){return ENV$2}let ENV$2=null;function setEnvironmentGlobal(a){ENV$2=a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let globalNameSpace;function getGlobalNamespace(){if(globalNameSpace==null){let a;if(typeof window<"u")a=window;else if(typeof global<"u")a=global;else if(typeof process<"u")a=process;else if(typeof self<"u")a=self;else throw new Error("Could not find a global object");globalNameSpace=a}return globalNameSpace}function getGlobalMap(){const a=getGlobalNamespace();return a._tfGlobals==null&&(a._tfGlobals=new Map),a._tfGlobals}function getGlobal(a,e){const i=getGlobalMap();if(i.has(a))return i.get(a);{const s=e();return i.set(a,s),i.get(a)}}const Abs="Abs",Acos="Acos",Acosh="Acosh",Add$1="Add",AddN="AddN",All="All",Any="Any",ArgMax="ArgMax",ArgMin="ArgMin",Asin="Asin",Asinh="Asinh",Atan="Atan",Atanh="Atanh",Atan2="Atan2",AvgPool="AvgPool",AvgPoolGrad="AvgPoolGrad",AvgPool3D="AvgPool3D",AvgPool3DGrad="AvgPool3DGrad",BatchMatMul="BatchMatMul",BatchToSpaceND="BatchToSpaceND",Bincount="Bincount",BroadcastTo="BroadcastTo",Cast="Cast",Ceil="Ceil",ClipByValue="ClipByValue",Complex$2="Complex",ComplexAbs="ComplexAbs",Concat="Concat",Conv2D$1="Conv2D",Conv2DBackpropFilter="Conv2DBackpropFilter",Conv2DBackpropInput="Conv2DBackpropInput",Conv3D$1="Conv3D",Conv3DBackpropFilterV2="Conv3DBackpropFilterV2",Conv3DBackpropInputV2="Conv3DBackpropInputV2",Cos="Cos",Cosh="Cosh",Cumsum="Cumsum",CropAndResize="CropAndResize",DenseBincount="DenseBincount",DepthToSpace="DepthToSpace",DepthwiseConv2dNative="DepthwiseConv2dNative",DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter",DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput",Diag="Diag",Dilation2D="Dilation2D",Dilation2DBackpropInput="Dilation2DBackpropInput",Dilation2DBackpropFilter="Dilation2DBackpropFilter",RealDiv="RealDiv",Elu$1="Elu",EluGrad="EluGrad",Erf="Erf",Equal="Equal",Exp="Exp",ExpandDims="ExpandDims",Expm1="Expm1",FFT="FFT",Fill="Fill",FlipLeftRight="FlipLeftRight",Floor="Floor",FloorDiv="FloorDiv",FusedBatchNorm="FusedBatchNorm",GatherV2="GatherV2",GatherNd="GatherNd",Greater="Greater",GreaterEqual="GreaterEqual",Identity$1="Identity",IFFT="IFFT",Imag="Imag",IsFinite="IsFinite",IsInf="IsInf",IsNan="IsNan",LeakyRelu="LeakyRelu",Less="Less",LessEqual="LessEqual",LinSpace="LinSpace",Log="Log",Log1p="Log1p",LogicalAnd="LogicalAnd",LogicalNot="LogicalNot",LogicalOr="LogicalOr",LogSoftmax$1="LogSoftmax",LRN="LRN",LRNGrad="LRNGrad",Max="Max",Maximum$1="Maximum",MaxPool="MaxPool",MaxPoolGrad="MaxPoolGrad",MaxPool3D="MaxPool3D",MaxPool3DGrad="MaxPool3DGrad",MaxPoolWithArgmax="MaxPoolWithArgmax",Mean="Mean",Min="Min",Minimum$1="Minimum",MirrorPad="MirrorPad",Mod="Mod",Multinomial="Multinomial",Multiply$1="Multiply",Neg="Neg",NotEqual="NotEqual",NonMaxSuppressionV3="NonMaxSuppressionV3",NonMaxSuppressionV4="NonMaxSuppressionV4",NonMaxSuppressionV5="NonMaxSuppressionV5",OnesLike="OnesLike",OneHot="OneHot",Pack="Pack",PadV2="PadV2",Pool="Pool",Pow="Pow",Prelu="Prelu",Prod="Prod",Range="Range",Real="Real",Reciprocal="Reciprocal",Relu$1="Relu",Reshape$1="Reshape",ResizeNearestNeighbor="ResizeNearestNeighbor",ResizeNearestNeighborGrad="ResizeNearestNeighborGrad",ResizeBilinear="ResizeBilinear",ResizeBilinearGrad="ResizeBilinearGrad",Relu6$1="Relu6",Reverse="Reverse",Round="Round",Rsqrt="Rsqrt",ScatterNd="ScatterNd",Select="Select",Selu$1="Selu",Slice="Slice",Sin="Sin",Sinh="Sinh",Sign="Sign",Sigmoid$1="Sigmoid",Softplus$1="Softplus",Sqrt="Sqrt",Sum="Sum",SpaceToBatchND="SpaceToBatchND",SplitV="SplitV",Softmax$2="Softmax",SquaredDifference="SquaredDifference",Square="Square",Sub="Sub",SparseToDense="SparseToDense",StridedSlice="StridedSlice",Tan="Tan",Tanh$1="Tanh",Tile="Tile",TopK="TopK",Transpose="Transpose",Unique="Unique",Unpack="Unpack",UnsortedSegmentSum="UnsortedSegmentSum",ZerosLike="ZerosLike",Step="Step",FromPixels="FromPixels",RotateWithOffset="RotateWithOffset",_FusedMatMul="_FusedMatMul",FusedConv2D="FusedConv2D",FusedDepthwiseConv2D="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kernelRegistry=getGlobal("kernelRegistry",()=>new Map),gradRegistry=getGlobal("gradRegistry",()=>new Map);function getKernel(a,e){const i=makeKey(a,e);return kernelRegistry.get(i)}function getGradient(a){return gradRegistry.get(a)}function getKernelsForBackend(a){const e=kernelRegistry.entries(),i=[];for(;;){const{done:s,value:o}=e.next();if(s)break;const[c,d]=o,[h]=c.split("_");h===a&&i.push(d)}return i}function registerKernel(a){const{kernelName:e,backendName:i}=a,s=makeKey(e,i);kernelRegistry.has(s)&&console.warn(`The kernel '${e}' for backend '${i}' is already registered`),kernelRegistry.set(s,a)}function registerGradient(a){const{kernelName:e}=a;gradRegistry.has(e)&&env$1().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${e}'`),gradRegistry.set(e,a)}function unregisterKernel(a,e){const i=makeKey(a,e);if(!kernelRegistry.has(i))throw new Error(`The kernel '${a}' for backend '${e}' is not registered`);kernelRegistry.delete(i)}function unregisterGradient(a){if(!gradRegistry.has(a))throw new Error(`The gradient '${a}' for backend is not registered`);gradRegistry.delete(a)}function copyRegisteredKernels(a,e){getKernelsForBackend(a).forEach(s=>{const o=Object.assign({},s,{backendName:e});registerKernel(o)})}function makeKey(a,e){return`${e}_${a}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createScalarValue(a,e){return e==="string"?encodeString(a):toTypedArray([a],e)}function noConversionNeeded(a,e){return a instanceof Float32Array&&e==="float32"||a instanceof Int32Array&&e==="int32"||a instanceof Uint8Array&&e==="bool"}function toTypedArray(a,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(a)&&(a=flatten$4(a)),env$1().getBool("DEBUG")&&checkConversionForErrors(a,e),noConversionNeeded(a,e))return a;if(e==null||e==="float32"||e==="complex64")return new Float32Array(a);if(e==="int32")return new Int32Array(a);if(e==="bool"){const i=new Uint8Array(a.length);for(let s=0;s<i.length;++s)Math.round(a[s])!==0&&(i[s]=1);return i}else throw new Error(`Unknown data type ${e}`)}function now(){return env$1().platform.now()}function fetch$1(a,e){return env$1().platform.fetch(a,e)}function encodeString(a,e="utf-8"){return e=e||"utf-8",env$1().platform.encode(a,e)}function decodeString(a,e="utf-8"){return e=e||"utf-8",env$1().platform.decode(a,e)}const util$5=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual,assert:assert$1,assertNonNegativeIntegerDimensions,assertNonNull,assertShapesMatch,bytesFromStringArray,bytesPerElement,checkConversionForErrors,clamp:clamp$1,computeStrides,createScalarValue,createShuffledIndices,decodeString,distSquared,encodeString,fetch:fetch$1,flatten:flatten$4,getArrayFromDType,getTypedArrayFromDType,hasEncodingLoss,indexToLoc,inferDtype,inferFromImplicitShape,isBoolean:isBoolean$1,isFunction:isFunction$1,isInt,isNumber:isNumber$1,isPromise,isScalarShape,isString:isString$1,isTypedArray,isValidDtype,locToIndex,makeOnesTypedArray,makeZerosNestedTypedArray,makeZerosTypedArray,nearestDivisor,nearestLargerEven,now,parseAxisParam,randUniform,repeatedTry,rightPad,shuffle,shuffleCombo,sizeFromShape,sizeToSquarishShape,squeezeShape,sum:sum$4,tanh:tanh$4,toNestedArray,toTypedArray},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Profiler{constructor(e,i){this.backendTimer=e,this.logger=i,i==null&&(this.logger=new Logger)}profileKernel(e,i,s){let o;const c=()=>{o=s()};let d;const h=now();if(this.backendTimer.timerAvailable()?d=this.backendTimer.time(c):(c(),o.map(_=>_.dataSync()),d=Promise.resolve({kernelMs:now()-h})),env$1().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let _=0;_<o.length;_++){const b=o[_];b.data().then($=>{checkComputationForErrors($,b.dtype,e)})}return{kernelName:e,outputs:o,inputs:i,timeMs:d.then(_=>_.kernelMs),extraInfo:d.then(_=>_.getExtraProfileInfo!=null?_.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:i,outputs:s,timeMs:o,inputs:c,extraInfo:d}=e;s.forEach(h=>{Promise.all([h.data(),o,d]).then(g=>{this.logger.logKernelProfile(i,h,g[0],g[1],c,g[2])})})}}function checkComputationForErrors(a,e,i){if(e!=="float32")return!1;for(let s=0;s<a.length;s++){const o=a[s];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${i}'`),!0}return!1}class Logger{logKernelProfile(e,i,s,o,c,d){const h=typeof o=="number"?rightPad(`${o}ms`,9):o.error,g=rightPad(e,25),_=i.rank,b=i.size,$=rightPad(i.shape.toString(),14);let j="";for(const _e in c){const tt=c[_e];if(tt!=null){const et=tt.shape||i.shape,nt=et.length;j+=`${_e}: ${nt}D ${nt>0?et:""} `}}console.log(`%c${g}	%c${h}	%c${_}D ${$}	%c${b}	%c${j}	%c${d}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getFilteredNodesXToY(a,e,i){const s={},o={};for(let g=0;g<e.length;g++)s[e[g].id]=!0;for(let g=0;g<a.length;g++){const _=a[g],b=_.inputs;for(const $ in b){const j=b[$];let _e=!1;for(let tt=0;tt<e.length;tt++)if(s[j.id]){_.outputs.forEach(et=>s[et.id]=!0),_e=!0,o[_.id]=!0;break}if(_e)break}}const c={};c[i.id]=!0;const d={};for(let g=a.length-1;g>=0;g--){const _=a[g],b=_.inputs;for(let $=0;$<_.outputs.length;$++)if(c[_.outputs[$].id]){for(const j in b)c[b[j].id]=!0,d[_.id]=!0;break}}const h=[];for(let g=0;g<a.length;g++){const _=a[g];if(o[_.id]&&d[_.id]){const b={};for(const j in _.inputs){const _e=_.inputs[j];s[_e.id]&&(b[j]=_e)}const $=Object.assign({},_);$.inputs=b,$.outputs=_.outputs,h.push($)}}return h}function backpropagateGradients(a,e,i,s){for(let o=e.length-1;o>=0;o--){const c=e[o],d=[];if(c.outputs.forEach(g=>{const _=a[g.id];_!=null?d.push(_):d.push(null)}),c.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${c.kernelName}.`);const h=c.gradient(d);for(const g in c.inputs){if(!(g in h))throw new Error(`Cannot backprop through input ${g}. Available gradients found: ${Object.keys(h)}.`);const _=i(()=>h[g]());if(_.dtype!=="float32")throw new Error(`Error in gradient for op ${c.kernelName}. The gradient of input ${g} must have 'float32' dtype, but has '${_.dtype}'`);const b=c.inputs[g];if(!arraysEqual(_.shape,b.shape))throw new Error(`Error in gradient for op ${c.kernelName}. The gradient of input '${g}' has shape '${_.shape}', which does not match the shape of the input '${b.shape}'`);if(a[b.id]==null)a[b.id]=_;else{const $=a[b.id];a[b.id]=s($,_),$.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FORMAT_LIMIT_NUM_VALS=20,FORMAT_NUM_FIRST_LAST_VALS=3,FORMAT_NUM_SIG_DIGITS=7;function tensorToString(a,e,i,s){const o=computeStrides(e),c=computeMaxSizePerColumn(a,e,i,o),d=e.length,h=subTensorToString(a,e,i,o,c),g=["Tensor"];return s&&(g.push(`  dtype: ${i}`),g.push(`  rank: ${d}`),g.push(`  shape: [${e}]`),g.push("  values:")),g.push(h.map(_=>"    "+_).join(`
`)),g.join(`
`)}function computeMaxSizePerColumn(a,e,i,s){const o=sizeFromShape(e),c=s[s.length-1],d=new Array(c).fill(0),h=e.length,g=i==="complex64"?createComplexTuples(a):a;if(h>1)for(let _=0;_<o/c;_++){const b=_*c;for(let $=0;$<c;$++)d[$]=Math.max(d[$],valToString(g[b+$],0,i).length)}return d}function valToString(a,e,i){let s;return Array.isArray(a)?s=`${parseFloat(a[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ${parseFloat(a[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`:isString$1(a)?s=`'${a}'`:i==="bool"?s=boolNumToString(a):s=parseFloat(a.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(),rightPad(s,e)}function boolNumToString(a){return a===0?"false":"true"}function subTensorToString(a,e,i,s,o,c=!0){const d=i==="complex64"?2:1,h=e[0],g=e.length;if(g===0){if(i==="complex64"){const et=createComplexTuples(a);return[valToString(et[0],0,i)]}return i==="bool"?[boolNumToString(a[0])]:[a[0].toString()]}if(g===1){if(h>FORMAT_LIMIT_NUM_VALS){const nt=FORMAT_NUM_FIRST_LAST_VALS*d;let rt=Array.from(a.slice(0,nt)),it=Array.from(a.slice((h-FORMAT_NUM_FIRST_LAST_VALS)*d,h*d));return i==="complex64"&&(rt=createComplexTuples(rt),it=createComplexTuples(it)),["["+rt.map((at,st)=>valToString(at,o[st],i)).join(", ")+", ..., "+it.map((at,st)=>valToString(at,o[h-FORMAT_NUM_FIRST_LAST_VALS+st],i)).join(", ")+"]"]}return["["+(i==="complex64"?createComplexTuples(a):Array.from(a)).map((nt,rt)=>valToString(nt,o[rt],i)).join(", ")+"]"]}const _=e.slice(1),b=s.slice(1),$=s[0]*d,j=[];if(h>FORMAT_LIMIT_NUM_VALS){for(let et=0;et<FORMAT_NUM_FIRST_LAST_VALS;et++){const nt=et*$,rt=nt+$;j.push(...subTensorToString(a.slice(nt,rt),_,i,b,o,!1))}j.push("...");for(let et=h-FORMAT_NUM_FIRST_LAST_VALS;et<h;et++){const nt=et*$,rt=nt+$;j.push(...subTensorToString(a.slice(nt,rt),_,i,b,o,et===h-1))}}else for(let et=0;et<h;et++){const nt=et*$,rt=nt+$;j.push(...subTensorToString(a.slice(nt,rt),_,i,b,o,et===h-1))}const _e=g===2?",":"";j[0]="["+j[0]+_e;for(let et=1;et<j.length-1;et++)j[et]=" "+j[et]+_e;let tt=`,
`;for(let et=2;et<g;et++)tt+=`
`;return j[j.length-1]=" "+j[j.length-1]+"]"+(c?"":tt),j}function createComplexTuples(a){const e=[];for(let i=0;i<a.length;i+=2)e.push([a[i],a[i+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TensorBuffer{constructor(e,i,s){if(this.dtype=i,this.shape=e.slice(),this.size=sizeFromShape(e),s!=null){const o=s.length;assert$1(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(i==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||getArrayFromDType(i,this.size),this.strides=computeStrides(e)}set(e,...i){i.length===0&&(i=[0]),assert$1(i.length===this.rank,()=>`The number of provided coordinates (${i.length}) must match the rank (${this.rank})`);const s=this.locToIndex(i);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let i=0;for(const o of e){if(o<0||o>=this.shape[i]){const c=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(c)}i++}let s=e[e.length-1];for(let o=0;o<e.length-1;++o)s+=this.strides[o]*e[o];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let i=e[e.length-1];for(let s=0;s<e.length-1;++s)i+=this.strides[s]*e[s];return i}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const i=new Array(this.shape.length);for(let s=0;s<i.length-1;++s)i[s]=Math.floor(e/this.strides[s]),e-=i[s]*this.strides[s];return i[i.length-1]=e,i}get rank(){return this.shape.length}toTensor(){return trackerFn().makeTensor(this.values,this.shape,this.dtype)}}let trackerFn=null,opHandler$1=null;function setTensorTracker(a){trackerFn=a}function setOpHandler(a){opHandler$1=a}class Tensor{constructor(e,i,s,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=i||"float32",this.size=sizeFromShape(e),this.strides=computeStrides(e),this.dataId=s,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return opHandler$1.buffer(this.shape,this.dtype,e)}bufferSync(){return opHandler$1.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return toNestedArray(this.shape,e)}arraySync(){return toNestedArray(this.shape,this.dataSync())}async data(){this.throwIfDisposed();const e=trackerFn().read(this.dataId);if(this.dtype==="string"){const i=await e;try{return i.map(s=>decodeString(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=trackerFn().readSync(this.dataId);if(this.dtype==="string")try{return e.map(i=>decodeString(i))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await trackerFn().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(trackerFn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return opHandler$1.print(this,e)}clone(){return this.throwIfDisposed(),opHandler$1.clone(this)}toString(e=!1){const i=this.dataSync();return tensorToString(i,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),opHandler$1.cast(this,e)}variable(e=!0,i,s){return this.throwIfDisposed(),trackerFn().makeVariable(this,e,i,s)}}Object.defineProperty(Tensor,Symbol.hasInstance,{value:a=>!!a&&a.data!=null&&a.dataSync!=null&&a.throwIfDisposed!=null});function getGlobalTensorClass(){return getGlobal("Tensor",()=>Tensor)}getGlobalTensorClass();class Variable extends Tensor{constructor(e,i,s,o){super(e.shape,e.dtype,e.dataId,o),this.trainable=i,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!arraysEqual(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);trackerFn().disposeTensor(this),this.dataId=e.dataId,trackerFn().incRef(this,null)}dispose(){trackerFn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Variable,Symbol.hasInstance,{value:a=>a instanceof Tensor&&a.assign!=null&&a.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Rank;(function(a){a.R0="R0",a.R1="R1",a.R2="R2",a.R3="R3",a.R4="R4",a.R5="R5",a.R6="R6"})(Rank||(Rank={}));var UpcastInt32AndMap;(function(a){a.float32="float32",a.int32="int32",a.bool="int32",a.complex64="complex64"})(UpcastInt32AndMap||(UpcastInt32AndMap={}));var UpcastBoolAndMap;(function(a){a.float32="float32",a.int32="int32",a.bool="bool",a.complex64="complex64"})(UpcastBoolAndMap||(UpcastBoolAndMap={}));var UpcastFloat32AndMap;(function(a){a.float32="float32",a.int32="float32",a.bool="float32",a.complex64="complex64"})(UpcastFloat32AndMap||(UpcastFloat32AndMap={}));var UpcastComplex64AndMap;(function(a){a.float32="complex64",a.int32="complex64",a.bool="complex64",a.complex64="complex64"})(UpcastComplex64AndMap||(UpcastComplex64AndMap={}));const upcastTypeMap={float32:UpcastFloat32AndMap,int32:UpcastInt32AndMap,bool:UpcastBoolAndMap,complex64:UpcastComplex64AndMap};function upcastType(a,e){if(a==="string"||e==="string"){if(a==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${a} with ${e}`)}return upcastTypeMap[a][e]}function sumOutType(a){return upcastType(a,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTypesMatch(a,e){if(a.dtype===e.dtype)return[a,e];const i=upcastType(a.dtype,e.dtype);return[a.cast(i),e.cast(i)]}function assertTypesMatch(a,e){assert$1(a.dtype===e.dtype,()=>`The dtypes of the first(${a.dtype}) and second(${e.dtype}) input must match`)}function isTensorInList(a,e){return e.some(i=>i.id===a.id)}function getTensorsInContainer(a){const e=[];return walkTensorContainer(a,e,new Set),e}function walkTensorContainer(a,e,i){if(a==null)return;if(a instanceof Tensor){e.push(a);return}if(!isIterable$1(a))return;const s=a;for(const o in s){const c=s[o];i.has(c)||(i.add(c),walkTensorContainer(c,e,i))}}function isIterable$1(a){return Array.isArray(a)||typeof a=="object"}const tensor_util=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch,getTensorsInContainer,isTensorInList,makeTypesMatch},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isRegisteredKernelInvocation(a){return a.kernelName!=null}class EngineState{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Engine{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const s=e[i];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:i}=this.initializeBackendsAndReturnBest();if(i)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:i}=this.initializeBackend(e);if(i)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,i,s=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:i,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:i,asyncInit:s}=this.initializeBackend(e);if(!(s?await i:i))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),!0}setupRegisteredKernels(){getKernelsForBackend(this.backendName).forEach(i=>{i.setupFunc!=null&&i.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){getKernelsForBackend(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const i=this.registryFactory[e];if(i==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=i.factory();if(s&&!(s instanceof KernelBackend)&&typeof s.then=="function"){const o=++this.pendingBackendInitId,c=s.then(d=>o<this.pendingBackendInitId?!1:(this.registry[e]=d,this.pendingBackendInit=null,!0)).catch(d=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(d.stack||d.message)),!1));return this.pendingBackendInit=c,{success:c,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return console.warn(`Initialization of backend ${e} failed`),console.warn(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,i)=>this.registryFactory[i].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let i=0;i<e.length;i++){const s=e[i],{success:o,asyncInit:c}=this.initializeBackend(s);if(c||o)return{name:s,asyncInit:c}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,i){const s=this.state.tensorInfo.get(i),o=s.backend,c=this.readSync(i),d=o.refCount(i);o.disposeData(i,!0),s.backend=e,e.move(i,c,s.shape,s.dtype,d),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,i){let s=null;if(i==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");i=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof i!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let o;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(o),()=>(o=i(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,i,s){e();try{const o=s();return i(),o}catch(o){throw i(),o}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(e){const i=ENGINE.runKernel(Identity$1,{x:e}),s={x:e},o=d=>({x:()=>{const h="float32",g={x:d},_={dtype:h};return ENGINE.runKernel(Cast,g,_)}}),c=[];return this.addTapeNode(this.state.activeScope.name,s,[i],o,c,{}),i}runKernel(e,i,s){if(!(getKernel(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:i,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,i,s){const o=this.backend.numDataIds();let c=0;s.forEach(g=>{c+=g.dtype==="complex64"?3:1});const d=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],h=o-i-c-d;if(h>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${h} data ids) after running '${e}'`)}runKernelFunc(e){let i,s=[];const o=this.isTapeOn(),c=this.state.numBytes,d=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let h;this.backendName==null&&this.backend;let g;const _=isRegisteredKernelInvocation(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(e)){const{kernelName:tt,inputs:et,attrs:nt}=e;this.backendName==null&&this.backend;const rt=getKernel(tt,this.backendName);assert$1(rt!=null,()=>`Cannot find registered kernel '${tt}' for backend '${this.backendName}'`),h=()=>{const it=this.backend.numDataIds();g=rt.kernelFunc({inputs:et,attrs:nt,backend:this.backend});const at=Array.isArray(g)?g:[g];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(tt,it,at);const st=at.map(ot=>{if(ot.rank!=null)return ot;const{dataId:ct,shape:lt,dtype:dt}=ot;return this.makeTensorFromDataId(ct,lt,dt)});if(o){const ot=this.getTensorsForGradient(tt,et,st);s=this.saveTensorsForBackwardMode(ot)}return st}}else{const{forwardFunc:tt}=e,et=nt=>{o&&(s=nt.map(rt=>this.keep(this.clone(rt))))};h=()=>{const nt=this.backend.numDataIds();g=this.tidy(()=>tt(this.backend,et));const rt=Array.isArray(g)?g:[g];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(_,nt,rt),rt}}const{inputs:b,attrs:$}=e,j=isRegisteredKernelInvocation(e)?null:e.backwardsFunc;let _e;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?i=h():(_e=this.profiler.profileKernel(_,b,()=>h()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(_e),i=_e.outputs)}),o&&this.addTapeNode(_,b,i,j,s,$),this.state.profiling&&this.state.activeProfile.kernels.push({name:_,bytesAdded:this.state.numBytes-c,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-d,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(b).map(tt=>b[tt]!=null?b[tt].shape:null),outputShapes:i.map(tt=>tt.shape),kernelTimeMs:_e.timeMs,extraInfo:_e.extraInfo}),Array.isArray(g)?i:i[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,i,s){const o=getGradient(e);if(o!=null){const c=o.inputsToSave||[],d=o.outputsToSave||[];let h;o.saveAllInputs?(assert$1(Array.isArray(i),()=>"saveAllInputs is true, expected inputs to be an array."),h=Object.keys(i).map(_=>i[_])):h=c.map(_=>i[_]);const g=s.filter((_,b)=>d[b]);return h.concat(g)}return[]}makeTensor(e,i,s,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",o=o||this.backend;let c=e;s==="string"&&isString$1(e[0])&&(c=e.map(g=>encodeString(g)));const d=o.write(c,i,s),h=new Tensor(i,s,d,this.nextTensorId());if(this.trackTensor(h,o),s==="string"){const g=this.state.tensorInfo.get(d),_=bytesFromStringArray(c);this.state.numBytes+=_-g.bytes,g.bytes=_}return h}makeTensorFromDataId(e,i,s,o){s=s||"float32";const c=new Tensor(i,s,e,this.nextTensorId());return this.trackTensor(c,o),c}makeVariable(e,i=!0,s,o){s=s||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));const c=new Variable(e,i,s,this.nextTensorId());if(this.state.registeredVariables[c.name]!=null)throw new Error(`Variable with name ${c.name} was already registered`);return this.state.registeredVariables[c.name]=c,this.incRef(c,this.backend),c}trackTensor(e,i){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*bytesPerElement(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:i||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Variable||this.track(e)}incRef(e,i){this.trackTensor(e,i),this.backend.incRef(e.dataId)}removeDataId(e,i){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===i&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const i=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=i.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*bytesPerElement(e.dtype);this.state.numBytes-=s}i.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,i.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const i=this.state.registeredVariables[e];this.disposeVariable(i)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const i=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-i,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,i,s,o,c,d){const h={id:this.state.nextTapeNodeId++,kernelName:e,inputs:i,outputs:s,saved:c},g=getGradient(e);g!=null&&(o=g.gradFunc),o!=null&&(h.gradient=_=>(_=_.map((b,$)=>{if(b==null){const j=s[$],_e=makeZerosTypedArray(j.size,j.dtype);return this.makeTensor(_e,j.shape,j.dtype)}return b}),o(_.length>1?_:_[0],c,d))),this.state.activeTape.push(h)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const i={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(i.name=e),this.state.scopeStack.push(i),this.state.activeScope=i}endScope(e){const i=getTensorsInContainer(e),s=new Set(i.map(c=>c.id));for(let c=0;c<this.state.activeScope.track.length;c++){const d=this.state.activeScope.track[c];!d.kept&&!s.has(d.id)&&d.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],i.forEach(c=>{!c.kept&&c.scopeId===o.id&&this.track(c)})}gradients(e,i,s,o=!1){if(assert$1(i.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const c=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));assert$1(c instanceof Tensor,()=>"The result y returned by f() must be a tensor.");const d=getFilteredNodesXToY(this.state.activeTape,i,c);if(!o&&d.length===0&&i.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const h={};h[c.id]=s??ones$2(c.shape),backpropagateGradients(h,d,_=>this.tidy(_),add$5);const g=i.map(_=>h[_.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(_=>{for(const b of _.saved)b.dispose()}),this.state.activeTape=null),{value:c,grads:g}})}customGrad(e){return assert$1(isFunction$1(e),()=>"The f passed in customGrad(f) must be a function."),(...i)=>{assert$1(i.every(h=>h instanceof Tensor),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const o={};i.forEach((h,g)=>{o[g]=h});const c=(h,g)=>(s=e(...i,g),assert$1(s.value instanceof Tensor,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),assert$1(isFunction$1(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),d=(h,g)=>{const _=s.gradFunc(h,g),b=Array.isArray(_)?_:[_];assert$1(b.length===i.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),assert$1(b.every(j=>j instanceof Tensor),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const $={};return b.forEach((j,_e)=>{$[_e]=()=>j}),$};return this.runKernelFunc({forwardFunc:c,backwardsFunc:d,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const i=now(),s=await this.backend.time(e);return s.wallMs=now()-i,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Engine.nextTensorId=0;Engine.nextVariableId=0;function ones$2(a){const e=makeOnesTypedArray(sizeFromShape(a),"float32");return ENGINE.makeTensor(e,a,"float32")}function getOrMakeEngine(){const a=getGlobalNamespace();if(a._tfengine==null){const e=new Environment(a);a._tfengine=new Engine(e)}return setEnvironmentGlobal(a._tfengine.ENV),setTensorTracker(()=>a._tfengine),a._tfengine}const ENGINE=getOrMakeEngine();function add$5(a,e){const i={a,b:e};return ENGINE.runKernel(Add$1,i)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _isNavigatorDefined(){return typeof navigator<"u"&&navigator!=null}function isMobile(){if(_isNavigatorDefined()){const a=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}return!1}function isBrowser(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const device_util=Object.freeze(Object.defineProperty({__proto__:null,isBrowser,isMobile},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ENV$1=env$1();ENV$1.registerFlag("DEBUG",()=>!1,a=>{a&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ENV$1.registerFlag("IS_BROWSER",()=>isBrowser());ENV$1.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ENV$1.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ENV$1.registerFlag("PROD",()=>!1);ENV$1.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ENV$1.getBool("DEBUG"));ENV$1.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ENV$1.registerFlag("IS_TEST",()=>!1);ENV$1.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function inferShape(a,e){let i=a;if(isTypedArray(a))return e==="string"?[]:[a.length];if(!Array.isArray(a))return[];const s=[];for(;Array.isArray(i)||isTypedArray(i)&&e!=="string";)s.push(i.length),i=i[0];return Array.isArray(a)&&env$1().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&deepAssertShapeConsistency(a,s,[]),s}function deepAssertShapeConsistency(a,e,i){if(i=i||[],!Array.isArray(a)&&!isTypedArray(a)){assert$1(e.length===0,()=>`Element arr[${i.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}assert$1(e.length>0,()=>`Element arr[${i.join("][")}] should be a primitive, but is an array of ${a.length} elements`),assert$1(a.length===e[0],()=>`Element arr[${i.join("][")}] should have ${e[0]} elements, but has ${a.length} elements`);const s=e.slice(1);for(let o=0;o<a.length;++o)deepAssertShapeConsistency(a[o],s,i.concat(o))}function assertDtype(a,e,i,s){if(a!=="string_or_numeric"){if(a==null)throw new Error("Expected dtype cannot be null.");if(a!=="numeric"&&a!==e||a==="numeric"&&e==="string")throw new Error(`Argument '${i}' passed to '${s}' must be ${a} tensor, but got ${e} tensor`)}}function convertToTensor(a,e,i,s="numeric"){if(a instanceof Tensor)return assertDtype(s,a.dtype,e,i),a;let o=inferDtype(a);if(o!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(o=s),assertDtype(s,o,e,i),a==null||!isTypedArray(a)&&!Array.isArray(a)&&typeof a!="number"&&typeof a!="boolean"&&typeof a!="string"){const g=a==null?"null":a.constructor.name;throw new Error(`Argument '${e}' passed to '${i}' must be a Tensor or TensorLike, but got '${g}'`)}const c=inferShape(a,o);!isTypedArray(a)&&!Array.isArray(a)&&(a=[a]);const h=o!=="string"?toTypedArray(a,o):flatten$4(a,[],!0);return ENGINE.makeTensor(h,c,o)}function convertToTensorArray(a,e,i,s="numeric"){if(!Array.isArray(a))throw new Error(`Argument ${e} passed to ${i} must be a \`Tensor[]\` or \`TensorLike[]\``);return a.map((c,d)=>convertToTensor(c,`${e}[${d}]`,i,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP_SCOPE_SUFFIX="__op";function op(a){const e=Object.keys(a);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let i=e[0];const s=a[i];i.endsWith("_")&&(i=i.substring(0,i.length-1)),i=i+OP_SCOPE_SUFFIX;const o=(...c)=>{ENGINE.startScope(i);try{const d=s(...c);return isPromise(d)&&console.error("Cannot return a Promise inside of tidy."),ENGINE.endScope(d),d}catch(d){throw ENGINE.endScope(null),d}};return Object.defineProperty(o,"name",{value:i,configurable:!0}),o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex_(a,e){const i=convertToTensor(a,"real","complex"),s=convertToTensor(e,"imag","complex");assertShapesMatch(i.shape,s.shape,`real and imag shapes, ${i.shape} and ${s.shape}, must match in call to tf.complex().`);const o={real:i,imag:s};return ENGINE.runKernel(Complex$2,o)}const complex$4=op({complex_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTensor(a,e,i,s){if(s==null&&(s=inferDtype(a)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!isTypedArray(a)&&!Array.isArray(a)&&typeof a!="number"&&typeof a!="boolean"&&typeof a!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){assertNonNegativeIntegerDimensions(e);const o=sizeFromShape(e),c=sizeFromShape(i);assert$1(o===c,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${c}`);for(let d=0;d<i.length;++d){const h=i[d],g=d===i.length-1?h!==sizeFromShape(e.slice(d)):!0;assert$1(i[d]===e[d]||!g,()=>`Error creating a new Tensor. Inferred shape (${i}) does not match the provided shape (${e}). `)}}return!isTypedArray(a)&&!Array.isArray(a)&&(a=[a]),e=e||i,a=s!=="string"?toTypedArray(a,s):flatten$4(a,[],!0),ENGINE.makeTensor(a,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor(a,e,i){const s=inferShape(a,i);return makeTensor(a,e,s,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DTYPE_VALUE_SIZE_MAP={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NUM_BYTES_STRING_LENGTH=4;async function encodeWeights(a,e){const i=[],s=[],o=Array.isArray(a)?a.map(d=>d.name):Object.keys(a);for(let d=0;d<o.length;++d){const h=o[d],g=Array.isArray(a)?a[d].tensor:a[h];if(g.dtype!=="float32"&&g.dtype!=="int32"&&g.dtype!=="bool"&&g.dtype!=="string"&&g.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${h}': ${g.dtype}`);const _={name:h,shape:g.shape,dtype:g.dtype};if(g.dtype==="string"){const b=new Promise(async $=>{const j=await g.bytes(),_e=j.reduce((nt,rt)=>nt+rt.length,0)+NUM_BYTES_STRING_LENGTH*j.length,tt=new Uint8Array(_e);let et=0;for(let nt=0;nt<j.length;nt++){const rt=j[nt],it=new Uint8Array(new Uint32Array([rt.length]).buffer);tt.set(it,et),et+=NUM_BYTES_STRING_LENGTH,tt.set(rt,et),et+=rt.length}$(tt)});s.push(b)}else s.push(g.data());e!=null&&(_.group=e),i.push(_)}const c=await Promise.all(s);return{data:concatenateTypedArrays(c),specs:i}}function decodeWeights(a,e){const i={};let s,o=0;for(const c of e){const d=c.name,h=c.dtype,g=c.shape,_=sizeFromShape(g);let b;if("quantization"in c){const $=c.quantization;if($.dtype==="uint8"||$.dtype==="uint16"){if(!("min"in $&&"scale"in $))throw new Error(`Weight ${c.name} with quantization ${$.dtype} doesn't have corresponding metadata min and scale.`)}else if($.dtype==="float16"){if(h!=="float32")throw new Error(`Weight ${c.name} is quantized with ${$.dtype} which only supports weights of type float32 not ${h}.`)}else throw new Error(`Weight ${c.name} has unknown quantization dtype ${$.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const j=DTYPE_VALUE_SIZE_MAP[$.dtype],_e=a.slice(o,o+_*j),tt=$.dtype==="uint8"?new Uint8Array(_e):new Uint16Array(_e);if(h==="float32")if($.dtype==="uint8"||$.dtype==="uint16"){b=new Float32Array(tt.length);for(let et=0;et<tt.length;et++){const nt=tt[et];b[et]=nt*$.scale+$.min}}else if($.dtype==="float16")s===void 0&&(s=getFloat16Decoder()),b=s(tt);else throw new Error(`Unsupported quantization type ${$.dtype} for weight type float32.`);else if(h==="int32"){if($.dtype!=="uint8"&&$.dtype!=="uint16")throw new Error(`Unsupported quantization type ${$.dtype} for weight type int32.`);b=new Int32Array(tt.length);for(let et=0;et<tt.length;et++){const nt=tt[et];b[et]=Math.round(nt*$.scale+$.min)}}else throw new Error(`Unsupported dtype in weight '${d}': ${h}`);o+=_*j}else if(h==="string"){const $=sizeFromShape(c.shape);b=[];for(let j=0;j<$;j++){const _e=new Uint32Array(a.slice(o,o+NUM_BYTES_STRING_LENGTH))[0];o+=NUM_BYTES_STRING_LENGTH;const tt=new Uint8Array(a.slice(o,o+_e));b.push(tt),o+=_e}}else{const $=DTYPE_VALUE_SIZE_MAP[h],j=a.slice(o,o+_*$);if(h==="float32")b=new Float32Array(j);else if(h==="int32")b=new Int32Array(j);else if(h==="bool")b=new Uint8Array(j);else if(h==="complex64"){b=new Float32Array(j);const _e=new Float32Array(b.length/2),tt=new Float32Array(b.length/2);for(let rt=0;rt<_e.length;rt++)_e[rt]=b[rt*2],tt[rt]=b[rt*2+1];const et=tensor(_e,g,"float32"),nt=tensor(tt,g,"float32");i[d]=complex$4(et,nt),et.dispose(),nt.dispose()}else throw new Error(`Unsupported dtype in weight '${d}': ${h}`);o+=_*$}h!=="complex64"&&(i[d]=tensor(b,g,h))}return i}function concatenateTypedArrays(a){if(a===null)throw new Error(`Invalid input value: ${JSON.stringify(a)}`);let e=0;const i=[];a.forEach(c=>{if(e+=c.byteLength,i.push(c.byteLength===c.buffer.byteLength?c:new c.constructor(c)),!(c instanceof Float32Array||c instanceof Int32Array||c instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${c.constructor.name}`)});const s=new Uint8Array(e);let o=0;return i.forEach(c=>{s.set(new Uint8Array(c.buffer),o),o+=c.byteLength}),s.buffer}const useNodeBuffer=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function stringByteLength(a){return useNodeBuffer?Buffer.byteLength(a):new Blob([a]).size}function arrayBufferToBase64String(a){if(useNodeBuffer)return Buffer.from(a).toString("base64");const e=new Uint8Array(a);let i="";for(let s=0,o=e.length;s<o;s++)i+=String.fromCharCode(e[s]);return btoa(i)}function base64StringToArrayBuffer(a){if(useNodeBuffer){const s=Buffer.from(a,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(a),i=new Uint8Array(e.length);for(let s=0;s<e.length;++s)i.set([e.charCodeAt(s)],s);return i.buffer}function concatenateArrayBuffers$1(a){if(a.length===1)return a[0];let e=0;a.forEach(o=>{e+=o.byteLength});const i=new Uint8Array(e);let s=0;return a.forEach(o=>{i.set(new Uint8Array(o),s),s+=o.byteLength}),i.buffer}function basename(a){const e="/";for(a=a.trim();a.endsWith(e);)a=a.slice(0,a.length-1);const i=a.split(e);return i[i.length-1]}function getModelArtifactsInfoForJSON(a){if(a.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:a.modelTopology==null?0:stringByteLength(JSON.stringify(a.modelTopology)),weightSpecsBytes:a.weightSpecs==null?0:stringByteLength(JSON.stringify(a.weightSpecs)),weightDataBytes:a.weightData==null?0:a.weightData.byteLength}}function computeFloat16MantisaTable(){const a=i=>{let s=i<<13,o=0;for(;!(s&8388608);)o-=8388608,s<<=1;return s&=-8388609,o+=947912704,s|o},e=new Uint32Array(2048);e[0]=0;for(let i=1;i<1024;i++)e[i]=a(i);for(let i=1024;i<2048;i++)e[i]=939524096+(i-1024<<13);return e}function computeFloat16ExponentTable(){const a=new Uint32Array(64);a[0]=0,a[31]=1199570944,a[32]=2147483648,a[63]=3347054592;for(let e=1;e<31;e++)a[e]=e<<23;for(let e=33;e<63;e++)a[e]=2147483648+(e-32<<23);return a}function computeFloat16OffsetTable(){const a=new Uint32Array(64);for(let e=0;e<64;e++)a[e]=1024;return a[0]=a[32]=0,a}function getFloat16Decoder(){const a=computeFloat16MantisaTable(),e=computeFloat16ExponentTable(),i=computeFloat16OffsetTable();return s=>{const o=new ArrayBuffer(4*s.length),c=new Uint32Array(o);for(let d=0;d<s.length;d++){const h=s[d],g=a[i[h>>10]+(h&1023)]+e[h>>10];c[d]=g}return new Float32Array(o)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IORouterRegistry{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return IORouterRegistry.instance==null&&(IORouterRegistry.instance=new IORouterRegistry),IORouterRegistry.instance}static registerSaveRouter(e){IORouterRegistry.getInstance().saveRouters.push(e)}static registerLoadRouter(e){IORouterRegistry.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return IORouterRegistry.getHandlers(e,"save")}static getLoadHandlers(e,i){return IORouterRegistry.getHandlers(e,"load",i)}static getHandlers(e,i,s){const o=[];return(i==="load"?IORouterRegistry.getInstance().loadRouters:IORouterRegistry.getInstance().saveRouters).forEach(d=>{const h=d(e,s);h!==null&&o.push(h)}),o}}const registerSaveRouter=a=>IORouterRegistry.registerSaveRouter(a),registerLoadRouter=a=>IORouterRegistry.registerLoadRouter(a),getSaveHandlers=a=>IORouterRegistry.getSaveHandlers(a),getLoadHandlers=(a,e)=>IORouterRegistry.getLoadHandlers(a,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DATABASE_NAME="tensorflowjs",DATABASE_VERSION=1,MODEL_STORE_NAME="models_store",INFO_STORE_NAME="model_info_store";function getIndexedDBFactory(){if(!env$1().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const a=typeof window>"u"?self:window,e=a.indexedDB||a.mozIndexedDB||a.webkitIndexedDB||a.msIndexedDB||a.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function setUpDatabase(a){const e=a.result;e.createObjectStore(MODEL_STORE_NAME,{keyPath:"modelPath"}),e.createObjectStore(INFO_STORE_NAME,{keyPath:"modelPath"})}class BrowserIndexedDB{constructor(e){if(this.indexedDB=getIndexedDBFactory(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,i){return new Promise((s,o)=>{const c=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);c.onupgradeneeded=()=>setUpDatabase(c),c.onsuccess=()=>{const d=c.result;if(i==null){const h=d.transaction(MODEL_STORE_NAME,"readonly"),_=h.objectStore(MODEL_STORE_NAME).get(this.modelPath);_.onsuccess=()=>{if(_.result==null)return d.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(_.result.modelArtifacts)},_.onerror=b=>(d.close(),o(_.error)),h.oncomplete=()=>d.close()}else{const h=getModelArtifactsInfoForJSON(i),g=d.transaction(INFO_STORE_NAME,"readwrite");let _=g.objectStore(INFO_STORE_NAME);const b=_.put({modelPath:this.modelPath,modelArtifactsInfo:h});let $;b.onsuccess=()=>{$=d.transaction(MODEL_STORE_NAME,"readwrite");const _e=$.objectStore(MODEL_STORE_NAME).put({modelPath:this.modelPath,modelArtifacts:i,modelArtifactsInfo:h});_e.onsuccess=()=>s({modelArtifactsInfo:h}),_e.onerror=tt=>{_=g.objectStore(INFO_STORE_NAME);const et=_.delete(this.modelPath);et.onsuccess=()=>(d.close(),o(_e.error)),et.onerror=nt=>(d.close(),o(_e.error))}},b.onerror=j=>(d.close(),o(b.error)),g.oncomplete=()=>{$==null?d.close():$.oncomplete=()=>d.close()}}},c.onerror=d=>o(c.error)})}}BrowserIndexedDB.URL_SCHEME="indexeddb://";const indexedDBRouter=a=>env$1().getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(BrowserIndexedDB.URL_SCHEME)?browserIndexedDB(a.slice(BrowserIndexedDB.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(indexedDBRouter);IORouterRegistry.registerLoadRouter(indexedDBRouter);function browserIndexedDB(a){return new BrowserIndexedDB(a)}function maybeStripScheme$1(a){return a.startsWith(BrowserIndexedDB.URL_SCHEME)?a.slice(BrowserIndexedDB.URL_SCHEME.length):a}class BrowserIndexedDBManager{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise((e,i)=>{const s=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);s.onupgradeneeded=()=>setUpDatabase(s),s.onsuccess=()=>{const o=s.result,c=o.transaction(INFO_STORE_NAME,"readonly"),h=c.objectStore(INFO_STORE_NAME).getAll();h.onsuccess=()=>{const g={};for(const _ of h.result)g[_.modelPath]=_.modelArtifactsInfo;e(g)},h.onerror=g=>(o.close(),i(h.error)),c.oncomplete=()=>o.close()},s.onerror=o=>i(s.error)})}async removeModel(e){return e=maybeStripScheme$1(e),new Promise((i,s)=>{const o=this.indexedDB.open(DATABASE_NAME,DATABASE_VERSION);o.onupgradeneeded=()=>setUpDatabase(o),o.onsuccess=()=>{const c=o.result,d=c.transaction(INFO_STORE_NAME,"readwrite"),h=d.objectStore(INFO_STORE_NAME),g=h.get(e);let _;g.onsuccess=()=>{if(g.result==null)return c.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const b=h.delete(e),$=()=>{_=c.transaction(MODEL_STORE_NAME,"readwrite");const _e=_.objectStore(MODEL_STORE_NAME).delete(e);_e.onsuccess=()=>i(g.result.modelArtifactsInfo),_e.onerror=tt=>s(g.error)};b.onsuccess=$,b.onerror=j=>($(),c.close(),s(g.error))}},g.onerror=b=>(c.close(),s(g.error)),d.oncomplete=()=>{_==null?c.close():_.oncomplete=()=>c.close()}},o.onerror=c=>s(o.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PATH_SEPARATOR="/",PATH_PREFIX="tensorflowjs_models",INFO_SUFFIX="info",MODEL_TOPOLOGY_SUFFIX="model_topology",WEIGHT_SPECS_SUFFIX="weight_specs",WEIGHT_DATA_SUFFIX="weight_data",MODEL_METADATA_SUFFIX="model_metadata";function getModelKeys(a){return{info:[PATH_PREFIX,a,INFO_SUFFIX].join(PATH_SEPARATOR),topology:[PATH_PREFIX,a,MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),weightSpecs:[PATH_PREFIX,a,WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),weightData:[PATH_PREFIX,a,WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),modelMetadata:[PATH_PREFIX,a,MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)}}function getModelPathFromKey(a){const e=a.split(PATH_SEPARATOR);if(e.length<3)throw new Error(`Invalid key format: ${a}`);return e.slice(1,e.length-1).join(PATH_SEPARATOR)}function maybeStripScheme(a){return a.startsWith(BrowserLocalStorage.URL_SCHEME)?a.slice(BrowserLocalStorage.URL_SCHEME.length):a}class BrowserLocalStorage{constructor(e){if(!env$1().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=getModelKeys(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const i=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),o=getModelArtifactsInfoForJSON(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,i),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,arrayBufferToBase64String(e.weightData));const c={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return e.signature!=null&&(c.signature=e.signature),e.userDefinedMetadata!=null&&(c.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(c.modelInitializer=e.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(c)),{modelArtifactsInfo:o}}catch{throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const i={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);i.modelTopology=s;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);i.weightSpecs=o;const c=this.LS.getItem(this.keys.modelMetadata);if(c!=null){const h=JSON.parse(c);i.format=h.format,i.generatedBy=h.generatedBy,i.convertedBy=h.convertedBy,h.signature!=null&&(i.signature=h.signature),h.userDefinedMetadata!=null&&(i.userDefinedMetadata=h.userDefinedMetadata),h.modelInitializer!=null&&(i.modelInitializer=h.modelInitializer)}const d=this.LS.getItem(this.keys.weightData);if(d==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return i.weightData=base64StringToArrayBuffer(d),i}}BrowserLocalStorage.URL_SCHEME="localstorage://";const localStorageRouter=a=>env$1().getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(BrowserLocalStorage.URL_SCHEME)?browserLocalStorage(a.slice(BrowserLocalStorage.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(localStorageRouter);IORouterRegistry.registerLoadRouter(localStorageRouter);function browserLocalStorage(a){return new BrowserLocalStorage(a)}class BrowserLocalStorageManager{constructor(){assert$1(env$1().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),assert$1(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},i=PATH_PREFIX+PATH_SEPARATOR,s=PATH_SEPARATOR+INFO_SUFFIX;for(let o=0;o<this.LS.length;++o){const c=this.LS.key(o);if(c.startsWith(i)&&c.endsWith(s)){const d=getModelPathFromKey(c);e[d]=JSON.parse(this.LS.getItem(c))}}return e}async removeModel(e){e=maybeStripScheme(e);const i=getModelKeys(e);if(this.LS.getItem(i.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(i.info));return this.LS.removeItem(i.info),this.LS.removeItem(i.topology),this.LS.removeItem(i.weightSpecs),this.LS.removeItem(i.weightData),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const URL_SCHEME_SUFFIX="://";class ModelStoreManagerRegistry{constructor(){this.managers={}}static getInstance(){return ModelStoreManagerRegistry.instance==null&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance}static registerManager(e,i){assert$1(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(URL_SCHEME_SUFFIX)&&(e=e.slice(0,e.indexOf(URL_SCHEME_SUFFIX))),assert$1(e.length>0,()=>"scheme must not be an empty string.");const s=ModelStoreManagerRegistry.getInstance();assert$1(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=i}static getManager(e){const i=this.getInstance().managers[e];if(i==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return i}static getSchemes(){return Object.keys(this.getInstance().managers)}}function parseURL(a){if(a.indexOf(URL_SCHEME_SUFFIX)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ModelStoreManagerRegistry.getSchemes().join(",")}`);return{scheme:a.split(URL_SCHEME_SUFFIX)[0],path:a.split(URL_SCHEME_SUFFIX)[1]}}async function cloneModelInternal(a,e,i=!1){assert$1(a!==e,()=>`Old path and new path are the same: '${a}'`);const s=IORouterRegistry.getLoadHandlers(a);assert$1(s.length>0,()=>`Copying failed because no load handler is found for source URL ${a}.`),assert$1(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${a}.`);const o=s[0],c=IORouterRegistry.getSaveHandlers(e);assert$1(c.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),assert$1(c.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const d=c[0],h=parseURL(a).scheme,g=parseURL(a).path,_=h===parseURL(a).scheme,b=await o.load();i&&_&&await ModelStoreManagerRegistry.getManager(h).removeModel(g);const $=await d.save(b);return i&&!_&&await ModelStoreManagerRegistry.getManager(h).removeModel(g),$.modelArtifactsInfo}async function listModels(){const a=ModelStoreManagerRegistry.getSchemes(),e={};for(const i of a){const s=await ModelStoreManagerRegistry.getManager(i).listModels();for(const o in s){const c=i+URL_SCHEME_SUFFIX+o;e[c]=s[o]}}return e}async function removeModel(a){const e=parseURL(a);return ModelStoreManagerRegistry.getManager(e.scheme).removeModel(e.path)}async function copyModel(a,e){return cloneModelInternal(a,e,!1)}async function moveModel(a,e){return cloneModelInternal(a,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PlatformBrowser{fetch(e,i){return fetch(e,i)}now(){return performance.now()}encode(e,i){if(i!=="utf-8"&&i!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${i}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,i){return new TextDecoder(i).decode(e)}}if(env$1().get("IS_BROWSER")){env$1().setPlatform("browser",new PlatformBrowser);try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new BrowserLocalStorageManager)}catch{}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new BrowserIndexedDBManager)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const getNodeFetch={importFetch:()=>require("node-fetch")};let systemFetch;class PlatformNode{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,i){return env$1().global.fetch!=null?env$1().global.fetch(e,i):(systemFetch==null&&(systemFetch=getNodeFetch.importFetch()),systemFetch(e,i))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,i){if(i!=="utf-8"&&i!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${i}`);return this.textEncoder.encode(e)}decode(e,i){return e.length===0?"":new this.util.TextDecoder(i).decode(e)}}env$1().get("IS_NODE")&&env$1().setPlatform("node",new PlatformNode);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function buffer(a,e="float32",i){return e=e||"float32",assertNonNegativeIntegerDimensions(a),new TensorBuffer(a,e,i)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast_(a,e){const i=convertToTensor(a,"x","cast");if(!isValidDtype(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&i.dtype!=="string"||e!=="string"&&i.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:i},o={dtype:e};return ENGINE.runKernel(Cast,s,o)}const cast$3=op({cast_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clone_(a){const i={x:convertToTensor(a,"x","clone","string_or_numeric")};return ENGINE.runKernel(Identity$1,i)}const clone$2=op({clone_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function print(a,e=!1){console.log(a.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getOrMakeEngine();const opHandler={buffer,cast:cast$3,clone:clone$2,print};setOpHandler(opHandler);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DEFAULT_FILE_NAME_PREFIX="model",DEFAULT_JSON_EXTENSION_NAME=".json",DEFAULT_WEIGHT_DATA_EXTENSION_NAME=".weights.bin";function defer(a){return new Promise(e=>setTimeout(e)).then(a)}class BrowserDownloads{constructor(e){if(!env$1().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(BrowserDownloads.URL_SCHEME)&&(e=e.slice(BrowserDownloads.URL_SCHEME.length)),(e==null||e.length===0)&&(e=DEFAULT_FILE_NAME_PREFIX),this.modelTopologyFileName=e+DEFAULT_JSON_EXTENSION_NAME,this.weightDataFileName=e+DEFAULT_WEIGHT_DATA_EXTENSION_NAME}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const i=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:s};e.signature!=null&&(o.signature=e.signature),e.userDefinedMetadata!=null&&(o.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(o.modelInitializer=e.modelInitializer);const c=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),d=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;if(d.download=this.modelTopologyFileName,d.href=c,await defer(()=>d.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const h=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;h.download=this.weightDataFileName,h.href=i,await defer(()=>h.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}}}}BrowserDownloads.URL_SCHEME="downloads://";class BrowserFiles{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.files=e}async load(){const e=this.files[0],i=this.files.slice(1);return new Promise((s,o)=>{const c=new FileReader;c.onload=d=>{const h=JSON.parse(d.target.result),g=h.modelTopology;if(g==null){o(new Error(`modelTopology field is missing from file ${e.name}`));return}i.length===0&&s({modelTopology:g});const _=h.weightsManifest;if(_==null){o(new Error(`weightManifest field is missing from file ${e.name}`));return}let b;try{b=this.checkManifestAndWeightFiles(_,i)}catch(tt){o(tt);return}const $=[],j=[],_e=[];_.forEach(tt=>{tt.paths.forEach(et=>{j.push(et),_e.push(null)}),$.push(...tt.weights)}),_.forEach(tt=>{tt.paths.forEach(et=>{const nt=new FileReader;nt.onload=rt=>{const it=rt.target.result,at=j.indexOf(et);if(_e[at]=it,_e.indexOf(null)===-1){const st={modelTopology:g,weightSpecs:$,weightData:concatenateArrayBuffers$1(_e),format:h.format,generatedBy:h.generatedBy,convertedBy:h.convertedBy};h.signature!=null&&(st.signature=h.signature),h.userDefinedMetadata!=null&&(st.userDefinedMetadata=h.userDefinedMetadata),h.modelInitializer!=null&&(st.modelInitializer=h.modelInitializer),s(st)}},nt.onerror=rt=>o(`Failed to weights data from file of path '${et}'.`),nt.readAsArrayBuffer(b[et])})})},c.onerror=d=>o(`Failed to read model topology and weights manifest JSON from file '${e.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),c.readAsText(e)})}checkManifestAndWeightFiles(e,i){const s=[],o=i.map(d=>basename(d.name)),c={};for(const d of e)d.paths.forEach(h=>{const g=basename(h);if(s.indexOf(g)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${g}'`);if(s.push(g),o.indexOf(g)===-1)throw new Error(`Weight file with basename '${g}' is not provided.`);c[h]=i[o.indexOf(g)]});if(s.length!==i.length)throw new Error(`Mismatch in the number of files in weights manifest (${s.length}) and the number of weight files provided (${i.length}).`);return c}}const browserDownloadsRouter=a=>env$1().getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(BrowserDownloads.URL_SCHEME)?browserDownloads(a.slice(BrowserDownloads.URL_SCHEME.length)):null;IORouterRegistry.registerSaveRouter(browserDownloadsRouter);function browserDownloads(a="model"){return new BrowserDownloads(a)}function browserFiles(a){return new BrowserFiles(a)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function monitorPromisesProgress(a,e,i,s){d(a),i=i??0,s=s??1,h(i,s);let o=0;const c=g=>(g.then(_=>{const b=i+ ++o/a.length*(s-i);return e(b),_}),g);function d(g){assert$1(g!=null&&Array.isArray(g)&&g.length>0,()=>"promises must be a none empty array")}function h(g,_){assert$1(g>=0&&g<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${g}`),assert$1(_>=0&&_<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${_}`),assert$1(_>=g,()=>`startFraction must be no more than endFraction, but got startFraction ${g} and endFraction ${_}`)}return Promise.all(a.map(c))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function loadWeightsAsArrayBuffer(a,e){e==null&&(e={});const i=e.fetchFunc==null?env$1().platform.fetch:e.fetchFunc,s=a.map($=>i($,e.requestInit,{isBinary:!0})),h=(e.onProgress==null?await Promise.all(s):await monitorPromisesProgress(s,e.onProgress,0,.5)).map($=>$.arrayBuffer());return e.onProgress==null?await Promise.all(h):await monitorPromisesProgress(h,e.onProgress,.5,1)}async function loadWeights$1(a,e="",i,s){return weightsLoaderFactory(d=>loadWeightsAsArrayBuffer(d,{requestInit:s}))(a,e,i)}function weightsLoaderFactory(a){return async(e,i="",s)=>{const o=e.map(()=>!1),c={},d=s!=null?s.map(()=>!1):[],h=[];if(e.forEach((_e,tt)=>{let et=0;_e.weights.forEach(nt=>{const rt="quantization"in nt?nt.quantization.dtype:nt.dtype,it=DTYPE_VALUE_SIZE_MAP[rt]*sizeFromShape(nt.shape),at=()=>{o[tt]=!0,c[tt]==null&&(c[tt]=[]),c[tt].push({manifestEntry:nt,groupOffset:et,sizeBytes:it})};s!=null?s.forEach((st,ot)=>{st===nt.name&&(at(),d[ot]=!0)}):at(),h.push(nt.name),et+=it})}),!d.every(_e=>_e)){const _e=s.filter((tt,et)=>!d[et]);throw new Error(`Could not find weights in manifest with names: ${_e.join(", ")}. 
Manifest JSON has weights with names: ${h.join(", ")}.`)}const g=o.reduce((_e,tt,et)=>(tt&&_e.push(et),_e),[]),_=[];g.forEach(_e=>{e[_e].paths.forEach(tt=>{const et=i+(i.endsWith("/")?"":"/")+tt;_.push(et)})});const b=await a(_),$={};let j=0;return g.forEach(_e=>{const tt=e[_e].paths.length;let et=0;for(let st=0;st<tt;st++)et+=b[j+st].byteLength;const nt=new ArrayBuffer(et),rt=new Uint8Array(nt);let it=0;for(let st=0;st<tt;st++){const ot=new Uint8Array(b[j+st]);rt.set(ot,it),it+=ot.byteLength}c[_e].forEach(st=>{const ot=nt.slice(st.groupOffset,st.groupOffset+st.sizeBytes),ct=decodeWeights(ot,[st.manifestEntry]);for(const lt in ct)$[lt]=ct[lt]}),j+=tt}),$}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OCTET_STREAM_MIME_TYPE="application/octet-stream",JSON_TYPE="application/json";class HTTPRequest{constructor(e,i){if(this.DEFAULT_METHOD="POST",i==null&&(i={}),this.weightPathPrefix=i.weightPathPrefix,this.onProgress=i.onProgress,this.weightUrlConverter=i.weightUrlConverter,i.fetchFunc!=null?(assert$1(typeof i.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=i.fetchFunc):this.fetch=env$1().platform.fetch,assert$1(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&assert$1(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,i.requestInit!=null&&i.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=i.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const i=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);i.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:s};e.signature!=null&&(o.signature=e.signature),e.userDefinedMetadata!=null&&(o.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(o.modelInitializer=e.modelInitializer),i.body.append("model.json",new Blob([JSON.stringify(o)],{type:JSON_TYPE}),"model.json"),e.weightData!=null&&i.body.append("model.weights.bin",new Blob([e.weightData],{type:OCTET_STREAM_MIME_TYPE}),"model.weights.bin");const c=await this.fetch(this.path,i);if(c.ok)return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e),responses:[c]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${c.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let i;try{i=await e.json()}catch{let et=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?et+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":et+=" Please make sure the server is serving valid JSON for this request.",new Error(et)}const s=i.modelTopology,o=i.weightsManifest,c=i.generatedBy,d=i.convertedBy,h=i.format,g=i.signature,_=i.userDefinedMetadata;if(s==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let b,$;o!=null&&([b,$]=await this.loadWeights(o));const j={modelTopology:s,weightSpecs:b,weightData:$,generatedBy:c,convertedBy:d,format:h};g!=null&&(j.signature=g),_!=null&&(j.userDefinedMetadata=_);const _e=i.modelInitializer;return _e&&(j.modelInitializer=_e),j}async loadWeights(e){const i=Array.isArray(this.path)?this.path[1]:this.path,[s,o]=parseUrl(i),c=this.weightPathPrefix||s,d=[];for(const b of e)d.push(...b.weights);const h=[],g=[];for(const b of e)for(const $ of b.paths)this.weightUrlConverter!=null?g.push(this.weightUrlConverter($)):h.push(c+$+o);this.weightUrlConverter&&h.push(...await Promise.all(g));const _=await loadWeightsAsArrayBuffer(h,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[d,concatenateArrayBuffers$1(_)]}}HTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//;function parseUrl(a){const e=a.lastIndexOf("/"),i=a.lastIndexOf("?"),s=a.substring(0,e),o=i>e?a.substring(i):"";return[s+"/",o]}function isHTTPScheme(a){return a.match(HTTPRequest.URL_SCHEME_REGEX)!=null}const httpRouter=(a,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let i=!0;if(Array.isArray(a)?i=a.every(s=>isHTTPScheme(s)):i=isHTTPScheme(a),i)return http(a,e)}return null};IORouterRegistry.registerSaveRouter(httpRouter);IORouterRegistry.registerLoadRouter(httpRouter);function http(a,e){return new HTTPRequest(a,e)}function browserHTTPRequest(a,e){return http(a,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PassthroughLoader{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class PassthroughSaver{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function fromMemory(a,e,i,s){return arguments.length===1?a.modelTopology!=null||a.weightSpecs!=null?new PassthroughLoader(a):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:a})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new PassthroughLoader({modelTopology:a,weightSpecs:e,weightData:i,trainingConfig:s}))}function withSaveHandler(a){return new PassthroughSaver(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const io=Object.freeze(Object.defineProperty({__proto__:null,browserFiles,browserHTTPRequest,concatenateArrayBuffers:concatenateArrayBuffers$1,copyModel,decodeWeights,encodeWeights,fromMemory,getLoadHandlers,getModelArtifactsInfoForJSON,getSaveHandlers,http,isHTTPScheme,listModels,loadWeights:loadWeights$1,moveModel,registerLoadRouter,registerSaveRouter,removeModel,weightsLoaderFactory,withSaveHandler},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function matMul_(a,e,i=!1,s=!1){let o=convertToTensor(a,"a","matMul"),c=convertToTensor(e,"b","matMul");[o,c]=makeTypesMatch(o,c);const d={a:o,b:c},h={transposeA:i,transposeB:s};return ENGINE.runKernel(BatchMatMul,d,h)}const matMul$1=op({matMul_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oneHot_(a,e,i=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const c={indices:convertToTensor(a,"indices","oneHot","int32")},d={depth:e,onValue:i,offValue:s};return ENGINE.runKernel(OneHot,c,d)}const oneHot$2=op({oneHot_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose_(a,e){const i=convertToTensor(a,"x","transpose");if(e==null&&(e=i.shape.map((c,d)=>d).reverse()),assert$1(i.rank===e.length,()=>`Error in transpose: rank of input ${i.rank} must match length of perm ${e}.`),e.forEach(c=>{assert$1(c>=0&&c<i.rank,()=>`All entries in 'perm' must be between 0 and ${i.rank-1} but got ${e}`)}),i.rank<=1)return i.clone();const s={x:i},o={perm:e};return ENGINE.runKernel(Transpose,s,o)}const transpose$3=op({transpose_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function confusionMatrix_(a,e,i){const s=convertToTensor(a,"labels","confusionMatrix"),o=convertToTensor(e,"predictions","confusionMatrix");assert$1(i==null||i>0&&Number.isInteger(i),()=>`If provided, numClasses must be a positive integer, but got ${i}`),assert$1(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),assert$1(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),assert$1(s.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),assert$1(i>0&&Number.isInteger(i),()=>`numClasses is required to be a positive integer, but got ${i}`);const c=oneHot$2(cast$3(s,"int32"),i),d=oneHot$2(cast$3(o,"int32"),i),h=transpose$3(c),g=matMul$1(h,d);return cast$3(g,"int32")}const confusionMatrix=op({confusionMatrix_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const math=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor3d(a,e,i){if(assertNonNull(a),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=inferShape(a,i);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return makeTensor(a,e,s,i)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fromPixels2DContext$1;function fromPixels_(a,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(a==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let i=!1,s=!1,o=!1,c=!1,d=!1,h=!1;if(a.data instanceof Uint8Array)i=!0;else if(typeof ImageData<"u"&&a instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement)c=!0;else if(a.getContext!=null)d=!0;else if(typeof ImageBitmap<"u"&&a instanceof ImageBitmap)h=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${a.constructor.name}`);if(o&&o&&a.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(getKernel(FromPixels,ENGINE.backendName)!=null){const tt={pixels:a},et={numChannels:e};return ENGINE.runKernel(FromPixels,tt,et)}const[_,b]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height];let $;d?$=a.getContext("2d").getImageData(0,0,_,b).data:s||i?$=a.data:(c||o||h)&&(fromPixels2DContext$1==null&&(fromPixels2DContext$1=document.createElement("canvas").getContext("2d")),fromPixels2DContext$1.canvas.width=_,fromPixels2DContext$1.canvas.height=b,fromPixels2DContext$1.drawImage(a,0,0,_,b),$=fromPixels2DContext$1.getImageData(0,0,_,b).data);let j;if(e===4)j=new Int32Array($);else{const tt=_*b;j=new Int32Array(tt*e);for(let et=0;et<tt;et++)for(let nt=0;nt<e;++nt)j[et*e+nt]=$[et*4+nt]}return tensor3d(j,[b,_,e],"int32")}async function toPixels(a,e){let i=convertToTensor(a,"img","toPixels");if(!(a instanceof Tensor)){const _=i;i=cast$3(_,"int32"),_.dispose()}if(i.rank!==2&&i.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${i.rank}.`);const[s,o]=i.shape.slice(0,2),c=i.rank===2?1:i.shape[2];if(c>4||c===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${c}`);if(i.dtype!=="float32"&&i.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${i.dtype}. Please use float32 or int32 tensors.`);const d=await i.data(),h=i.dtype==="float32"?255:1,g=new Uint8ClampedArray(o*s*4);for(let _=0;_<s*o;++_){const b=[0,0,0,255];for(let j=0;j<c;j++){const _e=d[_*c+j];if(i.dtype==="float32"){if(_e<0||_e>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_e}.`)}else if(i.dtype==="int32"&&(_e<0||_e>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_e}.`);c===1?(b[0]=_e*h,b[1]=_e*h,b[2]=_e*h):b[j]=_e*h}const $=_*4;g[$+0]=Math.round(b[0]),g[$+1]=Math.round(b[1]),g[$+2]=Math.round(b[2]),g[$+3]=Math.round(b[3])}if(e!=null){e.width=o,e.height=s;const _=e.getContext("2d"),b=new ImageData(g,o,s);_.putImageData(b,0,0)}return i!==a&&i.dispose(),g}const fromPixels$1=op({fromPixels_}),browser$1=Object.freeze(Object.defineProperty({__proto__:null,fromPixels:fromPixels$1,toPixels},Symbol.toStringTag,{value:"Module"}));function prepareAndValidate(a,e){const i=a.shape.length,s=e.shape.length;if(i<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${i}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>i)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${i}`);if(sizeFromShape(a.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${a.shape}.`);const o=e.shape,c=o[o.length-1];let d=1;for(let $=0;$<o.length-1;++$)d*=o[$];const h=a.shape,g=o.slice();g.pop();let _=1;for(let $=c;$<i;++$)_*=h[$],g.push(h[$]);const b=[...computeStrides(a.shape).map($=>$/_),1].slice(0,c);return[g,d,_,b]}const gather_nd_util=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate},Symbol.toStringTag,{value:"Module"}));function validateUpdateShape(a,e,i){const s=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,c=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${i.shape}, indices.shape: ${e.shape}, shape: ${a}, sliceDim: ${s}, and batchDim: ${o}.`;if(i.rank<o)throw new Error(c+` update.rank < ${o}. `);if(a.length<s+(i.rank-o))throw new Error(c+` Output shape length < ${s+(i.rank-o)}`);if(i.rank!==o+a.length-s)throw new Error(c+` update.rank != ${o+a.length-s}`);for(let d=0;d<o;++d)if(i.shape[d]!==e.shape[d])throw new Error(c+` updates.shape[${d}] (${i.shape[d]}) != indices.shape[${d}] (${e.shape[d]}).`);for(let d=0;d<i.rank-o;++d)if(i.shape[d+o]!==a[d+s])throw new Error(c+` updates.shape[${d+o}] (${i.shape[d+o]}) != shape[${d+o}] (${a[d+o]})`)}function validateInput$1(a,e,i){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(a.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${a.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(i.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${i}`);if(i.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(a.size===0)throw new Error(`Updates specified for empty output. updates shape: ${a.shape}`)}validateUpdateShape(i,e,a)}function calculateShapes(a,e,i){const s=e.shape.length,o=s>1?e.shape[s-1]:1,c=i.length;let d=1;for(let $=o;$<c;++$)d*=i[$];const h=o<1?1:o,g=sizeFromShape(e.shape)/h,_=[...computeStrides(i.slice(0,o)),1],b=sizeFromShape(i);return{sliceRank:o,numUpdates:g,sliceSize:d,strides:_,outputSize:b}}const scatter_nd_util=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes,validateInput:validateInput$1,validateUpdateShape},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertParamsValid(a,e,i){const s=a.shape.length;assert$1(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),assert$1(s===i.length,()=>`Error in slice${s}D: Length of size ${i} must match the rank of the array (${s}).`);for(let o=0;o<s;++o)assert$1(e[o]+i[o]<=a.shape[o],()=>`Error in slice${s}D: begin[${o}] + size[${o}] (${e[o]+i[o]}) would overflow input.shape[${o}] (${a.shape[o]})`)}function maskToAxes(a){const e=[];let i=0;for(;a>0;)a&1&&e.push(i),a/=2,i++;return e}function computeOutShape$2(a,e,i){const s=[];for(let o=0;o<a.length;o++)s[o]=Math.ceil((e[o]-a[o])/i[o]);return s}function stridesWithElidedDims(a,e,i,s){const o=[...a];for(let c=o.length;c<s.length;c++)o.push(1);for(let c=0;c<i;c++)c===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function unnormalizeAxis(a,e,i){return i<=a?i:i-(e-1)}function getElidedAxes(a,e){const i=[];for(let s=0;s<a;s++)i.push(e+s);return i}function getNormalizedAxes(a,e,i,s,o,c,d,h,g){const _=a.length;let b=new Array(_),$=new Array(_),j=new Array(_);if(e.length&&i>0){const _e=e[0],tt=i+1;b=startIndicesWithElidedDims(d,_e,tt,s,a),$=stopIndicesWithElidedDims(h,_e,tt,o,a),j=stridesWithElidedDims(c,_e,tt,a)}else for(let _e=0;_e<_;_e++)b[_e]=startForAxis(d,s,c,a,_e,g),$[_e]=stopForAxis(h,o,c,a,_e,g),j[_e]=stridesForAxis(c,_e,g);return{begin:b,end:$,strides:j}}function startIndicesWithElidedDims(a,e,i,s,o){const c=[...o],d=getElidedAxes(i,e);for(let h=0;h<c.length;h++)if(d.indexOf(h)>-1)c[h]=0;else{const g=unnormalizeAxis(e,i,h);let _=s[g];a&1<<g&&(_=0),c[h]=_}return c}function stopIndicesWithElidedDims(a,e,i,s,o){const c=[...o],d=getElidedAxes(i,e);for(let h=0;h<c.length;h++)if(d.indexOf(h)>-1)c[h]=Number.MAX_SAFE_INTEGER;else{const g=unnormalizeAxis(e,i,h);let _=s[g];a&1<<g&&(_=Number.MAX_SAFE_INTEGER),c[h]=_}for(let h=0;h<c.length;h++){const g=o[h];c[h]<0&&(c[h]+=g),c[h]=clamp$1(0,c[h],o[h])}return c}function stridesForAxis(a,e,i){let s=a[e];return(i&1<<e||s==null)&&(s=1),s}function startForAxis(a,e,i,s,o,c){let d=e[o];const h=i[o]||1;(a&1<<o||c&1<<o||d==null)&&(h>0?d=Number.MIN_SAFE_INTEGER:d=Number.MAX_SAFE_INTEGER);const g=s[o];return d<0&&(d+=g),d=clamp$1(0,d,g-1),d}function stopForAxis(a,e,i,s,o,c){let d=e[o];const h=i[o]||1;(a&1<<o||c&1<<o||d==null)&&(h>0?d=Number.MAX_SAFE_INTEGER:d=Number.MIN_SAFE_INTEGER);const g=s[o];return d<0&&(d+=g),h>0?d=clamp$1(0,d,g):d=clamp$1(-1,d,g-1),d}function isSliceContinous(a,e,i){let s=i.length;for(let o=0;o<i.length;o++)if(i[o]>1){s=o;break}for(let o=s+1;o<i.length;o++)if(e[o]>0||i[o]!==a[o])return!1;return!0}function computeFlatOffset(a,e){let i=a.length>0?a[a.length-1]:1;for(let s=0;s<a.length-1;s++)i+=a[s]*e[s];return i}function parseSliceParams(a,e,i){let s;const o=a.shape.length;typeof e=="number"?s=[e,...new Array(o-1).fill(0)]:e.length<o?s=e.concat(new Array(o-e.length).fill(0)):s=e.slice(),s.forEach(d=>{assert$1(d!==-1,()=>"slice() does not support negative begin indexing.")});let c;return i==null?c=new Array(o).fill(-1):typeof i=="number"?c=[i,...new Array(o-1).fill(-1)]:i.length<o?c=i.concat(new Array(o-i.length).fill(-1)):c=i,c=c.map((d,h)=>d>=0?d:(assert$1(d===-1,()=>`Negative size values should be exactly -1 but got ${d} for the slice() size at index ${h}.`),a.shape[h]-s[h])),[s,c]}function sliceInfo(a,e,i,s,o,c,d,h,g){let _=e.slice(),b=i.slice(),$=s;s==null&&($=new Array(_.length));const j=maskToAxes(d);if(j.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(d!==0&&h!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(d!==0&&g!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const _e=a.length-_.length,tt=maskToAxes(h),et=a.slice();tt.forEach(lt=>{_[lt]=0,b[lt]=1,et.splice(lt,0,1)});const{begin:nt,end:rt,strides:it}=getNormalizedAxes(et,j,_e,_,b,$,o,c,d);_=nt,b=rt,$=it;const at=maskToAxes(g);at.forEach(lt=>{b[lt]=_[lt]+1,$[lt]=1});const st=computeOutShape$2(_,b,$),ot=st.filter((lt,dt)=>at.indexOf(dt)===-1);return{nonStrided:$.every(lt=>lt===1),$begin:_,$end:b,$strides:$,size:st,newShape:et,outShape:ot}}const slice_util=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid,computeFlatOffset,computeOutShape:computeOutShape$2,getNormalizedAxes,isSliceContinous,maskToAxes,parseSliceParams,sliceInfo,startForAxis,startIndicesWithElidedDims,stopForAxis,stopIndicesWithElidedDims,stridesForAxis,stridesWithElidedDims},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Serializable{getClassName(){return this.constructor.className}static fromConfig(e,i){return new e(i)}}class SerializationMap{constructor(){this.classNameMap={}}static getMap(){return SerializationMap.instance==null&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance}static register(e){SerializationMap.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function registerClass(a){assert$1(a.className!=null,()=>"Class being registered does not have the static className property defined."),assert$1(typeof a.className=="string",()=>"className is required to be a string, but got type "+typeof a.className),assert$1(a.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),SerializationMap.register(a)}const serialization=Object.freeze(Object.defineProperty({__proto__:null,Serializable,SerializationMap,registerClass},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TEST_EPSILON_FLOAT32=.001,TEST_EPSILON_FLOAT16=.1;function expectArraysClose(a,e,i){return i==null&&(i=testEpsilon()),expectArraysPredicate(a,e,(s,o)=>areClose(s,o,i))}function testEpsilon(){return ENGINE.backend.floatPrecision()===32?TEST_EPSILON_FLOAT32:TEST_EPSILON_FLOAT16}function expectArraysPredicate(a,e,i){let s=!0;if((isTypedArray(a)||isTypedArray(e))&&(s=!1),isTypedArray(a)&&isTypedArray(e)&&(s=!0),s){const d=a.constructor.name,h=e.constructor.name;if(d!==h)throw new Error(`Arrays are of different type. Actual: ${d}. Expected: ${h}`)}if(Array.isArray(a)&&Array.isArray(e)){const d=inferShape(a),h=inferShape(e);if(!arraysEqual(d,h))throw new Error(`Arrays have different shapes. Actual: [${d}]. Expected: [${h}]`)}const o=isTypedArray(a)?a:flatten$4(a),c=isTypedArray(e)?e:flatten$4(e);if(o.length!==c.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${c.length}.
Actual:   ${o}.
Expected: ${c}.`);for(let d=0;d<c.length;++d){const h=o[d],g=c[d];if(!i(h,g))throw new Error(`Arrays differ: actual[${d}] = ${h}, expected[${d}] = ${g}.
Actual:   ${o}.
Expected: ${c}.`)}}function expectPromiseToFail(a,e){a().then(()=>e.fail(),()=>e())}function expectArraysEqual(a,e){const i=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return isString$1(a)||isString$1(a[0])||isString$1(e)||isString$1(e[0])?expectArraysPredicate(a,i,(s,o)=>s==o):expectArraysPredicate(a,e,(s,o)=>areClose(s,o,0))}function expectNumbersClose(a,e,i){if(i==null&&(i=testEpsilon()),!areClose(a,e,i))throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`)}function areClose(a,e,i){return!isFinite(a)&&!isFinite(e)?!0:!(isNaN(a)||isNaN(e)||Math.abs(a-e)>i)}function expectValuesInRange(a,e,i){for(let s=0;s<a.length;s++)if(a[s]<e||a[s]>i)throw new Error(`Value out of range:${a[s]} low: ${e}, high: ${i}`)}function expectArrayBuffersEqual(a,e){expect(new Float32Array(a)).toEqual(new Float32Array(e))}function encodeStrings(a){for(let e=0;e<a.length;e++){const i=a[e];Array.isArray(i)?encodeStrings(i):a[e]=encodeString(i)}return a}const test_util=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16,encodeStrings,expectArrayBuffersEqual,expectArraysClose,expectArraysEqual,expectNumbersClose,expectPromiseToFail,expectValuesInRange,testEpsilon},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const version$9="3.1.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function enableProdMode(){env$1().set("PROD",!0)}function enableDebugMode(){env$1().set("DEBUG",!0)}function disableDeprecationWarnings(){env$1().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function deprecationWarn(a){env$1().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(a+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function disposeVariables(){ENGINE.disposeVariables()}function engine(){return ENGINE}function memory(){return ENGINE.memory()}function profile(a){return ENGINE.profile(a)}function tidy(a,e){return ENGINE.tidy(a,e)}function dispose(a){getTensorsInContainer(a).forEach(i=>i.dispose())}function keep(a){return ENGINE.keep(a)}function time(a){return ENGINE.time(a)}function setBackend(a){return ENGINE.setBackend(a)}function ready(){return ENGINE.ready()}function getBackend(){return ENGINE.backendName}function removeBackend(a){ENGINE.removeBackend(a)}function findBackend(a){return ENGINE.findBackend(a)}function findBackendFactory(a){return ENGINE.findBackendFactory(a)}function registerBackend(a,e,i=1){return ENGINE.registerBackend(a,e,i)}function backend(){return ENGINE.backend}function setPlatform(a,e){env$1().setPlatform(a,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function add_(a,e){let i=convertToTensor(a,"a","add"),s=convertToTensor(e,"b","add");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(Add$1,o)}const add$4=op({add_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function floorDiv_(a,e){let i=convertToTensor(a,"a","floorDiv"),s=convertToTensor(e,"b","floorDiv");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(FloorDiv,o)}const floorDiv$2=op({floorDiv_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function div_(a,e){let i=convertToTensor(a,"a","div"),s=convertToTensor(e,"b","div");if([i,s]=makeTypesMatch(i,s),i.dtype==="int32"&&s.dtype==="int32")return floorDiv$2(i,s);const o={a:i,b:s},c={};return ENGINE.runKernel(RealDiv,o,c)}const div$2=op({div_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mul_(a,e){let i=convertToTensor(a,"a","mul"),s=convertToTensor(e,"b","mul");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(Multiply$1,o)}const mul$1=op({mul_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abs_(a){const e=convertToTensor(a,"x","abs");if(e.dtype==="complex64"){const i={x:e};return ENGINE.runKernel(ComplexAbs,i)}else{const i={x:e};return ENGINE.runKernel(Abs,i)}}const abs$4=op({abs_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function acos_(a){const i={x:convertToTensor(a,"x","acos")};return ENGINE.runKernel(Acos,i)}const acos$3=op({acos_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function acosh_(a){const i={x:convertToTensor(a,"x","acosh")};return ENGINE.runKernel(Acosh,i)}const acosh$3=op({acosh_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN_(a){assert$1(Array.isArray(a),()=>"The argument passed to tf.addN() must be a list of tensors"),assert$1(a.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${a.length}`);const e=a.map((o,c)=>convertToTensor(o,`tensors${c}`,"addN")),i=e[0];e.forEach(o=>{if(o.dtype!==i.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!arraysEqual(o.shape,i.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return ENGINE.runKernel(AddN,s)}const addN$2=op({addN_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function all_(a,e=null,i=!1){const o={x:convertToTensor(a,"x","all","bool")},c={axis:e,keepDims:i};return ENGINE.runKernel(All,o,c)}const all$2=op({all_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function any_(a,e=null,i=!1){const o={x:convertToTensor(a,"x","any","bool")},c={axis:e,keepDims:i};return ENGINE.runKernel(Any,o,c)}const any$2=op({any_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMax_(a,e=0){const s={x:convertToTensor(a,"x","argMax")},o={axis:e};return ENGINE.runKernel(ArgMax,s,o)}const argMax$2=op({argMax_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMin_(a,e=0){const s={x:convertToTensor(a,"x","argMin")},o={axis:e};return ENGINE.runKernel(ArgMin,s,o)}const argMin$2=op({argMin_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function asin_(a){const i={x:convertToTensor(a,"x","asin")};return ENGINE.runKernel(Asin,i)}const asin$3=op({asin_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function asinh_(a){const i={x:convertToTensor(a,"x","asinh")};return ENGINE.runKernel(Asinh,i)}const asinh$3=op({asinh_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function atan_(a){const i={x:convertToTensor(a,"x","atan")};return ENGINE.runKernel(Atan,i)}const atan$4=op({atan_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function atan2_(a,e){let i=convertToTensor(a,"a","atan2"),s=convertToTensor(e,"b","atan2");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(Atan2,o)}const atan2$3=op({atan2_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function atanh_(a){const i={x:convertToTensor(a,"x","atanh")};return ENGINE.runKernel(Atanh,i)}const atanh$3=op({atanh_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function computeDilation2DInfo(a,e,i,s,o="NHWC",c){const d=a[3],h=[...e,d],g=convertConv2DDataFormat(o);return computeConv2DInfo(a,h,i,c,s,null,null,g)}function computePool2DInfo(a,e,i,s,o,c,d="channelsLast"){const[h,g]=parseTupleParam(e);let _;if(d==="channelsLast")_=[h,g,a[3],a[3]];else if(d==="channelsFirst")_=[h,g,a[1],a[1]];else throw new Error(`Unknown dataFormat ${d}`);return computeConv2DInfo(a,_,i,s,o,c,!1,d)}function computePool3DInfo(a,e,i,s,o,c,d="NDHWC"){const[h,g,_]=parse3TupleParam(e);let b,$;if(d==="NDHWC")$="channelsLast",b=[h,g,_,a[4],a[4]];else if(d==="NCDHW")$="channelsFirst",b=[h,g,_,a[1],a[1]];else throw new Error(`Unknown dataFormat ${d}`);return computeConv3DInfo(a,b,i,s,o,!1,$,c)}function computeConv2DInfo(a,e,i,s,o,c,d=!1,h="channelsLast"){let[g,_,b,$]=[-1,-1,-1,-1];if(h==="channelsLast")[g,_,b,$]=a;else if(h==="channelsFirst")[g,$,_,b]=a;else throw new Error(`Unknown dataFormat ${h}`);const[j,_e,,tt]=e,[et,nt]=parseTupleParam(i),[rt,it]=parseTupleParam(s),at=getEffectiveFilterSize(j,rt),st=getEffectiveFilterSize(_e,it),{padInfo:ot,outHeight:ct,outWidth:lt}=getPadAndOutInfo(o,_,b,et,nt,at,st,c,h),dt=d?tt*$:tt;let xt;return h==="channelsFirst"?xt=[g,dt,ct,lt]:h==="channelsLast"&&(xt=[g,ct,lt,dt]),{batchSize:g,dataFormat:h,inHeight:_,inWidth:b,inChannels:$,outHeight:ct,outWidth:lt,outChannels:dt,padInfo:ot,strideHeight:et,strideWidth:nt,filterHeight:j,filterWidth:_e,effectiveFilterHeight:at,effectiveFilterWidth:st,dilationHeight:rt,dilationWidth:it,inShape:a,outShape:xt,filterShape:e}}function computeConv3DInfo(a,e,i,s,o,c=!1,d="channelsLast",h){let[g,_,b,$,j]=[-1,-1,-1,-1,-1];if(d==="channelsLast")[g,_,b,$,j]=a;else if(d==="channelsFirst")[g,j,_,b,$]=a;else throw new Error(`Unknown dataFormat ${d}`);const[_e,tt,et,,nt]=e,[rt,it,at]=parse3TupleParam(i),[st,ot,ct]=parse3TupleParam(s),lt=getEffectiveFilterSize(_e,st),dt=getEffectiveFilterSize(tt,ot),xt=getEffectiveFilterSize(et,ct),{padInfo:ut,outDepth:ft,outHeight:mt,outWidth:yt}=get3DPadAndOutInfo(o,_,b,$,rt,it,at,lt,dt,xt,h),St=c?nt*j:nt;let Et;return d==="channelsFirst"?Et=[g,St,ft,mt,yt]:d==="channelsLast"&&(Et=[g,ft,mt,yt,St]),{batchSize:g,dataFormat:d,inDepth:_,inHeight:b,inWidth:$,inChannels:j,outDepth:ft,outHeight:mt,outWidth:yt,outChannels:St,padInfo:ut,strideDepth:rt,strideHeight:it,strideWidth:at,filterDepth:_e,filterHeight:tt,filterWidth:et,effectiveFilterDepth:lt,effectiveFilterHeight:dt,effectiveFilterWidth:xt,dilationDepth:st,dilationHeight:ot,dilationWidth:ct,inShape:a,outShape:Et,filterShape:e}}function computeOutputShape2D(a,e,i,s,o){s==null&&(s=computeDefaultPad(a,e,i));const c=a[0],d=a[1],h=round$4((c-e+2*s)/i+1,o),g=round$4((d-e+2*s)/i+1,o);return[h,g]}function computeOutputShape4D(a,e,i,s,o,c){o==null&&(o=computeDefaultPad(a,e,s));const d=a[0],h=a[1],g=a[2],_=round$4((d-e+2*o)/s+1,c),b=round$4((h-e+2*o)/s+1,c),$=round$4((g-e+2*o)/s+1,c);return[_,b,$,i]}function computeDefaultPad(a,e,i,s=1){const o=getEffectiveFilterSize(e,s);return Math.floor((a[0]*(i-1)-i+o)/2)}function parseTupleParam(a){return typeof a=="number"?[a,a,a]:a.length===2?[a[0],a[1],1]:a}function parse3TupleParam(a){return typeof a=="number"?[a,a,a]:a}function getEffectiveFilterSize(a,e){return e<=1?a:a+(a-1)*(e-1)}function getPadAndOutInfo(a,e,i,s,o,c,d,h,g){let _,b,$;if(typeof a=="number"){_={top:a,bottom:a,left:a,right:a,type:a===0?"VALID":"NUMBER"};const _e=computeOutputShape2D([e,i],c,s,a,h);b=_e[0],$=_e[1]}else if(a==="same"){b=Math.ceil(e/s),$=Math.ceil(i/o);const j=Math.max(0,(b-1)*s+c-e),_e=Math.max(0,($-1)*o+d-i),tt=Math.floor(j/2),et=j-tt,nt=Math.floor(_e/2),rt=_e-nt;_={top:tt,bottom:et,left:nt,right:rt,type:"SAME"}}else if(a==="valid")_={top:0,bottom:0,left:0,right:0,type:"VALID"},b=Math.ceil((e-c+1)/s),$=Math.ceil((i-d+1)/o);else if(typeof a=="object"){const j=g==="channelsLast"?a[1][0]:a[2][0],_e=g==="channelsLast"?a[1][1]:a[2][1],tt=g==="channelsLast"?a[2][0]:a[3][0],et=g==="channelsLast"?a[2][1]:a[3][1];_={top:j,bottom:_e,left:tt,right:et,type:j===0&&_e===0&&tt===0&&et===0?"VALID":"EXPLICIT"},b=round$4((e-c+j+_e)/s+1,h),$=round$4((i-d+tt+et)/o+1,h)}else throw Error(`Unknown padding parameter: ${a}`);return{padInfo:_,outHeight:b,outWidth:$}}function get3DPadAndOutInfo(a,e,i,s,o,c,d,h,g,_,b){let $,j,_e,tt;if(typeof a=="number"){$={top:a,bottom:a,left:a,right:a,front:a,back:a,type:a===0?"VALID":"NUMBER"};const nt=computeOutputShape4D([e,i,s,1],h,1,o,a,b);j=nt[0],_e=nt[1],tt=nt[2]}else if(a==="same"){j=Math.ceil(e/o),_e=Math.ceil(i/c),tt=Math.ceil(s/d);const et=(j-1)*o+h-e,nt=(_e-1)*c+g-i,rt=(tt-1)*d+_-s,it=Math.floor(et/2),at=et-it,st=Math.floor(nt/2),ot=nt-st,ct=Math.floor(rt/2),lt=rt-ct;$={top:st,bottom:ot,left:ct,right:lt,front:it,back:at,type:"SAME"}}else if(a==="valid")$={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},j=Math.ceil((e-h+1)/o),_e=Math.ceil((i-g+1)/c),tt=Math.ceil((s-_+1)/d);else throw Error(`Unknown padding parameter: ${a}`);return{padInfo:$,outDepth:j,outHeight:_e,outWidth:tt}}function round$4(a,e){if(!e)return Math.trunc(a);switch(e){case"round":return Math.round(a);case"ceil":return Math.ceil(a);case"floor":return Math.floor(a);default:throw new Error(`Unknown roundingMode ${e}`)}}function tupleValuesAreOne(a){const[e,i,s]=parseTupleParam(a);return e===1&&i===1&&s===1}function eitherStridesOrDilationsAreOne(a,e){return tupleValuesAreOne(a)||tupleValuesAreOne(e)}function convertConv2DDataFormat(a){if(a==="NHWC")return"channelsLast";if(a==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${a}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape_(a,e){const s={x:convertToTensor(a,"x","reshape","string_or_numeric")},o={shape:e};return ENGINE.runKernel(Reshape$1,s,o)}const reshape$4=op({reshape_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool_(a,e,i,s,o){const c=convertToTensor(a,"x","avgPool","float32"),d=1;assert$1(eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let h=c,g=!1;c.rank===3&&(g=!0,h=reshape$4(c,[1,c.shape[0],c.shape[1],c.shape[2]])),assert$1(h.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${h.rank}.`),o!=null&&assert$1(isInt(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const _={x:h},b={filterSize:e,strides:i,pad:s,dimRoundingMode:o};let $=ENGINE.runKernel(AvgPool,_,b);return $=cast$3($,c.dtype),g?reshape$4($,[$.shape[1],$.shape[2],$.shape[3]]):$}const avgPool$2=op({avgPool_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3d_(a,e,i,s,o,c="NDHWC"){const d=convertToTensor(a,"x","avgPool3d","float32");let h=d,g=!1;d.rank===4&&(g=!0,h=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),assert$1(h.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${h.rank}.`),assert$1(c==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${c}`),o!=null&&assert$1(isInt(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const _={x:h},b={filterSize:e,strides:i,pad:s,dimRoundingMode:o,dataFormat:c};let $=ENGINE.runKernel(AvgPool3D,_,b);return $=cast$3($,h.dtype),g?reshape$4($,[$.shape[1],$.shape[2],$.shape[3],$.shape[4]]):$}const avgPool3d$1=op({avgPool3d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat_(a,e=0){assert$1(a.length>=1,()=>"Pass at least one tensor to concat");const i=convertToTensorArray(a,"tensors","concat","string_or_numeric");if(i[0].dtype==="complex64"&&i.forEach(c=>{if(c.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${c.dtype}. `)}),i.length===1)return clone$2(i[0]);const s=i,o={axis:e};return ENGINE.runKernel(Concat,s,o)}const concat$3=op({concat_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sigmoid_(a){const i={x:convertToTensor(a,"x","sigmoid")};return ENGINE.runKernel(Sigmoid$1,i)}const sigmoid$2=op({sigmoid_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice_(a,e,i){const s=convertToTensor(a,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const o={x:s},c={begin:e,size:i};return ENGINE.runKernel(Slice,o,c)}const slice$2=op({slice_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tanh_(a){const i={x:convertToTensor(a,"x","tanh")};return ENGINE.runKernel(Tanh$1,i)}const tanh$3=op({tanh_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function basicLSTMCell_(a,e,i,s,o,c){const d=convertToTensor(a,"forgetBias","basicLSTMCell"),h=convertToTensor(e,"lstmKernel","basicLSTMCell"),g=convertToTensor(i,"lstmBias","basicLSTMCell"),_=convertToTensor(s,"data","basicLSTMCell"),b=convertToTensor(o,"c","basicLSTMCell"),$=convertToTensor(c,"h","basicLSTMCell"),j=concat$3([_,$],1),_e=matMul$1(j,h),tt=add$4(_e,g),et=tt.shape[0],nt=tt.shape[1]/4,rt=[et,nt],it=slice$2(tt,[0,0],rt),at=slice$2(tt,[0,nt],rt),st=slice$2(tt,[0,nt*2],rt),ot=slice$2(tt,[0,nt*3],rt),ct=add$4(mul$1(sigmoid$2(it),tanh$3(at)),mul$1(b,sigmoid$2(add$4(d,st)))),lt=mul$1(tanh$3(ct),sigmoid$2(ot));return[ct,lt]}const basicLSTMCell=op({basicLSTMCell_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchToSpaceND_(a,e,i){const s=convertToTensor(a,"x","batchToSpaceND"),o=e.reduce((h,g)=>h*g);assert$1(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),assert$1(i.length===e.length,()=>`crops.length is ${i.length} but should be equal to blockShape.length  ${e.length}`),assert$1(s.shape[0]%o===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);const c={x:s},d={blockShape:e,crops:i};return ENGINE.runKernel(BatchToSpaceND,c,d)}const batchToSpaceND$2=op({batchToSpaceND_});function xAs4D(a){let e;return a.rank===0||a.rank===1?e=reshape$4(a,[1,1,1,a.size]):a.rank===2?e=reshape$4(a,[1,1,a.shape[0],a.shape[1]]):a.rank===3?e=reshape$4(a,[1,a.shape[0],a.shape[1],a.shape[2]]):e=a,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchNorm_(a,e,i,s,o,c){c==null&&(c=.001);const d=convertToTensor(a,"x","batchNorm"),h=convertToTensor(e,"mean","batchNorm"),g=convertToTensor(i,"variance","batchNorm");let _;o!=null&&(_=convertToTensor(o,"scale","batchNorm"));let b;s!=null&&(b=convertToTensor(s,"offset","batchNorm")),assert$1(h.rank===g.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),assert$1(b==null||h.rank===b.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),assert$1(_==null||h.rank===_.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const j={x:xAs4D(d),scale:_,offset:b,mean:h,variance:g},_e={varianceEpsilon:c},tt=ENGINE.runKernel(FusedBatchNorm,j,_e);return reshape$4(tt,d.shape)}const batchNorm$2=op({batchNorm_});function batchNorm2d_(a,e,i,s,o,c){const d=convertToTensor(a,"x","batchNorm"),h=convertToTensor(e,"mean","batchNorm"),g=convertToTensor(i,"variance","batchNorm");let _;o!=null&&(_=convertToTensor(o,"scale","batchNorm"));let b;return s!=null&&(b=convertToTensor(s,"offset","batchNorm")),assert$1(d.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${d.rank}.`),assert$1(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${h.rank}.`),assert$1(g.rank===2||g.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${g.rank}.`),_!=null&&assert$1(_.rank===2||_.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${_.rank}.`),b!=null&&assert$1(b.rank===2||b.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${b.rank}.`),batchNorm$2(d,h,g,b,_,c)}const batchNorm2d=op({batchNorm2d_});function batchNorm3d_(a,e,i,s,o,c){const d=convertToTensor(a,"x","batchNorm"),h=convertToTensor(e,"mean","batchNorm"),g=convertToTensor(i,"variance","batchNorm");let _;o!=null&&(_=convertToTensor(o,"scale","batchNorm"));let b;return s!=null&&(b=convertToTensor(s,"offset","batchNorm")),assert$1(d.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${d.rank}.`),assert$1(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${h.rank}.`),assert$1(g.rank===3||g.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${g.rank}.`),_!=null&&assert$1(_.rank===3||_.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${_.rank}.`),b!=null&&assert$1(b.rank===3||b.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${b.rank}.`),batchNorm$2(d,h,g,b,_,c)}const batchNorm3d=op({batchNorm3d_});function batchNorm4d_(a,e,i,s,o,c){const d=convertToTensor(a,"x","batchNorm"),h=convertToTensor(e,"mean","batchNorm"),g=convertToTensor(i,"variance","batchNorm");let _;o!=null&&(_=convertToTensor(o,"scale","batchNorm"));let b;return s!=null&&(b=convertToTensor(s,"offset","batchNorm")),assert$1(d.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${d.rank}.`),assert$1(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${h.rank}.`),assert$1(g.rank===4||g.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${g.rank}.`),_!=null&&assert$1(_.rank===4||_.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${_.rank}.`),b!=null&&assert$1(b.rank===4||b.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${b.rank}.`),batchNorm$2(d,h,g,b,_,c)}const batchNorm4d=op({batchNorm4d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincount_(a,e,i){const s=convertToTensor(a,"x","bincount"),o=convertToTensor(e,"weights","bincount");assert$1(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),assert$1(i>=0,()=>`size must be non-negative, but got ${i}.`),assert$1(o.size===s.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${o.shape}.`);const c={x:s,weights:o},d={size:i};return ENGINE.runKernel(Bincount,c,d)}const bincount$2=op({bincount_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function broadcastTo_(a,e){let i=convertToTensor(a,"broadcastTo","x");const s=i.shape;if(e.some(_=>!(_>0)||_%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<i.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${i.rank}.`);if(e.length>i.rank){const _=i.shape.slice();for(;_.length<e.length;)_.unshift(1);i=reshape$4(i,_)}const o=i.shape,c=Array.from(e);for(let _=e.length-1;_>=0;_--)if(o[_]===e[_])c[_]=1;else if(i.shape[_]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(c.map((_,b)=>_>1?b:-1).filter(_=>_>=0).length===0)return clone$2(i);const h={x:i},g={reps:c};return ENGINE.runKernel(Tile,h,g)}const broadcastTo=op({broadcastTo_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ceil_(a){const i={x:convertToTensor(a,"x","ceil")};return ENGINE.runKernel(Ceil,i)}const ceil$3=op({ceil_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clipByValue_(a,e,i){const s=convertToTensor(a,"x","clipByValue");assert$1(e<=i,()=>`Error in clip: min (${e}) must be less than or equal to max (${i}).`);const o={x:s},c={clipValueMin:e,clipValueMax:i};return ENGINE.runKernel(ClipByValue,o,c)}const clipByValue$1=op({clipByValue_});function concat1d_(a){return concat$3(a,0)}const concat1d=op({concat1d_});function concat2d_(a,e){return concat$3(a,e)}const concat2d=op({concat2d_});function concat3d_(a,e){return concat$3(a,e)}const concat3d=op({concat3d_});function concat4d_(a,e){return concat$3(a,e)}const concat4d=op({concat4d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2d_(a,e,i,s,o="NHWC",c=[1,1],d){const h=convertToTensor(a,"x","conv2d"),g=convertToTensor(e,"filter","conv2d");let _=h,b=!1;h.rank===3&&(b=!0,_=reshape$4(h,[1,h.shape[0],h.shape[1],h.shape[2]])),assert$1(_.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${_.rank}.`),assert$1(g.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${g.rank}.`),d!=null&&assert$1(isInt(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${s}.`);const $=o==="NHWC"?_.shape[3]:_.shape[1];assert$1($===g.shape[2],()=>`Error in conv2d: depth of input (${$}) must match input depth for filter ${g.shape[2]}.`),assert$1(eitherStridesOrDilationsAreOne(i,c),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const j={x:_,filter:g},_e={strides:i,pad:s,dataFormat:o,dilations:c,dimRoundingMode:d},tt=ENGINE.runKernel(Conv2D$1,j,_e);return b?reshape$4(tt,[tt.shape[1],tt.shape[2],tt.shape[3]]):tt}const conv2d$3=op({conv2d_});function conv1d_(a,e,i,s,o="NWC",c=1,d){const h=convertToTensor(a,"x","conv1d"),g=convertToTensor(e,"filter","conv1d");let _=h,b=!1;h.rank===2&&(b=!0,_=reshape$4(h,[1,h.shape[0],h.shape[1]])),assert$1(_.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${_.rank}.`),assert$1(g.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${g.rank}.`),d!=null&&assert$1(isInt(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${s}.`),assert$1(_.shape[2]===g.shape[1],()=>`Error in conv1d: depth of input (${_.shape[2]}) must match input depth for filter ${g.shape[1]}.`),assert$1(eitherStridesOrDilationsAreOne(i,c),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${i} and dilation '${c}'`),assert$1(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);const $=reshape$4(g,[1,g.shape[0],g.shape[1],g.shape[2]]),j=reshape$4(_,[_.shape[0],1,_.shape[1],_.shape[2]]),nt=conv2d$3(j,$,[1,i],s,"NHWC",[1,c],d);return b?reshape$4(nt,[nt.shape[2],nt.shape[3]]):reshape$4(nt,[nt.shape[0],nt.shape[2],nt.shape[3]])}const conv1d$1=op({conv1d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropInput_(a,e,i,s,o,c="NHWC",d){assert$1(a.length===e.rank,()=>`Length of inShape (${a.length}) and rank of dy (${e.rank}) must match`);let h=a,g=e,_=!1;e.rank===3&&(_=!0,g=reshape$4(e,[1,e.shape[0],e.shape[1],e.shape[2]]),h=[1,a[0],a[1],a[2]]),assert$1(h.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`),assert$1(g.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${g.rank}`),assert$1(i.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${i.rank}`);const b=c==="NHWC"?h[3]:h[1],$=c==="NHWC"?g.shape[3]:g.shape[1];assert$1(b===i.shape[2],()=>`Error in conv2dDerInput: depth of input (${b}) must match input depth for filter ${i.shape[2]}.`),assert$1($===i.shape[3],()=>`Error in conv2dDerInput: depth of output (${$}) must match output depth for filter ${i.shape[3]}.`),d!=null&&assert$1(isInt(o),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${d} but got pad ${o}.`);const j={dy:g,filter:i},_e={strides:s,pad:o,dataFormat:c,dimRoundingMode:d,inputShape:h},tt=ENGINE.runKernel(Conv2DBackpropInput,j,_e);return _?reshape$4(tt,[tt.shape[1],tt.shape[2],tt.shape[3]]):tt}const conv2DBackpropInput$2=op({conv2DBackpropInput_});function conv2dTranspose_(a,e,i,s,o,c){const d=convertToTensor(a,"x","conv2dTranspose"),h=convertToTensor(e,"filter","conv2dTranspose");return conv2DBackpropInput$2(i,d,h,s,o,"NHWC",c)}const conv2dTranspose$1=op({conv2dTranspose_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3d_(a,e,i,s,o="NDHWC",c=[1,1,1]){const d=convertToTensor(a,"x","conv3d"),h=convertToTensor(e,"filter","conv3d");let g=d,_=!1;d.rank===4&&(_=!0,g=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),assert$1(g.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${g.rank}.`),assert$1(h.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${h.rank}.`),assert$1(g.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${g.shape[4]}) must match input depth for filter ${h.shape[3]}.`),assert$1(eitherStridesOrDilationsAreOne(i,c),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`),assert$1(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);const b={x:g,filter:h},$={strides:i,pad:s,dataFormat:o,dilations:c},j=ENGINE.runKernel(Conv3D$1,b,$);return _?reshape$4(j,[j.shape[1],j.shape[2],j.shape[3],j.shape[4]]):j}const conv3d$1=op({conv3d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInput_(a,e,i,s,o){assert$1(a.length===e.rank,()=>`Length of inShape (${a.length}) and rank of dy (${e.rank}) must match`);let c=a,d=e,h=!1;e.rank===4&&(h=!0,d=reshape$4(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),c=[1,a[0],a[1],a[2],a[3]]);const g=c[4],_=d.shape[4];assert$1(c.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${c.length}.`),assert$1(d.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${d.rank}`),assert$1(i.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${i.rank}`),assert$1(g===i.shape[3],()=>`Error in conv3dDerInput: depth of input (${g}) must match input depth for filter ${i.shape[3]}.`),assert$1(_===i.shape[4],()=>`Error in conv3dDerInput: depth of output (${_}) must match output depth for filter ${i.shape[4]}.`);const b={dy:d,filter:i},$={pad:o,strides:s,inputShape:c},j=ENGINE.runKernel(Conv3DBackpropInputV2,b,$);return h?reshape$4(j,[j.shape[1],j.shape[2],j.shape[3],j.shape[4]]):j}const conv3DBackpropInput$1=op({conv3DBackpropInput_});function conv3dTranspose_(a,e,i,s,o){const c=convertToTensor(a,"x","conv3dTranspose"),d=convertToTensor(e,"filter","conv3dTranspose");return conv3DBackpropInput$1(i,c,d,s,o)}const conv3dTranspose=op({conv3dTranspose_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cos_(a){const i={x:convertToTensor(a,"x","cos")};return ENGINE.runKernel(Cos,i)}const cos$4=op({cos_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cosh_(a){const i={x:convertToTensor(a,"x","cosh")};return ENGINE.runKernel(Cosh,i)}const cosh$3=op({cosh_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumsum_(a,e=0,i=!1,s=!1){const c={x:convertToTensor(a,"x","cumsum")},d={axis:e,exclusive:i,reverse:s};return ENGINE.runKernel(Cumsum,c,d)}const cumsum$2=op({cumsum_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function denseBincount_(a,e,i,s=!1){const o=convertToTensor(a,"x","denseBincount"),c=convertToTensor(e,"weights","denseBincount");assert$1(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),assert$1(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),assert$1(i>=0,()=>`size must be non-negative, but got ${i}.`),assert$1(c.size===o.size||c.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${c.shape}.`);const d={x:o,weights:c},h={size:i,binaryOutput:s};return ENGINE.runKernel(DenseBincount,d,h)}const denseBincount$2=op({denseBincount_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthToSpace_(a,e,i="NHWC"){const s=convertToTensor(a,"x","depthToSpace"),o=i==="NHWC"?s.shape[1]:s.shape[2],c=i==="NHWC"?s.shape[2]:s.shape[3],d=i==="NHWC"?s.shape[3]:s.shape[1];assert$1(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${s.shape}`),assert$1(c*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${c} and ${e} for depthToSpace with input shape
        ${s.shape}`),assert$1(d%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${d} for depthToSpace with input shape ${s.shape}`);const h={x:s},g={blockSize:e,dataFormat:i};return ENGINE.runKernel(DepthToSpace,h,g)}const depthToSpace$2=op({depthToSpace_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2d_(a,e,i,s,o="NHWC",c=[1,1],d){const h=convertToTensor(a,"x","depthwiseConv2d"),g=convertToTensor(e,"filter","depthwiseConv2d");let _=h,b=!1;h.rank===3&&(b=!0,_=reshape$4(h,[1,h.shape[0],h.shape[1],h.shape[2]])),assert$1(_.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${_.rank}.`),assert$1(g.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${g.rank}.`),assert$1(_.shape[3]===g.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${_.shape[3]}) must match the inChannels dimension in filter ${g.shape[2]}.`),d!=null&&assert$1(isInt(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${s}.`);const $={x:_,filter:g},j={strides:i,pad:s,dataFormat:o,dilations:c,dimRoundingMode:d},_e=ENGINE.runKernel(DepthwiseConv2dNative,$,j);return b?reshape$4(_e,[_e.shape[1],_e.shape[2],_e.shape[3]]):_e}const depthwiseConv2d$3=op({depthwiseConv2d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function diag_(a){const i={x:convertToTensor(a,"x","diag")};return ENGINE.runKernel(Diag,i)}const diag$3=op({diag_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dilation2d_(a,e,i,s,o=[1,1],c="NHWC"){const d=convertToTensor(a,"x","dilation2d"),h=convertToTensor(e,"filter","dilation2d");assert$1(d.rank===3||d.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${d.rank}.`),assert$1(h.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${h.rank}.`),assert$1(c==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${c}`);let g=d,_=!1;d.rank===3&&(g=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2]]),_=!0);const b={x:g,filter:h},$={strides:i,pad:s,dilations:o},j=ENGINE.runKernel(Dilation2D,b,$);return _?reshape$4(j,[j.shape[1],j.shape[2],j.shape[3]]):j}const dilation2d=op({dilation2d_});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getBroadcastDims$1(a,e){const i=a.length,s=[];for(let o=0;o<i;o++){const c=i-1-o,d=a[c]||1;(e[e.length-1-o]||1)>1&&d===1&&s.unshift(c)}return s}function getReductionAxes(a,e){const i=[];for(let s=0;s<e.length;s++){const o=a[a.length-s-1],c=e.length-s-1,d=e[c];(o==null||o===1&&d>1)&&i.unshift(c)}return i}function assertAndGetBroadcastShape(a,e){const i=[],s=Math.max(a.length,e.length);for(let o=0;o<s;o++){let c=a[a.length-o-1];c==null&&(c=1);let d=e[e.length-o-1];if(d==null&&(d=1),c===1)i.unshift(d);else if(d===1)i.unshift(c);else if(c!==d){const h=`Operands could not be broadcast together with shapes ${a} and ${e}.`;throw Error(h)}else i.unshift(c)}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function equal_(a,e){let i=convertToTensor(a,"a","equal"),s=convertToTensor(e,"b","equal");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(Equal,o)}const equal$3=op({equal_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function where_(a,e,i){const s=convertToTensor(e,"a","where"),o=convertToTensor(i,"b","where"),c=convertToTensor(a,"condition","where","bool"),d=assertAndGetBroadcastShape(s.shape,o.shape),h=broadcastTo(s,d),g=broadcastTo(o,d);c.rank===1&&assert$1(c.shape[0]===s.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),c.rank!==1&&assertShapesMatch(c.shape,g.shape,"Error in where: ");const _={condition:c,t:h,e:g};return ENGINE.runKernel(Select,_)}const where=op({where_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike_(a){const i={x:convertToTensor(a,"x","zerosLike")};return ENGINE.runKernel(ZerosLike,i)}const zerosLike$2=op({zerosLike_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function divNoNan_(a,e){let i=convertToTensor(a,"a","div"),s=convertToTensor(e,"b","div");[i,s]=makeTypesMatch(i,s);const o=div$2(i,s),c=zerosLike$2(o),d=equal$3(s,c);return where(d,c,o)}const divNoNan=op({divNoNan_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dot_(a,e){const i=convertToTensor(a,"t1","dot"),s=convertToTensor(e,"t2","dot");assert$1((i.rank===1||i.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${i.rank} and ${s.rank}.`);const o=i.rank===1?i.size:i.shape[1],c=s.rank===1?s.size:s.shape[0];if(assert$1(o===c,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${c}.`),i.rank===1&&s.rank===1){const d=reshape$4(i,[1,-1]),h=reshape$4(s,[-1,1]),g=matMul$1(d,h);return reshape$4(g,[])}else if(i.rank===1&&s.rank===2){const d=reshape$4(i,[1,-1]),h=reshape$4(s,[s.shape[0],s.shape[1]]),g=matMul$1(d,h);return reshape$4(g,[g.size])}else if(i.rank===2&&s.rank===1){const d=reshape$4(s,[-1,1]),h=matMul$1(i,d);return reshape$4(h,[h.size])}else{const d=reshape$4(s,[s.shape[0],s.shape[1]]);return matMul$1(i,d)}}const dot$3=op({dot_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function elu_(a){const i={x:convertToTensor(a,"x","elu")};return ENGINE.runKernel(Elu$1,i)}const elu$4=op({elu_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function erf_(a){let e=convertToTensor(a,"x","erf");assert$1(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=cast$3(e,"float32"));const i={x:e};return ENGINE.runKernel(Erf,i)}const erf$2=op({erf_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exp_(a){const i={x:convertToTensor(a,"x","exp")};return ENGINE.runKernel(Exp,i)}const exp$3=op({exp_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims_(a,e=0){const i=convertToTensor(a,"x","expandDims","string_or_numeric");assert$1(e<=i.rank,()=>"Axis must be <= rank of the tensor");const s={input:i},o={dim:e};return ENGINE.runKernel(ExpandDims,s,o)}const expandDims$3=op({expandDims_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expm1_(a){const i={x:convertToTensor(a,"x","expm1")};return ENGINE.runKernel(Expm1,i)}const expm1$2=op({expm1_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile_(a,e){const i=convertToTensor(a,"x","tile","string_or_numeric");assert$1(i.rank===e.length,()=>`Error in transpose: rank of input ${i.rank} must match length of reps ${e}.`);const s={x:i},o={reps:e};return ENGINE.runKernel(Tile,s,o)}const tile$3=op({tile_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye_(a,e,i,s="float32"){e==null&&(e=a);const o=buffer([a,e],s),c=a<=e?a:e;for(let h=0;h<c;++h)o.set(1,h,h);const d=reshape$4(o.toTensor(),[a,e]);if(i==null)return d;if(i.length===1)return tile$3(expandDims$3(d,0),[i[0],1,1]);if(i.length===2)return tile$3(expandDims$3(expandDims$3(d,0),0),[i[0],i[1],1,1]);if(i.length===3)return tile$3(expandDims$3(expandDims$3(expandDims$3(d,0),0),0),[i[0],i[1],i[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${i.length}D.`)}const eye=op({eye_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill$2(a,e,i){const s={shape:a,value:e,dtype:i};return ENGINE.runKernel(Fill,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function floor_(a){const i={x:convertToTensor(a,"x","floor")};return ENGINE.runKernel(Floor,i)}const floor$3=op({floor_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gather_(a,e,i=0,s=0){const o=convertToTensor(a,"x","gather"),c=convertToTensor(e,"indices","gather","int32"),d={x:o,indices:c},h={axis:i,batchDims:s};return ENGINE.runKernel(GatherV2,d,h)}const gather$1=op({gather_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function greater_(a,e){let i=convertToTensor(a,"a","greater"),s=convertToTensor(e,"b","greater");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(Greater,o)}const greater$3=op({greater_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function greaterEqual_(a,e){let i=convertToTensor(a,"a","greaterEqual"),s=convertToTensor(e,"b","greaterEqual");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(GreaterEqual,o)}const greaterEqual$2=op({greaterEqual_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag_(a){const i={input:convertToTensor(a,"input","imag")};return ENGINE.runKernel(Imag,i)}const imag$2=op({imag_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isFinite_(a){const i={x:convertToTensor(a,"x","isFinite")};return ENGINE.runKernel(IsFinite,i)}const isFinite$3=op({isFinite_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isInf_(a){const i={x:convertToTensor(a,"x","isInf")};return ENGINE.runKernel(IsInf,i)}const isInf$2=op({isInf_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isNaN_(a){const i={x:convertToTensor(a,"x","isNaN")};return ENGINE.runKernel(IsNan,i)}const isNaN$3=op({isNaN_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function leakyRelu_(a,e=.2){const s={x:convertToTensor(a,"x","leakyRelu")},o={alpha:e};return ENGINE.runKernel(LeakyRelu,s,o)}const leakyRelu$2=op({leakyRelu_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function less_(a,e){let i=convertToTensor(a,"a","less"),s=convertToTensor(e,"b","less");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(Less,o)}const less$3=op({less_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lessEqual_(a,e){let i=convertToTensor(a,"a","lessEqual"),s=convertToTensor(e,"b","lessEqual");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(LessEqual,o)}const lessEqual$2=op({lessEqual_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linspace(a,e,i){if(i<=0)throw new Error("The number of values should be positive.");const s={start:a,stop:e,num:i};return ENGINE.runKernel(LinSpace,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function localResponseNormalization_(a,e=5,i=1,s=1,o=.5){const c=convertToTensor(a,"x","localResponseNormalization");assert$1(c.rank===4||c.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${c.rank}.`),assert$1(isInt(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let d=c,h=!1;c.rank===3&&(h=!0,d=reshape$4(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const g={x:d},_={depthRadius:e,bias:i,alpha:s,beta:o},b=ENGINE.runKernel(LRN,g,_);return h?reshape$4(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const localResponseNormalization=op({localResponseNormalization_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function log_(a){const i={x:convertToTensor(a,"x","log")};return ENGINE.runKernel(Log,i)}const log$4=op({log_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function log1p_(a){const i={x:convertToTensor(a,"x","log1p")};return ENGINE.runKernel(Log1p,i)}const log1p$2=op({log1p_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function grad(a){return assert$1(isFunction$1(a),()=>"The f passed in grad(f) must be a function"),(e,i)=>{const s=convertToTensor(e,"x","tf.grad","string_or_numeric"),o=i!=null?convertToTensor(i,"dy","tf.grad"):null;return ENGINE.tidy(()=>{const{value:c,grads:d}=ENGINE.gradients(()=>a(s),[s],o);return o!=null&&assertShapesMatch(c.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),checkGrads(d),d[0]})}}function grads(a){return assert$1(isFunction$1(a),()=>"The f passed in grads(f) must be a function"),(e,i)=>{assert$1(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=convertToTensorArray(e,"args","tf.grads","string_or_numeric"),o=i!=null?convertToTensor(i,"dy","tf.grads"):null;return ENGINE.tidy(()=>{const{value:c,grads:d}=ENGINE.gradients(()=>a(...s),s,o);return o!=null&&assertShapesMatch(c.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(d),d})}}function valueAndGrad(a){return assert$1(isFunction$1(a),()=>"The f passed in valueAndGrad(f) must be a function"),(e,i)=>{assert$1(e instanceof Tensor,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),assert$1(i==null||i instanceof Tensor,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:o}=ENGINE.gradients(()=>a(e),[e],i);return checkGrads(s),{grad:s[0],value:o}}}function valueAndGrads(a){return assert$1(isFunction$1(a),()=>"The f passed in valueAndGrads(f) must be a function"),(e,i)=>{assert$1(Array.isArray(e)&&e.every(o=>o instanceof Tensor),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),assert$1(i==null||i instanceof Tensor,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=ENGINE.gradients(()=>a(...e),e,i);return i!=null&&assertShapesMatch(s.value.shape,i.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),checkGrads(s.grads),s}}function variableGrads(a,e){assert$1(isFunction$1(a),()=>"The f passed in variableGrads(f) must be a function"),assert$1(e==null||Array.isArray(e)&&e.every(_=>_ instanceof Variable),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const i=e!=null;if(!i){e=[];for(const _ in ENGINE.registeredVariables)e.push(ENGINE.registeredVariables[_])}const s=i?e.filter(_=>!_.trainable):null,o=e.length;e=e.filter(_=>_.trainable),assert$1(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);const c=!0,{value:d,grads:h}=ENGINE.gradients(a,e,null,c);assert$1(h.some(_=>_!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),assert$1(d.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${d.rank} tensor`);const g={};return e.forEach((_,b)=>{h[b]!=null&&(g[_.name]=h[b])}),s!=null&&s.forEach(_=>g[_.name]=null),{value:d,grads:g}}function customGrad(a){return ENGINE.customGrad(a)}function checkGrads(a){if(a.filter(i=>i==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function neg_(a){const i={x:convertToTensor(a,"x","neg")};return ENGINE.runKernel(Neg,i)}const neg$2=op({neg_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softplus_(a){const i={x:convertToTensor(a,"x","softplus")};return ENGINE.runKernel(Softplus$1,i)}const softplus$2=op({softplus_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logSigmoid_(a){const e=convertToTensor(a,"x","logSigmoid");return customGrad(s=>({value:neg$2(softplus$2(neg$2(s))),gradFunc:d=>mul$1(d,sigmoid$2(neg$2(s)))}))(e)}const logSigmoid=op({logSigmoid_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max_(a,e=null,i=!1){const o={x:convertToTensor(a,"x","max")},c={reductionIndices:e,keepDims:i};return ENGINE.runKernel(Max,o,c)}const max$4=op({max_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sub_(a,e){let i=convertToTensor(a,"a","sub"),s=convertToTensor(e,"b","sub");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(Sub,o)}const sub$3=op({sub_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum_(a,e=null,i=!1){let s=convertToTensor(a,"x","sum");s.dtype==="bool"&&(s=cast$3(s,"int32"));const o={x:s},c={axis:e,keepDims:i};return ENGINE.runKernel(Sum,o,c)}const sum$3=op({sum_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logSoftmax_(a,e=-1){const i=convertToTensor(a,"logits","logSoftmax");if(e===-1&&(e=i.rank-1),e!==i.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${i.rank} and axis was ${e}`);return customGrad((o,c)=>{const h=max$4(o,e,!0),g=sub$3(o,h),_=sub$3(cast$3(g,"float32"),log$4(sum$3(exp$3(g),e,!0)));return c([_]),{value:_,gradFunc:($,j)=>{const[_e]=j,tt=!0,et=exp$3(_e);return sub$3($,mul$1(sum$3($,e,tt),et))}}})(i)}const logSoftmax=op({logSoftmax_});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axesAreInnerMostDims(a,e){for(let i=0;i<a.length;++i)if(a[a.length-i-1]!==e-1-i)return!1;return!0}function combineLocations(a,e,i){const s=a.length+e.length,o=[];let c=0,d=0;for(let h=0;h<s;h++)i.indexOf(h)===-1?o.push(a[c++]):o.push(e[d++]);return o}function computeOutAndReduceShapes(a,e){const i=[],s=a.length;for(let c=0;c<s;c++)e.indexOf(c)===-1&&i.push(a[c]);const o=e.map(c=>a[c]);return[i,o]}function expandShapeToKeepDim(a,e){const i=e.map(s=>1);return combineLocations(a,i,e)}function assertAxesAreInnerMostDims(a,e,i){assert$1(axesAreInnerMostDims(e,i),()=>`${a} supports only inner-most axes for now. Got axes ${e} and rank-${i} input.`)}function getAxesPermutation(a,e){if(axesAreInnerMostDims(a,e))return null;const i=[];for(let s=0;s<e;++s)a.indexOf(s)===-1&&i.push(s);return a.forEach(s=>i.push(s)),i}function getUndoAxesPermutation(a){return a.map((e,i)=>[i,e]).sort((e,i)=>e[1]-i[1]).map(e=>e[0])}function getInnerMostAxes(a,e){const i=[];for(let s=e-a;s<e;++s)i.push(s);return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logSumExp_(a,e=null,i=!1){const s=convertToTensor(a,"x","logSumExp"),o=parseAxisParam(e,s.shape),c=max$4(s,o,!0),d=sub$3(s,c),h=exp$3(d),g=sum$3(h,o),_=log$4(g),b=add$4(reshape$4(c,_.shape),_);if(i){const $=expandShapeToKeepDim(b.shape,o);return reshape$4(b,$)}return b}const logSumExp=op({logSumExp_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalAnd_(a,e){const i=convertToTensor(a,"a","logicalAnd","bool"),s=convertToTensor(e,"b","logicalAnd","bool");assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(LogicalAnd,o)}const logicalAnd$2=op({logicalAnd_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalNot_(a){const i={x:convertToTensor(a,"x","logicalNot","bool")};return ENGINE.runKernel(LogicalNot,i)}const logicalNot$2=op({logicalNot_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalOr_(a,e){const i=convertToTensor(a,"a","logicalOr","bool"),s=convertToTensor(e,"b","logicalOr","bool");assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(LogicalOr,o)}const logicalOr$2=op({logicalOr_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logicalXor_(a,e){const i=convertToTensor(a,"a","logicalXor","bool"),s=convertToTensor(e,"b","logicalXor","bool");return assertAndGetBroadcastShape(i.shape,s.shape),logicalAnd$2(logicalOr$2(a,e),logicalNot$2(logicalAnd$2(a,e)))}const logicalXor=op({logicalXor_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool_(a,e,i,s,o){const c=convertToTensor(a,"x","maxPool"),d=1;let h=c,g=!1;c.rank===3&&(g=!0,h=reshape$4(c,[1,c.shape[0],c.shape[1],c.shape[2]])),assert$1(h.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${h.rank}.`),assert$1(eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`),o!=null&&assert$1(isInt(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const _={x:h},b={filterSize:e,strides:i,pad:s,dimRoundingMode:o},$=ENGINE.runKernel(MaxPool,_,b);return g?reshape$4($,[$.shape[1],$.shape[2],$.shape[3]]):$}const maxPool$2=op({maxPool_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3d_(a,e=[1,1,1],i,s,o,c="NDHWC"){const d=convertToTensor(a,"x","maxPool3d");let h=d,g=!1;d.rank===4&&(g=!0,h=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),assert$1(h.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${h.rank}.`),assert$1(c==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${c}`),o!=null&&assert$1(isInt(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const _={x:h},b={filterSize:e,strides:i,pad:s,dimRoundingMode:o,dataFormat:c},$=ENGINE.runKernel(MaxPool3D,_,b);return g?reshape$4($,[$.shape[1],$.shape[2],$.shape[3],$.shape[4]]):$}const maxPool3d$1=op({maxPool3d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolWithArgmax_(a,e,i,s,o=!1){const d={x:convertToTensor(a,"x","maxPoolWithArgmax")},h={filterSize:e,strides:i,pad:s,includeBatchInIndex:o},g=ENGINE.runKernel(MaxPoolWithArgmax,d,h);return{result:g[0],indexes:g[1]}}const maxPoolWithArgmax=op({maxPoolWithArgmax_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maximum_(a,e){let i=convertToTensor(a,"a","maximum"),s=convertToTensor(e,"b","maximum");[i,s]=makeTypesMatch(i,s),i.dtype==="bool"&&(i=cast$3(i,"int32"),s=cast$3(s,"int32")),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(Maximum$1,o)}const maximum$3=op({maximum_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mean_(a,e=null,i=!1){const o={x:convertToTensor(a,"x","mean")},c={axis:e,keepDims:i};return ENGINE.runKernel(Mean,o,c)}const mean$1=op({mean_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function min_(a,e=null,i=!1){const o={x:convertToTensor(a,"x","min")},c={axis:e,keepDims:i};return ENGINE.runKernel(Min,o,c)}const min$4=op({min_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function minimum_(a,e){let i=convertToTensor(a,"a","minimum"),s=convertToTensor(e,"b","minimum");[i,s]=makeTypesMatch(i,s),i.dtype==="bool"&&(i=cast$3(i,"int32"),s=cast$3(s,"int32")),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(Minimum$1,o)}const minimum$3=op({minimum_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mirrorPad_(a,e,i){assert$1(i==="reflect"||i==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${i}.`);const s=convertToTensor(a,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");assert$1(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const o=i==="reflect"?1:0;for(let h=0;h<s.rank;h++)assert$1(e[h].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),assert$1(e[h][0]>=0&&e[h][0]<=s.shape[h]-o&&e[h][1]>=0&&e[h][1]<=s.shape[h]-o,()=>`Padding in dimension ${h} cannot be greater than or equal to ${s.shape[h]-o} or less than 0 for input of shape ${s.shape}`);const c={paddings:e,mode:i},d={x:s};return ENGINE.runKernel(MirrorPad,d,c)}const mirrorPad$1=op({mirrorPad_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mod_(a,e){let i=convertToTensor(a,"a","mod"),s=convertToTensor(e,"b","mod");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(Mod,o)}const mod$3=op({mod_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function square_(a){const e=convertToTensor(a,"x","square"),i={};return ENGINE.runKernel("Square",{x:e},i)}const square$2=op({square_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moments_(a,e=null,i=!1){a=convertToTensor(a,"x","moments");const s=parseAxisParam(e,a.shape),o=mean$1(a,s,i);let c=o.shape;i||(c=expandShapeToKeepDim(o.shape,s));const d=square$2(sub$3(cast$3(a,"float32"),reshape$4(o,c))),h=mean$1(d,s,i);return{mean:o,variance:h}}const moments=op({moments_});function multiRNNCell_(a,e,i,s){const o=convertToTensor(e,"data","multiRNNCell"),c=convertToTensorArray(i,"c","multiRNNCell"),d=convertToTensorArray(s,"h","multiRNNCell");let h=o;const g=[];for(let $=0;$<a.length;$++){const j=a[$](h,c[$],d[$]);g.push(j[0]),g.push(j[1]),h=j[1]}const _=[],b=[];for(let $=0;$<g.length;$+=2)_.push(g[$]),b.push(g[$+1]);return[_,b]}const multiRNNCell=op({multiRNNCell_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function multinomial_(a,e,i,s=!1){const o=convertToTensor(a,"logits","multinomial"),c=o.size,d=o.rank;if(c<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${c}.`);if(d>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${d}`);i=i||Math.random();const g={logits:d===1?reshape$4(o,[1,-1]):o},_={numSamples:e,seed:i,normalized:s},b=ENGINE.runKernel(Multinomial,g,_);return d===1?reshape$4(b,[b.size]):b}const multinomial$2=op({multinomial_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function notEqual_(a,e){let i=convertToTensor(a,"a","notEqual"),s=convertToTensor(e,"b","notEqual");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s};return ENGINE.runKernel(NotEqual,o)}const notEqual$2=op({notEqual_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros$4(a,e="float32"){if(e==="complex64"){const s=zeros$4(a,"float32"),o=zeros$4(a,"float32");return complex$4(s,o)}const i=makeZerosTypedArray(sizeFromShape(a),e);return ENGINE.makeTensor(i,a,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ones$1(a,e="float32"){if(e==="complex64"){const s=ones$1(a,"float32"),o=zeros$4(a,"float32");return complex$4(s,o)}const i=makeOnesTypedArray(sizeFromShape(a),e);return ENGINE.makeTensor(i,a,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike_(a){const i={x:convertToTensor(a,"x","onesLike")};return ENGINE.runKernel(OnesLike,i)}const onesLike$2=op({onesLike_});function outerProduct_(a,e){const i=convertToTensor(a,"v1","outerProduct"),s=convertToTensor(e,"v2","outerProduct");assert$1(i.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${i.rank} and ${s.rank}.`);const o=reshape$4(i,[-1,1]),c=reshape$4(s,[1,-1]);return matMul$1(o,c)}const outerProduct=op({outerProduct_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pad_(a,e,i=0){const s=convertToTensor(a,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:e,constantValue:i},c={x:s};return ENGINE.runKernel(PadV2,c,o)}const pad=op({pad_});function pad1d_(a,e,i=0){return assert$1(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),pad(a,[e],i)}const pad1d=op({pad1d_});function pad2d_(a,e,i=0){return assert$1(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),pad(a,e,i)}const pad2d=op({pad2d_});function pad3d_(a,e,i=0){return assert$1(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),pad(a,e,i)}const pad3d=op({pad3d_});function pad4d_(a,e,i=0){return assert$1(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),pad(a,e,i)}const pad4d=op({pad4d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function spaceToBatchND_(a,e,i){const s=convertToTensor(a,"x","spaceToBatchND");assert$1(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),assert$1(i.length===e.length,()=>`paddings.shape[0] ${i.length} must be equal to [blockShape] ${e.length}`),assert$1(s.shape.reduce((d,h,g)=>g>0&&g<=e.length?d&&(h+i[g-1][0]+i[g-1][1])%e[g-1]===0:d,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${i.toString()} must be divisible by blockShapes ${e.toString()}`);const o={x:s},c={blockShape:e,paddings:i};return ENGINE.runKernel(SpaceToBatchND,o,c)}const spaceToBatchND$2=op({spaceToBatchND_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pool_(a,e,i,s,o,c){o==null&&(o=[1,1]),c==null&&(c=1),s===0&&(s="valid");const d=convertToTensor(a,"x","maxPool");let h=d,g=!1;d.rank===3&&(g=!0,h=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2]])),assert$1(eitherStridesOrDilationsAreOne(c,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${c} and dilations '${o}'`);const _=computePool2DInfo(h.shape,e,c,o,s),b=[_.dilationHeight,_.dilationWidth];let $;s==="same"?$=withSpaceToBatchBasePaddings([_.filterHeight,_.filterWidth],b):$=[[0,0],[0,0]];const j=b[0]===1&&b[1]===1,[_e,tt]=requiredSpaceToBatchPaddings([_.inHeight,_.inWidth],b,$),et=j?s:"valid",nt=j?h:spaceToBatchND$2(h,b,_e),it=(i==="avg"?()=>avgPool$2(nt,e,c,et):()=>maxPool$2(nt,e,c,et))(),at=j?it:batchToSpaceND$2(it,b,tt);return g?reshape$4(at,[at.shape[1],at.shape[2],at.shape[3]]):at}function requiredSpaceToBatchPaddings(a,e,i){const s=i.map(b=>b[0]),o=i.map(b=>b[1]),c=a.concat(s,o),d=e.map((b,$)=>(b-c[$]%b)%b),h=o.map((b,$)=>b+d[$]),g=e.map((b,$)=>[s[$],h[$]]),_=e.map((b,$)=>[0,d[$]]);return[g,_]}function withSpaceToBatchBasePaddings(a,e){const s=a.map((d,h)=>d+(d-1)*(e[h]-1)).map(d=>d-1),o=s.map(d=>Math.floor(d/2)),c=s.map((d,h)=>d-o[h]);return s.map((d,h)=>[o[h],c[h]])}const pool$2=op({pool_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pow_(a,e){let i=convertToTensor(a,"base","pow"),s=convertToTensor(e,"exp","pow");[i,s]=makeTypesMatch(i,s);const o={a:i,b:s};return ENGINE.runKernel(Pow,o)}const pow$4=op({pow_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prelu_(a,e){const i=convertToTensor(a,"x","prelu"),s=convertToTensor(e,"alpha","prelu"),o={x:i,alpha:s};return ENGINE.runKernel(Prelu,o)}const prelu$3=op({prelu_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prod_(a,e=null,i=!1){let s=convertToTensor(a,"x","prod");s.dtype==="bool"&&(s=cast$3(s,"int32"));const o={x:s},c={axis:e,keepDims:i};return ENGINE.runKernel(Prod,o,c)}const prod$2=op({prod_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rand_(a,e,i){const s=sizeFromShape(a);let o=null;if(i==null||i==="float32")o=new Float32Array(s);else if(i==="int32")o=new Int32Array(s);else if(i==="bool")o=new Uint8Array(s);else throw new Error(`Unknown data type ${i}`);for(let c=0;c<s;c++)o[c]=e();return ENGINE.makeTensor(o,a,i)}const rand=op({rand_});var alea$1={exports:{}};alea$1.exports;(function(a){(function(e,i,s){function o(g){var _=this,b=h();_.next=function(){var $=2091639*_.s0+_.c*23283064365386963e-26;return _.s0=_.s1,_.s1=_.s2,_.s2=$-(_.c=$|0)},_.c=1,_.s0=b(" "),_.s1=b(" "),_.s2=b(" "),_.s0-=b(g),_.s0<0&&(_.s0+=1),_.s1-=b(g),_.s1<0&&(_.s1+=1),_.s2-=b(g),_.s2<0&&(_.s2+=1),b=null}function c(g,_){return _.c=g.c,_.s0=g.s0,_.s1=g.s1,_.s2=g.s2,_}function d(g,_){var b=new o(g),$=_&&_.state,j=b.next;return j.int32=function(){return b.next()*4294967296|0},j.double=function(){return j()+(j()*2097152|0)*11102230246251565e-32},j.quick=j,$&&(typeof $=="object"&&c($,b),j.state=function(){return c(b,{})}),j}function h(){var g=4022871197,_=function(b){b=b.toString();for(var $=0;$<b.length;$++){g+=b.charCodeAt($);var j=.02519603282416938*g;g=j>>>0,j-=g,j*=g,g=j>>>0,j-=g,g+=j*4294967296}return(g>>>0)*23283064365386963e-26};return _}i&&i.exports?i.exports=d:this.alea=d})(commonjsGlobal$1,a)})(alea$1);var aleaExports=alea$1.exports,xor128$1={exports:{}};xor128$1.exports;(function(a){(function(e,i,s){function o(h){var g=this,_="";g.x=0,g.y=0,g.z=0,g.w=0,g.next=function(){var $=g.x^g.x<<11;return g.x=g.y,g.y=g.z,g.z=g.w,g.w^=g.w>>>19^$^$>>>8},h===(h|0)?g.x=h:_+=h;for(var b=0;b<_.length+64;b++)g.x^=_.charCodeAt(b)|0,g.next()}function c(h,g){return g.x=h.x,g.y=h.y,g.z=h.z,g.w=h.w,g}function d(h,g){var _=new o(h),b=g&&g.state,$=function(){return(_.next()>>>0)/4294967296};return $.double=function(){do var j=_.next()>>>11,_e=(_.next()>>>0)/4294967296,tt=(j+_e)/(1<<21);while(tt===0);return tt},$.int32=_.next,$.quick=$,b&&(typeof b=="object"&&c(b,_),$.state=function(){return c(_,{})}),$}i&&i.exports?i.exports=d:this.xor128=d})(commonjsGlobal$1,a)})(xor128$1);var xor128Exports=xor128$1.exports,xorwow$1={exports:{}};xorwow$1.exports;(function(a){(function(e,i,s){function o(h){var g=this,_="";g.next=function(){var $=g.x^g.x>>>2;return g.x=g.y,g.y=g.z,g.z=g.w,g.w=g.v,(g.d=g.d+362437|0)+(g.v=g.v^g.v<<4^($^$<<1))|0},g.x=0,g.y=0,g.z=0,g.w=0,g.v=0,h===(h|0)?g.x=h:_+=h;for(var b=0;b<_.length+64;b++)g.x^=_.charCodeAt(b)|0,b==_.length&&(g.d=g.x<<10^g.x>>>4),g.next()}function c(h,g){return g.x=h.x,g.y=h.y,g.z=h.z,g.w=h.w,g.v=h.v,g.d=h.d,g}function d(h,g){var _=new o(h),b=g&&g.state,$=function(){return(_.next()>>>0)/4294967296};return $.double=function(){do var j=_.next()>>>11,_e=(_.next()>>>0)/4294967296,tt=(j+_e)/(1<<21);while(tt===0);return tt},$.int32=_.next,$.quick=$,b&&(typeof b=="object"&&c(b,_),$.state=function(){return c(_,{})}),$}i&&i.exports?i.exports=d:this.xorwow=d})(commonjsGlobal$1,a)})(xorwow$1);var xorwowExports=xorwow$1.exports,xorshift7$1={exports:{}};xorshift7$1.exports;(function(a){(function(e,i,s){function o(h){var g=this;g.next=function(){var b=g.x,$=g.i,j,_e;return j=b[$],j^=j>>>7,_e=j^j<<24,j=b[$+1&7],_e^=j^j>>>10,j=b[$+3&7],_e^=j^j>>>3,j=b[$+4&7],_e^=j^j<<7,j=b[$+7&7],j=j^j<<13,_e^=j^j<<9,b[$]=_e,g.i=$+1&7,_e};function _(b,$){var j,_e=[];if($===($|0))_e[0]=$;else for($=""+$,j=0;j<$.length;++j)_e[j&7]=_e[j&7]<<15^$.charCodeAt(j)+_e[j+1&7]<<13;for(;_e.length<8;)_e.push(0);for(j=0;j<8&&_e[j]===0;++j);for(j==8?_e[7]=-1:_e[j],b.x=_e,b.i=0,j=256;j>0;--j)b.next()}_(g,h)}function c(h,g){return g.x=h.x.slice(),g.i=h.i,g}function d(h,g){h==null&&(h=+new Date);var _=new o(h),b=g&&g.state,$=function(){return(_.next()>>>0)/4294967296};return $.double=function(){do var j=_.next()>>>11,_e=(_.next()>>>0)/4294967296,tt=(j+_e)/(1<<21);while(tt===0);return tt},$.int32=_.next,$.quick=$,b&&(b.x&&c(b,_),$.state=function(){return c(_,{})}),$}i&&i.exports?i.exports=d:this.xorshift7=d})(commonjsGlobal$1,a)})(xorshift7$1);var xorshift7Exports=xorshift7$1.exports,xor4096$1={exports:{}};xor4096$1.exports;(function(a){(function(e,i,s){function o(h){var g=this;g.next=function(){var b=g.w,$=g.X,j=g.i,_e,tt;return g.w=b=b+1640531527|0,tt=$[j+34&127],_e=$[j=j+1&127],tt^=tt<<13,_e^=_e<<17,tt^=tt>>>15,_e^=_e>>>12,tt=$[j]=tt^_e,g.i=j,tt+(b^b>>>16)|0};function _(b,$){var j,_e,tt,et,nt,rt=[],it=128;for($===($|0)?(_e=$,$=null):($=$+"\0",_e=0,it=Math.max(it,$.length)),tt=0,et=-32;et<it;++et)$&&(_e^=$.charCodeAt((et+32)%$.length)),et===0&&(nt=_e),_e^=_e<<10,_e^=_e>>>15,_e^=_e<<4,_e^=_e>>>13,et>=0&&(nt=nt+1640531527|0,j=rt[et&127]^=_e+nt,tt=j==0?tt+1:0);for(tt>=128&&(rt[($&&$.length||0)&127]=-1),tt=127,et=4*128;et>0;--et)_e=rt[tt+34&127],j=rt[tt=tt+1&127],_e^=_e<<13,j^=j<<17,_e^=_e>>>15,j^=j>>>12,rt[tt]=_e^j;b.w=nt,b.X=rt,b.i=tt}_(g,h)}function c(h,g){return g.i=h.i,g.w=h.w,g.X=h.X.slice(),g}function d(h,g){h==null&&(h=+new Date);var _=new o(h),b=g&&g.state,$=function(){return(_.next()>>>0)/4294967296};return $.double=function(){do var j=_.next()>>>11,_e=(_.next()>>>0)/4294967296,tt=(j+_e)/(1<<21);while(tt===0);return tt},$.int32=_.next,$.quick=$,b&&(b.X&&c(b,_),$.state=function(){return c(_,{})}),$}i&&i.exports?i.exports=d:this.xor4096=d})(commonjsGlobal$1,a)})(xor4096$1);var xor4096Exports=xor4096$1.exports,tychei$1={exports:{}};tychei$1.exports;(function(a){(function(e,i,s){function o(h){var g=this,_="";g.next=function(){var $=g.b,j=g.c,_e=g.d,tt=g.a;return $=$<<25^$>>>7^j,j=j-_e|0,_e=_e<<24^_e>>>8^tt,tt=tt-$|0,g.b=$=$<<20^$>>>12^j,g.c=j=j-_e|0,g.d=_e<<16^j>>>16^tt,g.a=tt-$|0},g.a=0,g.b=0,g.c=-1640531527,g.d=1367130551,h===Math.floor(h)?(g.a=h/4294967296|0,g.b=h|0):_+=h;for(var b=0;b<_.length+20;b++)g.b^=_.charCodeAt(b)|0,g.next()}function c(h,g){return g.a=h.a,g.b=h.b,g.c=h.c,g.d=h.d,g}function d(h,g){var _=new o(h),b=g&&g.state,$=function(){return(_.next()>>>0)/4294967296};return $.double=function(){do var j=_.next()>>>11,_e=(_.next()>>>0)/4294967296,tt=(j+_e)/(1<<21);while(tt===0);return tt},$.int32=_.next,$.quick=$,b&&(typeof b=="object"&&c(b,_),$.state=function(){return c(_,{})}),$}i&&i.exports?i.exports=d:this.tychei=d})(commonjsGlobal$1,a)})(tychei$1);var tycheiExports=tychei$1.exports,seedrandom$1={exports:{}};const __viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(__viteBrowserExternal$1);(function(a){(function(e,i){var s=this,o=256,c=6,d=52,h="random",g=i.pow(o,c),_=i.pow(2,d),b=_*2,$=o-1,j;function _e(st,ot,ct){var lt=[];ot=ot==!0?{entropy:!0}:ot||{};var dt=rt(nt(ot.entropy?[st,at(e)]:st??it(),3),lt),xt=new tt(lt),ut=function(){for(var ft=xt.g(c),mt=g,yt=0;ft<_;)ft=(ft+yt)*o,mt*=o,yt=xt.g(1);for(;ft>=b;)ft/=2,mt/=2,yt>>>=1;return(ft+yt)/mt};return ut.int32=function(){return xt.g(4)|0},ut.quick=function(){return xt.g(4)/4294967296},ut.double=ut,rt(at(xt.S),e),(ot.pass||ct||function(ft,mt,yt,St){return St&&(St.S&&et(St,xt),ft.state=function(){return et(xt,{})}),yt?(i[h]=ft,mt):ft})(ut,dt,"global"in ot?ot.global:this==i,ot.state)}i["seed"+h]=_e;function tt(st){var ot,ct=st.length,lt=this,dt=0,xt=lt.i=lt.j=0,ut=lt.S=[];for(ct||(st=[ct++]);dt<o;)ut[dt]=dt++;for(dt=0;dt<o;dt++)ut[dt]=ut[xt=$&xt+st[dt%ct]+(ot=ut[dt])],ut[xt]=ot;(lt.g=function(ft){for(var mt,yt=0,St=lt.i,Et=lt.j,vt=lt.S;ft--;)mt=vt[St=$&St+1],yt=yt*o+vt[$&(vt[St]=vt[Et=$&Et+mt])+(vt[Et]=mt)];return lt.i=St,lt.j=Et,yt})(o)}function et(st,ot){return ot.i=st.i,ot.j=st.j,ot.S=st.S.slice(),ot}function nt(st,ot){var ct=[],lt=typeof st,dt;if(ot&&lt=="object")for(dt in st)try{ct.push(nt(st[dt],ot-1))}catch{}return ct.length?ct:lt=="string"?st:st+"\0"}function rt(st,ot){for(var ct=st+"",lt,dt=0;dt<ct.length;)ot[$&dt]=$&(lt^=ot[$&dt]*19)+ct.charCodeAt(dt++);return at(ot)}function it(){try{var st;return j&&(st=j.randomBytes)?st=st(o):(st=new Uint8Array(o),(s.crypto||s.msCrypto).getRandomValues(st)),at(st)}catch{var ot=s.navigator,ct=ot&&ot.plugins;return[+new Date,s,ct,s.screen,at(e)]}}function at(st){return String.fromCharCode.apply(0,st)}if(rt(i.random(),e),a.exports){a.exports=_e;try{j=require$$0}catch{}}})([],Math)})(seedrandom$1);var seedrandomExports=seedrandom$1.exports,alea=aleaExports,xor128=xor128Exports,xorwow=xorwowExports,xorshift7=xorshift7Exports,xor4096=xor4096Exports,tychei=tycheiExports,sr=seedrandomExports;sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;var seedrandom=sr;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MPRandGauss{constructor(e,i,s,o,c){this.mean=e,this.stdDev=i,this.dtype=s,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const d=c||Math.random();this.random=seedrandom.alea(d.toString())}nextValue(){if(!isNaN(this.nextVal)){const o=this.nextVal;return this.nextVal=NaN,o}let e,i,s=!1;for(;!s;){let o,c,d;do o=2*this.random()-1,c=2*this.random()-1,d=o*o+c*c;while(d>=1||d===0);const h=Math.sqrt(-2*Math.log(d)/d);e=this.mean+this.stdDev*o*h,i=this.mean+this.stdDev*c*h,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(i))&&(this.nextVal=this.convertValue(i)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class RandGamma{constructor(e,i,s,o){this.alpha=e,this.beta=1/i,this.dtype=s;const c=o||Math.random();this.randu=seedrandom.alea(c.toString()),this.randn=new MPRandGauss(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,i,s,o,c,d;for(;;){do o=this.randn.nextValue(),d=1+this.c*o;while(d<=0);if(d*=d*d,e=o*o,i=1-.331*e*e,s=.5*e+this.d*(1-d+Math.log(d)),c=this.randu(),c<i||Math.log(c)<s)break}return d=1/this.beta*this.d*d,this.alpha<1&&(d*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(d)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class UniformRandom{constructor(e=0,i=1,s,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=i-e,this.dtype=s,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${i} <= 1 and dtype is not float`);this.random=seedrandom.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomGamma_(a,e,i=1,s="float32",o){if(i==null&&(i=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const c=new RandGamma(e,i,s,o),d=buffer(a,s);for(let h=0;h<d.values.length;h++)d.values[h]=c.nextValue();return d.toTensor()}const randomGamma=op({randomGamma_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomNormal_(a,e=0,i=1,s,o){if(s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const c=new MPRandGauss(e,i,s,!1,o),d=buffer(a,s);for(let h=0;h<d.values.length;h++)d.values[h]=c.nextValue();return d.toTensor()}const randomNormal$2=op({randomNormal_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function randomUniform_(a,e=0,i=1,s="float32",o){const c=buffer(a,s),d=new UniformRandom(e,i,null,o);for(let h=0;h<c.values.length;h++)c.values[h]=d.nextValue();return c.toTensor()}const randomUniform$1=op({randomUniform_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function range$4(a,e,i=1,s="float32"){if(i===0)throw new Error("Cannot have a step of zero");const o={start:a,stop:e,step:i,dtype:s};return ENGINE.runKernel(Range,{},o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real_(a){const i={input:convertToTensor(a,"input","real")};return ENGINE.runKernel(Real,i)}const real$2=op({real_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reciprocal_(a){const i={x:convertToTensor(a,"x","reciprocal")};return ENGINE.runKernel(Reciprocal,i)}const reciprocal$2=op({reciprocal_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function relu_(a){const i={x:convertToTensor(a,"x","relu")};return ENGINE.runKernel(Relu$1,i)}const relu$2=op({relu_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function relu6_(a){const i={x:convertToTensor(a,"x","relu6")};return ENGINE.runKernel(Relu6$1,i)}const relu6$2=op({relu6_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse_(a,e){const s={x:convertToTensor(a,"x","reverse")},o={dims:e};return ENGINE.runKernel(Reverse,s,o)}const reverse$2=op({reverse_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse1d_(a){const e=convertToTensor(a,"x","reverse");return assert$1(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),reverse$2(e,0)}const reverse1d=op({reverse1d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse2d_(a,e){const i=convertToTensor(a,"x","reverse");return assert$1(i.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${i.rank}.`),reverse$2(i,e)}const reverse2d=op({reverse2d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse3d_(a,e){const i=convertToTensor(a,"x","reverse");return assert$1(i.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${i.rank}.`),reverse$2(i,e)}const reverse3d=op({reverse3d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse4d_(a,e){const i=convertToTensor(a,"x","reverse");return assert$1(i.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${i.rank}.`),reverse$2(i,e)}const reverse4d=op({reverse4d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function round_(a){const i={x:convertToTensor(a,"x","round")};return ENGINE.runKernel(Round,i)}const round$3=op({round_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rsqrt_(a){const i={x:convertToTensor(a,"x","rsqrt")};return ENGINE.runKernel(Rsqrt,i)}const rsqrt$2=op({rsqrt_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scalar(a,e){if((isTypedArray(a)&&e!=="string"||Array.isArray(a))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&isTypedArray(a)&&!(a instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return makeTensor(a,[],[],e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function selu_(a){const i={x:convertToTensor(a,"x","selu")};return ENGINE.runKernel(Selu$1,i)}const selu$2=op({selu_});function separableConv2d_(a,e,i,s,o,c=[1,1],d="NHWC"){const h=convertToTensor(a,"x","separableConv2d"),g=convertToTensor(e,"depthwiseFilter","separableConv2d"),_=convertToTensor(i,"pointwiseFilter","separableConv2d");let b=h,$=!1;if(h.rank===3&&($=!0,b=reshape$4(h,[1,h.shape[0],h.shape[1],h.shape[2]])),d==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");assert$1(b.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${b.rank}.`),assert$1(g.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${g.rank}.`),assert$1(_.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${g.rank}.`),assert$1(_.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${_.shape[0]}.`),assert$1(_.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${_.shape[1]}.`);const j=g.shape[2],_e=g.shape[3];assert$1(_.shape[2]===j*_e,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${j*_e}, but got ${_.shape[2]}.`);const tt=depthwiseConv2d$3(b,g,s,o,d,c),nt=conv2d$3(tt,_,1,"valid",d);return $?reshape$4(nt,[nt.shape[1],nt.shape[2],nt.shape[3]]):nt}const separableConv2d$1=op({separableConv2d_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function setdiff1dAsync_(a,e){const i=convertToTensor(a,"x","setdiff1d"),s=convertToTensor(e,"y","setdiff1d");assert$1(i.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${i.dtype}) and y (${s.dtype}).`),assert$1(i.rank===1,()=>`x should be 1D tensor, but got x (${i.shape}).`),assert$1(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const o=await i.data(),c=await s.data(),d=new Set(c);let h=0;for(let b=0;b<o.length;b++)d.has(o[b])||h++;const g=new TensorBuffer([h],i.dtype),_=new TensorBuffer([h],"int32");for(let b=0,$=0;b<o.length;b++)d.has(o[b])||(g.values[$]=o[b],_.values[$]=b,$++);return[g.toTensor(),_.toTensor()]}const setdiff1dAsync=setdiff1dAsync_;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sign_(a){const i={x:convertToTensor(a,"x","sign")};return ENGINE.runKernel(Sign,i)}const sign$5=op({sign_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sin_(a){const i={x:convertToTensor(a,"x","sin")};return ENGINE.runKernel(Sin,i)}const sin$4=op({sin_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sinh_(a){const i={x:convertToTensor(a,"x","sinh")};return ENGINE.runKernel(Sinh,i)}const sinh$3=op({sinh_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice1d_(a,e,i){const s=convertToTensor(a,"x","slice1d");return assert$1(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),slice$2(s,[e],[i])}const slice1d=op({slice1d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice2d_(a,e,i){const s=convertToTensor(a,"x","slice2d");return assert$1(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),slice$2(s,e,i)}const slice2d=op({slice2d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice3d_(a,e,i){const s=convertToTensor(a,"x","slice3d");return assert$1(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),slice$2(s,e,i)}const slice3d=op({slice3d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice4d_(a,e,i){const s=convertToTensor(a,"x","slice4d");return assert$1(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),slice$2(s,e,i)}const slice4d=op({slice4d_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax_(a,e=-1){const i=convertToTensor(a,"logits","softmax","float32");if(e===-1&&(e=i.rank-1),e!==i.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i.rank} and dim was ${e}`);const s={logits:i},o={dim:e};return ENGINE.runKernel(Softmax$2,s,o)}const softmax$3=op({softmax_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fft_(a){assert$1(a.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${a.dtype}.`);const e={input:a};return ENGINE.runKernel(FFT,e)}const fft$2=op({fft_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ifft_(a){assert$1(a.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${a.dtype}.`);const e={input:a};return ENGINE.runKernel(IFFT,e)}const ifft$2=op({ifft_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function irfft_(a){const e=a.shape[a.shape.length-1],i=a.size/e;let s;if(e<=2){const o=reshape$4(a,[i,e]);s=ifft$2(o)}else{const o=[i,2*(e-1)],c=reshape$4(real$2(a),[i,e]),d=reshape$4(imag$2(a),[i,e]),h=reverse$2(slice$2(c,[0,1],[i,e-2]),1),g=mul$1(reverse$2(slice$2(d,[0,1],[i,e-2]),1),scalar(-1)),_=concat$3([c,h],1),b=concat$3([d,g],1),$=reshape$4(complex$4(_,b),[o[0],o[1]]);s=ifft$2($)}if(s=real$2(s),a.rank===3&&a.shape[0]!==0){const o=s,c=a.shape[0];s=reshape$4(s,[c,s.shape[0]/c,s.shape[1]]),o.dispose()}return s}const irfft=op({irfft_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function split_(a,e,i=0){const o={x:convertToTensor(a,"x","split")},c={numOrSizeSplits:e,axis:i};return ENGINE.runKernel(SplitV,o,c)}const split$1=op({split_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rfft_(a,e){assert$1(a.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${a.dtype}`);let i=a.shape[a.shape.length-1];const s=a.size/i;let o;if(e!=null&&e<i){const tt=a.shape.map(nt=>0),et=a.shape.map(nt=>nt);et[a.shape.length-1]=e,o=slice$2(a,tt,et),i=e}else if(e!=null&&e>i){const tt=a.shape.map(et=>et);tt[a.shape.length-1]=e-i,o=concat$3([a,zeros$4(tt)],a.shape.length-1),i=e}else o=a;const c=zerosLike$2(o),d=reshape$4(complex$4(o,c),[s,i]),h=fft$2(d),g=Math.floor(i/2)+1,_=real$2(h),b=imag$2(h),$=split$1(_,[g,i-g],_.shape.length-1),j=split$1(b,[g,i-g],b.shape.length-1),_e=o.shape.slice();return _e[o.shape.length-1]=g,reshape$4(complex$4($[0],j[0]),_e)}const rfft=op({rfft_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sqrt_(a){const i={x:convertToTensor(a,"x","sqrt")};return ENGINE.runKernel(Sqrt,i)}const sqrt$4=op({sqrt_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function squaredDifference_(a,e){let i=convertToTensor(a,"a","squaredDifference"),s=convertToTensor(e,"b","squaredDifference");[i,s]=makeTypesMatch(i,s),assertAndGetBroadcastShape(i.shape,s.shape);const o={a:i,b:s},c={};return ENGINE.runKernel(SquaredDifference,o,c)}const squaredDifference$2=op({squaredDifference_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function squeeze_(a,e){const i=convertToTensor(a,"x","squeeze");return reshape$4(i,squeezeShape(i.shape,e).newShape)}const squeeze$1=op({squeeze_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stack_(a,e=0){const i=convertToTensorArray(a,"tensors","stack","string_or_numeric");assert$1(i.length>=1,()=>"Pass at least one tensor to tf.stack"),i.length>0&&assert$1(e<=i[0].rank,()=>"Axis must be <= rank of the tensor");const s=i,o={axis:e};return ENGINE.runKernel(Pack,s,o)}const stack=op({stack_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function step_(a,e=0){const s={x:convertToTensor(a,"x","step")},o={alpha:e};return ENGINE.runKernel(Step,s,o)}const step$2=op({step_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSlice_(a,e,i,s,o=0,c=0,d=0,h=0,g=0){const b={x:convertToTensor(a,"x","stridedSlice")},$={begin:e,end:i,strides:s,beginMask:o,endMask:c,ellipsisMask:d,newAxisMask:h,shrinkAxisMask:g};return ENGINE.runKernel(StridedSlice,b,$)}const stridedSlice$2=op({stridedSlice_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tan_(a){const i={x:convertToTensor(a,"x","tan")};return ENGINE.runKernel(Tan,i)}const tan$3=op({tan_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor1d(a,e){assertNonNull(a);const i=inferShape(a,e);if(i.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return makeTensor(a,null,i,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor2d(a,e,i){if(assertNonNull(a),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=inferShape(a,i);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return makeTensor(a,e,s,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor4d(a,e,i){if(assertNonNull(a),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=inferShape(a,i);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return makeTensor(a,e,s,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor5d(a,e,i){if(assertNonNull(a),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=inferShape(a,i);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return makeTensor(a,e,s,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor6d(a,e,i){if(assertNonNull(a),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=inferShape(a,i);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,makeTensor(a,e,s,i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topk_(a,e=1,i=!0){const s=convertToTensor(a,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const o=s.shape[s.shape.length-1];if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);const c={x:s},d={k:e,sorted:i},[h,g]=ENGINE.runKernel(TopK,c,d);return{values:h,indices:g}}const topk=op({topk_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function truncatedNormal_(a,e=0,i=1,s,o){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const c=new MPRandGauss(e,i,s,!0,o),d=buffer(a,s);for(let h=0;h<d.values.length;h++)d.values[h]=c.nextValue();return d.toTensor()}const truncatedNormal$1=op({truncatedNormal_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unique_(a,e=0){const i=convertToTensor(a,"x","unique","string_or_numeric");assert$1(i.rank>0,()=>"The input tensor must be at least 1D");const s={x:i},o={axis:e},[c,d]=ENGINE.runKernel(Unique,s,o);return{values:c,indices:d}}const unique$3=op({unique_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unsortedSegmentSum_(a,e,i){const s=convertToTensor(a,"x","unsortedSegmentSum"),o=convertToTensor(e,"segmentIds","unsortedSegmentSum","int32");assert$1(isInt(i),()=>"numSegments must be of dtype int");const c={x:s,segmentIds:o},d={numSegments:i};return ENGINE.runKernel(UnsortedSegmentSum,c,d)}const unsortedSegmentSum$2=op({unsortedSegmentSum_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unstack_(a,e=0){const i=convertToTensor(a,"x","unstack","string_or_numeric");assert$1(e>=-i.shape.length&&e<i.shape.length,()=>`Axis = ${e} is not in [-${i.shape.length}, ${i.shape.length})`);const s={value:i},o={axis:e};return ENGINE.runKernel(Unpack,s,o)}const unstack=op({unstack_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function variable(a,e=!0,i,s){return ENGINE.makeVariable(a,e,i,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whereImpl$2(a,e){const i=[];for(let c=0;c<e.length;c++)e[c]&&i.push(c);const s=buffer(a,"int32"),o=buffer([i.length,a.length],"int32");for(let c=0;c<i.length;c++){const d=s.indexToLoc(i[c]),h=c*a.length;o.values.set(d,h)}return o.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function whereAsync_(a){const e=convertToTensor(a,"condition","whereAsync","bool"),i=await e.data(),s=whereImpl$2(e.shape,i);return a!==e&&e.dispose(),s}const whereAsync=whereAsync_;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function booleanMaskAsync_(a,e,i){const s=convertToTensor(a,"tensor","boolMask"),o=convertToTensor(e,"mask","boolMask","bool"),c=i??0,d=o.rank,h=s.shape;assert$1(d>0,()=>"mask cannot be scalar"),assertShapesMatch(h.slice(c,c+d),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let g=1;for(let et=c;et<c+d;et++)g*=h[et];const _=h.slice(0,c).concat([g],h.slice(c+d)),b=reshape$4(s,_),$=reshape$4(o,[-1]),j=await whereAsync($),_e=squeeze$1(j,[1]),tt=gather$1(b,_e,c);return a!==s&&s.dispose(),e!==o&&o.dispose(),_e.dispose(),b.dispose(),$.dispose(),j.dispose(),tt}const booleanMaskAsync=booleanMaskAsync_;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function norm_(a,e="euclidean",i=null,s=!1){a=convertToTensor(a,"x","norm");const o=normImpl(a,e,i);let c=o.shape;if(s){const d=parseAxisParam(i,a.shape);c=expandShapeToKeepDim(o.shape,d)}return reshape$4(o,c)}function normImpl(a,e,i=null){if(a.rank===0)return abs$4(a);if(a.rank!==1&&i===null)return normImpl(reshape$4(a,[-1]),e,i);if(a.rank===1||typeof i=="number"||Array.isArray(i)&&i.length===1){if(e===1)return sum$3(abs$4(a),i);if(e===1/0)return max$4(abs$4(a),i);if(e===-1/0)return min$4(abs$4(a),i);if(e==="euclidean"||e===2)return sqrt$4(sum$3(pow$4(abs$4(a),scalar(2,"int32")),i));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(i)&&i.length===2){if(e===1)return max$4(sum$3(abs$4(a),i[0]),i[1]-1);if(e===1/0)return max$4(sum$3(abs$4(a),i[1]),i[0]);if(e===-1/0)return min$4(sum$3(abs$4(a),i[1]),i[0]);if(e==="fro"||e==="euclidean")return sqrt$4(sum$3(square$2(a),i));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${i}`)}const norm$1=op({norm_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function movingAverage_(a,e,i,s,o=!0){const c=convertToTensor(a,"v","movingAverage"),d=convertToTensor(e,"x","movingAverage"),h=convertToTensor(i,"decay","movingAverage");assertTypesMatch(c,d),assert$1(arraysEqual(c.shape,d.shape),()=>"Shape mismatch in v and x");const g=scalar(1),_=sub$3(g,h);let b=mul$1(sub$3(d,c),_);if(o){assert$1(s!=null,()=>"When using zeroDebias: true, step is required.");const $=convertToTensor(s,"step","movingAverage");b=div$2(b,sub$3(g,pow$4(h,$)))}return add$4(c,b)}const movingAverage=op({movingAverage_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterND_(a,e,i){const s=convertToTensor(a,"indices","scatterND","int32"),o=convertToTensor(e,"updates","scatterND");validateInput$1(o,s,i);const c={indices:s,updates:o},d={shape:i};return ENGINE.runKernel(ScatterNd,c,d)}const scatterND=op({scatterND_});function validateInput(a,e,i,s){if(a.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);const o=a.rank>0?a.shape[0]:1,c=a.rank>1?a.shape[1]:1;if(i.length!==c)throw new Error(`outputShape has incorrect number of elements:, ${i.length}, should be: ${c}.`);const d=e.size;if(!(e.rank===0||e.rank===1&&d===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseToDense_(a,e,i,s=0){const o=convertToTensor(a,"sparseIndices","sparseToDense","int32"),c=convertToTensor(e,"sparseValues","sparseToDense"),d=convertToTensor(s,"defaultValue","sparseToDense",c.dtype);validateInput(o,c,i,d);const h={sparseIndices:o,sparseValues:c,defaultValue:d},g={outputShape:i};return ENGINE.runKernel(SparseToDense,h,g)}const sparseToDense$2=op({sparseToDense_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherND_(a,e){const i=convertToTensor(e,"indices","gatherND","int32"),o={params:convertToTensor(a,"x","gatherND"),indices:i};return ENGINE.runKernel(GatherNd,o)}const gatherND=op({gatherND_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getNoiseShape(a,e){if(e==null)return a.shape.slice();if(arraysEqual(a.shape,e))return e;if(a.shape.length===e.length){const i=[];for(let s=0;s<a.shape.length;s++)e[s]==null&&a.shape[s]!=null?i.push(a.shape[s]):i.push(e[s]);return i}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dropout_(a,e,i,s){const o=convertToTensor(a,"x","dropout");if(assert$1(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),assert$1(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return a instanceof Tensor?o.clone():o;const c=getNoiseShape(o,i),d=1-e,h=div$2(floor$3(add$4(randomUniform$1(c,0,1,"float32",s),d)),d);return mul$1(o,h)}const dropout$2=op({dropout_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function enclosingPowerOfTwo(a){return Math.floor(Math.pow(2,Math.ceil(Math.log(a)/Math.log(2))))}function cosineWindow(a,e,i){const s=1-a%2,o=new Float32Array(a);for(let c=0;c<a;++c){const d=2*Math.PI*c/(a+s-1);o[c]=e-i*Math.cos(d)}return tensor1d(o,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function inTopKAsync_(a,e,i=1){const s=convertToTensor(a,"predictions","inTopK"),o=convertToTensor(e,"targets","inTopK");assert$1(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),assert$1(s.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${o.rank}`),assertShapesMatch(s.shape.slice(0,s.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const c=s.shape[s.shape.length-1];assert$1(i>0&&i<=c,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${c}), but got ${i}`);const d=await s.data(),h=await o.data(),[g,_]=[d.length/c,c],b=getTypedArrayFromDType("bool",g);for(let $=0;$<g;$++){const j=$*_,_e=d.subarray(j,j+_),tt=[];for(let et=0;et<_e.length;et++)tt.push({value:_e[et],index:et});tt.sort((et,nt)=>nt.value-et.value),b[$]=0;for(let et=0;et<i;et++)if(tt[et].index===h[$]){b[$]=1;break}}return a!==s&&s.dispose(),e!==o&&o.dispose(),tensor(b,o.shape,"bool")}const inTopKAsync=inTopKAsync_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropFilter_(a,e,i,s,o,c="NHWC",d){let h=a;a.rank===3&&(h=reshape$4(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let g=e;g.rank===3&&(g=reshape$4(e,[1,e.shape[0],e.shape[1],e.shape[2]])),assert$1(h.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`),assert$1(g.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${g.shape}.`),assert$1(i.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${i}.`);const _=c==="NHWC"?h.shape[3]:h.shape[1],b=c==="NHWC"?g.shape[3]:g.shape[1];assert$1(_===i[2],()=>`Error in conv2dDerFilter: depth of input ${_}) must match input depth in filter (${i[2]}.`),assert$1(b===i[3],()=>`Error in conv2dDerFilter: depth of dy (${b}) must match output depth for filter (${i[3]}).`),d!=null&&assert$1(isInt(o),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${d} but got pad ${o}.`);const $={x:h,dy:g},j={strides:s,pad:o,dataFormat:c,dimRoundingMode:d,filterShape:i};return ENGINE.runKernel(Conv2DBackpropFilter,$,j)}const conv2DBackpropFilter$2=op({conv2DBackpropFilter_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getFusedDyActivation(a,e,i){if(i==null||i==="linear")return a;if(i==="relu")return mul$1(a,step$2(e));throw new Error(`Cannot compute gradient for fused activation ${i}.`)}function getFusedBiasGradient(a,e){let i=e;const s=getReductionAxes(a.shape,e.shape);return s.length>0&&(i=sum$3(i,s)),reshape$4(i,a.shape)}function applyActivation$1(a,e,i,s){if(e==="linear")return a;if(e==="relu")return relu$2(a);if(e==="elu")return elu$4(a);if(e==="relu6")return relu6$2(a);if(e==="prelu")return prelu$3(a,i);if(e==="leakyrelu")return leakyRelu$2(a,s);throw new Error(`Unknown fused activation ${e}.`)}const shouldFuse=(a,e)=>!(a>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2d_({x:a,filter:e,strides:i,pad:s,dataFormat:o="NHWC",dilations:c=[1,1],dimRoundingMode:d,bias:h,activation:g="linear",preluActivationWeights:_,leakyreluAlpha:b}){if(g=g||"linear",shouldFuse(ENGINE.state.gradientDepth,g)===!1){let ot=conv2d$3(a,e,i,s,o,c,d);return h!=null&&(ot=add$4(ot,h)),applyActivation$1(ot,g,_,b)}const $=convertToTensor(a,"x","conv2d"),j=convertToTensor(e,"filter","conv2d");let _e=$,tt=!1;$.rank===3&&(tt=!0,_e=reshape$4($,[1,$.shape[0],$.shape[1],$.shape[2]])),assert$1(_e.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${_e.rank}.`),assert$1(j.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${j.rank}.`),d!=null&&assert$1(isInt(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${s}.`),assert$1(_e.shape[3]===j.shape[2],()=>`Error in conv2d: depth of input (${_e.shape[3]}) must match input depth for filter ${j.shape[2]}.`),assert$1(eitherStridesOrDilationsAreOne(i,c),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`),assert$1(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);const et=computeConv2DInfo(_e.shape,j.shape,i,c,s,d);let nt;h!=null&&(nt=convertToTensor(h,"bias","fused conv2d"),[nt]=makeTypesMatch(nt,$),assertAndGetBroadcastShape(et.outShape,nt.shape));let rt;_!=null&&(rt=convertToTensor(_,"prelu weights","fused conv2d"));const it=(ot,ct)=>{const[lt,dt,xt,ut]=ct,ft=getFusedDyActivation(ot,xt,g);assert$1(tupleValuesAreOne(c),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${c}'`);const mt=conv2DBackpropInput$2(dt.shape,ft,lt,i,s),yt=conv2DBackpropFilter$2(dt,ft,lt.shape,i,s),St=[mt,yt];if(ut!=null){const Et=getFusedBiasGradient(ut,ft);St.push(Et)}return St},at={x:_e,filter:j,bias:nt,preluActivationWeights:rt},st={strides:i,pad:s,dataFormat:o,dilations:c,dimRoundingMode:d,activation:g,leakyreluAlpha:b};return h==null?customGrad((ct,lt,dt)=>{let xt=ENGINE.runKernel(FusedConv2D,at,st);return dt([lt,ct,xt]),tt&&(xt=reshape$4(xt,[xt.shape[1],xt.shape[2],xt.shape[3]])),{value:xt,gradFunc:it}})(_e,j):customGrad((ct,lt,dt,xt)=>{let ut=ENGINE.runKernel(FusedConv2D,at,st);return xt([lt,ct,ut,dt]),tt&&(ut=reshape$4(ut,[ut.shape[1],ut.shape[2],ut.shape[3]])),{value:ut,gradFunc:it}})(_e,j,nt)}const conv2d$2=op({fusedConv2d_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropFilter_(a,e,i,s,o,c=[1,1],d){let h=a;a.rank===3&&(h=reshape$4(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let g=e;g.rank===3&&(g=reshape$4(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const _={x:h,dy:g},b={strides:s,pad:o,dimRoundingMode:d,dilations:c,filterShape:i};return ENGINE.runKernel(DepthwiseConv2dNativeBackpropFilter,_,b)}const depthwiseConv2dNativeBackpropFilter$2=op({depthwiseConv2dNativeBackpropFilter_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropInput_(a,e,i,s,o,c=[1,1],d){let h=e,g=!1;e.rank===3&&(g=!0,h=reshape$4(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const _={dy:h,filter:i},b={strides:s,pad:o,dimRoundingMode:d,dilations:c,inputShape:a},$=ENGINE.runKernel(DepthwiseConv2dNativeBackpropInput,_,b);return g?reshape$4($,[$.shape[1],$.shape[2],$.shape[3]]):$}const depthwiseConv2dNativeBackpropInput$2=op({depthwiseConv2dNativeBackpropInput_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedDepthwiseConv2d_({x:a,filter:e,strides:i,pad:s,dataFormat:o="NHWC",dilations:c=[1,1],dimRoundingMode:d,bias:h,activation:g="linear",preluActivationWeights:_,leakyreluAlpha:b}){if(shouldFuse(ENGINE.state.gradientDepth,g)===!1){let ot=depthwiseConv2d$3(a,e,i,s,o,c,d);return h!=null&&(ot=add$4(ot,h)),applyActivation$1(ot,g,_,b)}const $=convertToTensor(a,"x","depthwiseConv2d"),j=convertToTensor(e,"filter","depthwiseConv2d");let _e=$,tt=!1;$.rank===3&&(tt=!0,_e=reshape$4($,[1,$.shape[0],$.shape[1],$.shape[2]])),assert$1(_e.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${_e.rank}.`),assert$1(j.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${j.rank}.`),assert$1(_e.shape[3]===j.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${_e.shape[3]}) must match the inChannels dimension in filter ${j.shape[2]}.`),c==null&&(c=[1,1]),assert$1(eitherStridesOrDilationsAreOne(i,c),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`),d!=null&&assert$1(isInt(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${d} but got pad ${s}.`);const et=computeConv2DInfo(_e.shape,j.shape,i,c,s,d,!0);let nt;h!=null&&(nt=convertToTensor(h,"bias","fused conv2d"),[nt]=makeTypesMatch(nt,$),assertAndGetBroadcastShape(et.outShape,nt.shape));let rt;_!=null&&(rt=convertToTensor(_,"prelu weights","fused depthwiseConv2d"));const it=(ot,ct)=>{assert$1(tupleValuesAreOne(c),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${c}'`);const[lt,dt,xt,ut]=ct,ft=getFusedDyActivation(ot,xt,g),mt=depthwiseConv2dNativeBackpropInput$2(dt.shape,ft,lt,i,s,c,d),yt=depthwiseConv2dNativeBackpropFilter$2(dt,ft,lt.shape,i,s,c,d);if(ut!=null){const St=getFusedBiasGradient(nt,ft);return[mt,yt,St]}return[mt,yt]},at={x:_e,filter:j,bias:nt,preluActivationWeights:rt},st={strides:i,pad:s,dataFormat:o,dilations:c,dimRoundingMode:d,activation:g,leakyreluAlpha:b};return h==null?customGrad((ct,lt,dt)=>{let xt=ENGINE.runKernel(FusedDepthwiseConv2D,at,st);return dt([lt,ct,xt]),tt&&(xt=reshape$4(xt,[xt.shape[1],xt.shape[2],xt.shape[3]])),{value:xt,gradFunc:it}})(_e,j):customGrad((ct,lt,dt,xt)=>{let ut=ENGINE.runKernel(FusedDepthwiseConv2D,at,st);return xt([lt,ct,ut,dt]),tt&&(ut=reshape$4(ut,[ut.shape[1],ut.shape[2],ut.shape[3]])),{value:ut,gradFunc:it}})(_e,j,nt)}const depthwiseConv2d$2=op({fusedDepthwiseConv2d_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedMatMul_({a,b:e,transposeA:i=!1,transposeB:s=!1,bias:o,activation:c="linear",preluActivationWeights:d,leakyreluAlpha:h}){if(shouldFuse(ENGINE.state.gradientDepth,c)===!1){let ut=matMul$1(a,e,i,s);return o!=null&&(ut=add$4(ut,o)),applyActivation$1(ut,c,d,h)}let g=convertToTensor(a,"a","fused matMul"),_=convertToTensor(e,"b","fused matMul");[g,_]=makeTypesMatch(g,_);const b=i?g.shape[g.rank-2]:g.shape[g.rank-1],$=s?_.shape[_.rank-1]:_.shape[_.rank-2],j=i?g.shape[g.rank-1]:g.shape[g.rank-2],_e=s?_.shape[_.rank-2]:_.shape[_.rank-1],tt=g.shape.slice(0,-2),et=_.shape.slice(0,-2),nt=sizeFromShape(tt),rt=sizeFromShape(et);assert$1(g.rank>=2&&_.rank>=2&&g.rank===_.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${g.rank} and ${_.rank}.`),assert$1(arraysEqual(tt,et),()=>`Error in fused matMul: outer dimensions (${tt}) and (${et}) of Tensors with shapes ${g.shape} and ${_.shape} must match.`),assert$1(b===$,()=>`Error in fused matMul: inner shapes (${b}) and (${$}) of Tensors with shapes ${g.shape} and ${_.shape} and transposeA=${i} and transposeB=${s} must match.`);const it=g.shape.slice(0,-2).concat([j,_e]),at=i?reshape$4(g,[nt,b,j]):reshape$4(g,[nt,j,b]),st=s?reshape$4(_,[rt,_e,$]):reshape$4(_,[rt,$,_e]);let ot;o!=null&&(ot=convertToTensor(o,"bias","fused matMul"),[ot]=makeTypesMatch(ot,g),assertAndGetBroadcastShape(it,ot.shape));let ct;d!=null&&(ct=convertToTensor(d,"prelu weights","fused matMul"));const lt=(ut,ft)=>{const[mt,yt,St,Et]=ft,vt=getFusedDyActivation(reshape$4(ut,St.shape),St,c);let Nt,wt;if(!i&&!s?(Nt=matMul$1(vt,yt,!1,!0),wt=matMul$1(mt,vt,!0,!1)):!i&&s?(Nt=matMul$1(vt,yt,!1,!1),wt=matMul$1(vt,mt,!0,!1)):i&&!s?(Nt=matMul$1(yt,vt,!1,!0),wt=matMul$1(mt,vt,!1,!1)):(Nt=matMul$1(yt,vt,!0,!0),wt=matMul$1(vt,mt,!0,!0)),o!=null){const $t=getFusedBiasGradient(Et,vt);return[Nt,wt,$t]}else return[Nt,wt]},dt={a:at,b:st,bias:ot,preluActivationWeights:ct},xt={transposeA:i,transposeB:s,activation:c,leakyreluAlpha:h};return o==null?customGrad((ft,mt,yt)=>{const St=ENGINE.runKernel(_FusedMatMul,dt,xt);return yt([ft,mt,St]),{value:reshape$4(St,it),gradFunc:lt}})(at,st):customGrad((ft,mt,yt,St)=>{const Et=ENGINE.runKernel(_FusedMatMul,dt,xt);return St([ft,mt,Et,yt]),{value:reshape$4(Et,it),gradFunc:lt}})(at,st,ot)}const matMul=op({fusedMatMul_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fused_ops=Object.freeze(Object.defineProperty({__proto__:null,conv2d:conv2d$2,depthwiseConv2d:depthwiseConv2d$2,matMul},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hammingWindow_(a){return cosineWindow(a,.54,.46)}const hammingWindow=op({hammingWindow_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hannWindow_(a){return cosineWindow(a,.5,.5)}const hannWindow=op({hannWindow_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function frame_(a,e,i,s=!1,o=0){let c=0;const d=[];for(;c+e<=a.size;)d.push(slice$2(a,c,e)),c+=i;if(s)for(;c<a.size;){const h=c+e-a.size,g=concat$3([slice$2(a,c,e-h),fill$2([h],o)]);d.push(g),c+=i}return d.length===0?tensor2d([],[0,e]):reshape$4(concat$3(d),[d.length,e])}const frame=op({frame_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stft_(a,e,i,s,o=hannWindow){s==null&&(s=enclosingPowerOfTwo(e));const c=frame(a,e,i),d=mul$1(c,o(e)),h=[];for(let g=0;g<c.shape[0];g++)h.push(rfft(slice$2(d,[g,0],[1,e]),s));return concat$3(h)}const stft=op({stft_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cropAndResize_(a,e,i,s,o="bilinear",c=0){const d=convertToTensor(a,"image","cropAndResize"),h=convertToTensor(e,"boxes","cropAndResize","float32"),g=convertToTensor(i,"boxInd","cropAndResize","int32"),_=h.shape[0];assert$1(d.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${d.rank}.`),assert$1(h.rank===2&&h.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${_},4] but had shape ${h.shape}.`),assert$1(g.rank===1&&g.shape[0]===_,()=>`Error in cropAndResize: boxInd must be have size [${_}] but had shape ${h.shape}.`),assert$1(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),assert$1(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),assert$1(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);const b={image:d,boxes:h,boxInd:g},$={method:o,extrapolationValue:c,cropSize:s};return ENGINE.runKernel(CropAndResize,b,$)}const cropAndResize$2=op({cropAndResize_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function flipLeftRight_(a){const e=convertToTensor(a,"image","flipLeftRight","float32");assert$1(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const i={image:e};return ENGINE.runKernel(FlipLeftRight,i,{})}const flipLeftRight=op({flipLeftRight_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rotateWithOffset_(a,e,i=0,s=.5){const o=convertToTensor(a,"image","rotateWithOffset","float32");assert$1(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);const c={image:o},d={radians:e,fillValue:i,center:s};return ENGINE.runKernel(RotateWithOffset,c,d)}const rotateWithOffset=op({rotateWithOffset_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppSanityCheck(a,e,i,s,o,c){s==null&&(s=.5),o==null&&(o=Number.NEGATIVE_INFINITY),c==null&&(c=0);const d=a.shape[0];return i=Math.min(i,d),assert$1(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),assert$1(a.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${a.rank}'`),assert$1(a.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${a.shape[1]}`),assert$1(e.rank===1,()=>"scores must be a 1D tensor"),assert$1(e.shape[0]===d,()=>`scores has incompatible shape with boxes. Expected ${d}, but was ${e.shape[0]}`),assert$1(0<=c&&c<=1,()=>`softNmsSigma must be in [0, 1], but was '${c}'`),{maxOutputSize:i,iouThreshold:s,scoreThreshold:o,softNmsSigma:c}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppression_(a,e,i,s=.5,o=Number.NEGATIVE_INFINITY){const c=convertToTensor(a,"boxes","nonMaxSuppression"),d=convertToTensor(e,"scores","nonMaxSuppression"),h=nonMaxSuppSanityCheck(c,d,i,s,o);i=h.maxOutputSize,s=h.iouThreshold,o=h.scoreThreshold;const g={maxOutputSize:i,iouThreshold:s,scoreThreshold:o};return ENGINE.runKernel(NonMaxSuppressionV3,{boxes:c,scores:d},g)}const nonMaxSuppression=op({nonMaxSuppression_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryInsert(a,e,i){const s=binarySearch(a,e,i),o=s<0?-(s+1):s;a.splice(o,0,e)}function binarySearch(a,e,i){return binarySearch_(a,e,i||defaultComparator)}function defaultComparator(a,e){return a>e?1:a<e?-1:0}function binarySearch_(a,e,i){let s=0,o=a.length,c=0,d=!1;for(;s<o;){c=s+(o-s>>>1);const h=i(e,a[c]);h>0?s=c+1:(o=c,d=!h)}return d?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionV3Impl$2(a,e,i,s,o){return nonMaxSuppressionImpl_(a,e,i,s,o,0)}function nonMaxSuppressionV4Impl$2(a,e,i,s,o,c){return nonMaxSuppressionImpl_(a,e,i,s,o,0,!1,c,!0)}function nonMaxSuppressionV5Impl$2(a,e,i,s,o,c){return nonMaxSuppressionImpl_(a,e,i,s,o,c,!0)}function nonMaxSuppressionImpl_(a,e,i,s,o,c,d=!1,h=!1,g=!1){const _=[];for(let nt=0;nt<e.length;nt++)e[nt]>o&&_.push({score:e[nt],boxIndex:nt,suppressBeginIndex:0});_.sort(ascendingComparator);const b=c>0?-.5/c:0,$=[],j=[];for(;$.length<i&&_.length>0;){const nt=_.pop(),{score:rt,boxIndex:it,suppressBeginIndex:at}=nt;if(rt<o)break;let st=!1;for(let ot=$.length-1;ot>=at;--ot){const ct=intersectionOverUnion(a,it,$[ot]);if(ct>=s){st=!0;break}if(nt.score=nt.score*suppressWeight(s,b,ct),nt.score<=o)break}nt.suppressBeginIndex=$.length,st||(nt.score===rt?($.push(it),j.push(nt.score)):nt.score>o&&binaryInsert(_,nt,ascendingComparator))}const _e=$.length,tt=i-_e;h&&tt>0&&($.push(...new Array(tt).fill(0)),j.push(...new Array(tt).fill(0)));const et={selectedIndices:$};return d&&(et.selectedScores=j),g&&(et.validOutputs=_e),et}function intersectionOverUnion(a,e,i){const s=a.subarray(e*4,e*4+4),o=a.subarray(i*4,i*4+4),c=Math.min(s[0],s[2]),d=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),g=Math.max(s[1],s[3]),_=Math.min(o[0],o[2]),b=Math.min(o[1],o[3]),$=Math.max(o[0],o[2]),j=Math.max(o[1],o[3]),_e=(h-c)*(g-d),tt=($-_)*(j-b);if(_e<=0||tt<=0)return 0;const et=Math.max(c,_),nt=Math.max(d,b),rt=Math.min(h,$),it=Math.min(g,j),at=Math.max(rt-et,0)*Math.max(it-nt,0);return at/(_e+tt-at)}function suppressWeight(a,e,i){const s=Math.exp(e*i*i);return i<=a?s:0}function ascendingComparator(a,e){return a.score-e.score||a.score===e.score&&e.boxIndex-a.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nonMaxSuppressionAsync_(a,e,i,s=.5,o=Number.NEGATIVE_INFINITY){const c=convertToTensor(a,"boxes","nonMaxSuppressionAsync"),d=convertToTensor(e,"scores","nonMaxSuppressionAsync"),h=nonMaxSuppSanityCheck(c,d,i,s,o);i=h.maxOutputSize,s=h.iouThreshold,o=h.scoreThreshold;const g=await Promise.all([c.data(),d.data()]),_=g[0],b=g[1],{selectedIndices:$}=nonMaxSuppressionV3Impl$2(_,b,i,s,o);return c!==a&&c.dispose(),d!==e&&d.dispose(),tensor1d($,"int32")}const nonMaxSuppressionAsync=nonMaxSuppressionAsync_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionWithScore_(a,e,i,s=.5,o=Number.NEGATIVE_INFINITY,c=0){const d=convertToTensor(a,"boxes","nonMaxSuppression"),h=convertToTensor(e,"scores","nonMaxSuppression"),g=nonMaxSuppSanityCheck(d,h,i,s,o,c);i=g.maxOutputSize,s=g.iouThreshold,o=g.scoreThreshold,c=g.softNmsSigma;const _={boxes:d,scores:h},b={maxOutputSize:i,iouThreshold:s,scoreThreshold:o,softNmsSigma:c},$=ENGINE.runKernel(NonMaxSuppressionV5,_,b);return{selectedIndices:$[0],selectedScores:$[1]}}const nonMaxSuppressionWithScore=op({nonMaxSuppressionWithScore_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nonMaxSuppressionWithScoreAsync_(a,e,i,s=.5,o=Number.NEGATIVE_INFINITY,c=0){const d=convertToTensor(a,"boxes","nonMaxSuppressionAsync"),h=convertToTensor(e,"scores","nonMaxSuppressionAsync"),g=nonMaxSuppSanityCheck(d,h,i,s,o,c);i=g.maxOutputSize,s=g.iouThreshold,o=g.scoreThreshold,c=g.softNmsSigma;const _=await Promise.all([d.data(),h.data()]),b=_[0],$=_[1],{selectedIndices:j,selectedScores:_e}=nonMaxSuppressionV5Impl$2(b,$,i,s,o,c);return d!==a&&d.dispose(),h!==e&&h.dispose(),{selectedIndices:tensor1d(j,"int32"),selectedScores:tensor1d(_e)}}const nonMaxSuppressionWithScoreAsync=nonMaxSuppressionWithScoreAsync_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionPadded_(a,e,i,s=.5,o=Number.NEGATIVE_INFINITY,c=!1){const d=convertToTensor(a,"boxes","nonMaxSuppression"),h=convertToTensor(e,"scores","nonMaxSuppression"),g=nonMaxSuppSanityCheck(d,h,i,s,o,null),_=g.maxOutputSize,b=g.iouThreshold,$=g.scoreThreshold,j={boxes:d,scores:h},_e={maxOutputSize:_,iouThreshold:b,scoreThreshold:$,padToMaxOutputSize:c},tt=ENGINE.runKernel(NonMaxSuppressionV4,j,_e);return{selectedIndices:tt[0],validOutputs:tt[1]}}const nonMaxSuppressionPadded=op({nonMaxSuppressionPadded_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nonMaxSuppressionPaddedAsync_(a,e,i,s=.5,o=Number.NEGATIVE_INFINITY,c=!1){const d=convertToTensor(a,"boxes","nonMaxSuppressionAsync"),h=convertToTensor(e,"scores","nonMaxSuppressionAsync"),g=nonMaxSuppSanityCheck(d,h,i,s,o,null),_=g.maxOutputSize,b=g.iouThreshold,$=g.scoreThreshold,[j,_e]=await Promise.all([d.data(),h.data()]),{selectedIndices:tt,validOutputs:et}=nonMaxSuppressionV4Impl$2(j,_e,_,b,$,c);return d!==a&&d.dispose(),h!==e&&h.dispose(),{selectedIndices:tensor1d(tt,"int32"),validOutputs:scalar(et,"int32")}}const nonMaxSuppressionPaddedAsync=nonMaxSuppressionPaddedAsync_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinear_(a,e,i=!1,s=!1){const o=convertToTensor(a,"images","resizeBilinear");assert$1(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),assert$1(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),assert$1(s===!1||i===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let c=o,d=!1;o.rank===3&&(d=!0,c=reshape$4(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const h={images:c},g={alignCorners:i,halfPixelCenters:s,size:e},_=ENGINE.runKernel(ResizeBilinear,h,g);return d?reshape$4(_,[_.shape[1],_.shape[2],_.shape[3]]):_}const resizeBilinear$2=op({resizeBilinear_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighbor_(a,e,i=!1,s=!1){const o=convertToTensor(a,"images","resizeNearestNeighbor");assert$1(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),assert$1(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),assert$1(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),assert$1(s===!1||i===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let c=o,d=!1;o.rank===3&&(d=!0,c=reshape$4(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const h={images:c},g={alignCorners:i,halfPixelCenters:s,size:e},_=ENGINE.runKernel(ResizeNearestNeighbor,h,g);return d?reshape$4(_,[_.shape[1],_.shape[2],_.shape[3]]):_}const resizeNearestNeighbor$2=op({resizeNearestNeighbor_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bandPart_(a,e,i){assert$1(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),assert$1(i%1===0,()=>`bandPart(): numUpper must be an integer, got ${i}.`);const s=convertToTensor(a,"a","bandPart");assert$1(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const o=s.shape,[c,d]=s.shape.slice(-2);if(!(e<=c))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${c}).`);if(!(i<=d))throw new Error(`bandPart(): numUpper (${i}) must not be greater than the number of columns (${d}).`);e<0&&(e=c),i<0&&(i=d);const h=reshape$4(range$4(0,c,1,"int32"),[-1,1]),g=range$4(0,d,1,"int32"),_=sub$3(h,g),b=logicalAnd$2(lessEqual$2(_,scalar(+e,"int32")),greaterEqual$2(_,scalar(-i,"int32"))),$=zeros$4([c,d],s.dtype);return reshape$4(stack(unstack(reshape$4(s,[-1,c,d])).map(j=>where(b,j,$))),o)}const bandPart=op({bandPart_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gramSchmidt_(a){let e;if(Array.isArray(a)){e=!1,assert$1(a!=null&&a.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const o=a[0].shape[0];for(let c=1;c<a.length;++c)assert$1(a[c].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${a[c].shape[0]} vs. ${o})`)}else e=!0,a=split$1(a,a.shape[0],0).map(o=>squeeze$1(o,[0]));assert$1(a.length<=a[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${a.length}) exceeds number of dimensions (${a[0].shape[0]}).`);const i=[],s=a;for(let o=0;o<a.length;++o)i.push(ENGINE.tidy(()=>{let c=s[o];if(o>0)for(let d=0;d<o;++d){const h=mul$1(sum$3(mul$1(i[d],c)),i[d]);c=sub$3(c,h)}return div$2(c,norm$1(c,"euclidean"))}));return e?stack(i,0):i}const gramSchmidt=op({gramSchmidt_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr_(a,e=!1){if(assert$1(a.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${a.rank}`),a.rank===2)return qr2d(a,e);{const i=a.shape.slice(0,a.shape.length-2).reduce((g,_)=>g*_),s=unstack(reshape$4(a,[i,a.shape[a.shape.length-2],a.shape[a.shape.length-1]]),0),o=[],c=[];s.forEach(g=>{const[_,b]=qr2d(g,e);o.push(_),c.push(b)});const d=reshape$4(stack(o,0),a.shape),h=reshape$4(stack(c,0),a.shape);return[d,h]}}function qr2d(a,e=!1){return ENGINE.tidy(()=>{assert$1(a.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${a.shape.length}D Tensor.`);const i=a.shape[0],s=a.shape[1];let o=eye(i),c=clone$2(a);const d=tensor2d([[1]],[1,1]);let h=clone$2(d);const g=i>=s?s:i;for(let _=0;_<g;++_){const b=c,$=h,j=o;[h,c,o]=ENGINE.tidy(()=>{const _e=slice$2(c,[_,_],[i-_,1]),tt=norm$1(_e),et=slice$2(c,[_,_],[1,1]),nt=where(greater$3(et,0),tensor2d([[-1]]),tensor2d([[1]])),rt=sub$3(et,mul$1(nt,tt)),it=div$2(_e,rt);it.shape[0]===1?h=clone$2(d):h=concat$3([d,slice$2(it,[1,0],[it.shape[0]-1,it.shape[1]])],0);const at=neg$2(div$2(matMul$1(nt,rt),tt)),st=slice$2(c,[_,0],[i-_,s]),ot=mul$1(at,h),ct=transpose$3(h);if(_===0)c=sub$3(st,matMul$1(ot,matMul$1(ct,st)));else{const xt=sub$3(st,matMul$1(ot,matMul$1(ct,st)));c=concat$3([slice$2(c,[0,0],[_,s]),xt],0)}const lt=transpose$3(ot),dt=slice$2(o,[0,_],[i,o.shape[1]-_]);if(_===0)o=sub$3(dt,matMul$1(matMul$1(dt,h),lt));else{const xt=sub$3(dt,matMul$1(matMul$1(dt,h),lt));o=concat$3([slice$2(o,[0,0],[i,_]),xt],1)}return[h,c,o]}),dispose([b,$,j])}return!e&&i>s&&(o=slice$2(o,[0,0],[i,s]),c=slice$2(c,[0,0],[s,s])),[o,c]})}const qr$1=op({qr_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Reduction;(function(a){a[a.NONE=0]="NONE",a[a.MEAN=1]="MEAN",a[a.SUM=2]="SUM",a[a.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Reduction||(Reduction={}));function computeWeightedLoss_(a,e,i=Reduction.SUM_BY_NONZERO_WEIGHTS){const s=convertToTensor(a,"losses","computeWeightedLoss");let o=null;e!=null&&(o=convertToTensor(e,"weights","computeWeightedLoss"));const c=o==null?s:mul$1(s,o);if(i===Reduction.NONE)return c;if(i===Reduction.SUM)return sum$3(c);if(i===Reduction.MEAN){if(o==null)return mean$1(c);{const d=s.size/o.size,h=div$2(sum$3(c),sum$3(o));return d>1?div$2(h,scalar(d)):h}}if(i===Reduction.SUM_BY_NONZERO_WEIGHTS){if(o==null)return div$2(sum$3(c),scalar(s.size));{const d=mul$1(o,ones$1(s.shape)),h=cast$3(sum$3(notEqual$2(d,scalar(0))),"float32");return div$2(sum$3(c),h)}}throw Error(`Unknown reduction: ${i}`)}const computeWeightedLoss$1=op({computeWeightedLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function absoluteDifference_(a,e,i,s=Reduction.SUM_BY_NONZERO_WEIGHTS){const o=convertToTensor(a,"labels","absoluteDifference"),c=convertToTensor(e,"predictions","absoluteDifference");let d=null;i!=null&&(d=convertToTensor(i,"weights","absoluteDifference")),assertShapesMatch(o.shape,c.shape,"Error in absoluteDifference: ");const h=abs$4(sub$3(o,c));return computeWeightedLoss$1(h,d,s)}const absoluteDifference=op({absoluteDifference_});function cosineDistance_(a,e,i,s,o=Reduction.SUM_BY_NONZERO_WEIGHTS){const c=convertToTensor(a,"labels","cosineDistance"),d=convertToTensor(e,"predictions","cosineDistance");let h=null;s!=null&&(h=convertToTensor(s,"weights","cosineDistance")),assertShapesMatch(c.shape,d.shape,"Error in cosineDistance: ");const g=scalar(1),_=sub$3(g,sum$3(mul$1(c,d),i,!0));return computeWeightedLoss$1(_,h,o)}const cosineDistance=op({cosineDistance_});function hingeLoss_(a,e,i,s=Reduction.SUM_BY_NONZERO_WEIGHTS){let o=convertToTensor(a,"labels","hingeLoss");const c=convertToTensor(e,"predictions","hingeLoss");let d=null;i!=null&&(d=convertToTensor(i,"weights","hingeLoss")),assertShapesMatch(o.shape,c.shape,"Error in hingeLoss: ");const h=scalar(1);o=sub$3(mul$1(scalar(2),o),h);const g=relu$2(sub$3(h,mul$1(o,c)));return computeWeightedLoss$1(g,d,s)}const hingeLoss=op({hingeLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function huberLoss_(a,e,i,s=1,o=Reduction.SUM_BY_NONZERO_WEIGHTS){const c=convertToTensor(a,"labels","huberLoss"),d=convertToTensor(e,"predictions","huberLoss");let h=null;i!=null&&(h=convertToTensor(i,"weights","huberLoss")),assertShapesMatch(c.shape,d.shape,"Error in huberLoss: ");const g=scalar(s),_=abs$4(sub$3(d,c)),b=minimum$3(_,g),$=sub$3(_,b),j=add$4(mul$1(scalar(.5),square$2(b)),mul$1(g,$));return computeWeightedLoss$1(j,h,o)}const huberLoss=op({huberLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function logLoss_(a,e,i,s=1e-7,o=Reduction.SUM_BY_NONZERO_WEIGHTS){const c=convertToTensor(a,"labels","logLoss"),d=convertToTensor(e,"predictions","logLoss");let h=null;i!=null&&(h=convertToTensor(i,"weights","logLoss")),assertShapesMatch(c.shape,d.shape,"Error in logLoss: ");const g=scalar(1),_=scalar(s),b=neg$2(mul$1(c,log$4(add$4(d,_)))),$=mul$1(sub$3(g,c),log$4(add$4(sub$3(g,d),_))),j=sub$3(b,$);return computeWeightedLoss$1(j,h,o)}const logLoss=op({logLoss_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function meanSquaredError_(a,e,i,s=Reduction.SUM_BY_NONZERO_WEIGHTS){const o=convertToTensor(a,"labels","meanSquaredError"),c=convertToTensor(e,"predictions","meanSquaredError");let d=null;i!=null&&(d=convertToTensor(i,"weights","meanSquaredError")),assertShapesMatch(o.shape,c.shape,"Error in meanSquaredError: ");const h=squaredDifference$2(o,c);return computeWeightedLoss$1(h,d,s)}const meanSquaredError$2=op({meanSquaredError_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sigmoidCrossEntropyWithLogits_(a,e){const i=convertToTensor(a,"labels","sigmoidCrossEntropyWithLogits"),s=convertToTensor(e,"logits","sigmoidCrossEntropyWithLogits");assertShapesMatch(i.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const o=relu$2(s),c=mul$1(s,i),d=log1p$2(exp$3(neg$2(abs$4(s))));return add$4(sub$3(o,c),d)}function sigmoidCrossEntropy_(a,e,i,s=0,o=Reduction.SUM_BY_NONZERO_WEIGHTS){let c=convertToTensor(a,"multiClassLabels","sigmoidCrossEntropy");const d=convertToTensor(e,"logits","sigmoidCrossEntropy");let h=null;if(i!=null&&(h=convertToTensor(i,"weights","sigmoidCrossEntropy")),assertShapesMatch(c.shape,d.shape,"Error in sigmoidCrossEntropy: "),s>0){const _=scalar(s),b=scalar(1),$=scalar(.5);c=add$4(mul$1(c,sub$3(b,_)),mul$1($,_))}const g=sigmoidCrossEntropyWithLogits_(c,d);return computeWeightedLoss$1(g,h,o)}const sigmoidCrossEntropy=op({sigmoidCrossEntropy_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmaxCrossEntropyWithLogits_(a,e,i=-1){if(i===-1&&(i=e.rank-1),i!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${i}`);return customGrad((o,c,d)=>{const g=logSumExp(c,[i],!0),_=sub$3(cast$3(c,"float32"),g);d([o,_]);const b=neg$2(mul$1(_,o));return{value:sum$3(b,[i]),gradFunc:(_e,tt)=>{const[et,nt]=tt,rt=expandShapeToKeepDim(_e.shape,[i]);return[mul$1(reshape$4(_e,rt),sub$3(cast$3(et,"float32"),exp$3(nt))),mul$1(reshape$4(_e,rt),sub$3(exp$3(nt),cast$3(et,"float32")))]}}})(a,e)}function softmaxCrossEntropy_(a,e,i,s=0,o=Reduction.SUM_BY_NONZERO_WEIGHTS){let c=convertToTensor(a,"onehotLabels","softmaxCrossEntropy");const d=convertToTensor(e,"logits","softmaxCrossEntropy");let h=null;if(i!=null&&(h=convertToTensor(i,"weights","softmaxCrossEntropy")),assertShapesMatch(c.shape,d.shape,"Error in softmaxCrossEntropy: "),s>0){const _=scalar(s),b=scalar(1),$=scalar(c.shape[1]);c=add$4(mul$1(c,sub$3(b,_)),div$2(_,$))}const g=softmaxCrossEntropyWithLogits_(c,d);return computeWeightedLoss$1(g,h,o)}const softmaxCrossEntropy=op({softmaxCrossEntropy_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spectral$1={fft:fft$2,ifft:ifft$2,rfft,irfft},signal={hammingWindow,hannWindow,frame,stft},image$1={flipLeftRight,resizeNearestNeighbor:resizeNearestNeighbor$2,resizeBilinear:resizeBilinear$2,rotateWithOffset,cropAndResize:cropAndResize$2,nonMaxSuppression,nonMaxSuppressionAsync,nonMaxSuppressionWithScore,nonMaxSuppressionWithScoreAsync,nonMaxSuppressionPadded,nonMaxSuppressionPaddedAsync},linalg={bandPart,gramSchmidt,qr:qr$1},losses={absoluteDifference,computeWeightedLoss:computeWeightedLoss$1,cosineDistance,hingeLoss,huberLoss,logLoss,meanSquaredError:meanSquaredError$2,sigmoidCrossEntropy,softmaxCrossEntropy};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Optimizer extends Serializable{minimize(e,i=!1,s){const{value:o,grads:c}=this.computeGradients(e,s);if(s!=null){const d=s.map(h=>({name:h.name,tensor:c[h.name]}));this.applyGradients(d)}else this.applyGradients(c);return dispose(c),i?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,i){return variableGrads(e,i)}dispose(){this.iterations_!=null&&dispose(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Optimizer,Symbol.hasInstance,{value:a=>a.minimize!=null&&a.computeGradients!=null&&a.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdadeltaOptimizer extends Optimizer{constructor(e,i,s=null){super(),this.learningRate=e,this.rho=i,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const c=ENGINE.registeredVariables[s],d=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${s}/accum_grad`,variable:tidy(()=>zerosLike$2(c).variable(d))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${s}/accum_var`,variable:tidy(()=>zerosLike$2(c).variable(d))});const h=Array.isArray(e)?e[o].tensor:e[s];if(h==null)return;const g=this.accumulatedGrads[o].variable,_=this.accumulatedUpdates[o].variable;tidy(()=>{const b=add$4(mul$1(g,this.rho),mul$1(square$2(h),1-this.rho)),$=mul$1(div$2(sqrt$4(add$4(_,this.epsilon)),sqrt$4(add$4(g,this.epsilon))),h),j=add$4(mul$1(_,this.rho),mul$1(square$2($),1-this.rho));g.assign(b),_.assign(j);const _e=add$4(mul$1($,-this.learningRate),c);c.assign(_e)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(dispose(this.accumulatedGrads.map(e=>e.variable)),dispose(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(e){e=await this.extractIterations(e);const i=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,i).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.accumulatedUpdates=e.slice(i,i*2).map(o=>({originalName:o.name,variable:o.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,i){return new e(i.learningRate,i.rho,i.epsilon)}}AdadeltaOptimizer.className="Adadelta";registerClass(AdadeltaOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdagradOptimizer extends Optimizer{constructor(e,i=.1){super(),this.learningRate=e,this.initialAccumulatorValue=i,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const c=ENGINE.registeredVariables[s];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${s}/accumulator`,variable:tidy(()=>fill$2(c.shape,this.initialAccumulatorValue).variable(!1))});const d=Array.isArray(e)?e[o].tensor:e[s];if(d==null)return;const h=this.accumulatedGrads[o].variable;tidy(()=>{const g=add$4(h,square$2(d));h.assign(g);const _=add$4(mul$1(div$2(d,sqrt$4(add$4(g,ENGINE.backend.epsilon()))),-this.learningRate),c);c.assign(_)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&dispose(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const i=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,i){return new e(i.learningRate,i.initialAccumulatorValue)}}AdagradOptimizer.className="Adagrad";registerClass(AdagradOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdamOptimizer extends Optimizer{constructor(e,i,s,o=null){super(),this.learningRate=e,this.beta1=i,this.beta2=s,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tidy(()=>{this.accBeta1=scalar(i).variable(),this.accBeta2=scalar(s).variable()}),o==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(e){const i=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);tidy(()=>{const s=sub$3(1,this.accBeta1),o=sub$3(1,this.accBeta2);i.forEach((c,d)=>{const h=ENGINE.registeredVariables[c],g=!1;this.accumulatedFirstMoment[d]==null&&(this.accumulatedFirstMoment[d]={originalName:`${c}/m`,variable:tidy(()=>zerosLike$2(h).variable(g))}),this.accumulatedSecondMoment[d]==null&&(this.accumulatedSecondMoment[d]={originalName:`${c}/v`,variable:tidy(()=>zerosLike$2(h).variable(g))});const _=Array.isArray(e)?e[d].tensor:e[c];if(_==null)return;const b=this.accumulatedFirstMoment[d].variable,$=this.accumulatedSecondMoment[d].variable,j=add$4(mul$1(b,this.beta1),mul$1(_,1-this.beta1)),_e=add$4(mul$1($,this.beta2),mul$1(square$2(_),1-this.beta2)),tt=div$2(j,s),et=div$2(_e,o);b.assign(j),$.assign(_e);const nt=add$4(mul$1(div$2(tt,add$4(sqrt$4(et),this.epsilon)),-this.learningRate),h);h.assign(nt)}),this.accBeta1.assign(mul$1(this.accBeta1,this.beta1)),this.accBeta2.assign(mul$1(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&dispose(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&dispose(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(e){e=await this.extractIterations(e),tidy(()=>{this.accBeta1.assign(pow$4(this.beta1,this.iterations_+1)),this.accBeta2.assign(pow$4(this.beta2,this.iterations_+1))});const i=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,i).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(i,i*2).map(o=>({originalName:o.name,variable:o.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,i){return new e(i.learningRate,i.beta1,i.beta2,i.epsilon)}}AdamOptimizer.className="Adam";registerClass(AdamOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AdamaxOptimizer extends Optimizer{constructor(e,i,s,o=null,c=0){super(),this.learningRate=e,this.beta1=i,this.beta2=s,this.epsilon=o,this.decay=c,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tidy(()=>{this.iteration=scalar(0).variable(),this.accBeta1=scalar(i).variable()}),o==null&&(this.epsilon=ENGINE.backend.epsilon())}applyGradients(e){const i=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);tidy(()=>{const s=sub$3(1,this.accBeta1),o=div$2(-this.learningRate,add$4(mul$1(this.iteration,this.decay),1));i.forEach((c,d)=>{const h=ENGINE.registeredVariables[c],g=!1;this.accumulatedFirstMoment[d]==null&&(this.accumulatedFirstMoment[d]={originalName:`${c}/m`,variable:zerosLike$2(h).variable(g)}),this.accumulatedWeightedInfNorm[d]==null&&(this.accumulatedWeightedInfNorm[d]={originalName:`${c}/v`,variable:zerosLike$2(h).variable(g)});const _=Array.isArray(e)?e[d].tensor:e[c];if(_==null)return;const b=this.accumulatedFirstMoment[d].variable,$=this.accumulatedWeightedInfNorm[d].variable,j=add$4(mul$1(b,this.beta1),mul$1(_,1-this.beta1)),_e=mul$1($,this.beta2),tt=abs$4(_),et=maximum$3(_e,tt);b.assign(j),$.assign(et);const nt=add$4(mul$1(div$2(o,s),div$2(j,add$4(et,this.epsilon))),h);h.assign(nt)}),this.iteration.assign(add$4(this.iteration,1)),this.accBeta1.assign(mul$1(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&dispose(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&dispose(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,i){return new e(i.learningRate,i.beta1,i.beta2,i.epsilon,i.decay)}}AdamaxOptimizer.className="Adamax";registerClass(AdamaxOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SGDOptimizer extends Optimizer{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const c=Array.isArray(e)?e[o].tensor:e[s];if(c==null)return;const d=ENGINE.registeredVariables[s];tidy(()=>{const h=add$4(mul$1(this.c,c),d);d.assign(h)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=keep(scalar(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,i){return new e(i.learningRate)}}SGDOptimizer.className="SGD";registerClass(SGDOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MomentumOptimizer extends SGDOptimizer{constructor(e,i,s=!1){super(e),this.learningRate=e,this.momentum=i,this.useNesterov=s,this.accumulations=[],this.m=scalar(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const c=ENGINE.registeredVariables[s];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${s}/momentum`,variable:tidy(()=>zerosLike$2(c).variable(!1))});const d=this.accumulations[o].variable,h=Array.isArray(e)?e[o].tensor:e[s];h!=null&&tidy(()=>{let g;const _=add$4(mul$1(this.m,d),h);this.useNesterov?g=add$4(mul$1(this.c,add$4(h,mul$1(_,this.m))),c):g=add$4(mul$1(this.c,_),c),d.assign(_),c.assign(g)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&dispose(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const i=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(i)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,i){return new e(i.learningRate,i.momentum,i.useNesterov)}}MomentumOptimizer.className="Momentum";registerClass(MomentumOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RMSPropOptimizer extends Optimizer{constructor(e,i=.9,s=0,o=null,c=!1){if(super(),this.learningRate=e,this.decay=i,this.momentum=s,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=c,o==null&&(this.epsilon=ENGINE.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,o)=>{const c=ENGINE.registeredVariables[s],d=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${s}/rms`,variable:tidy(()=>zerosLike$2(c).variable(d))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${s}/momentum`,variable:tidy(()=>zerosLike$2(c).variable(d))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${s}/mg`,variable:tidy(()=>zerosLike$2(c).variable(d))});const h=Array.isArray(e)?e[o].tensor:e[s];if(h==null)return;const g=this.accumulatedMeanSquares[o].variable,_=this.accumulatedMoments[o].variable;tidy(()=>{const b=add$4(mul$1(g,this.decay),mul$1(square$2(h),1-this.decay));if(this.centered){const $=this.accumulatedMeanGrads[o].variable,j=add$4(mul$1($,this.decay),mul$1(h,1-this.decay)),_e=div$2(mul$1(h,this.learningRate),sqrt$4(sub$3(b,add$4(square$2(j),this.epsilon)))),tt=add$4(mul$1(_,this.momentum),_e);g.assign(b),$.assign(j),_.assign(tt);const et=sub$3(c,tt);c.assign(et)}else{const $=add$4(mul$1(g,this.decay),mul$1(square$2(h),1-this.decay)),j=add$4(mul$1(_,this.momentum),div$2(mul$1(h,this.learningRate),sqrt$4(add$4($,this.epsilon))));g.assign($),_.assign(j);const _e=sub$3(c,j);c.assign(_e)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&dispose(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&dispose(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&dispose(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(i=>({name:i.originalName,tensor:i.variable})))}async setWeights(e){e=await this.extractIterations(e);const i=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,i).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.accumulatedMoments=e.slice(i,i*2).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(i*2,i*3).map(o=>({originalName:o.name,variable:o.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,i){return new e(i.learningRate,i.decay,i.momentum,i.epsilon,i.centered)}}RMSPropOptimizer.className="RMSProp";registerClass(RMSPropOptimizer);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OptimizerConstructors{static sgd(e){return new SGDOptimizer(e)}static momentum(e,i,s=!1){return new MomentumOptimizer(e,i,s)}static rmsprop(e,i=.9,s=0,o=null,c=!1){return new RMSPropOptimizer(e,i,s,o,c)}static adam(e=.001,i=.9,s=.999,o=null){return new AdamOptimizer(e,i,s,o)}static adadelta(e=.001,i=.95,s=null){return new AdadeltaOptimizer(e,i,s)}static adamax(e=.002,i=.9,s=.999,o=null,c=0){return new AdamaxOptimizer(e,i,s,o,c)}static adagrad(e,i=.1){return new AdagradOptimizer(e,i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const train={sgd:OptimizerConstructors.sgd,momentum:OptimizerConstructors.momentum,adadelta:OptimizerConstructors.adadelta,adagrad:OptimizerConstructors.adagrad,rmsprop:OptimizerConstructors.rmsprop,adamax:OptimizerConstructors.adamax,adam:OptimizerConstructors.adam};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const delayCallback=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:a=>a();function nextFrame(){return new Promise(a=>delayCallback(()=>a()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertParamsConsistent(a,e){const i=a[0].length;a.forEach((o,c)=>{assert$1(o.length===i,()=>`Error in concat${i}D: rank of tensors[${c}] must be the same as the rank of the rest (${i})`)}),assert$1(e>=0&&e<i,()=>`Error in concat${i}D: axis must be between 0 and ${i-1}.`);const s=a[0];a.forEach((o,c)=>{for(let d=0;d<i;d++)assert$1(d===e||o[d]===s[d],()=>`Error in concat${i}D: Shape of tensors[${c}] (${o}) does not match the shape of the rest (${s}) along the non-concatenated axis ${c}.`)})}function computeOutShape$1(a,e){const i=a[0].slice();for(let s=1;s<a.length;s++)i[e]+=a[s][e];return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PARALLELIZE_THRESHOLD=30;function computeOptimalWindowSize(a){return a<=PARALLELIZE_THRESHOLD?a:nearestDivisor(a,Math.floor(Math.sqrt(a)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getImageCenter(a,e,i){const s=i*(typeof a=="number"?a:a[0]),o=e*(typeof a=="number"?a:a[1]);return[s,o]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getReshaped(a,e,i,s=!0){let o=[];if(s)o=o.concat(e.slice(0)),o.push(a[0]/i),o=o.concat(a.slice(1));else{o=o.concat(a[0]);const c=e.length;for(let d=0;d<c;++d)o=o.concat([a[d+1]/e[d],e[d]]);o=o.concat(a.slice(c+1))}return o}function getPermuted(a,e,i=!0){const s=[];if(i){s.push(e);for(let o=e+1;o<a;++o)o<=2*e?(s.push(o),s.push(o-(e+1))):s.push(o)}else{const o=[],c=[];for(let d=1;d<a;++d)d>=e*2+1||d%2===1?c.push(d):o.push(d);s.push(...o),s.push(0),s.push(...c)}return s}function getReshapedPermuted(a,e,i,s=!0){const o=[];s?o.push(a[0]/i):o.push(a[0]*i);for(let c=1;c<a.length;++c)c<=e.length?s?o.push(e[c-1]*a[c]):o.push(a[c]/e[c-1]):o.push(a[c]);return o}function getSliceBeginCoords(a,e){const i=[0];for(let s=0;s<e;++s)i.push(a[s][0]);return i}function getSliceSize(a,e,i){const s=a.slice(0,1);for(let o=0;o<i;++o)s.push(a[o+1]-e[o][0]-e[o][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SELU_SCALEALPHA=1.7580993408473768,SELU_SCALE=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ERF_P=.3275911,ERF_A1=.254829592,ERF_A2=-.284496736,ERF_A3=1.421413741,ERF_A4=-1.453152027,ERF_A5=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function warn(...a){env$1().getBool("IS_TEST")||console.warn(...a)}function log$3(...a){env$1().getBool("IS_TEST")||console.log(...a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mergeRealAndImagArrays(a,e){if(a.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${a.length}, imag: ${e.length}.`);const i=new Float32Array(a.length*2);for(let s=0;s<i.length;s+=2)i[s]=a[s/2],i[s+1]=e[s/2];return i}function splitRealAndImagArrays(a){const e=new Float32Array(a.length/2),i=new Float32Array(a.length/2);for(let s=0;s<a.length;s+=2)e[s/2]=a[s],i[s/2]=a[s+1];return{real:e,imag:i}}function complexWithEvenIndex(a){const e=Math.ceil(a.length/4),i=new Float32Array(e),s=new Float32Array(e);for(let o=0;o<a.length;o+=4)i[Math.floor(o/4)]=a[o],s[Math.floor(o/4)]=a[o+1];return{real:i,imag:s}}function complexWithOddIndex(a){const e=Math.floor(a.length/4),i=new Float32Array(e),s=new Float32Array(e);for(let o=2;o<a.length;o+=4)i[Math.floor(o/4)]=a[o],s[Math.floor(o/4)]=a[o+1];return{real:i,imag:s}}function getComplexWithIndex(a,e){const i=a[e*2],s=a[e*2+1];return{real:i,imag:s}}function assignToTypedArray(a,e,i,s){a[s*2]=e,a[s*2+1]=i}function exponents(a,e){const i=new Float32Array(a/2),s=new Float32Array(a/2);for(let o=0;o<Math.ceil(a/2);o++){const c=(e?2:-2)*Math.PI*(o/a);i[o]=Math.cos(c),s[o]=Math.sin(c)}return{real:i,imag:s}}function exponent(a,e,i){const s=(i?2:-2)*Math.PI*(a/e),o=Math.cos(s),c=Math.sin(s);return{real:o,imag:c}}function prepareSplitSize(a,e,i=0){let s=[];if(typeof e=="number")assert$1(a.shape[i]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(a.shape[i]/e);else{const o=e.reduce((d,h)=>(h===-1&&(d+=1),d),0);assert$1(o<=1,()=>"There should be only one negative value in split array.");const c=e.indexOf(-1);if(c!==-1){const d=e.reduce((h,g)=>g>0?h+g:h);e[c]=a.shape[i]-d}assert$1(a.shape[i]===e.reduce((d,h)=>d+h),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function segOpComputeOptimalWindowSize(a,e){let i=!1,s;for(a<=PARALLELIZE_THRESHOLD?(s=a,i=!0):s=nearestDivisor(a,Math.floor(Math.sqrt(a)));!i;)s>e||s===a?i=!0:s=nearestDivisor(a,s+1);return s}function computeOutShape(a,e,i){const s=[],o=a.length;for(let c=0;c<o;c++)c!==e?s.push(a[c]):s.push(i);return s}function collectGatherOpShapeInfo(a,e,i,s){const o=e.shape.length,c=a.shape.length;if(s!==0&&(s<-o||s>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`);if(s<0&&(s+=o),s>c)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${c}).`);if(i<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${i}).`);for(let $=0;$<s;++$)if(a.shape[$]!==e.shape[$])throw new Error(`x.shape[${$}]: ${a.shape[$]} should be equal to indices.shape[${$}]: ${e.shape[$]}.`);const d=a.shape[i],h=[];let g=1,_=1,b=1;for(let $=0;$<s;++$)h.push(a.shape[$]),g*=a.shape[$];for(let $=s;$<i;$++)h.push(a.shape[$]),_*=a.shape[$];for(let $=s;$<o;$++)h.push(e.shape[$]);for(let $=i+1;$<c;$++)h.push(a.shape[$]),b*=a.shape[$];return{batchSize:g,sliceSize:b,outerSize:_,dimSize:d,outputShape:h}}const segment_util=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo,computeOutShape,segOpComputeOptimalWindowSize},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fromUint8ToStringArray(a){try{return a.map(e=>decodeString(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function fromStringArrayToUint8(a){return a.map(e=>encodeString(e))}const backend_util=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1,ERF_A2,ERF_A3,ERF_A4,ERF_A5,ERF_P,PARALLELIZE_THRESHOLD,SELU_SCALE,SELU_SCALEALPHA,applyActivation:applyActivation$1,assertAndGetBroadcastShape,assertAxesAreInnerMostDims,assertParamsConsistent,assignToTypedArray,axesAreInnerMostDims,calculateShapes,combineLocations,complexWithEvenIndex,complexWithOddIndex,computeConv2DInfo,computeConv3DInfo,computeDefaultPad,computeDilation2DInfo,computeOptimalWindowSize,computeOutAndReduceShapes,computeOutShape:computeOutShape$1,computePool2DInfo,computePool3DInfo,convertConv2DDataFormat,eitherStridesOrDilationsAreOne,expandShapeToKeepDim,exponent,exponents,fromStringArrayToUint8,fromUint8ToStringArray,getAxesPermutation,getBroadcastDims:getBroadcastDims$1,getComplexWithIndex,getFusedBiasGradient,getFusedDyActivation,getImageCenter,getInnerMostAxes,getPermuted,getReductionAxes,getReshaped,getReshapedPermuted,getSliceBeginCoords,getSliceSize,getUndoAxesPermutation,log:log$3,mergeRealAndImagArrays,prepareAndValidate,prepareSplitSize,segment_util,shouldFuse,slice_util,splitRealAndImagArrays,tupleValuesAreOne,upcastType,validateInput:validateInput$1,validateUpdateShape,warn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kernel_impls=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:nonMaxSuppressionV3Impl$2,nonMaxSuppressionV4Impl:nonMaxSuppressionV4Impl$2,nonMaxSuppressionV5Impl:nonMaxSuppressionV5Impl$2,whereImpl:whereImpl$2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const absGradConfig={kernelName:Abs,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,step$2(cast$3(i,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const acosGradConfig={kernelName:Acos,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>{const s=square$2(cast$3(i,"float32")),o=sqrt$4(sub$3(scalar(1),s));return neg$2(div$2(a,o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const acoshGradConfig={kernelName:Acosh,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>{const s=sqrt$4(sub$3(square$2(cast$3(i,"float32")),1));return div$2(a,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const addGradConfig={kernelName:Add$1,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{let h=a;const g=getReductionAxes(i.shape,o);return g.length>0&&(h=sum$3(h,g)),reshape$4(h,i.shape)},b:()=>{let h=a;const g=getReductionAxes(s.shape,o);return g.length>0&&(h=sum$3(h,g)),reshape$4(h,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const addNGradConfig={kernelName:AddN,saveAllInputs:!0,gradFunc:(a,e)=>{const i={};return e.forEach((s,o)=>{i[o]=()=>a.clone()}),i}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const argMaxGradConfig={kernelName:ArgMax,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>zerosLike$2(i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const argMinGradConfig={kernelName:ArgMin,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>zerosLike$2(i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const asinGradConfig={kernelName:Asin,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,sqrt$4(sub$3(scalar(1),square$2(cast$3(i,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const asinhGradConfig={kernelName:Asinh,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>{const s=sqrt$4(add$4(scalar(1),square$2(cast$3(i,"float32"))));return div$2(a,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atan2GradConfig={kernelName:Atan2,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{const h=add$4(square$2(i),square$2(s));let g=mul$1(a,div$2(s,h));const _=getReductionAxes(i.shape,o);return _.length>0&&(g=sum$3(g,_)),reshape$4(g,i.shape)},b:()=>{const h=add$4(square$2(i),square$2(s));let g=neg$2(mul$1(a,div$2(i,h)));const _=getReductionAxes(s.shape,o);return _.length>0&&(g=sum$3(g,_)),reshape$4(g,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atanGradConfig={kernelName:Atan,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,add$4(square$2(cast$3(i,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atanhGradConfig={kernelName:Atanh,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,sub$3(scalar(1),square$2(cast$3(i,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3dGrad_(a,e,i,s,o,c){const d=convertToTensor(a,"dy","avgPool3dGrad"),h=convertToTensor(e,"input","avgPool3dGrad");let g=d,_=h,b=!1;h.rank===4&&(b=!0,g=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]]),_=reshape$4(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),assert$1(g.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${g.rank}.`),assert$1(_.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${_.rank}.`),c!=null&&assert$1(isInt(o),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${c} but got pad ${o}.`);const $={dy:g,input:_},j={filterSize:i,strides:s,pad:o,dimRoundingMode:c},_e=ENGINE.runKernel(AvgPool3DGrad,$,j);return b?reshape$4(_e,[_e.shape[1],_e.shape[2],_e.shape[3],_e.shape[4]]):_e}const avgPool3dGrad=op({avgPool3dGrad_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const avgPool3DGradConfig$1={kernelName:AvgPool3D,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{filterSize:o,strides:c,pad:d,dimRoundingMode:h}=i;return{x:()=>avgPool3dGrad(a,s,o,c,d,h)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPoolGrad_(a,e,i,s,o){const c=convertToTensor(a,"dy","avgPoolGrad"),d=convertToTensor(e,"input","avgPoolGrad");assert$1(d.rank===c.rank,()=>`Rank of input (${d.rank}) does not match rank of dy (${c.rank})`);let h=d,g=c,_=!1;d.rank===3&&(_=!0,h=reshape$4(d,[1,d.shape[0],d.shape[1],d.shape[2]]),g=reshape$4(c,[1,c.shape[0],c.shape[1],c.shape[2]])),assert$1(g.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${g.rank}.`),assert$1(h.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${h.rank}.`);const b={dy:g,input:h},$={filterSize:i,strides:s,pad:o},j=ENGINE.runKernel(AvgPoolGrad,b,$);return _?reshape$4(j,[j.shape[1],j.shape[2],j.shape[3]]):j}const avgPoolGrad$2=op({avgPoolGrad_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const avgPoolGradConfig$2={kernelName:AvgPool,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{filterSize:o,strides:c,pad:d}=i;return{x:()=>avgPoolGrad$2(a,s,o,c,d)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const batchMatMulGradConfig={kernelName:BatchMatMul,inputsToSave:["a","b"],gradFunc:(a,e,i)=>{const[s,o]=e,{transposeA:c,transposeB:d}=i;return!c&&!d?{a:()=>matMul$1(a,o,!1,!0),b:()=>matMul$1(s,a,!0,!1)}:!c&&d?{a:()=>matMul$1(a,o,!1,!1),b:()=>matMul$1(a,s,!0,!1)}:c&&!d?{a:()=>matMul$1(o,a,!1,!0),b:()=>matMul$1(s,a,!1,!1)}:{a:()=>matMul$1(o,a,!0,!0),b:()=>matMul$1(a,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const batchToSpaceNDGradConfig={kernelName:BatchToSpaceND,gradFunc:(a,e,i)=>{const{blockShape:s,crops:o}=i;return{x:()=>spaceToBatchND$2(a,s,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const broadcastToGradConfig={kernelName:BroadcastTo,gradFunc:(a,e,i)=>{const s=i,o=s.inputShape,c=s.shape,d=Array.from(c);for(let g=o.length-1;g>=0;g--)if(o[g]===c[g])d[g]=1;else if(o[g]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${c}].`);const h=[];for(let g=0;g<d.length;g++)d[g]>1&&h.push(g);return{x:()=>sum$3(a,h,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const castGradConfig={kernelName:Cast,gradFunc:a=>({x:()=>a.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ceilGradConfig={kernelName:Ceil,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const clipByValueGradConfig={kernelName:ClipByValue,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{clipValueMin:o,clipValueMax:c}=i;return{x:()=>where(logicalAnd$2(greaterEqual$2(s,o),lessEqual$2(s,c)),a,zerosLike$2(a))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const complexAbsGradConfig={kernelName:ComplexAbs,inputsToSave:["x"],gradFunc:absGradConfig.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const concatGradConfig={kernelName:Concat,saveAllInputs:!0,gradFunc:(a,e,i)=>{const s=e.map(g=>g.shape),{axis:o}=i,c=parseAxisParam(o,e[0].shape)[0],d=s.map(g=>g[c]);return split$1(a,d,c).map(g=>()=>g)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const conv2DGradConfig={kernelName:Conv2D$1,inputsToSave:["x","filter"],gradFunc:(a,e,i)=>{const[s,o]=e,{dilations:c,strides:d,pad:h,dataFormat:g}=i;return assert$1(tupleValuesAreOne(c),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${c}'`),{x:()=>conv2DBackpropInput$2(s.shape,a,o,d,h,g),filter:()=>conv2DBackpropFilter$2(s,a,o.shape,d,h,g)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const conv2DBackpropInputGradConfig={kernelName:Conv2DBackpropInput,inputsToSave:["dy","filter"],gradFunc:(a,e,i)=>{const[s,o]=e,{strides:c,pad:d,dataFormat:h,dimRoundingMode:g}=i;return{dy:()=>conv2d$3(a,o,c,d,h,1,g),filter:()=>conv2DBackpropFilter$2(a,s,o.shape,c,d,h,g)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropFilter_(a,e,i,s,o){let c=a;a.rank===4&&(c=reshape$4(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]));let d=e;d.rank===4&&(d=reshape$4(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),assert$1(c.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${c.shape}.`),assert$1(d.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${d.shape}.`),assert$1(i.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${i}.`),assert$1(c.shape[4]===i[3],()=>`Error in conv3dDerFilter: depth of input ${c.shape[4]}) must match input depth in filter (${i[3]}.`),assert$1(d.shape[4]===i[4],()=>`Error in conv3dDerFilter: depth of dy (${d.shape[4]}) must match output depth for filter (${i[4]}).`);const h={x:c,dy:d},g={strides:s,pad:o,filterShape:i};return ENGINE.runKernel(Conv3DBackpropFilterV2,h,g)}const conv3DBackpropFilter=op({conv3DBackpropFilter_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const conv3DGradConfig={kernelName:Conv3D$1,inputsToSave:["x","filter"],gradFunc:(a,e,i)=>{const{dilations:s,strides:o,pad:c}=i;assert$1(tupleValuesAreOne(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[d,h]=e;return{x:()=>conv3DBackpropInput$1(d.shape,a,h,o,c),filter:()=>conv3DBackpropFilter(d,a,h.shape,o,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cosGradConfig={kernelName:Cos,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(neg$2(sin$4(cast$3(i,"float32"))),a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const coshGradConfig={kernelName:Cosh,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(sinh$3(cast$3(i,"float32")),a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cumsumGradConfig={kernelName:Cumsum,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{axis:o,exclusive:c,reverse:d}=i;return{x:()=>{const h=getAxesPermutation([o],s.rank);let g=cumsum$2(a,o,c,!d);return h!=null&&(g=transpose$3(g,h)),g}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const depthwiseConv2dNativeGradConfig={kernelName:DepthwiseConv2dNative,inputsToSave:["x","filter"],gradFunc:(a,e,i)=>{const{dilations:s,strides:o,pad:c,dimRoundingMode:d}=i,h=s??[1,1];assert$1(tupleValuesAreOne(h),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${h}'`);const[g,_]=e;return assert$1(g.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${g.rank}.`),assert$1(_.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${_.rank}.`),assert$1(g.shape[3]===_.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${_.shape[2]}.`),assert$1(eitherStridesOrDilationsAreOne(o,h),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${h}'.`),d!=null&&assert$1(isInt(c),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${c}.`),{x:()=>depthwiseConv2dNativeBackpropInput$2(g.shape,a,_,o,c,s,d),filter:()=>depthwiseConv2dNativeBackpropFilter$2(g,a,_.shape,o,c,s,d)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2dGradConfig={kernelName:Dilation2D,inputsToSave:["x","filter"],gradFunc:(a,e,i)=>{const[s,o]=e,c={x:s,filter:o,dy:a},d={x:s,filter:o,dy:a};return{x:()=>ENGINE.runKernel(Dilation2DBackpropInput,c,i),filter:()=>ENGINE.runKernel(Dilation2DBackpropFilter,d,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eluGradConfig$2={kernelName:Elu$1,outputsToSave:[!0],gradFunc:(a,e)=>{const[i]=e,s={dy:a,y:i};return{x:()=>ENGINE.runKernel(EluGrad,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const erfGradConfig={kernelName:Erf,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e,s=mul$1(exp$3(neg$2(square$2(i))),2/Math.sqrt(Math.PI));return{x:()=>mul$1(a,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expGradConfig={kernelName:Exp,outputsToSave:[!0],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expandDimsGradConfig={kernelName:ExpandDims,inputsToSave:["input"],gradFunc:(a,e)=>{const[i]=e;return{input:()=>reshape$4(a,i.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expm1GradConfig={kernelName:Expm1,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,exp$3(i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const floorGradConfig={kernelName:Floor,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const floorDivGradConfig={kernelName:FloorDiv,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{const h=div$2(a,cast$3(s,"float32")),g=getReductionAxes(i.shape,o);return g.length>0?reshape$4(sum$3(h,g),i.shape):h},b:()=>{let h=mul$1(a,cast$3(i,"float32"));const g=getReductionAxes(s.shape,o);g.length>0&&(h=reshape$4(sum$3(h,g),s.shape));const _=square$2(s);return neg$2(div$2(h,cast$3(_,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fusedBatchNormGradConfig={kernelName:FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:(a,e,i)=>{const{varianceEpsilon:s}=i,[o,c,d,h]=e,g=h??scalar(1),_=getReductionAxes(c.shape,o.shape),b=[];if(c.rank===1){for(let st=0;st<o.shape.length-1;++st)b.push(o.shape[st]);b.push(1)}const $=sub$3(o,c),j=mul$1(a,g),_e=rsqrt$2(add$4(d,scalar(s))),tt=mul$1(mul$1(mul$1(_e,_e),_e),scalar(-.5));return{x:()=>c.rank===1?reshape$4(mul$1(mul$1(a,tile$3(reshape$4(_e,[1,1,1,c.shape[0]]),b)),g),o.shape):reshape$4(mul$1(mul$1(a,_e),g),o.shape),mean:()=>{let st=mul$1(mul$1(_e,scalar(-1)),j);return c.rank===1&&(st=sum$3(st,_)),reshape$4(st,c.shape)},variance:()=>{let st=mul$1(mul$1(tt,$),j);return c.rank===1&&(st=sum$3(st,_)),reshape$4(st,c.shape)},scale:()=>{const st=mul$1($,_e);let ot=mul$1(a,st);return c.rank===1&&(ot=sum$3(ot,_)),reshape$4(ot,c.shape)},offset:()=>{let st=a;return c.rank===1&&(st=sum$3(st,_)),reshape$4(st,c.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gatherGradConfig={kernelName:GatherV2,inputsToSave:["x","indices"],gradFunc:(a,e,i)=>{const[s,o]=e,{axis:c}=i,d=parseAxisParam(c,s.shape)[0];return{x:()=>{const g=s.shape,_=o.size,b=g.slice(0,d),$=b.length,j=g.slice(c,g.length).slice(1),_e=j.length,tt=arrayRange(0,$),et=arrayRange($+1,$+1+_e),nt=arrayConcat([b,[_],j]),rt=reshape$4(a,nt),it=reshape$4(o,[_]),at=arrayConcat([[$],tt,et]),st=transpose$3(rt,at);let ot=unsortedSegmentSum$2(st,it,s.shape[d]);const ct=getUndoAxesPermutation(at);return ot=transpose$3(ot,ct),ot},indices:()=>o}}};function arrayRange(a,e){const i=[];for(let s=a;s<e;++s)i.push(s);return i}function arrayConcat(a){const e=[];for(let i=0;i<a.length;++i)for(let s=0;s<a[i].length;++s)e.push(a[i][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const greaterEqualGradConfig={kernelName:GreaterEqual,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e;return{a:()=>zerosLike$2(i),b:()=>zerosLike$2(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const identityGradConfig={kernelName:Identity$1,gradFunc:a=>({x:()=>cast$3(a,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isFiniteGradConfig={kernelName:IsFinite,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isInfGradConfig={kernelName:IsInf,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isNanGradConfig={kernelName:IsNan,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const leakyReluGradConfig={kernelName:LeakyRelu,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{alpha:o}=i,c=greater$3(s,0);return{x:()=>where(c,a,mul$1(a,o))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const log1pGradConfig={kernelName:Log1p,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,add$4(i,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logGradConfig={kernelName:Log,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,cast$3(i,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logSoftmaxGradConfig={kernelName:LogSoftmax$1,inputsToSave:[],outputsToSave:[!0],gradFunc:(a,e,i)=>{const[s]=e,{axis:o}=i;return{logits:()=>{const d=exp$3(s);return sub$3(a,mul$1(sum$3(a,o,!0),d))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function localResponseNormalizationBackprop_(a,e,i,s=5,o=1,c=1,d=.5){const h={x:a,y:e,dy:i},g={depthRadius:s,bias:o,alpha:c,beta:d};return ENGINE.runKernel(LRNGrad,h,g)}const localResponseNormalizationBackprop=op({localResponseNormalizationBackprop_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lrnGradConfig={kernelName:LRN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,e,i)=>{const[s,o]=e,{depthRadius:c,bias:d,alpha:h,beta:g}=i;return{x:()=>localResponseNormalizationBackprop(s,o,a,c,d,h,g)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gradForMinAndMax(a,e,i,s){return e.rank<i.rank&&(e=reshape$4(e,expandShapeToKeepDim(e.shape,s))),a.rank<i.rank&&(a=reshape$4(a,expandShapeToKeepDim(a.shape,s))),{x:()=>mul$1(a,cast$3(equal$3(i,e),a.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maxGradConfig={kernelName:Max,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,e,i)=>{const s=i,{reductionIndices:o}=s,c=e[0],d=e[1],h=parseAxisParam(o,c.shape),g=gradForMinAndMax(a,d,c,h);return{x:()=>g.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maximumGradConfig={kernelName:Maximum$1,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e;return{a:()=>mul$1(a,cast$3(greaterEqual$2(i,s),"float32")),b:()=>mul$1(a,cast$3(less$3(i,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3dGrad_(a,e,i,s,o,c,d){const h=convertToTensor(a,"dy","maxPool3dGrad"),g=convertToTensor(e,"input","maxPool3dGrad"),_=convertToTensor(i,"output","maxPool3dGrad");let b=h,$=g,j=_,_e=!1;g.rank===4&&(_e=!0,b=reshape$4(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),$=reshape$4(g,[1,g.shape[0],g.shape[1],g.shape[2],g.shape[3]]),j=reshape$4(_,[1,_.shape[0],_.shape[1],_.shape[2],_.shape[3]])),assert$1(b.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${b.rank}.`),assert$1($.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${$.rank}.`),assert$1(j.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${j.rank}.`),d!=null&&assert$1(isInt(c),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${d} but got pad ${c}.`);const tt={dy:b,input:$,output:j},et={filterSize:s,strides:o,pad:c,dimRoundingMode:d},nt=ENGINE.runKernel(MaxPool3DGrad,tt,et);return _e?reshape$4(nt,[nt.shape[1],nt.shape[2],nt.shape[3],nt.shape[4]]):nt}const maxPool3dGrad=op({maxPool3dGrad_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maxPool3DGradConfig$1={kernelName:MaxPool3D,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,e,i)=>{const[s,o]=e,{filterSize:c,strides:d,pad:h,dimRoundingMode:g}=i;return{x:()=>maxPool3dGrad(a,s,o,c,d,h,g)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolGrad_(a,e,i,s,o,c,d){const h=convertToTensor(a,"dy","maxPoolGrad"),g=convertToTensor(e,"input","maxPoolGrad"),_=convertToTensor(i,"output","maxPoolGrad");assert$1(g.rank===h.rank,()=>`Rank of input (${g.rank}) does not match rank of dy (${h.rank})`),assert$1(h.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${h.rank}.`),assert$1(g.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${g.rank}.`),d!=null&&assert$1(isInt(c),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${d} but got pad ${c}.`);const b={dy:h,input:g,output:_},$={filterSize:s,strides:o,pad:c,dimRoundingMode:d};return ENGINE.runKernel(MaxPoolGrad,b,$)}const maxPoolGrad$2=op({maxPoolGrad_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maxPoolGradConfig$2={kernelName:MaxPool,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,e,i)=>{const[s,o]=e,{filterSize:c,strides:d,pad:h}=i;return{x:()=>maxPoolGrad$2(a,s,o,c,d,h)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const meanGradConfig={kernelName:Mean,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{axis:o}=i,c=parseAxisParam(o,s.shape),h=computeOutAndReduceShapes(s.shape,c)[1],g=sizeFromShape(h);return{x:()=>{const b=s.shape.slice();c.forEach(_e=>{b[_e]=1});const $=reshape$4(a,b);return div$2(mul$1($,ones$1(s.shape,"float32")),g)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const minGradConfig={kernelName:Min,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(a,e,i)=>{const s=i,{axis:o}=s,[c,d]=e,h=parseAxisParam(o,c.shape),g=gradForMinAndMax(a,d,c,h);return{x:()=>g.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const minimumGradConfig={kernelName:Minimum$1,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e;return{a:()=>mul$1(a,cast$3(lessEqual$2(i,s),"float32")),b:()=>mul$1(a,cast$3(greater$3(i,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mirrorPadGradConfig={kernelName:MirrorPad,inputsToSave:["x"],gradFunc:(a,e,i)=>{const s=e[0],{paddings:o}=i,c=o.map(d=>d[0]);return{x:()=>slice$2(a,c,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const modGradConfig={kernelName:Mod,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{const h=getReductionAxes(i.shape,o);return h.length>0?reshape$4(sum$3(a,h),i.shape):a},b:()=>{const h=mul$1(a,neg$2(floor$3(div$2(i,s)))),g=getReductionAxes(s.shape,o);return g.length>0?reshape$4(sum$3(h,g),s.shape):h}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const multiplyGradConfig={kernelName:Multiply$1,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{const h=mul$1(a,cast$3(s,"float32")),g=getReductionAxes(i.shape,o);return g.length>0?reshape$4(sum$3(h,g),i.shape):h},b:()=>{const h=mul$1(a,cast$3(i,"float32")),g=getReductionAxes(s.shape,o);return g.length>0?reshape$4(sum$3(h,g),s.shape):h}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const negGradConfig={kernelName:Neg,gradFunc:a=>({x:()=>neg$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oneHotGradConfig={kernelName:OneHot,inputsToSave:["indices"],gradFunc:(a,e)=>{const i=e[0];return{indices:()=>zeros$4(i.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const onesLikeGradConfig={kernelName:OnesLike,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const packGradConfig={kernelName:Pack,saveAllInputs:!0,gradFunc:(a,e,i)=>{const{axis:s}=i;return unstack(a,s).map(c=>()=>c)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const padV2GradConfig={kernelName:PadV2,inputsToSave:["x"],gradFunc:(a,e,i)=>{const s=e[0],{paddings:o}=i,c=o.map(d=>d[0]);return{x:()=>slice$2(a,c,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const powGradConfig={kernelName:Pow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(a,e)=>{const[i,s,o]=e,c=i,d=s,h=assertAndGetBroadcastShape(c.shape,d.shape);return{a:()=>{const b=cast$3(d,"float32");let $=mul$1(a,mul$1(b,pow$4(c,sub$3(b,scalar(1)))));const j=getReductionAxes(c.shape,h);return j.length>0&&($=sum$3($,j)),reshape$4($,c.shape)},b:()=>{const b=greater$3(c,0),$=where(b,log$4(c),zerosLike$2(c));let j=mul$1(a,mul$1(o,$));const _e=getReductionAxes(d.shape,h);return _e.length>0&&(j=sum$3(j,_e)),reshape$4(j,d.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const preluGradConfig={kernelName:Prelu,inputsToSave:["x","alpha"],gradFunc:(a,e)=>{const[i,s]=e,o=greater$3(i,0);return{x:()=>where(o,a,mul$1(a,s)),alpha:()=>{let c=where(o,zerosLike$2(a),mul$1(a,i));const d=getReductionAxes(s.shape,a.shape);return d.length>0&&(c=sum$3(c,d)),reshape$4(c,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const divGradConfig={kernelName:RealDiv,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{const h=div$2(a,cast$3(s,"float32")),g=getReductionAxes(i.shape,o);return g.length>0?reshape$4(sum$3(h,g),i.shape):h},b:()=>{let h=mul$1(a,cast$3(i,"float32"));const g=getReductionAxes(s.shape,o);g.length>0&&(h=reshape$4(sum$3(h,g),s.shape));const _=square$2(s);return neg$2(div$2(h,cast$3(_,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const reciprocalGradConfig={kernelName:Reciprocal,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,neg$2(square$2(i)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const relu6GradConfig={kernelName:Relu6$1,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e,s=mul$1(lessEqual$2(i,6),step$2(i));return{x:()=>mul$1(a,cast$3(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const reluGradConfig={kernelName:Relu$1,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,cast$3(step$2(i),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const reshapeGradConfig={kernelName:Reshape$1,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>reshape$4(a,i.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const resizeBilinearGradConfig$2={kernelName:ResizeBilinear,inputsToSave:["images"],gradFunc:(a,e,i)=>{const[s]=e,o={dy:a,images:s};return{images:()=>ENGINE.runKernel(ResizeBilinearGrad,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const resizeNearestNeighborGradConfig$2={kernelName:ResizeNearestNeighbor,inputsToSave:["images"],gradFunc:(a,e,i)=>{const[s]=e,o={dy:a,images:s};return{images:()=>ENGINE.runKernel(ResizeNearestNeighborGrad,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const reverseGradConfig={kernelName:Reverse,gradFunc:(a,e,i)=>{const{dims:s}=i,o=parseAxisParam(s,a.shape);return{x:()=>reverse$2(a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const roundGradConfig={kernelName:Round,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rsqrtGradConfig={kernelName:Rsqrt,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>neg$2(div$2(a,mul$1(pow$4(i,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const selectGradConfig={kernelName:Select,inputsToSave:["condition"],gradFunc:(a,e)=>{const[i]=e;return{condition:()=>cast$3(zerosLike$2(i),"float32"),t:()=>mul$1(a,cast$3(i,a.dtype)),e:()=>mul$1(a,cast$3(logicalNot$2(i),a.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const seluGradConfig={kernelName:Selu$1,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>{const s=greater$3(i,scalar(0)),o=scalar(SELU_SCALEALPHA),c=scalar(SELU_SCALE),d=mul$1(a,c),h=mul$1(mul$1(a,o),exp$3(cast$3(i,"float32")));return where(s,d,h)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sigmoidGradConfig={kernelName:Sigmoid$1,outputsToSave:[!0],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,mul$1(i,sub$3(scalar(1),i)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const signGradConfig={kernelName:Sign,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sinGradConfig={kernelName:Sin,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(cos$4(cast$3(i,"float32")),a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sinhGradConfig={kernelName:Sinh,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(cosh$3(cast$3(i,"float32")),a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sliceGradConfig={kernelName:Slice,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{begin:o,size:c}=i,d=s.shape,[h,g]=parseSliceParams(s,o,c),_=[];for(let b=0;b<a.rank;b++)_.push([h[b],d[b]-h[b]-g[b]]);return{x:()=>pad(a,_)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const softmaxGradConfig={kernelName:Softmax$2,outputsToSave:[!0],gradFunc:(a,e,i)=>{const[s]=e,{dim:o}=i,c=!0,d=mul$1(a,s);return{logits:()=>sub$3(d,mul$1(sum$3(d,[o],c),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const softplusGradConfig={kernelName:Softplus$1,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,sigmoid$2(i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spaceToBatchNDGradConfig={kernelName:SpaceToBatchND,gradFunc:(a,e,i)=>{const{blockShape:s,paddings:o}=i;return{x:()=>batchToSpaceND$2(a,s,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const splitVGradConfig={kernelName:SplitV,gradFunc:(a,e,i)=>{const{axis:s}=i;return{x:()=>concat$3(a,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sqrtGradConfig={kernelName:Sqrt,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,mul$1(sqrt$4(cast$3(i,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const squareGradConfig={kernelName:Square,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(a,mul$1(cast$3(i,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const squaredDifferenceGradConfig={kernelName:SquaredDifference,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=scalar(2);return{a:()=>mul$1(a,mul$1(o,sub$3(i,s))),b:()=>mul$1(a,mul$1(o,sub$3(s,i)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const stepGradConfig={kernelName:Step,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const subGradConfig={kernelName:Sub,inputsToSave:["a","b"],gradFunc:(a,e)=>{const[i,s]=e,o=assertAndGetBroadcastShape(i.shape,s.shape);return{a:()=>{let h=a;const g=getReductionAxes(i.shape,o);return g.length>0&&(h=sum$3(h,g)),reshape$4(h,i.shape)},b:()=>{let h=a;const g=getReductionAxes(s.shape,o);return g.length>0&&(h=sum$3(h,g)),reshape$4(neg$2(h),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sumGradConfig={kernelName:Sum,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,o=s.shape.slice(),{axis:c}=i;parseAxisParam(c,s.shape).forEach(_=>{o[_]=1});const h=reshape$4(a,o),g=mul$1(h,ones$1(s.shape,"float32"));return{x:()=>g}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tanGradConfig={kernelName:Tan,inputsToSave:["x"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>div$2(a,square$2(cos$4(i)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tanhGradConfig={kernelName:Tanh$1,outputsToSave:[!0],gradFunc:(a,e)=>{const[i]=e;return{x:()=>mul$1(sub$3(scalar(1),square$2(i)),a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tileGradConfig={kernelName:Tile,inputsToSave:["x"],gradFunc:(a,e,i)=>{const[s]=e,{reps:o}=i;return{x:()=>{let d=zerosLike$2(s);if(s.rank===1)for(let h=0;h<o[0];++h)d=add$4(d,slice$2(a,[h*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let h=0;h<o[0];++h)for(let g=0;g<o[1];++g)d=add$4(d,slice$2(a,[h*s.shape[0],g*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let h=0;h<o[0];++h)for(let g=0;g<o[1];++g)for(let _=0;_<o[2];++_)d=add$4(d,slice$2(a,[h*s.shape[0],g*s.shape[1],_*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let h=0;h<o[0];++h)for(let g=0;g<o[1];++g)for(let _=0;_<o[2];++_)for(let b=0;b<o[3];++b)d=add$4(d,slice$2(a,[h*s.shape[0],g*s.shape[1],_*s.shape[2],b*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return d}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const transposeGradConfig={kernelName:Transpose,gradFunc:(a,e,i)=>{const s=i,{perm:o}=s,c=getUndoAxesPermutation(o);return{x:()=>transpose$3(a,c)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const unpackGradConfig={kernelName:Unpack,gradFunc:(a,e,i)=>{const s=i,{axis:o}=s;return{value:()=>stack(a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const unsortedSegmentSumGradConfig={kernelName:UnsortedSegmentSum,inputsToSave:["segmentIds"],gradFunc:(a,e)=>{const[i]=e;return{x:()=>gatherDropNegatives(a,i)}}};function gatherDropNegatives(a,e){const i=maximum$3(e,zerosLike$2(e)),s=gather$1(a,i);let o=greaterEqual$2(e,scalar(0,"int32"));const c=s.rank-o.rank;for(let h=0;h<c;++h)o=expandDims$3(o,h+1);o=logicalAnd$2(o,ones$1(s.shape,"bool"));const d=zerosLike$2(s);return where(o,s,d)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zerosLikeGradConfig={kernelName:ZerosLike,gradFunc:a=>({x:()=>zerosLike$2(a)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gradConfigs=[absGradConfig,acosGradConfig,acoshGradConfig,addGradConfig,addNGradConfig,argMaxGradConfig,argMinGradConfig,asinGradConfig,asinhGradConfig,atan2GradConfig,atanGradConfig,atanhGradConfig,avgPool3DGradConfig$1,avgPoolGradConfig$2,batchMatMulGradConfig,batchToSpaceNDGradConfig,broadcastToGradConfig,castGradConfig,ceilGradConfig,clipByValueGradConfig,complexAbsGradConfig,concatGradConfig,conv2DBackpropInputGradConfig,conv2DGradConfig,conv3DGradConfig,cosGradConfig,coshGradConfig,cumsumGradConfig,depthwiseConv2dNativeGradConfig,dilation2dGradConfig,divGradConfig,eluGradConfig$2,erfGradConfig,expGradConfig,expandDimsGradConfig,expm1GradConfig,floorDivGradConfig,floorGradConfig,fusedBatchNormGradConfig,gatherGradConfig,greaterEqualGradConfig,identityGradConfig,isFiniteGradConfig,isInfGradConfig,isNanGradConfig,leakyReluGradConfig,log1pGradConfig,logGradConfig,logSoftmaxGradConfig,lrnGradConfig,maxGradConfig,maxGradConfig,maximumGradConfig,maxPool3DGradConfig$1,maxPoolGradConfig$2,meanGradConfig,minGradConfig,minimumGradConfig,mirrorPadGradConfig,modGradConfig,multiplyGradConfig,negGradConfig,oneHotGradConfig,onesLikeGradConfig,packGradConfig,padV2GradConfig,padV2GradConfig,powGradConfig,preluGradConfig,reciprocalGradConfig,relu6GradConfig,reluGradConfig,reshapeGradConfig,resizeBilinearGradConfig$2,resizeNearestNeighborGradConfig$2,reverseGradConfig,roundGradConfig,rsqrtGradConfig,selectGradConfig,seluGradConfig,sigmoidGradConfig,signGradConfig,sinGradConfig,sinhGradConfig,sliceGradConfig,softmaxGradConfig,softplusGradConfig,spaceToBatchNDGradConfig,spaceToBatchNDGradConfig,splitVGradConfig,splitVGradConfig,sqrtGradConfig,squaredDifferenceGradConfig,squareGradConfig,stepGradConfig,subGradConfig,sumGradConfig,tanGradConfig,tanhGradConfig,tileGradConfig,transposeGradConfig,unpackGradConfig,unsortedSegmentSumGradConfig,zerosLikeGradConfig];for(const a of gradConfigs)registerGradient(a);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.abs=function(){return this.throwIfDisposed(),abs$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.acos=function(){return this.throwIfDisposed(),acos$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.acosh=function(){return this.throwIfDisposed(),acosh$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.add=function(a){return this.throwIfDisposed(),add$4(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.all=function(a,e){return this.throwIfDisposed(),all$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.any=function(a,e){return this.throwIfDisposed(),any$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.argMax=function(a){return this.throwIfDisposed(),argMax$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.argMin=function(a){return this.throwIfDisposed(),argMin$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.asScalar=function(){return this.throwIfDisposed(),assert$1(this.size===1,()=>"The array must have only 1 element."),reshape$4(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.asType=function(a){return this.throwIfDisposed(),cast$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.as1D=function(){return this.throwIfDisposed(),reshape$4(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.as2D=function(a,e){return this.throwIfDisposed(),reshape$4(this,[a,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.as3D=function(a,e,i){return this.throwIfDisposed(),reshape$4(this,[a,e,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.as4D=function(a,e,i,s){return this.throwIfDisposed(),reshape$4(this,[a,e,i,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.as5D=function(a,e,i,s,o){return this.throwIfDisposed(),reshape$4(this,[a,e,i,s,o])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.asin=function(){return this.throwIfDisposed(),asin$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.asinh=function(){return this.throwIfDisposed(),asinh$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.atan=function(){return this.throwIfDisposed(),atan$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.atan2=function(a){return this.throwIfDisposed(),atan2$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.atanh=function(){return this.throwIfDisposed(),atanh$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.avgPool=function(a,e,i,s){return this.throwIfDisposed(),avgPool$2(this,a,e,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.batchToSpaceND=function(a,e){return this.throwIfDisposed(),batchToSpaceND$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.batchNorm=function(a,e,i,s,o){return this.throwIfDisposed(),batchNorm$2(this,a,e,i,s,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.broadcastTo=function(a){return this.throwIfDisposed(),broadcastTo(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.cast=function(a){return this.throwIfDisposed(),cast$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.ceil=function(){return this.throwIfDisposed(),ceil$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.clipByValue=function(a,e){return this.throwIfDisposed(),clipByValue$1(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.concat=function(a,e){return this.throwIfDisposed(),a instanceof Tensor&&(a=[a]),concat$3([this,...a],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.conv1d=function(a,e,i,s,o,c){return this.throwIfDisposed(),conv1d$1(this,a,e,i,s,o,c)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.conv2dTranspose=function(a,e,i,s,o){return this.throwIfDisposed(),conv2dTranspose$1(this,a,e,i,s,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.conv2d=function(a,e,i,s,o,c){return this.throwIfDisposed(),conv2d$3(this,a,e,i,s,o,c)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.cos=function(){return this.throwIfDisposed(),cos$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.cosh=function(){return this.throwIfDisposed(),cosh$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.cumsum=function(a,e,i){return this.throwIfDisposed(),cumsum$2(this,a,e,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.depthToSpace=function(a,e){return this.throwIfDisposed(),depthToSpace$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.depthwiseConv2d=function(a,e,i,s,o,c){return this.throwIfDisposed(),depthwiseConv2d$3(this,a,e,i,s,o,c)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.dilation2d=function(a,e,i,s,o){return this.throwIfDisposed(),dilation2d(this,a,e,i,s,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.divNoNan=function(a){return this.throwIfDisposed(),divNoNan(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.div=function(a){return this.throwIfDisposed(),div$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.dot=function(a){return this.throwIfDisposed(),dot$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.elu=function(){return this.throwIfDisposed(),elu$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.equal=function(a){return this.throwIfDisposed(),equal$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.erf=function(){return this.throwIfDisposed(),erf$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.exp=function(){return this.throwIfDisposed(),exp$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.expandDims=function(a){return this.throwIfDisposed(),expandDims$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.expm1=function(){return this.throwIfDisposed(),expm1$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.fft=function(){return this.throwIfDisposed(),fft$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.flatten=function(){return this.throwIfDisposed(),reshape$4(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.floor=function(){return this.throwIfDisposed(),floor$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.floorDiv=function(a){return this.throwIfDisposed(),floorDiv$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.gather=function(a,e){return this.throwIfDisposed(),gather$1(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.greaterEqual=function(a){return this.throwIfDisposed(),greaterEqual$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.greater=function(a){return this.throwIfDisposed(),greater$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.ifft=function(){return this.throwIfDisposed(),ifft$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.irfft=function(){return this.throwIfDisposed(),irfft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.isFinite=function(){return this.throwIfDisposed(),isFinite$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.isInf=function(){return this.throwIfDisposed(),isInf$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.isNaN=function(){return this.throwIfDisposed(),isNaN$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.leakyRelu=function(a){return this.throwIfDisposed(),leakyRelu$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.lessEqual=function(a){return this.throwIfDisposed(),lessEqual$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.less=function(a){return this.throwIfDisposed(),less$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.localResponseNormalization=function(a,e,i,s){return this.throwIfDisposed(),localResponseNormalization(this,a,e,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logSigmoid=function(){return this.throwIfDisposed(),logSigmoid(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logSoftmax=function(a){return this.throwIfDisposed(),logSoftmax(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logSumExp=function(a,e){return this.throwIfDisposed(),logSumExp(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.log=function(){return this.throwIfDisposed(),log$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.log1p=function(){return this.throwIfDisposed(),log1p$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logicalAnd=function(a){return this.throwIfDisposed(),logicalAnd$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logicalNot=function(){return this.throwIfDisposed(),logicalNot$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logicalOr=function(a){return this.throwIfDisposed(),logicalOr$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.logicalXor=function(a){return this.throwIfDisposed(),logicalXor(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.matMul=function(a,e,i){return this.throwIfDisposed(),matMul$1(this,a,e,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.maxPool=function(a,e,i,s){return this.throwIfDisposed(),maxPool$2(this,a,e,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.max=function(a,e){return this.throwIfDisposed(),max$4(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.maximum=function(a){return this.throwIfDisposed(),maximum$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.mean=function(a,e){return this.throwIfDisposed(),mean$1(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.min=function(a,e){return this.throwIfDisposed(),min$4(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.minimum=function(a){return this.throwIfDisposed(),minimum$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.mirrorPad=function(a,e){return this.throwIfDisposed(),mirrorPad$1(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.mod=function(a){return this.throwIfDisposed(),mod$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.mul=function(a){return this.throwIfDisposed(),mul$1(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.neg=function(){return this.throwIfDisposed(),neg$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.norm=function(a,e,i){return this.throwIfDisposed(),norm$1(this,a,e,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.notEqual=function(a){return this.throwIfDisposed(),notEqual$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.oneHot=function(a,e=1,i=0){return this.throwIfDisposed(),oneHot$2(this,a,e,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.onesLike=function(){return this.throwIfDisposed(),onesLike$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.pad=function(a,e){return this.throwIfDisposed(),pad(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.pool=function(a,e,i,s,o){return this.throwIfDisposed(),pool$2(this,a,e,i,s,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.pow=function(a){return this.throwIfDisposed(),pow$4(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.prelu=function(a){return this.throwIfDisposed(),prelu$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.prod=function(a,e){return this.throwIfDisposed(),prod$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.reciprocal=function(){return this.throwIfDisposed(),reciprocal$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.relu=function(){return this.throwIfDisposed(),relu$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.relu6=function(){return this.throwIfDisposed(),relu6$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.reshapeAs=function(a){return this.throwIfDisposed(),reshape$4(this,a.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.reshape=function(a){return this.throwIfDisposed(),reshape$4(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.resizeBilinear=function(a,e,i){return this.throwIfDisposed(),resizeBilinear$2(this,a,e,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.resizeNearestNeighbor=function(a,e,i){return this.throwIfDisposed(),resizeNearestNeighbor$2(this,a,e,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.reverse=function(a){return this.throwIfDisposed(),reverse$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.rfft=function(){return this.throwIfDisposed(),rfft(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.round=function(){return this.throwIfDisposed(),round$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.rsqrt=function(){return this.throwIfDisposed(),rsqrt$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.selu=function(){return this.throwIfDisposed(),selu$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.separableConv2d=function(a,e,i,s,o,c){return this.throwIfDisposed(),separableConv2d$1(this,a,e,i,s,o,c)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sigmoid=function(){return this.throwIfDisposed(),sigmoid$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sign=function(){return this.throwIfDisposed(),sign$5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sin=function(){return this.throwIfDisposed(),sin$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sinh=function(){return this.throwIfDisposed(),sinh$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.slice=function(a,e){return this.throwIfDisposed(),slice$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.softmax=function(a){return this.throwIfDisposed(),softmax$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.softplus=function(){return this.throwIfDisposed(),softplus$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.spaceToBatchND=function(a,e){return this.throwIfDisposed(),spaceToBatchND$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.split=function(a,e){return this.throwIfDisposed(),split$1(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sqrt=function(){return this.throwIfDisposed(),sqrt$4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.square=function(){return this.throwIfDisposed(),square$2(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.squaredDifference=function(a){return this.throwIfDisposed(),squaredDifference$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.squeeze=function(a){return this.throwIfDisposed(),squeeze$1(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.stack=function(a,e){this.throwIfDisposed();const i=a instanceof Tensor?[this,a]:[this,...a];return stack(i,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.step=function(a){return this.throwIfDisposed(),step$2(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.stridedSlice=function(a,e,i,s,o,c,d,h){return this.throwIfDisposed(),stridedSlice$2(this,a,e,i,s,o,c,d,h)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sub=function(a){return this.throwIfDisposed(),sub$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.sum=function(a,e){return this.throwIfDisposed(),sum$3(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.tan=function(){return this.throwIfDisposed(),tan$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.tanh=function(){return this.throwIfDisposed(),tanh$3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.tile=function(a){return this.throwIfDisposed(),tile$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.toBool=function(){return this.throwIfDisposed(),cast$3(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.toFloat=function(){return this.throwIfDisposed(),cast$3(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.toInt=function(){return this.throwIfDisposed(),cast$3(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.topk=function(a,e){return this.throwIfDisposed(),topk(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.transpose=function(a){return this.throwIfDisposed(),transpose$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.unique=function(a){return this.throwIfDisposed(),unique$3(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.unsortedSegmentSum=function(a,e){return this.throwIfDisposed(),unsortedSegmentSum$2(this,a,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.unstack=function(a){return this.throwIfDisposed(),unstack(this,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.where=function(a,e){return this.throwIfDisposed(),where(a,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getGlobalTensorClass().prototype.zerosLike=function(){return this.throwIfDisposed(),zerosLike$2(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let _epsilon;function epsilon$1(){return _epsilon==null&&(_epsilon=backend().epsilon()),_epsilon}function imageDataFormat(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class AttributeError extends Error{constructor(e){super(e),Object.setPrototypeOf(this,AttributeError.prototype)}}class RuntimeError extends Error{constructor(e){super(e),Object.setPrototypeOf(this,RuntimeError.prototype)}}class ValueError extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ValueError.prototype)}}class NotImplementedError extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NotImplementedError.prototype)}}class AssertionError extends Error{constructor(e){super(e),Object.setPrototypeOf(this,AssertionError.prototype)}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pyListRepeat(a,e){if(Array.isArray(a)){let i=[];for(let s=0;s<e;s++)i=i.concat(a);return i}else{const i=new Array(e);return i.fill(a),i}}function assert(a,e){if(!a)throw new AssertionError(e)}function count(a,e){let i=0;for(const s of a)s===e&&i++;return i}function singletonOrArray(a){return a.length===1?a[0]:a}function toList(a){return Array.isArray(a)?a:[a]}function toSnakeCase(a){const i=a.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return i[0]!=="_"?i:"private"+i}function toCamelCase(a){return a.length<=1||a.indexOf("_")===-1?a:a.replace(/[_]+(\w|$)/g,(e,i)=>i.toUpperCase())}let _GLOBAL_CUSTOM_OBJECTS={};function serializeKerasObject(a){if(a==null)return null;const e={};return e.className=a.getClassName(),e.config=a.getConfig(),e}function convertNDArrayScalarsInConfig(a){if(!(a==null||typeof a!="object"))if(Array.isArray(a))a.forEach(e=>convertNDArrayScalarsInConfig(e));else{const e=Object.keys(a);for(const i of e){const s=a[i];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?a[i]=s.value:convertNDArrayScalarsInConfig(s))}}}function deserializeKerasObject(a,e={},i={},s="object",o=!1){if(typeof a=="string"){const c=a;let d;if(c in i)d=i[c];else if(c in _GLOBAL_CUSTOM_OBJECTS)d=_GLOBAL_CUSTOM_OBJECTS[c];else if(d=e[c],d==null)throw new ValueError(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return d}else{const c=a;if(c.className==null||c.config==null)throw new ValueError(`${s}: Improper config format: ${JSON.stringify(c)}.
'className' and 'config' must set.`);const d=c.className;let h,g;if(d in i?[h,g]=i[d]:d in _GLOBAL_CUSTOM_OBJECTS?[h,g]=_GLOBAL_CUSTOM_OBJECTS.className:d in e&&([h,g]=e[d]),h==null)throw new ValueError(`Unknown ${s}: ${d}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(g!=null){const _={};for(const _e of Object.keys(_GLOBAL_CUSTOM_OBJECTS))_[_e]=_GLOBAL_CUSTOM_OBJECTS[_e];for(const _e of Object.keys(i))_[_e]=i[_e];const b=c.config;b.customObjects=_;const $=Object.assign({},_GLOBAL_CUSTOM_OBJECTS);for(const _e of Object.keys(i))_GLOBAL_CUSTOM_OBJECTS[_e]=i[_e];convertNDArrayScalarsInConfig(c.config);const j=g(h,c.config,i,o);return _GLOBAL_CUSTOM_OBJECTS=Object.assign({},$),j}else{const _=Object.assign({},_GLOBAL_CUSTOM_OBJECTS);for(const $ of Object.keys(i))_GLOBAL_CUSTOM_OBJECTS[$]=i[$];const b=new h(c.config);return _GLOBAL_CUSTOM_OBJECTS=Object.assign({},_),b}}}function numberCompare(a,e){return a<e?-1:a>e?1:0}function reverseNumberCompare(a,e){return-1*numberCompare(a,e)}function unique$2(a){if(a==null)return a;const e=[];for(const i of a)e.indexOf(i)===-1&&e.push(i);return e}function isObjectEmpty(a){if(a==null)throw new ValueError(`Invalid value in obj: ${JSON.stringify(a)}`);for(const e in a)if(a.hasOwnProperty(e))return!1;return!0}function checkStringTypeUnionValue(a,e,i){if(i!=null&&a.indexOf(i)<0)throw new ValueError(`${i} is not a valid ${e}.  Valid values are ${a} or null/undefined.`)}function checkArrayTypeAndLength(a,e,i=0,s=1/0){return assert(i>=0),assert(s>=i),Array.isArray(a)&&a.length>=i&&a.length<=s&&a.every(o=>typeof o===e)}function assertPositiveInteger(a,e){Array.isArray(a)?(assert$1(a.length>0,()=>`${e} is unexpectedly an empty array.`),a.forEach((i,s)=>assertPositiveInteger(i,`element ${s+1} of ${e}`))):assert$1(Number.isInteger(a)&&a>0,()=>`Expected ${e} to be a positive integer, but got ${formatAsFriendlyString(a)}.`)}function formatAsFriendlyString(a){return a===null?"null":Array.isArray(a)?"["+a.map(e=>formatAsFriendlyString(e)).join(",")+"]":typeof a=="string"?`"${a}"`:`${a}`}function debounce(a,e){let i=now(),s;return(...c)=>{const d=now();return d-i<e||(i=d,s=a(...c)),s}}function mapActivationToFusedKernel(a){return a==="relu"?"relu":a==="linear"?"linear":a==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function calcL2Norms(a,e){return tidy(()=>sqrt$4(sum$3(mul$1(a,a),e,!0)))}class Constraint extends Serializable{getConfig(){return{}}}class MaxNorm extends Constraint{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return tidy(()=>{const i=calcL2Norms(e,this.axis),s=clipByValue$1(i,0,this.maxValue);return mul$1(e,div$2(s,add$4(epsilon$1(),i)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}MaxNorm.className="MaxNorm";registerClass(MaxNorm);class UnitNorm extends Constraint{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return tidy(()=>div$2(e,add$4(epsilon$1(),calcL2Norms(e,this.axis))))}getConfig(){return{axis:this.axis}}}UnitNorm.className="UnitNorm";registerClass(UnitNorm);class NonNeg extends Constraint{apply(e){return relu$2(e)}}NonNeg.className="NonNeg";registerClass(NonNeg);class MinMaxNorm extends Constraint{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return tidy(()=>{const i=calcL2Norms(e,this.axis),s=add$4(mul$1(this.rate,clipByValue$1(i,this.minValue,this.maxValue)),mul$1(1-this.rate,i));return mul$1(e,div$2(s,add$4(epsilon$1(),i)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}MinMaxNorm.className="MinMaxNorm";registerClass(MinMaxNorm);const CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function serializeConstraint(a){return serializeKerasObject(a)}function deserializeConstraint(a,e={}){return deserializeKerasObject(a,SerializationMap.getMap().classNameMap,e,"constraint")}function getConstraint(a){if(a==null)return null;if(typeof a=="string"){const i={className:a in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP?CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[a]:a,config:{}};return deserializeConstraint(i)}else return a instanceof Constraint?a:deserializeConstraint(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function maxNorm(a){return new MaxNorm(a)}function unitNorm(a){return new UnitNorm(a)}function nonNeg(){return new NonNeg}function minMaxNorm(a){return new MinMaxNorm(a)}const exports_constraints=Object.freeze(Object.defineProperty({__proto__:null,maxNorm,minMaxNorm,nonNeg,unitNorm},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],VALID_INTERPOLATION_FORMAT_VALUES=["nearest","bilinear"],VALID_PADDING_MODE_VALUES=["valid","same","causal"],VALID_POOL_MODE_VALUES=["max","avg"],VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const nameMap=new Map;function checkDataFormat(a){checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES,"DataFormat",a)}function checkInterpolationFormat(a){checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES,"InterpolationFormat",a)}function checkPaddingMode(a){checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES,"PaddingMode",a)}function checkPoolMode(a){checkStringTypeUnionValue(VALID_POOL_MODE_VALUES,"PoolMode",a)}const _nameScopeStack=[],_nameScopeDivider="/";function nameScope(a,e){_nameScopeStack.push(a);try{const i=e();return _nameScopeStack.pop(),i}catch(i){throw _nameScopeStack.pop(),i}}function currentNameScopePrefix(){return _nameScopeStack.length===0?"":_nameScopeStack.join(_nameScopeDivider)+_nameScopeDivider}function getScopedTensorName(a){if(!isValidTensorName(a))throw new Error("Not a valid tensor name: '"+a+"'");return currentNameScopePrefix()+a}function getUniqueTensorName(a){if(!isValidTensorName(a))throw new Error("Not a valid tensor name: '"+a+"'");nameMap.has(a)||nameMap.set(a,0);const e=nameMap.get(a);if(nameMap.set(a,nameMap.get(a)+1),e>0){const i=`${a}_${e}`;return nameMap.set(i,1),i}else return a}const tensorNameRegex=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function isValidTensorName(a){return!!a.match(tensorNameRegex)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isInteger$1(a){return a===parseInt(a.toString(),10)}function arrayProd(a,e,i){e==null&&(e=0),i==null&&(i=a.length);let s=1;for(let o=e;o<i;++o)s*=a[o];return s}function toArray1D(a){return a=Array.isArray(a)?new Float32Array(a):a,tensor1d(a)}function min$3(a){return min$4(toArray1D(a)).dataSync()[0]}function max$3(a){return max$4(toArray1D(a)).dataSync()[0]}function range$3(a,e){if(e<a)throw new ValueError(`end (${e}) < begin (${a}) is forbidden.`);const i=[];for(let s=a;s<e;++s)i.push(s);return i}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cast$2(a,e){return a.asType(e)}function expandDims$2(a,e=-1){const i=a.shape.slice();return e<0&&(e=i.length+e+1),i.splice(e,0,1),a.reshape(i)}function repeat(a,e){return tidy(()=>{if(a.shape.length!==2)throw new ValueError(`repeat() expects a rank-2 tensor, but received a rank-${a.shape.length} tensor.`);const i=expandDims$2(a,1);return tile$2(i,[1,e,1])})}function flatten$3(a){const e=[arrayProd(a.shape)];return a.reshape(e)}function batchFlatten(a){if(a.rank<=1)throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${a.rank}.`);const e=[a.shape[0],arrayProd(a.shape,1)];return a.reshape(e)}function sliceAlongFirstAxis(a,e,i){return tidy(()=>{switch(a.rank){case 1:return slice1d(a,e,i);case 2:return slice2d(a,[e,0],[i,a.shape[1]]);case 3:return slice3d(a,[e,0,0],[i,a.shape[1],a.shape[2]]);case 4:return slice4d(a,[e,0,0,0],[i,a.shape[1],a.shape[2],a.shape[3]]);case 5:return slice$2(a,[e,0,0,0,0],[i,a.shape[1],a.shape[2],a.shape[3],a.shape[4]]);case 6:return slice$2(a,[e,0,0,0,0,0],[i,a.shape[1],a.shape[2],a.shape[3],a.shape[4],a.shape[5]]);default:throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`)}})}function sliceAlongLastAxis(a,e,i){return tidy(()=>{switch(a.rank){case 1:return slice1d(a,e,i);case 2:return slice2d(a,[0,e],[a.shape[0],i]);case 3:return slice3d(a,[0,0,e],[a.shape[0],a.shape[1],i]);case 4:return slice4d(a,[0,0,0,e],[a.shape[0],a.shape[1],a.shape[2],i]);default:throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${a.rank}`)}})}function sliceAlongAxis(a,e,i,s){return tidy(()=>{switch(a.rank){case 1:return slice1d(a,e,i);case 2:switch(s){case 1:return sliceAlongFirstAxis(a,e,i);case 2:return sliceAlongLastAxis(a,e,i);default:throw new ValueError(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return sliceAlongFirstAxis(a,e,i);case 2:return slice3d(a,[0,e,0],[a.shape[0],i,a.shape[2]]);case 3:return sliceAlongLastAxis(a,e,i);default:throw new ValueError(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return sliceAlongFirstAxis(a,e,i);case 2:return slice4d(a,[0,e,0,0],[a.shape[0],i,a.shape[2],a.shape[3]]);case 3:return slice4d(a,[0,0,e,0],[a.shape[0],a.shape[1],i,a.shape[3]]);case 4:return sliceAlongLastAxis(a,e,i);default:throw new ValueError(`The axis is not within the rank of the tensor ${s}`)}default:throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ${a.rank}`)}})}function concatenate$1(a,e=-1){let i;return e<0&&(i=a[0].rank,i!==0?e=i:e=0),e===a[0].rank&&(e=-1),concat$3(a,e)}function concatAlongFirstAxis(a,e){switch(a.rank){case 1:return concat1d([a,e]);case 2:return concat2d([a,e],0);case 3:return concat3d([a,e],0);case 4:return concat4d([a,e],0);default:throw new ValueError(`concatAlongFirstAxis() received an unsupported tensor rank: ${a.rank}`)}}function tile$2(a,e){if(Array.isArray(e)||(e=[e]),a.rank!==e.length)throw new ValueError(`The length of input n (${e.length}) does not match the number of dimensions in input x (${a.rank})`);return tile$3(a,e)}function randomNormal$1(a,e=0,i=1,s,o){return randomNormal$2(a,e,i,s,o)}function dot$2(a,e,i,s){if(a.rank<2||e.rank<2)throw new NotImplementedError(`dot requires both inputs to be rank >= 2 but got x shape = ${a.shape} and y shape = ${e.shape}`);if(e.rank>=3){const o=a.shape.slice(-1)[0],c=e.shape.slice(-2)[0];if(o!==c)throw new NotImplementedError(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${a.shape} and  y shape = ${e.shape}`)}if(a.rank===2&&e.rank===2)return matMul({a,b:e,transposeA:!1,transposeB:!1,bias:s?reshapeBias(a.rank,s,imageDataFormat()):null,activation:i});{const o=a.shape.slice(),c=o.pop();a=a.reshape([-1,c]);const d=e.shape.slice(),h=d.pop(),g=d.pop(),_=[...d,h],b=Array.from({length:e.rank},(tt,et)=>et===0?e.rank-2:et<=e.rank-2?et-1:et);e=e.transpose(b).reshape([g,-1]);const $=[...o,..._];return matMul({a,b:e,transposeA:!1,transposeB:!1,bias:s?reshapeBias(a.rank,s,imageDataFormat()):null,activation:i}).reshape($)}}function gather(a,e,i){return tidy(()=>(Array.isArray(e)?e=tensor1d(e,"int32"):e=e.toInt(),gather$1(a,e,i)))}function square$1(a){return mul$1(a,a)}function reshapeBias(a,e,i){const s=e.shape;if(e.rank!==1&&e.rank!==a)throw new ValueError(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${a}`);if(a===5){if(i==="channelsFirst")return s.length===1?e.reshape([1,s[0],1,1,1]):e.reshape([1,s[3],s[0],s[1],s[2]]);if(i==="channelsLast")return s.length===1?e.reshape([1,1,1,1,s[0]]):e.reshape([1].concat(s))}else if(a===4){if(i==="channelsFirst")return s.length===1?e.reshape([1,s[0],1,1]):e.reshape([1,s[2],s[0],s[1]]);if(i==="channelsLast")return s.length===1?e.reshape([1,1,1,s[0]]):e.reshape([1].concat(s))}else if(a===3){if(i==="channelsFirst")return s.length===1?e.reshape([1,s[0],1]):e.reshape([1,s[1],s[0]]);if(i==="channelsLast")return s.length===1?e.reshape([1,1,s[0]]):e.reshape([1].concat(s))}else if(a<3)return e;throw new ValueError(`Unsupported input rank by biasAdd: ${e.rank}`)}function biasAdd(a,e,i){return tidy(()=>(i==null&&(i=imageDataFormat()),checkDataFormat(i),a.add(reshapeBias(a.rank,e,i))))}function elu$3(a,e=1){if(e!==1)throw new NotImplementedError(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return elu$4(a)}function softsign(a){return tidy(()=>div$2(a,abs$4(a).add(1)))}function dropout$1(a,e,i,s){return tidy(()=>dropout$2(a,e,i,s))}function hardSigmoid(a){return tidy(()=>{const e=add$4(.5,mul$1(.2,a));return clipByValue$1(e,0,1)})}function inTrainPhase(a,e,i=!1){return i?a():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function checkFanMode(a){checkStringTypeUnionValue(VALID_FAN_MODE_VALUES,"FanMode",a)}function checkDistribution(a){checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES,"Distribution",a)}class Initializer extends Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Zeros extends Initializer{apply(e,i){return zeros$4(e,i)}}Zeros.className="Zeros";registerClass(Zeros);class Ones extends Initializer{apply(e,i){return ones$1(e,i)}}Ones.className="Ones";registerClass(Ones);class Constant extends Initializer{constructor(e){if(super(),typeof e!="object")throw new ValueError(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ValueError(`config must have value set but got ${e}`);this.value=e.value}apply(e,i){return tidy(()=>mul$1(scalar(this.value),ones$1(e,i)))}getConfig(){return{value:this.value}}}Constant.className="Constant";registerClass(Constant);class RandomUniform extends Initializer{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,i){return randomUniform$1(e,this.minval,this.maxval,i)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}RandomUniform.className="RandomUniform";registerClass(RandomUniform);class RandomNormal extends Initializer{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,i){if(i=i||"float32",i!=="float32"&&i!=="int32")throw new NotImplementedError(`randomNormal does not support dType ${i}.`);return randomNormal$1(e,this.mean,this.stddev,i,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}RandomNormal.className="RandomNormal";registerClass(RandomNormal);class TruncatedNormal extends Initializer{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,i){if(i=i||"float32",i!=="float32"&&i!=="int32")throw new NotImplementedError(`truncatedNormal does not support dType ${i}.`);return truncatedNormal$1(e,this.mean,this.stddev,i,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}TruncatedNormal.className="TruncatedNormal";registerClass(TruncatedNormal);class Identity extends Initializer{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,i){return tidy(()=>{if(e.length!==2||e[0]!==e[1])throw new ValueError("Identity matrix initializer can only be used for 2D square matrices.");return mul$1(this.gain,eye(e[0]))})}getConfig(){return{gain:this.gain}}}Identity.className="Identity";registerClass(Identity);function computeFans(a,e="channelsLast"){let i,s;if(checkDataFormat(e),a.length===2)i=a[0],s=a[1];else if([3,4,5].indexOf(a.length)!==-1){if(e==="channelsFirst"){const o=arrayProd(a,2);i=a[1]*o,s=a[0]*o}else if(e==="channelsLast"){const o=arrayProd(a,0,a.length-2);i=a[a.length-2]*o,s=a[a.length-1]*o}}else{const o=arrayProd(a);i=Math.sqrt(o),s=Math.sqrt(o)}return[i,s]}class VarianceScaling extends Initializer{constructor(e){if(super(),e.scale<0)throw new ValueError(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,checkFanMode(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,checkDistribution(this.distribution),this.seed=e.seed}apply(e,i){const s=computeFans(e),o=s[0],c=s[1];let d=this.scale;if(this.mode==="fanIn"?d/=Math.max(1,o):this.mode==="fanOut"?d/=Math.max(1,c):d/=Math.max(1,(o+c)/2),this.distribution==="normal"){const h=Math.sqrt(d);if(i=i||"float32",i!=="float32"&&i!=="int32")throw new NotImplementedError(`${this.getClassName()} does not support dType ${i}.`);return truncatedNormal$1(e,0,h,i,this.seed)}else{const h=Math.sqrt(3*d);return randomUniform$1(e,-h,h,i)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}VarianceScaling.className="VarianceScaling";registerClass(VarianceScaling);class GlorotUniform extends VarianceScaling{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return VarianceScaling.className}}GlorotUniform.className="GlorotUniform";registerClass(GlorotUniform);class GlorotNormal extends VarianceScaling{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return VarianceScaling.className}}GlorotNormal.className="GlorotNormal";registerClass(GlorotNormal);class HeNormal extends VarianceScaling{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return VarianceScaling.className}}HeNormal.className="HeNormal";registerClass(HeNormal);class HeUniform extends VarianceScaling{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return VarianceScaling.className}}HeUniform.className="HeUniform";registerClass(HeUniform);class LeCunNormal extends VarianceScaling{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return VarianceScaling.className}}LeCunNormal.className="LeCunNormal";registerClass(LeCunNormal);class LeCunUniform extends VarianceScaling{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return VarianceScaling.className}}LeCunUniform.className="LeCunNormal";registerClass(LeCunUniform);class Orthogonal extends Initializer{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new NotImplementedError("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,i){return tidy(()=>{if(e.length<2)throw new NotImplementedError("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const s=e[0]>e[1]?[e[1],e[0]]:e,o=randomNormal$1(s,0,1,"float32");let c=linalg.gramSchmidt(o);return e[0]>e[1]&&(c=c.transpose()),mul$1(this.gain,c)})}getConfig(){return{gain:this.gain,seed:this.seed}}}Orthogonal.className="Orthogonal";registerClass(Orthogonal);const INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function deserializeInitializer(a,e={}){return deserializeKerasObject(a,SerializationMap.getMap().classNameMap,e,"initializer")}function serializeInitializer(a){return serializeKerasObject(a)}function getInitializer(a){if(typeof a=="string"){const e=a in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[a]:a;if(e==="GlorotNormal")return new GlorotNormal;if(e==="GlorotUniform")return new GlorotUniform;if(e==="HeNormal")return new HeNormal;if(e==="HeUniform")return new HeUniform;if(e==="LeCunNormal")return new LeCunNormal;if(e==="LeCunUniform")return new LeCunUniform;{const i={};return i.className=e,i.config={},deserializeInitializer(i)}}else return a instanceof Initializer?a:deserializeInitializer(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zeros$3(){return new Zeros}function ones(){return new Ones}function constant(a){return new Constant(a)}function randomUniform(a){return new RandomUniform(a)}function randomNormal(a){return new RandomNormal(a)}function truncatedNormal(a){return new TruncatedNormal(a)}function identity$3(a){return new Identity(a)}function varianceScaling(a){return new VarianceScaling(a)}function glorotUniform(a){return new GlorotUniform(a)}function glorotNormal(a){return new GlorotNormal(a)}function heNormal(a){return new HeNormal(a)}function heUniform(a){return new HeUniform(a)}function leCunNormal(a){return new LeCunNormal(a)}function leCunUniform(a){return new LeCunUniform(a)}function orthogonal(a){return new Orthogonal(a)}const exports_initializers=Object.freeze(Object.defineProperty({__proto__:null,constant,glorotNormal,glorotUniform,heNormal,heUniform,identity:identity$3,leCunNormal,leCunUniform,ones,orthogonal,randomNormal,randomUniform,truncatedNormal,varianceScaling,zeros:zeros$3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let _nextUniqueTensorId=0;function getNextUniqueTensorId(){return _nextUniqueTensorId++}const _uidPrefixes={};function getUid(a=""){return a in _uidPrefixes||(_uidPrefixes[a]=0),_uidPrefixes[a]+=1,a+_uidPrefixes[a].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isArrayOfShapes(a){return Array.isArray(a)&&Array.isArray(a[0])}function normalizeShapeList(a){return a.length===0?[]:Array.isArray(a[0])?a:[a]}function getExactlyOneTensor(a){let e;if(Array.isArray(a)){if(a.length!==1)throw new ValueError(`Expected Tensor length to be 1; got ${a.length}`);e=a[0]}else e=a;return e}function getExactlyOneShape(a){if(Array.isArray(a)&&Array.isArray(a[0])){if(a.length===1)return a=a,a[0];throw new ValueError(`Expected exactly 1 Shape; got ${a.length}`)}else return a}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function countParamsInWeights(a){let e=0;for(const i of a)i.shape.length===0?e+=1:e+=i.shape.reduce((s,o)=>s*o);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const DEFAULT_VARIABLE_NAME_PREFIX="Variable";class LayerVariable{constructor(e,i="float32",s=DEFAULT_VARIABLE_NAME_PREFIX,o=!0,c=null){this.dtype=i??"float32",this.shape=e.shape,this.id=getNextUniqueTensorId(),s=s??DEFAULT_VARIABLE_NAME_PREFIX,this.originalName=getScopedTensorName(s),this.name=getUniqueTensorName(this.originalName),this.trainable_=o,this.constraint=c,this.val=variable(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),checkShapesMatch(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function checkShapesMatch(a,e){if(a.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(a.shape)+" vs. "+JSON.stringify(e.shape))}function batchGetValue(a){return a.map(e=>e.read())}function batchSetValue(a){a.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class InputSpec{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class SymbolicTensor{constructor(e,i,s,o,c,d,h){this.dtype=e,this.shape=i,this.sourceLayer=s,this.inputs=o,this.callArgs=c,this.outputTensorIndex=h,this.id=getNextUniqueTensorId(),d!=null&&(this.originalName=getScopedTensorName(d),this.name=getUniqueTensorName(this.originalName)),this.rank=i.length}}let _nextNodeID=0;class Node{constructor(e,i){this.callArgs=i,this.id=_nextNodeID++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const i of this.inboundLayers)i!=null?e.push(i.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let _nextLayerID=0;class Layer extends Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=_nextLayerID++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let i=e.name;if(!i){const s=this.getClassName();i=toSnakeCase(s)+"_"+getUid(s)}if(this.name=i,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let c=null;e.batchSize!=null&&(c=e.batchSize),s=[c].concat(e.inputShape)}this.batchInputShape=s;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,i){return e.name+"_ib-"+i.toString()}getNodeAtIndex(e,i){if(this.inboundNodes.length===0)throw new RuntimeError(`The layer has never been called and thus has no defined ${i}.`);if(this.inboundNodes.length<=e)throw new ValueError(`Asked to get ${i} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return singletonOrArray(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return singletonOrArray(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new AttributeError(`Layer ${this.name} is not connected, no input to return.`);return singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new AttributeError(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new AttributeError(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(i=>i.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=toList(e),this.inputSpec==null||this.inputSpec.length===0)return;const i=toList(this.inputSpec);if(e.length!==i.length)throw new ValueError(`Layer ${this.name} expects ${i.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let s=0;s<e.length;s++){const o=e[s],c=i[s];if(c==null)continue;const d=o.rank;if(c.ndim!=null&&d!==c.ndim)throw new ValueError(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${c.ndim}, found ndim=${d}`);if(c.maxNDim!=null&&d>c.maxNDim)throw new ValueError(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${c.maxNDim}, found ndim=${d}`);if(c.minNDim!=null&&d<c.minNDim)throw new ValueError(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${c.minNDim}, found ndim=${d}.`);if(c.dtype!=null&&o.dtype!==c.dtype)throw new ValueError(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${c.dtype}, found dtype=${o.dtype}.`);if(c.axes){const h=o.shape;for(const g in c.axes){const _=Number(g),b=c.axes[g],$=_>=0?h[_]:h[h.length+_];if(b!=null&&[b,null].indexOf($)===-1)throw new ValueError(`Input ${s} is incompatible with layer ${this.name}: expected axis ${_} of input shape to have value ${b} but got shape ${h}.`)}}if(c.shape!=null)for(let h=0;h<c.shape.length;++h){const g=c.shape[h],_=o.shape[h];if(g!=null&&_!=null&&g!==_)throw new ValueError(`Input ${s} is incompatible with layer ${this.name}: expected shape=${c.shape}, found shape=${o.shape}.`)}}}call(e,i){return e}invokeCallHook(e,i){this._callHook!=null&&this._callHook(e,i)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,i){i=i||{},this.assertNotDisposed();const s=toList(e);let o=!0;for(const d of s)if(!(d instanceof SymbolicTensor)){o=!1;break}let c=!0;for(const d of s)if(d instanceof SymbolicTensor){c=!1;break}if(o===c)throw new ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return nameScope(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const d=[];for(const h of toList(e))d.push(h.shape);this.build(singletonOrArray(d)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&c&&(this._refCount=1)}if(this.assertInputCompatibility(e),c){let d=this.call(e,i);const h=toList(d),g=[];for(let _ of h)s.indexOf(_)!==-1&&(_=_.clone()),g.push(_);if(d=singletonOrArray(g),this.activityRegularizer!=null)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return d}else{const d=collectInputShape(e),h=this.computeOutputShape(d);let g;const _=guessOutputDType(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?d[0]:d),h!=null&&h.length>0&&Array.isArray(h[0])?g=h.map((b,$)=>new SymbolicTensor(_,b,this,toList(e),i,this.name,$)):g=new SymbolicTensor(_,h,this,toList(e),i,this.name),this.addInboundNode(e,g,null,null,d,h,i),this._refCount++,this.activityRegularizer!=null)throw new NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return g}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let i=!1;this.batchInputShape.forEach((s,o)=>{s!=null&&e[o]!=null&&e[o]!==s&&(i=!0)}),i&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new AttributeError(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const i of this.inboundNodes){const s=JSON.stringify(i.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const i=this.inboundNodes[0].outputShapes;return Array.isArray(i)&&Array.isArray(i[0])&&i.length===1?i[0]:i}else throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new RuntimeError(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return countParamsInWeights(this.weights)}build(e){this.built=!0}getWeights(e=!1){return batchGetValue(e?this.trainableWeights:this.weights)}setWeights(e){tidy(()=>{const i=this.weights;if(i.length!==e.length)throw new ValueError(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${i.length} weights. Provided weights: ${e}...`);if(i.length===0)return;const s=[],o=batchGetValue(i);for(let c=0;c<o.length;++c){const d=o[c],h=i[c],g=e[c];if(!arraysEqual(d.shape,g.shape))throw new ValueError(`Layer weight shape ${d.shape} not compatible with provided weight shape ${g.shape}`);s.push([h,g])}batchSetValue(s)})}addWeight(e,i,s,o,c,d,h){if(this._addedWeightNames.indexOf(e)!==-1)throw new ValueError(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(o=getInitializer("zeros"));const g=o.apply(i,s),_=new LayerVariable(g,s,e,d,h);return g.dispose(),c!=null&&this.addLoss(()=>c.apply(_.read())),d==null&&(d=!0),d?this._trainableWeights.push(_):this._nonTrainableWeights.push(_),_}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=toList(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,i){if(!this.supportsMasking){if(i!=null)if(Array.isArray(i))i.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return i}addInboundNode(e,i,s,o,c,d,h=null){const g=toList(e);i=toList(i),s=toList(s),o=toList(o),c=normalizeShapeList(c),d=normalizeShapeList(d);const _=[],b=[],$=[];for(const j of g)_.push(j.sourceLayer),b.push(j.nodeIndex),$.push(j.tensorIndex);new Node({outboundLayer:this,inboundLayers:_,nodeIndices:b,tensorIndices:$,inputTensors:g,outputTensors:i,inputMasks:s,outputMasks:o,inputShapes:c,outputShapes:d},h);for(let j=0;j<i.length;j++)i[j].sourceLayer=this,i[j].nodeIndex=this.inboundNodes.length-1,i[j].tensorIndex=j}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function collectInputShape(a){a=toList(a);const e=[];for(const i of a)e.push(i.shape);return singletonOrArray(e)}function guessOutputDType(a){return"float32"}function getSourceInputs(a,e,i){if((e==null||i!=null&&i>0)&&(e=a.sourceLayer,i=a.nodeIndex),e.inboundNodes.length===0)return[a];{const s=e.inboundNodes[i];if(s.inboundLayers.length===0)return s.inputTensors;{const o=[];for(let c=0;c<s.inboundLayers.length;c++){const d=s.inputTensors[c],h=s.inboundLayers[c],g=s.nodeIndices[c],_=getSourceInputs(d,h,g);for(const b of _)o.indexOf(b)===-1&&o.push(b)}return o}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class InputLayer extends Layer{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:getUid("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let i=e.batchInputShape;if(i==null){if(e.inputShape==null)throw new ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");i=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=i,this.dtype=s,this.inputSpec=[{shape:i}];const o=new SymbolicTensor(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[i],outputShapes:[i]})}apply(e,i){throw new ValueError(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}InputLayer.className="InputLayer";registerClass(InputLayer);function Input(a){if(a.batchShape==null&&a.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(a.batchShape!=null&&a.shape!=null)throw new ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=a.batchShape;a.shape!=null&&e==null&&(e=[null].concat(a.shape));let i=a.dtype;return i==null&&(i="float32"),new InputLayer({batchInputShape:e,name:a.name,dtype:i,sparse:a.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function resolveScalarsInLogs(a){if(a==null)return;const e=[],i=[],s=[];for(const o in a){const c=a[o];if(typeof c!="number"){const d=c;e.push(d.data()),i.push(o),s.push(d)}}if(e.length>0){const o=await Promise.all(e);for(let c=0;c<o.length;++c)a[i[c]]=o[c][0];dispose(s)}}function disposeTensorsInLogs(a){if(a!=null)for(const e in a){const i=a[e];typeof i!="number"&&i.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var ModelLoggingVerbosity;(function(a){a[a.SILENT=0]="SILENT",a[a.VERBOSE=1]="VERBOSE"})(ModelLoggingVerbosity||(ModelLoggingVerbosity={}));const DEFAULT_YIELD_EVERY_MS=125;class BaseCallback{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,i){}async onEpochEnd(e,i){}async onBatchBegin(e,i){}async onBatchEnd(e,i){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class CallbackList{constructor(e,i=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=i}append(e){this.callbacks.push(e)}setParams(e){for(const i of this.callbacks)i.setParams(e)}setModel(e){for(const i of this.callbacks)i.setModel(e)}async onEpochBegin(e,i){i==null&&(i={});for(const s of this.callbacks)await s.onEpochBegin(e,i)}async onEpochEnd(e,i){i==null&&(i={});for(const s of this.callbacks)await s.onEpochEnd(e,i)}async onBatchBegin(e,i){i==null&&(i={});for(const s of this.callbacks)await s.onBatchBegin(e,i)}async onBatchEnd(e,i){i==null&&(i={});for(const s of this.callbacks)await s.onBatchEnd(e,i)}async onTrainBegin(e){e==null&&(e={});for(const i of this.callbacks)await i.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const i of this.callbacks)await i.onTrainEnd(e)}}class BaseLogger extends BaseCallback{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,i){i==null&&(i={});const s=i.size==null?0:i.size;this.seen+=s;for(const o in i){const c=i[o];if(typeof c=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+c*s;else{let d;o in this.totals?d=this.totals[o]:this.totals[o]=0;const h=tidy(()=>add$4(this.totals[o],mul$1(c,s)));this.totals[o]=h,d!=null&&d.dispose()}}}async onEpochEnd(e,i){if(i!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?i[s]=this.totals[s]/this.seen:tidy(()=>{const o=mul$1(div$2(1,this.seen),this.totals[s]);i[s]=o,this.totals[s].dispose(),keep(i[s])}))}}class History extends BaseCallback{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,i){i==null&&(i={}),this.epoch.push(e);for(const s in i)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(i[s])}async syncData(){const e=[],i=[],s=[];for(const c in this.history){const d=this.history[c];for(let h=0;h<d.length;++h)if(typeof d[h]!="number"){const g=d[h];e.push(g.data()),i.push(c),s.push(h)}}const o=await Promise.all(e);for(let c=0;c<o.length;++c)this.history[i[c]][s[c]].dispose(),this.history[i[c]][s[c]]=o[c][0]}}class CustomCallback extends BaseCallback{constructor(e,i){if(super(),this.currentEpoch=0,this.yieldEvery=i||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=DEFAULT_YIELD_EVERY_MS),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");isNumber$1(this.yieldEvery)&&(this.maybeWait=debounce(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,i,s){const o=[];this.yield!=null&&(await resolveScalarsInLogs(s),o.push(this.yield(e,i,s))),o.push(nextFrame()),await Promise.all(o)}async onEpochBegin(e,i){this.currentEpoch=e,this.epochBegin!=null&&(await resolveScalarsInLogs(i),await this.epochBegin(e,i))}async onEpochEnd(e,i){const s=[];this.epochEnd!=null&&(await resolveScalarsInLogs(i),s.push(this.epochEnd(e,i))),this.yieldEvery==="epoch"&&s.push(nextFrame()),await Promise.all(s)}async onBatchBegin(e,i){this.batchBegin!=null&&(await resolveScalarsInLogs(i),await this.batchBegin(e,i))}async onBatchEnd(e,i){const s=[];this.batchEnd!=null&&(await resolveScalarsInLogs(i),s.push(this.batchEnd(e,i))),this.yieldEvery==="batch"?s.push(nextFrame()):isNumber$1(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,i)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await resolveScalarsInLogs(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await resolveScalarsInLogs(e),await this.trainEnd(e))}}function standardizeCallbacks(a,e){return a==null&&(a={}),a instanceof BaseCallback?[a]:Array.isArray(a)&&a[0]instanceof BaseCallback?a:toList(a).map(s=>new CustomCallback(s,e))}class CallbackConstructorRegistry{constructor(){}static registerCallbackConstructor(e,i){assert$1(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),CallbackConstructorRegistry.checkForDuplicate(i),CallbackConstructorRegistry.constructors[e]==null&&(CallbackConstructorRegistry.constructors[e]=[]),CallbackConstructorRegistry.constructors[e].push(i)}static checkForDuplicate(e){for(const i in CallbackConstructorRegistry.constructors)CallbackConstructorRegistry.constructors[+i].forEach(o=>{if(o===e)throw new ValueError("Duplicate callback constructor.")})}static clear(){CallbackConstructorRegistry.constructors={}}static createCallbacks(e){const i=[];for(const s in CallbackConstructorRegistry.constructors){const o=+s;e>=o&&i.push(...CallbackConstructorRegistry.constructors[o])}return i.map(s=>new s)}}CallbackConstructorRegistry.constructors={};function configureCallbacks(a,e,i,s,o,c,d,h,g){const _=new History,b=[new BaseLogger,...CallbackConstructorRegistry.createCallbacks(e)];a!=null&&b.push(...a),b.push(_);const $=new CallbackList(b);return $.setParams({epochs:i,initialEpoch:s,samples:o,steps:c,batchSize:d,verbose:e,doValidation:h,metrics:g}),{callbackList:$,history:_}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function deserialize(a,e={},i=!1){return deserializeKerasObject(a,SerializationMap.getMap().classNameMap,e,"layer",i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function l2Normalize(a,e){return tidy(()=>{a.dtype!=="float32"&&(a=a.asType("float32"));const i=sum$3(square$1(a),e,!0),s=fill$2(i.shape,epsilon$1()),o=sqrt$4(maximum$3(i,s));return div$2(a,o)})}function meanSquaredError$1(a,e){return tidy(()=>mean$1(square$1(sub$3(e,a)),-1))}function meanAbsoluteError$1(a,e){return tidy(()=>mean$1(abs$4(sub$3(e,a)),-1))}function meanAbsolutePercentageError$1(a,e){return tidy(()=>{const i=sub$3(a,e),s=clipByValue$1(abs$4(a),epsilon$1(),Number.MAX_VALUE),o=abs$4(div$2(i,s));return mul$1(100,mean$1(o,-1))})}function meanSquaredLogarithmicError(a,e){return tidy(()=>{const i=clipByValue$1(e,epsilon$1(),Number.MAX_VALUE),s=log$4(add$4(1,i)),o=clipByValue$1(a,epsilon$1(),Number.MAX_VALUE),c=log$4(add$4(1,o));return mean$1(square$1(sub$3(s,c)),-1)})}function squaredHinge(a,e){return tidy(()=>{const i=maximum$3(0,sub$3(1,mul$1(a,e)));return mean$1(square$1(i),-1)})}function hinge(a,e){return tidy(()=>{const i=maximum$3(0,sub$3(1,mul$1(a,e)));return mean$1(i,-1)})}function categoricalHinge(a,e){return tidy(()=>{const i=sum$3(mul$1(a,e),-1),s=max$4(mul$1(sub$3(1,a),e),-1);return maximum$3(0,add$4(1,sub$3(s,i)))})}function logcosh(a,e){return tidy(()=>{const i=Math.log(2),s=sub$3(e,a),o=sub$3(add$4(s,softplus$2(mul$1(-2,s))),i);return mean$1(o,-1)})}function categoricalCrossentropy$2(a,e,i=!1){return tidy(()=>{if(i)e=softmax$3(e);else{const s=sum$3(e,e.shape.length-1,!0);e=div$2(e,s)}return e=clipByValue$1(e,epsilon$1(),1-epsilon$1()),neg$2(sum$3(mul$1(a.toFloat(),log$4(e)),e.shape.length-1))})}function sparseCategoricalCrossentropy$1(a,e,i=!1){return tidy(()=>{const s=floor$3(flatten$3(a)).toInt();e=clipByValue$1(e,epsilon$1(),1-epsilon$1());const o=e.shape,c=oneHot$2(s,o[o.length-1]).reshape(o);return categoricalCrossentropy$2(c,e,i)})}function sigmoidCrossEntropyWithLogits(a,e){if(!arraysEqual(a.shape,e.shape))throw new ValueError(`logits and labels must have the same shape, but got shapes ${JSON.stringify(a.shape)} and ${JSON.stringify(e.shape)}`);return tidy(()=>{const i=e.relu(),s=e.abs().neg();return i.sub(e.mul(a)).add(s.exp().log1p())})}function binaryCrossentropy$2(a,e){return tidy(()=>{let i;return i=clipByValue$1(e,epsilon$1(),1-epsilon$1()),i=log$4(div$2(i,sub$3(1,i))),mean$1(sigmoidCrossEntropyWithLogits(a,i),-1)})}function kullbackLeiblerDivergence(a,e){return tidy(()=>{const i=clipByValue$1(a,epsilon$1(),1),s=clipByValue$1(e,epsilon$1(),1);return sum$3(mul$1(a,log$4(div$2(i,s))),-1)})}function poisson(a,e){return tidy(()=>{const i=log$4(add$4(epsilon$1(),e));return mean$1(sub$3(e,mul$1(a,i)),-1)})}function cosineProximity$1(a,e){return tidy(()=>{const i=l2Normalize(a,-1),s=l2Normalize(e,-1),o=mul$1(i,s);return neg$2(sum$3(o,-1))})}const lossesMap={meanSquaredError:meanSquaredError$1,meanAbsoluteError:meanAbsoluteError$1,meanAbsolutePercentageError:meanAbsolutePercentageError$1,meanSquaredLogarithmicError,squaredHinge,hinge,categoricalHinge,logcosh,categoricalCrossentropy:categoricalCrossentropy$2,sparseCategoricalCrossentropy:sparseCategoricalCrossentropy$1,binaryCrossentropy:binaryCrossentropy$2,kullbackLeiblerDivergence,poisson,cosineProximity:cosineProximity$1};function get$1(a){if(typeof a=="string"){if(a in lossesMap)return lossesMap[a];let e=`Unknown loss ${a}`;throw a.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${a}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ValueError(e)}else return a}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function binaryAccuracy$1(a,e){return tidy(()=>{const i=mul$1(.5,onesLike$2(e)),s=cast$2(greater$3(e,i),a.dtype);return mean$1(equal$3(a,s),-1)})}function categoricalAccuracy$1(a,e){return tidy(()=>cast$2(equal$3(argMax$2(a,-1),argMax$2(e,-1)),"float32"))}function truePositives(a,e){return tidy(()=>logicalAnd$2(a.equal(1),e.equal(1)).sum().cast("float32"))}function falseNegatives(a,e){return tidy(()=>logicalAnd$2(a.equal(1),e.equal(0)).sum().cast("float32"))}function falsePositives(a,e){return tidy(()=>logicalAnd$2(a.equal(0),e.equal(1)).sum().cast("float32"))}function precision$1(a,e){return tidy(()=>{const i=truePositives(a,e),s=falsePositives(a,e),o=i.add(s);return where(greater$3(o,0),i.div(o),0).cast("float32")})}function recall$1(a,e){return tidy(()=>{const i=truePositives(a,e),s=falseNegatives(a,e),o=i.add(s);return where(greater$3(o,0),i.div(o),0).cast("float32")})}function binaryCrossentropy$1(a,e){return binaryCrossentropy$2(a,e)}function sparseCategoricalAccuracy$1(a,e){return a.rank===e.rank&&(a=a.squeeze([a.rank-1])),e=e.argMax(-1),e.dtype!==a.dtype&&(e=e.asType(a.dtype)),equal$3(a,e).asType("float32")}const mse$1=meanSquaredError$1,MSE$1=meanSquaredError$1,mae=meanAbsoluteError$1,MAE=meanAbsoluteError$1,mape$1=meanAbsolutePercentageError$1,MAPE$1=meanAbsolutePercentageError$1,categoricalCrossentropy$1=categoricalCrossentropy$2,cosine$1=cosineProximity$1,sparseCategoricalCrossentropy=sparseCategoricalCrossentropy$1,metricsMap={binaryAccuracy:binaryAccuracy$1,categoricalAccuracy:categoricalAccuracy$1,precision:precision$1,categoricalCrossentropy:categoricalCrossentropy$1,sparseCategoricalCrossentropy,mse:mse$1,MSE:MSE$1,mae,MAE,mape:mape$1,MAPE:MAPE$1,cosine:cosine$1};function get(a){if(typeof a=="string"&&a in metricsMap)return metricsMap[a];if(typeof a!="string"&&a!=null)return a;throw new ValueError(`Unknown metric ${a}`)}function getLossOrMetricName(a){if(assert(a!==null,`Unknown LossOrMetricFn ${a}`),typeof a=="string")return a;{let e;for(const i of Object.keys(lossesMap))if(lossesMap[i]===a){e=i;break}if(e!==void 0)return e;for(const i of Object.keys(metricsMap))if(metricsMap[i]===a){e=i;break}return e!==void 0?e:a.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function getOptimizer(a){const e={Adagrad:()=>train.adagrad(.01),Adadelta:()=>train.adadelta(1,.95,epsilon$1()),Adam:()=>train.adam(.001,.9,.999,epsilon$1()),Adamax:()=>train.adamax(.002,.9,.999,epsilon$1(),0),RMSProp:()=>train.rmsprop(.001,.9,0,epsilon$1()),SGD:()=>train.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,a in e)return e[a]();throw new ValueError(`Unknown Optimizer ${a}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH=1*1024*1024;function checkUserDefinedMetadata(a,e,i=!1){if(a==null||typeof a!="object"||Object.getPrototypeOf(a)!==Object.prototype||!plainObjectCheck(a))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(i){const s=JSON.stringify(a);s.length>MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`)}}function plainObjectCheck(a){if(a===null)return!0;if(typeof a=="object")if(Object.getPrototypeOf(a)===Object.prototype){const e=Object.keys(a);for(const i of e)if(typeof i!="string"||!plainObjectCheck(a[i]))return!1;return!0}else if(Array.isArray(a)){for(const e of a)if(!plainObjectCheck(e))return!1;return!0}else return!1;else{const e=typeof a;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function printSummary(a,e,i,s=console.log){const o=isModelSequentialLike(a),c=["Layer (type)","Output shape","Param #"];o?(e=e||65,i=i||[.45,.85,1]):(e=e||98,i=i||[.33,.55,.67,1]),i[i.length-1]<=1&&(i=i.map(b=>Math.floor(e*b)));let d;if(!o){c.push("Receives inputs"),d=[];for(const b in a.nodesByDepth)d.push(...a.nodesByDepth[b])}s("_".repeat(e)),printRow(c,i,s),s("=".repeat(e));const h=a.layers;for(let b=0;b<h.length;++b)o?printLayerSummary(h[b],i,s):printLayerSummaryWithConnections(h[b],i,d,s),s((b===h.length-1?"=":"_").repeat(e));a.checkTrainableWeightsConsistency();const g=countTrainableParams(a),_=countParamsInWeights(a.nonTrainableWeights);s(`Total params: ${g+_}`),s(`Trainable params: ${g}`),s(`Non-trainable params: ${_}`),s("_".repeat(e))}function countTrainableParams(a){let e;return a.collectedTrainableWeights!=null?e=countParamsInWeights(a.collectedTrainableWeights):e=countParamsInWeights(a.trainableWeights),e}function isModelSequentialLike(a){let e=!0;const i=[],s=[];for(const o in a.nodesByDepth)i.push(a.nodesByDepth[o]);for(const o of i){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}s.push(...o)}if(e)for(const o of a.layers){let c=!1;for(const d of o.inboundNodes)if(s.indexOf(d)!==-1)if(c){e=!1;break}else c=!0;if(!e)break}return e}function printRow(a,e,i=console.log){let s="";for(let o=0;o<a.length;++o)o>0&&(s=s.slice(0,s.length-1)+" "),s+=a[o],s=s.slice(0,e[o]),s+=" ".repeat(e[o]-s.length);i(s)}function printLayerSummary(a,e,i){let s;try{s=JSON.stringify(a.outputShape)}catch{s="multiple"}const o=a.name,c=a.getClassName(),d=[`${o} (${c})`,s,a.countParams().toString()];printRow(d,e,i)}function printLayerSummaryWithConnections(a,e,i,s){let o;try{o=JSON.stringify(a.outputShape)}catch{o="multiple"}const c=[];for(const b of a.inboundNodes)if(!(i!=null&&i.length>0&&i.indexOf(b)===-1))for(let $=0;$<b.inboundLayers.length;++$){const j=b.inboundLayers[$].name,_e=b.nodeIndices[$],tt=b.tensorIndices[$];c.push(`${j}[${_e}][${tt}]`)}const d=a.name,h=a.getClassName(),g=c.length===0?"":c[0],_=[`${d} (${h})`,o,a.countParams().toString(),g];printRow(_,e,s);for(let b=1;b<c.length;++b)printRow(["","","",c[b]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isArrayItemInputOrOutputName(a,e,i){return(a==="inboundNodes"||a==="outputLayers"||a==="inputLayers")&&e===0&&typeof i=="string"}function convertPythonicToTs(a,e){if(a===null)return null;if(typeof a=="string")return toCamelCase(a);if(typeof a=="number"||typeof a=="boolean")return a;if(a instanceof Array){const i=[],s=a.length;for(let o=0;o<s;++o){const c=a[o];isArrayItemInputOrOutputName(e,o,c)?i.push(c):i.push(convertPythonicToTs(c,e))}return i}else{const i={};for(const s of Object.keys(a)){const o=a[s];if(s==="name"&&typeof o=="string")i[s]=o;else{const c=toCamelCase(s);i[c]=convertPythonicToTs(o,c)}}return i}}function convertTsToPythonic(a,e){if(a==null)return null;if(typeof a=="string")return toSnakeCase(a);if(typeof a=="number"||typeof a=="boolean")return a;if(a instanceof Array){const i=[],s=a.length;for(let o=0;o<s;++o){const c=a[o];isArrayItemInputOrOutputName(e,o,c)?i.push(c):i.push(convertTsToPythonic(c,e))}return i}else{const i={};for(const s of Object.keys(a)){const o=a[s],c=toSnakeCase(s);(s==="name"||s==="className")&&typeof o=="string"?i[c]=o:i[c]=convertTsToPythonic(o,s)}return i}}/** @license See the LICENSE file. */const version$8="3.1.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function assertFeedCompatibility(a,e){if(a.dtype==null||a.dtype===e.dtype)return e;try{return cast$3(e,a.dtype)}catch{throw new ValueError(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${a.name}' (${a.dtype}).`)}}class FeedDict{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof FeedDict)for(const i in e.id2Value)this.id2Value[i]=e.id2Value[i],i in e.id2Mask&&(this.id2Mask[i]=e.id2Mask[i]);else{if(e==null)return;for(const i of e)this.add(i.key,i.value)}}add(e,i,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=assertFeedCompatibility(e,i),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new ValueError(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof SymbolicTensor){if(this.id2Value[e.id]==null)throw new ValueError(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const i=this.name2Id[e];if(i==null)throw new ValueError(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[i]}}getMask(e){if(e instanceof SymbolicTensor){if(this.id2Value[e.id]==null)throw new ValueError(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const i=this.name2Id[e];if(i==null)throw new ValueError(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[i]}}disposeMasks(){this.id2Mask!=null&&dispose(this.id2Mask)}}const cachedSorted={},cachedRecipientCounts={};function execute(a,e,i,s){const o=i==null?!1:i.training,c=Array.isArray(a),d=c?a:[a],h=d.map(tt=>tt.name),g=[],_=e.names();for(const tt of h)_.indexOf(tt)!==-1?g.push(e.getValue(tt)):g.push(null);const b=h.join(",")+"|"+e.names().join(",");let $,j;if(cachedSorted[b]==null){const tt=getTopologicalSortAndRecipientCounts(d,e);$=tt.sorted,j=tt.recipientCounts,cachedSorted[b]=$,cachedRecipientCounts[b]=j}$=cachedSorted[b],j={},o||Object.assign(j,cachedRecipientCounts[b]);const _e=new FeedDict(e);for(let tt=0;tt<$.length;++tt){const et=$[tt],nt=et.sourceLayer;if(nt instanceof InputLayer)continue;const rt=[],it=[],at=[];let st=!1;for(const xt of et.inputs){const ut=_e.getValue(xt),ft=_e.getMask(xt);rt.push(ut),it.push(ft),ft!=null&&(st=!0),o||(j[xt.name]--,j[xt.name]===0&&!e.hasKey(xt)&&h.indexOf(xt.name)===-1&&!ut.isDisposed&&xt.sourceLayer.stateful!==!0&&at.push(ut))}st&&(i=i||{},i.mask=it[0]);const ot=toList(nt.apply(rt,i));let ct=null;nt.supportsMasking&&(ct=nt.computeMask(rt,it));const lt=getNodeOutputs(et),dt=Array.isArray(lt)?lt:[lt];for(let xt=0;xt<dt.length;++xt){_e.hasKey(dt[xt])||_e.add(dt[xt],ot[xt],Array.isArray(ct)?ct[0]:ct);const ut=h.indexOf(dt[xt].name);ut!==-1&&(g[ut]=ot[xt])}o||dispose(at)}return _e.disposeMasks(),c?g:g[0]}function getTopologicalSortAndRecipientCounts(a,e){assert$1(a!=null&&a.length>0,()=>"Expected at least one fetch, got none");let i=[],s={};if(a.length===1){const o=getTopologicalSortAndRecipientCountsForOneFetch(a[0],e);i=o.sorted,s=o.recipientMap}else{const o=new Set;for(const c of a){const{sorted:d,recipientMap:h}=getTopologicalSortAndRecipientCountsForOneFetch(c,e);for(const g of d)o.has(g.name)||(i.push(g),o.add(g.name));for(const g in h)s[g]==null&&(s[g]=new Set),h[g].forEach(_=>s[g].add(_))}}return{sorted:i,recipientCounts:recipientMap2Counts(s)}}function recipientMap2Counts(a){const e={};for(const i in a)e[i]=a[i].size;return e}function getTopologicalSortAndRecipientCountsForOneFetch(a,e){const i=new Set,s=[],o={};for(const h of e.names())i.add(h);const c=[],d=[];for(c.push(a);c.length>0;){const h=c[c.length-1];if(i.has(h.name)){c.pop();continue}const g=d[d.length-1]===c.length-1;if(h.inputs.length===0||g)c.pop(),s.push(h),i.add(h.name),g&&d.pop();else{d.push(c.length-1);for(const _ of h.inputs)o[_.name]==null&&(o[_.name]=new Set),o[_.name].add(h.name),!i.has(_.name)&&c.push(_)}}return{sorted:s,recipientMap:o}}function getNodeOutputs(a){let e;if(a.sourceLayer.inboundNodes.length===1)e=a.sourceLayer.output;else{let i=null;for(let s=0;s<a.sourceLayer.inboundNodes.length;++s)for(const o of a.sourceLayer.inboundNodes[s].outputTensors)if(o.id===a.id){i=s;break}e=a.sourceLayer.getOutputAt(i)}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Container extends Layer{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const it=this.getClassName().toLowerCase();this.name=getUid(it)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],unique$2(this.inputs).length!==this.inputs.length)throw new ValueError(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(it=>it.name)}`);unique$2(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(it=>it.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const it of this.outputs){const at=it.sourceLayer,st=it.nodeIndex,ot=it.tensorIndex;this.outputLayers.push(at),this.outputLayersNodeIndices.push(st),this.outputLayersTensorIndices.push(ot)}for(const it of this.inputs){const at=it.sourceLayer,st=it.nodeIndex,ot=it.tensorIndex;assert(st===0,"input layer has >1 nodes"),assert(ot===0,"input layer has >1 tensors"),this.inputLayers.push(at),this.inputLayersNodeIndices.push(st),this.inputLayersTensorIndices.push(ot)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let it=0;it<this.inputLayers.length;it++){const at=this.inputLayers[it];if(!(at instanceof InputLayer))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${it} (0-based) originates from layer type ${at.getClassName()}.`);this.inputNames.push(at.name),this.feedInputShapes.push(at.batchInputShape),this.feedInputNames.push(at.name)}for(const it of this.outputLayers)this.outputNames.push(it.name);this.internalInputShapes=this.inputs.map(it=>it.shape),this.internalOutputShapes=this.outputs.map(it=>it.shape);const i={},s={},o={},c={},d={},h=[],g=(it,at,st,ot,ct,lt)=>{(ot==null||ct==null||lt==null)&&(ot=it.sourceLayer,ct=it.nodeIndex,lt=it.tensorIndex);const dt=ot.inboundNodes[ct];if(st.indexOf(dt)!==-1)throw new RuntimeError(`The tensor ${it.name} at layer "${ot.name}" is part of a cycle.`);if(at.indexOf(dt)!==-1)return;this.containerNodes.add(Container.nodeKey(ot,ct)),ot.id in d||(d[ot.id]=Object.keys(d).length),st.indexOf(dt)===-1&&st.push(dt);const xt=dt.inboundLayers.length;for(let ut=0;ut<xt;ut++){const ft=dt.inputTensors[ut],mt=dt.inboundLayers[ut],yt=dt.nodeIndices[ut],St=dt.tensorIndices[ut];g(ft,at,st,mt,yt,St)}for(at.push(dt);st.indexOf(dt)>=0;)st.splice(st.indexOf(dt),1);h.push(dt)},_=[],b=[];for(const it of this.outputs)g(it,_,b);const $=h.slice().reverse();for(const it of $){s[it.id]=it,it.id in i||(i[it.id]=0);let at=i[it.id];const st=o[it.outboundLayer.id]==null?0:o[it.outboundLayer.id];at=Math.max(at,st),o[it.outboundLayer.id]=at,c[it.outboundLayer.id]=it.outboundLayer,i[it.id]=at;for(let ot=0;ot<it.inboundLayers.length;ot++){const ct=it.inboundLayers[ot],lt=it.nodeIndices[ot],dt=ct.inboundNodes[lt],xt=i[dt.id]==null?0:i[dt.id];i[dt.id]=Math.max(at+1,xt),s[dt.id]=dt}}const j={};for(const it in i){const at=i[it];at in j||(j[at]=[]),j[at].push(s[it])}const _e={};for(const it in o){const at=o[it];at in _e||(_e[at]=[]),_e[at].push(c[it])}let tt=Object.keys(_e).map(it=>parseInt(it,10)).sort(reverseNumberCompare);this.layers=[];for(const it of tt){const at=_e[it];at.sort((st,ot)=>{const ct=d[st.id],lt=d[ot.id];return ct<lt?-1:ct>lt?1:0});for(const st of at)st instanceof Container&&this.internalContainerRefs.push(st),this.layers.push(st)}this.layersByDepth=_e,tt=Object.keys(j).map(it=>parseInt(it,10)).sort(reverseNumberCompare);const et=this.inputs.slice(),nt=[];for(const it of tt)for(const at of j[it]){const st=at.outboundLayer;if(st!=null){for(const ot of at.inputTensors)if(et.indexOf(ot)===-1)throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${ot} at layer "${st.name}". The following previous layers were accessed without issue: ${nt}`);for(const ot of at.outputTensors)et.push(ot);nt.push(st.name)}}this.nodesByDepth=j;const rt=this.layers.map(it=>it.name);for(const it of rt){const at=rt.filter(st=>st===it).length;if(at!==1)throw new RuntimeError(`The name "${it}" is used ${at} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(rt))}this.outboundNodes=[],this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(it=>null),outputMasks:this.outputs.map(it=>null),inputShapes:this.inputs.map(it=>it.shape),outputShapes:this.outputs.map(it=>it.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const i of this.layers)e.numDisposedVariables+=i.dispose().numDisposedVariables;for(const i of this.internalContainerRefs)e.numDisposedVariables+=i.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(i=>{i._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const i of this.layers)e=e.concat(i.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const i of this.layers)e.push(...i.nonTrainableWeights);if(!this.trainable){const i=[];for(const s of this.layers)i.push(...s.trainableWeights);return i.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,i=!0){const s={};let o=0;for(const d of this.layers)for(const h of d.weights){if(s[h.originalName]!=null)throw new ValueError(`Duplicate weight name: ${h.originalName}`);s[h.originalName]=h,o++}const c=[];for(const d in e){let h=d;if(s[d]==null){const g=d.split("/");h=g.slice(0,-2).concat([g[g.length-1]]).join("/")}if(s[h]!=null)c.push([s[h],e[d]]);else if(i)throw new ValueError(`Provided weight data has no target variable: ${d}`);delete s[h]}if(i){const d=[];for(const h in s)d.push(h);if(d.length>0)throw new ValueError(`${d.length} of ${o} weights are not set: ${d}`)}batchSetValue(c)}updatedConfig(){const e=this.getConfig(),i={};return i.className=this.getClassName(),i.config=e,i.kerasVersion=`tfjs-layers ${version$8}`,i.backend="TensorFlow.js",i}toJSON(e,i=!0){const s=convertTsToPythonic(this.updatedConfig());return i?JSON.stringify(s):s}call(e,i){return tidy(()=>{e=toList(e);const s=new FeedDict;for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o]);return execute(this.outputs,s,i)})}computeMask(e,i){return tidy(()=>{e=toList(e);let s;return i==null?s=pyListRepeat(null,e.length):s=toList(i),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const i=normalizeShapeList(e);if(i.length!==this.inputLayers.length)throw new ValueError(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let h=0;h<i.length;h++){const g=this.inputLayers[h],_=i[h],b=g.name+"_0_0";s[b]=_}const o=Object.keys(this.nodesByDepth).map(h=>parseInt(h,10)).sort(reverseNumberCompare);if(o.length>1)for(const h of o){const g=this.nodesByDepth[h];for(const _ of g){const b=_.outboundLayer;if(this.inputLayers.map(et=>et.id).indexOf(b.id)!==-1)continue;const $=[];for(let et=0;et<_.inboundLayers.length;et++){const nt=_.inboundLayers[et],rt=_.nodeIndices[et],it=_.tensorIndices[et],at=`${nt.name}_${rt}_${it}`,st=s[at];$.push(st)}const j=b.computeOutputShape(singletonOrArray($)),_e=normalizeShapeList(j),tt=b.inboundNodes.indexOf(_);for(let et=0;et<_e.length;et++){const nt=`${b.name}_${tt}_${et}`;s[nt]=_e[et]}}}const c=[],d=[];for(let h=0;h<this.outputLayers.length;h++){const g=this.outputLayers[h],_=this.outputLayersNodeIndices[h],b=this.outputLayersTensorIndices[h],$=`${g.name}_${_}_${b}`;d.push($)}for(let h=0;h<d.length;h++){const g=d[h];assert(g in s),c.push(s[g])}return singletonOrArray(c)}runInternalGraph(e,i){i==null&&(i=pyListRepeat(null,e.length));const s={};for(let g=0;g<this.inputs.length;++g){const _=this.inputs[g],b=e[g],$=i[g];s[_.id]=[b,$]}const o=Object.keys(this.nodesByDepth).map(g=>parseInt(g,10)).sort(reverseNumberCompare);for(const g of o){const _=this.nodesByDepth[g];for(const b of _){const $=b.outboundLayer,j=b.inputTensors,_e=b.outputTensors,tt=new Array;for(const et of j)et.id in s&&tt.push(s[et.id]);if(tt.length===j.length){let et={},nt,rt,it,at;if(b.callArgs!=null&&(et=b.callArgs),tt.length===1){const[st,ot]=tt[0];et.mask==null&&(et.mask=ot),it=toList($.call(st,et)),at=toList($.computeMask(st,ot)),nt=[st],rt=[ot]}else nt=tt.map(st=>st[0]),rt=tt.map(st=>st[1]),et.mask==null&&(et.mask=rt),it=toList($.call(nt,et)),at=toList($.computeMask(nt,rt));if($.activityRegularizer)throw new NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let st=0;st<_e.length;++st){const ot=_e[st],ct=it[st],lt=at[st];s[ot.id]=[ct,lt]}}}}const c=[],d=[],h=[];for(const g of this.outputs){assert(g.id in s,`Could not compute output ${g.name} : ${g.id}`);const[_,b]=s[g.id];h.push(_.shape),c.push(_),d.push(b)}return[c,d,h]}buildNodeConversionMap(e){const i={};let s;for(const o of this.layers){s=o instanceof Container?1:0;for(let c=0;c<o.inboundNodes.length;c++){const d=Container.nodeKey(o,c);this.containerNodes.has(d)&&(i[d]=s,s+=1)}}return i}getLayer(e,i){if(i!=null){if(this.layers.length<=i)throw new ValueError(`Was asked to retrieve layer at index ${i}, but model only has ${this.layers.length} layer(s).`);return this.layers[i]}else if(e==null)throw new ValueError("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===e)return s;throw new ValueError(`No such layer: ${e}`)}calculateLosses(){return tidy(()=>{const e=[];for(const i of this.layers)for(let s=0;s<i.inboundNodes.length;++s){const o=Container.nodeKey(i,s);this.containerNodes.has(o)&&e.push(...i.calculateLosses())}return e})}getConfig(){const e={name:this.name},i=this.buildNodeConversionMap(this.layers),s=[];for(const d of this.layers){const h=d.getClassName(),g=d.getConfig(),_=[];for(let $=0;$<d.inboundNodes.length;$++){const j=d.inboundNodes[$],_e=Container.nodeKey(d,$);let tt={};if(this.containerNodes.has(_e)){if(j.callArgs)try{JSON.stringify(j.callArgs),tt=j.callArgs}catch{console.warn(`Layer ${d.name} was passed non-serializable keyword arguments: ${j.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),tt={}}if(j.inboundLayers.length>0){const et=[];for(let nt=0;nt<j.inboundLayers.length;nt++){const rt=j.inboundLayers[nt],it=j.nodeIndices[nt],at=j.tensorIndices[nt],st=Container.nodeKey(rt,it);let ot=i[st];ot==null&&(ot=0),et.push([rt.name,ot,at,tt])}_.push(et)}}}const b={};b.name=d.name,b.className=h,b.config=g,b.inboundNodes=_,s.push(b)}e.layers=s;const o=[];for(let d=0;d<this.inputLayers.length;d++){const h=this.inputLayers[d],g=this.inputLayersNodeIndices[d],_=Container.nodeKey(h,g);if(!this.containerNodes.has(_))continue;let b=i[_];b==null&&(b=0);const $=this.inputLayersTensorIndices[d];o.push([h.name,b,$])}e.inputLayers=o;const c=[];for(let d=0;d<this.outputLayers.length;d++){const h=this.outputLayers[d],g=this.outputLayersNodeIndices[d],_=Container.nodeKey(h,g);if(!this.containerNodes.has(_))continue;let b=i[_];b==null&&(b=0);const $=this.outputLayersTensorIndices[d];c.push([h.name,b,$])}return e.outputLayers=c,e}static fromConfig(e,i,s={},o=!1){const c={},d={};function h(nt,rt){nt.name in d?d[nt.name].push(rt):d[nt.name]=[rt]}function g(nt,rt){const it=[];let at;for(const st of rt){const ot=st[0],ct=st[1],lt=st[2];if(at=st[3]==null?{}:st[3],!(ot in c)){h(nt,rt);return}const dt=c[ot];if(dt.inboundNodes.length<=ct){h(nt,rt);return}const xt=dt.inboundNodes[ct];it.push(xt.outputTensors[lt])}it.length>0&&nt.apply(singletonOrArray(it),at)}function _(nt){const rt=nt.name,it=deserialize(nt,i.customObjects!=null?i.customObjects:{});it.setFastWeightInitDuringBuild(o),c[rt]=it,nt.inboundNodes.forEach(st=>{if(!(st instanceof Array))throw new ValueError(`Corrupted configuration, expected array for nodeData: ${st}`);h(it,st)})}const b=i.name,$=i.layers;for(const nt of $)_(nt);for(;!isObjectEmpty(d);)for(const nt of $){const rt=c[nt.name];if(rt.name in d){const it=d[rt.name];delete d[rt.name];for(const at of it)g(rt,at)}}const j=[],_e=[],tt=i.inputLayers;for(const nt of tt){const rt=nt[0],it=nt[1],at=nt[2];assert(rt in c);const ot=c[rt].inboundNodes[it].outputTensors;j.push(ot[at])}const et=i.outputLayers;for(const nt of et){const rt=nt[0],it=nt[1],at=nt[2];assert(rt in c);const ot=c[rt].inboundNodes[it].outputTensors;_e.push(ot[at])}return new e({inputs:j,outputs:_e,name:b})}get stateful(){if(this._stateful)throw new ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){tidy(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function standardizeSampleOrClassWeights(a,e,i){const s=e.length;if(a==null||Array.isArray(a)&&a.length===0)return e.map(o=>null);if(s===1)return Array.isArray(a)&&a.length===1?a:typeof a=="object"&&e[0]in a?[a[e[0]]]:[a];if(Array.isArray(a)){if(a.length!==s)throw new Error(`Provided ${i} is an array of ${a.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return a}else if(typeof a=="object"&&Object.keys(a).length>0&&typeof a[Object.keys(a)[0]]=="object"){const o=[];return e.forEach(c=>{c in a?o.push(a[c]):o.push(null)}),o}else throw new Error(`The model has multiple (${s}) outputs, so ${i} must be either an array with ${s} elements or an object with ${e} keys. Provided ${i} not understood: ${JSON.stringify(a)}`)}function standardizeClassWeights(a,e){return standardizeSampleOrClassWeights(a,e,"classWeight")}async function standardizeWeights(a,e,i,s){if(i!=null){const o=tidy(()=>{if(a.shape.length===1)return a.clone();if(a.shape.length===2){if(a.shape[1]>1)return a.argMax(1);if(a.shape[1]===1)return a.reshape([a.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${a.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${a.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),c=Array.from(await o.data());dispose(o);const d=[];return c.forEach(h=>{if(i[h]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${h} exists in the data but not in classWeight`);d.push(i[h])}),tensor1d(d,"float32")}else return null}function computeWeightedLoss(a,e){return mul$1(a,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const DEFAULT_VALIDATION_BATCH_SIZE=32;function standardizeDataIteratorOutput(a,e){let i,s;const o=e;i=o.xs,s=o.ys,assert$1(i!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const c=flattenTensorOrArrayOrMap("input",a.inputNames,i),d=flattenTensorOrArrayOrMap("output",a.outputNames,s),h=c[0].shape[0];assert$1(c.length===a.inputs.length,()=>`LayersModel has ${a.inputs.length} inputs, but the dataset provides ${c.length} inputs.  (Expected input keys: ${JSON.stringify(a.inputNames)})`),assert$1(d.length===a.outputs.length,()=>`LayersModel has ${a.outputs.length} outputs, but the dataset provides ${d.length} outputs.  (Expected output keys: ${JSON.stringify(a.outputNames)})`);for(let g=0;g<c.length;g++)assert$1(c[g].shape[0]===h,()=>`Batch size mismatch: input ${a.inputNames[g]} has ${c[g].shape[0]}; expected  ${h} based on input ${a.inputNames[0]}.`);for(let g=0;g<d.length;g++)assert$1(d[g].shape[0]===h,()=>`Batch size mismatch: output ${a.outputNames[g]} has ${d[g].shape[0]}; expected  ${h} based on input ${a.inputNames[0]}.`);return{xs:c,ys:d}}function flattenTensorOrArrayOrMap(a,e,i){if(i instanceof Tensor)return[i];if(Array.isArray(i))return assert$1(i.length===e.length,()=>`Received an array of ${i.length} Tensors, but expected ${e.length} to match the ${a} keys ${e}.`),i;{const s=[];for(const o of e){if(i[o]==null)throw new ValueError(`The feature data generated by the dataset lacks the required ${a} key '${o}'.`);s.push(i[o])}return s}}function standardizeTensorValidationData(a){if(a.length===3)throw new NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:a[0],ys:a[1]}}async function fitDataset(a,e,i){const s=i.batchesPerEpoch!=null;if(assert$1(a.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),assert$1(i!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),assert$1(i.epochs!=null&&i.epochs>0&&Number.isInteger(i.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${i.epochs}`),assert$1(!s||i.batchesPerEpoch>0&&Number.isInteger(i.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${i.batchesPerEpoch}`),assert$1(i.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),a.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");a.isTraining=!0;try{const o=i.validationData!=null;let c,d;if(o)if(isDatasetObject(i.validationData))assert$1(i.validationBatches==null||i.validationBatches>0&&Number.isInteger(i.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${i.validationBatches}`);else{const nt=standardizeTensorValidationData(i.validationData);c=nt.xs,d=nt.ys}const h=a.makeTrainFunction(),g=a.getDedupedMetricsNames();let _;o?_=g.slice().concat(g.map(nt=>"val_"+nt)):_=g.slice();const b=standardizeCallbacks(i.callbacks,i.yieldEvery),$=i.verbose==null?1:i.verbose,{callbackList:j,history:_e}=configureCallbacks(b,$,i.epochs,null,null,getStepsPerEpoch(e,i),null,o,_);j.setModel(a),a.history=_e,await j.onTrainBegin(),a.stopTraining_=!1;let tt=i.initialEpoch==null?0:i.initialEpoch,et=await e.iterator();for(;tt<i.epochs;){const nt={};await j.onEpochBegin(tt);let rt=0,it=0;for(s||(et=await e.iterator());!s||rt<i.batchesPerEpoch;){const at=await et.next();if(s&&at.done){console.warn(`You provided \`batchesPerEpoch\` as ${i.batchesPerEpoch}, but your dataset iterator ran out of data after ${rt} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${i.batchesPerEpoch*i.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(at.value!=null){const{xs:st,ys:ot}=standardizeDataIteratorOutput(a,at.value),ct={};ct.batch=it,ct.size=st[0].shape[0],await j.onBatchBegin(it,ct);const lt=[];if(i.classWeight!=null){const ut=standardizeClassWeights(i.classWeight,a.outputNames);for(let ft=0;ft<ut.length;++ft)lt.push(await standardizeWeights(ot[ft],null,ut[ft]))}const dt=st.concat(ot).concat(lt),xt=h(dt);dispose(dt);for(let ut=0;ut<g.length;++ut){const ft=g[ut],mt=xt[ut];ct[ft]=mt,keep(mt)}await j.onBatchEnd(it,ct),disposeTensorsInLogs(ct),it++,rt++}if(s?rt>=i.batchesPerEpoch:at.done){if(o){let st;isDatasetObject(i.validationData)?st=toList(await a.evaluateDataset(i.validationData,{batches:i.validationBatches})):st=toList(a.evaluate(c,d,{batchSize:i.validationBatchSize==null?DEFAULT_VALIDATION_BATCH_SIZE:i.validationBatchSize,verbose:0}));for(let ot=0;ot<a.metricsNames.length;++ot)nt[`val_${a.metricsNames[ot]}`]=st[ot]}break}if(a.stopTraining_)break}if(await j.onEpochEnd(tt,nt),tt++,a.stopTraining_)break}return await j.onTrainEnd(),await a.history.syncData(),a.history}finally{a.isTraining=!1}}function getStepsPerEpoch(a,e){let i=null;return e.batchesPerEpoch!=null?i=e.batchesPerEpoch:Number.isFinite(a.size)&&(i=a.size),i}function isDatasetObject(a){return typeof a.iterator=="function"}function isLazyIteratorObject(a){return typeof a.next=="function"}async function evaluateDataset(a,e,i){i=i||{};const s=i.batches!=null,o=a.testFunction;let c=[];if(i.verbose>0)throw new NotImplementedError("Verbose mode is not implemented yet.");assert$1(!s||i.batches>0&&Number.isInteger(i.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(i.batches)}`);const d=isLazyIteratorObject(e)?e:await e.iterator();let h=0,g=0;for(;!s||g<i.batches;){const _=await d.next();if(c=tidy(()=>{if(_.value){const{xs:b,ys:$}=standardizeDataIteratorOutput(a,_.value),j=b.concat($),_e=tidy(()=>o(j));if(dispose(j),g===0)for(let et=0;et<_e.length;++et)c.push(scalar(0));const tt=j[0].shape[0];for(let et=0;et<_e.length;++et){const nt=_e[et],rt=c[et];c[et]=tidy(()=>add$4(c[et],mul$1(tt,nt))),g>0&&dispose(rt)}dispose(_e),h+=tt,++g}return c}),_.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${i.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let _=0;_<c.length;++_){const b=c[_];c[_]=div$2(c[_],h),dispose(b)}return singletonOrArray(c)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function checkBatchSize(a){assert$1(a>0&&Number.isInteger(a),()=>`batchSize is required to be a positive integer, but got ${a}`)}function sliceArrays(a,e,i){return a==null?[null]:Array.isArray(a)?a.map(s=>sliceAlongFirstAxis(s,e,i-e)):sliceAlongFirstAxis(a,e,i-e)}function sliceArraysByIndices(a,e){return tidy(()=>a==null?null:Array.isArray(a)?a.map(i=>sliceArraysByIndices(i,e)):gather(a,e.dtype==="int32"?e:e.toInt()))}function makeBatches(a,e){const i=[];let s=0,o=null;for(;s<a;)o=s+e,o>=a&&(o=a),i.push([s,o]),s=o;return i}async function fitLoop(a,e,i,s,o,c,d,h,g,_,b,$,j,_e,tt){o==null&&(o=32),c==null&&(c=1),b==null&&(b=!0),j==null&&(j=0);let et=!1;g!=null&&_!=null&&(et=!0);const nt=a.checkNumSamples(i,o,_e,"steps_per_epoch");let rt;nt!=null&&(rt=range$3(0,nt)),d==null&&(d=1);const{callbackList:it,history:at}=configureCallbacks(h,d,c,j,nt,_e,o,et,$);it.setModel(a),a.history=at,await it.onTrainBegin(),a.stopTraining_=!1;for(let st=j;st<c;++st){await it.onEpochBegin(st);const ot={};{if(b==="batch")throw new NotImplementedError("batch shuffling is not implemneted yet");b&&shuffle(rt);const ct=tensor1d(rt),lt=makeBatches(nt,o);for(let dt=0;dt<lt.length;++dt){const xt={};if(await it.onBatchBegin(dt,xt),tidy(()=>{const ut=lt[dt][0],ft=lt[dt][1],mt=sliceAlongFirstAxis(ct,ut,ft-ut);xt.batch=dt,xt.size=ft-ut;const yt=sliceArraysByIndices(i,mt),St=e(yt);for(let Et=0;Et<s.length;++Et){const vt=s[Et],Nt=St[Et];xt[vt]=Nt,keep(Nt)}if(dt===lt.length-1&&et){const Et=a.testLoop(g,_,o);for(let vt=0;vt<s.length;++vt){const Nt=s[vt],wt=Et[vt];keep(wt),ot["val_"+Nt]=wt}}}),await it.onBatchEnd(dt,xt),disposeTensorsInLogs(xt),a.stopTraining_)break}ct.dispose()}if(await it.onEpochEnd(st,ot),a.stopTraining_)break}return await it.onTrainEnd(),await a.history.syncData(),a.history}async function fitTensors(a,e,i,s={}){if(a.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");a.isTraining=!0;let o,c,d,h,g,_,b;try{const $=s.batchSize==null?32:s.batchSize;checkBatchSize($);const _e=await a.standardizeUserData(e,i,s.sampleWeight,s.classWeight,!1,$);o=_e[0],c=_e[1],b=_e[2];let tt=!1,et;if(s.validationData!=null&&s.validationData.length>0){if(tt=!0,s.validationData.length===2)d=s.validationData[0],h=s.validationData[1];else throw s.validationData.length===3?new NotImplementedError("validationData including sample weights is not supported yet."):new ValueError(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const dt=await a.standardizeUserData(d,h,null,null,!0,$);g=dt[0],_=dt[1],et=g.concat(_)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){tt=!0;const lt=Math.floor(o[0].shape[0]*(1-s.validationSplit)),dt=o[0].shape[0];g=sliceArrays(o,lt,dt),o=sliceArrays(o,0,lt),_=sliceArrays(c,lt,dt),c=sliceArrays(c,0,lt),et=g.concat(_)}else s.validationSteps!=null&&(tt=!0);const nt=o.concat(c).concat(b);a.checkTrainableWeightsConsistency();const rt=a.makeTrainFunction(),it=a.getDedupedMetricsNames();let at,st;tt?(a.makeTestFunction(),at=a.testFunction,st=it.slice().concat(it.map(lt=>"val_"+lt))):(at=null,et=[],st=it.slice());const ot=standardizeCallbacks(s.callbacks,s.yieldEvery);return await fitLoop(a,rt,nt,it,$,s.epochs,s.verbose,ot,at,et,s.shuffle,st,s.initialEpoch,null,null)}finally{a.isTraining=!1,disposeNewTensors(o,e),disposeNewTensors(c,i),disposeNewTensors(g,d),disposeNewTensors(_,h),b!=null&&dispose(b)}}function ensureTensorsRank2OrHigher(a){const e=[];a instanceof Tensor&&(a=[a]);for(let i=0;i<a.length;++i){const s=a[i];if(s.rank===1)e.push(expandDims$2(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function disposeNewTensors(a,e){if(a==null)return;const i=[];if(e instanceof Tensor)i.push(e.id);else if(Array.isArray(e))e.forEach(o=>i.push(o.id));else if(e!=null)for(const o in e){const c=e[o];i.push(c.id)}const s=[];if(a instanceof Tensor)i.indexOf(a.id)===-1&&s.push(a);else if(Array.isArray(a))a.forEach(o=>{i.indexOf(o.id)===-1&&s.push(o)});else if(a!=null)for(const o in a){const c=a[o];i.indexOf(c.id)===-1&&s.push(c)}s.forEach(o=>{o.isDisposed||o.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function isDataTensor(a){return a instanceof Tensor}function isDataArray(a){return Array.isArray(a)}function isDataDict(a){return!isDataTensor(a)&&!isDataArray(a)}function standardizeInputData(a,e,i,s=!0,o=""){if(e==null||e.length===0){if(a!=null){let d=!1;if(isDataArray(a)&&a.length>0)d=!0;else if(isDataDict(a)){for(const h in a)if(a.hasOwnProperty(h)){d=!0;break}}else d=!0;if(d)throw new ValueError(`Error when checking model ${o} expected no data, but got ${a}`)}return[]}if(a==null)return e.map(d=>null);let c;if(isDataDict(a)){a=a,c=[];for(const d of e){if(a[d]==null)throw new ValueError(`No data provided for "${d}". Need data for each key in: ${e}`);c.push(a[d])}}else if(isDataArray(a)){if(a=a,a.length!==e.length)throw new ValueError(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${a}`);c=a}else{if(a=a,e.length>1)throw new ValueError(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${a.shape}`);c=[a]}if(c=ensureTensorsRank2OrHigher(c),i!=null)for(let d=0;d<e.length;++d){if(i[d]==null)continue;const h=c[d];if(h.shape.length!==i[d].length)throw new ValueError(`Error when checking ${o}: expected ${e[d]} to have ${i[d].length} dimension(s). but got array with shape ${h.shape}`);for(let g=0;g<i[d].length;++g){if(g===0&&!s)continue;const _=h.shape[g],b=i[d][g];if(b!=null&&b>=0&&_!==b)throw new ValueError(`Error when checking ${o}: expected ${e[d]} to have shape [${i[d]}], but got array with shape [${h.shape}].`)}}return c}function checkArrayLengths(a,e,i){const s=unique$2(a.map(c=>c.shape[0]));s.sort();const o=unique$2(e.map(c=>c.shape[0]));if(o.sort(),s.length>1)throw new ValueError(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(a.map(c=>c.shape))}`);if(o.length>1)throw new ValueError(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(c=>c.shape))}`);if(s.length>0&&o.length>0&&!arraysEqual(s,o))throw new ValueError(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${o[0]} target sample(s).`)}function checkLossAndTargetCompatibility(a,e,i){const s=[meanSquaredError$1,binaryCrossentropy$2,categoricalCrossentropy$2];for(let o=0;o<a.length;++o){const c=a[o],d=e[o],h=i[o];if(d!=null){if(d===categoricalCrossentropy$2&&c.shape[c.shape.length-1]===1)throw new ValueError(`You are passing a target array of shape ${c.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(d)!==-1){const g=c.shape.slice(1),_=h.slice(1);for(let b=0;b<g.length;++b){const $=g[b],j=_[b];if(j!=null&&$!==j)throw new ValueError(`A target Tensor with shape ${c.shape} was passed for an output of shape ${h}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function checkInputData(a,e,i,s=!0,o=""){let c;if(Array.isArray(a)){if(a.length!==e.length)throw new ValueError(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${a.length} Tensors(s).`);c=a}else{if(e.length>1)throw new ValueError(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(a.shape)}.`);c=[a]}if(i!=null)for(let d=0;d<e.length;++d){if(i[d]==null)continue;const h=c[d];if(h.shape.length!==i[d].length)throw new ValueError(`Error when checking ${o}: expected ${e[d]} to have ${i[d].length} dimension(s), but got array with shape ${JSON.stringify(h.shape)}`);for(let g=0;g<i[d].length;++g){if(g===0&&!s)continue;const _=h.shape[g],b=i[d][g];if(b!=null&&b!==_)throw new ValueError(`Error when checking ${o}: expected ${e[d]} to have shape ${JSON.stringify(i[d])} but got array with shape ${JSON.stringify(h.shape)}.`)}}}function collectMetrics(a,e){if(a==null||Array.isArray(a)&&a.length===0)return e.map(s=>[]);let i;if(typeof a=="string"||typeof a=="function")i=[a];else if(Array.isArray(a)||typeof a=="object")i=a;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${a}`);if(Array.isArray(i))return e.map(s=>i);{const s=[];for(const o of e){let c=i.hasOwnProperty(o)?i[o]:[];Array.isArray(c)||(c=[c]),s.push(c)}return s}}const LAYERS_MODEL_FORMAT_NAME="layers-model";class LayersModel extends Container{constructor(e){super(e),this.isTraining=!1}summary(e,i,s=console.log){if(!this.built)throw new ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");printSummary(this,e,i,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=getOptimizer(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Optimizer))throw new ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let i=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const d in e.loss)if(this.outputNames.indexOf(d)===-1)throw new ValueError(`Unknown entry in loss dictionary: "${d}". Only expected the following keys: ${this.outputNames}`);for(const d of this.outputNames)e.loss[d]==null&&console.warn(`Output "${d}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${d} during training`),i.push(get$1(e.loss[d]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ValueError(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);i=e.loss.map(h=>get$1(h))}else{const d=get$1(e.loss);this.outputs.forEach(h=>{i.push(d)})}this.lossFunctions=i,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let d=0;d<this.outputs.length;++d){const h=this.internalOutputShapes[d],g=this.outputNames[d];this.feedOutputNames.push(g),this.feedOutputShapes.push(h),this.feedLossFns.push(this.lossFunctions[d])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],nameScope("loss",()=>{for(let d=0;d<this.outputs.length;++d){if(s.indexOf(d)!==-1)continue;const h=this.lossFunctions[d];this.outputs.length>1&&(this.metricsTensors.push([h,d]),this.metricsNames.push(this.outputNames[d]+"_loss"))}});const o=collectMetrics(e.metrics,this.outputNames),c=(d,h,g)=>{this.outputNames.length>1&&(h=this.outputNames[d]+"_"+h),this.metricsNames.push(h),this.metricsTensors.push([g,d])};nameScope("metric",()=>{for(let d=0;d<this.outputs.length;++d){if(s.indexOf(d)!==-1)continue;const h=o[d];(_=>{const b="";let $,j,_e;for(const tt of _){if(typeof tt=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(tt)!==-1){const nt=this.internalOutputShapes[d];nt[nt.length-1]===1||this.lossFunctions[d]===binaryCrossentropy$2?["accuracy","acc"].indexOf(tt)!==-1?j=binaryAccuracy$1:["crossentropy","ce"].indexOf(tt)!==-1&&(j=binaryCrossentropy$1):this.lossFunctions[d]===sparseCategoricalCrossentropy$1?["accuracy","acc"].indexOf(tt)!==-1?j=sparseCategoricalAccuracy$1:["crossentropy","ce"].indexOf(tt)!==-1&&(j=sparseCategoricalCrossentropy):["accuracy","acc"].indexOf(tt)!==-1?j=categoricalAccuracy$1:["crossentropy","ce"].indexOf(tt)!==-1&&(j=categoricalCrossentropy$1);let rt;["accuracy","acc"].indexOf(tt)!==-1?rt="acc":["crossentropy","ce"].indexOf(tt)!==-1&&(rt="ce"),_e=j,$=b+rt}else _e=get(tt),$=b+getLossOrMetricName(tt);let et;nameScope($,()=>{et=_e}),c(d,$,et)}})(h)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,i,s={}){const o=s.batchSize==null?32:s.batchSize;checkBatchSize(o);const d=this.standardizeUserDataXY(e,i,!0,o);try{const h=d[0].concat(d[1]);this.makeTestFunction();const g=this.testFunction,_=this.testLoop(g,h,o,s.verbose,s.steps);return singletonOrArray(_)}finally{disposeNewTensors(d[0],e),disposeNewTensors(d[1],i)}}async evaluateDataset(e,i){return this.makeTestFunction(),evaluateDataset(this,e,i)}checkNumSamples(e,i,s,o="steps"){let c;if(s!=null){if(c=null,i!=null)throw new ValueError(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${i}`)}else if(e!=null)Array.isArray(e)?c=e[0].shape[0]:c=e.shape[0];else throw new ValueError(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return c}execute(e,i){if(Array.isArray(i)&&i.length===0)throw new ValueError("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(i),o=s?i:[i],c=this.retrieveSymbolicTensors(o),d=new FeedDict;if(e instanceof Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ValueError(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let g=0;g<this.inputs.length;++g)d.add(this.inputs[g],e[g])}else for(const g of this.inputs){const _=e[g.name];if(_==null)throw new ValueError(`No value is provided for the model's input ${g.name}`);d.add(g,_)}const h=execute(c,d);return s?h:h[0]}retrieveSymbolicTensors(e){const i=pyListRepeat(null,e.length);let s=e.length;for(const o of this.layers){const c=Array.isArray(o.output)?o.output:[o.output],d=c.map(h=>h.name);for(let h=0;h<e.length;++h){const g=d.indexOf(e[h]);if(g!==-1&&(i[h]=c[g],s--),s===0)break}if(s===0)break}if(s>0){const o=[];throw i.forEach((c,d)=>{c==null&&o.push(e[d])}),new ValueError(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return i}predictLoop(e,i=32,s=!1){return tidy(()=>{const o=this.checkNumSamples(e);if(s)throw new NotImplementedError("Verbose predictLoop() is not implemented yet.");const c=makeBatches(o,i),d=this.outputs.map(h=>[]);for(let h=0;h<c.length;++h)tidy(()=>{const _=c[h][0],b=c[h][1],$=sliceArrays(e,_,b),j=[];if(Array.isArray($))for(let tt=0;tt<$.length;++tt)j.push({key:this.inputs[tt],value:$[tt]});else j.push({key:this.inputs[0],value:$});const _e=new FeedDict(j);return execute(this.outputs,_e)}).forEach((_,b)=>d[b].push(_));return singletonOrArray(d.map(h=>concat$3(h,0)))})}predict(e,i={}){const s=ensureTensorsRank2OrHigher(e);checkInputData(s,this.inputNames,this.feedInputShapes,!1);try{const o=i.batchSize==null?32:i.batchSize;return checkBatchSize(o),this.predictLoop(s,o)}finally{disposeNewTensors(s,e)}}predictOnBatch(e){checkInputData(e,this.inputNames,this.feedInputShapes,!0);const i=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,i)}standardizeUserDataXY(e,i,s=!0,o){if(this.optimizer_==null)throw new RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const c=[];for(let d=0;d<this.feedOutputShapes.length;++d){const h=this.feedOutputShapes[d];this.feedLossFns[d]===sparseCategoricalCrossentropy$1?c.push(h.slice(0,h.length-1).concat([1])):c.push(h)}if(e=standardizeInputData(e,this.feedInputNames,this.feedInputShapes,!1,"input"),i=standardizeInputData(i,this.feedOutputNames,c,!1,"target"),checkArrayLengths(e,i),checkLossAndTargetCompatibility(i,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!==0)throw new ValueError(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,i]}async standardizeUserData(e,i,s,o,c=!0,d){const[h,g]=this.standardizeUserDataXY(e,i,c,d);if(s!=null)throw new Error("sample weight is not supported yet.");let _=null;if(o!=null){const b=standardizeClassWeights(o,this.outputNames);_=[];for(let $=0;$<b.length;++$)_.push(await standardizeWeights(g[$],null,b[$]))}return[h,g,_]}testLoop(e,i,s,o=0,c){return tidy(()=>{const d=this.checkNumSamples(i,s,c,"steps"),h=[];if(o>0)throw new NotImplementedError("Verbose mode is not implemented yet.");if(c!=null)throw new NotImplementedError("steps mode in testLoop() is not implemented yet");{const g=makeBatches(d,s),_=tensor1d(range$3(0,d));for(let b=0;b<g.length;++b){const $=g[b][0],j=g[b][1],_e=sliceAlongFirstAxis(_,$,j-$),tt=sliceArraysByIndices(i,_e),et=e(tt);if(b===0)for(let nt=0;nt<et.length;++nt)h.push(scalar(0));for(let nt=0;nt<et.length;++nt){const rt=et[nt];h[nt]=add$4(h[nt],mul$1(j-$,rt))}}for(let b=0;b<h.length;++b)h[b]=div$2(h[b],d)}return h})}getDedupedMetricsNames(){const e=this.metricsNames,i=[];for(let s=0;s<e.length;++s){const o=e[s];let c=o;if(count(e,o)>1){const d=count(e.slice(0,s),o);c+=`_${d}`}i.push(c)}return i}makeTrainFunction(){return e=>{const i=[],s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),c=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),d=[],h=()=>{const $=[];for(let et=0;et<this.inputs.length;++et)$.push({key:this.inputs[et],value:s[et]});const j=new FeedDict($),_e=execute(this.outputs,j,{training:!0});let tt;for(let et=0;et<this.lossFunctions.length;++et){const nt=this.lossFunctions[et];let rt=nt(o[et],_e[et]);c[et]!=null&&(rt=computeWeightedLoss(rt,c[et]));const it=mean$1(rt);i.push(it),et===0?tt=rt:tt=add$4(tt,rt)}for(let et=0;et<this.metricsTensors.length;++et){let nt;if(this.outputs.length>1&&et<this.outputs.length)nt=i[et];else{const rt=this.metricsTensors[et][0],it=this.metricsTensors[et][1];nt=mean$1(rt(o[it],_e[it]))}keep(nt),d.push(nt)}return tt=mean$1(tt),this.calculateLosses().forEach(et=>{tt=add$4(tt,et)}),tt},g=this.collectedTrainableWeights.map($=>$.read());return[this.optimizer_.minimize(h,!0,g)].concat(d)}}makeTestFunction(){this.testFunction=e=>tidy(()=>{const i=[];let s;const o=e.slice(0,this.inputs.length),c=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),d=[];for(let _=0;_<this.inputs.length;++_)d.push({key:this.inputs[_],value:o[_]});const h=new FeedDict(d),g=execute(this.outputs,h);for(let _=0;_<this.lossFunctions.length;++_){const b=this.lossFunctions[_],$=mean$1(b(c[_],g[_]));_===0?s=$:s=add$4(s,$),i.push(s)}for(let _=0;_<this.metricsTensors.length;++_){const b=this.metricsTensors[_][0],$=this.metricsTensors[_][1],j=mean$1(b(c[$],g[$]));i.push(j)}return i})}async fit(e,i,s={}){return fitTensors(this,e,i,s)}async fitDataset(e,i){return fitDataset(this,e,i)}async trainOnBatch(e,i){const s=await this.standardizeUserData(e,i),o=s[0],c=s[1],h=this.makeTrainFunction()(o.concat(c)),g=[];for(const _ of h){const b=await _.data();g.push(b[0])}return dispose(h),singletonOrArray(g)}getNamedWeights(e){const i=[],s=e!=null&&e.trainableOnly,o=s?this.trainableWeights:this.weights,c=this.getWeights(s);for(let d=0;d<o.length;++d)s&&!o[d].trainable||i.push({name:o[d].originalName,tensor:c[d]});return i}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const i=memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=i-memory().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=toSnakeCase(this.loss);else if(Array.isArray(this.loss)){for(const i of this.loss)if(typeof i!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(i=>toSnakeCase(i))}else{const i=Object.keys(this.loss);e={};const s=this.loss;for(const o of i)if(typeof s[o]=="string")e[o]=toSnakeCase(s[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[toSnakeCase(getLossOrMetricName(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>toSnakeCase(getLossOrMetricName(e)));{const e={};for(const i in this.metrics)e[i]=toSnakeCase(getLossOrMetricName(this.metrics[i]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const i=convertPythonicToTs(e.optimizer_config),s=deserialize(i);let o;if(typeof e.loss=="string")o=toCamelCase(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(d=>toCamelCase(d));else if(e.loss!=null){o={};for(const d in e.loss)o[d]=toCamelCase(e.loss[d])}let c;if(Array.isArray(e.metrics))c=e.metrics.map(d=>toCamelCase(d));else if(e.metrics!=null){c={};for(const d in e.metrics)c[d]=toCamelCase(e.metrics[d])}this.compile({loss:o,metrics:c,optimizer:s})}async save(e,i){if(typeof e=="string"){const _=getSaveHandlers(e);if(_.length===0)throw new ValueError(`Cannot find any save handlers for URL '${e}'`);if(_.length>1)throw new ValueError(`Found more than one (${_.length}) save handlers for URL '${e}'`);e=_[0]}if(e.save==null)throw new ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await encodeWeights(this.getNamedWeights(i)),h={modelTopology:this.toJSON(null,!1),format:LAYERS_MODEL_FORMAT_NAME,generatedBy:`TensorFlow.js tfjs-layers v${version$8}`,convertedBy:null};if((i==null?!1:i.includeOptimizer)&&this.optimizer!=null){h.trainingConfig=this.getTrainingConfig();const _="optimizer",{data:b,specs:$}=await encodeWeights(await this.optimizer.getWeights(),_);s.specs.push(...$),s.data=concatenateArrayBuffers$1([s.data,b])}return this.userDefinedMetadata!=null&&(checkUserDefinedMetadata(this.userDefinedMetadata,this.name,!0),h.userDefinedMetadata=this.userDefinedMetadata),h.weightData=s.data,h.weightSpecs=s.specs,e.save(h)}setUserDefinedMetadata(e){checkUserDefinedMetadata(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}LayersModel.className="Model";registerClass(LayersModel);class Functional extends LayersModel{}Functional.className="Functional";registerClass(Functional);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function modelFromJSON(a,e){"modelTopology"in a||(a={modelTopology:a}),a=a;let i=a.modelTopology;i.model_config!=null&&(i=i.model_config);const s=convertPythonicToTs(i),o=deserialize(s,e);if(a.weightsManifest!=null){const c=await loadWeights$1(a.weightsManifest,a.pathPrefix,o.weights.map(h=>h.originalName)),d={};for(const h of o.weights)d[h.originalName]=c[h.originalName];o.loadWeights(d),dispose(c)}return o}async function loadLayersModelInternal(a,e){if(e==null&&(e={}),typeof a=="string"){const i=getLoadHandlers(a,e);if(i.length===0)i.push(browserHTTPRequest(a,e));else if(i.length>1)throw new ValueError(`Found more than one (${i.length}) load handlers for URL '${a}'`);a=i[0]}return loadLayersModelFromIOHandler(a,void 0,e)}async function loadLayersModelFromIOHandler(a,e,i){if(i==null&&(i={}),a.load==null)throw new ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await a.load();let o=s.modelTopology;o.model_config!=null&&(o=o.model_config);const c=i.strict==null?!0:i.strict,d=s.weightData!=null&&s.weightSpecs!=null&&c,h=deserialize(convertPythonicToTs(o),e,d),g=s.trainingConfig;if(g!=null&&h.loadTrainingConfig(g),s.userDefinedMetadata!=null&&h.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:_,optimizerWeights:b}=decodeModelAndOptimizerWeights(s.weightData,s.weightSpecs);h.loadWeights(_,c),h.optimizer!=null&&b.length>0&&await h.optimizer.setWeights(b),dispose(_),dispose(b.map($=>$.tensor))}return h}function decodeModelAndOptimizerWeights(a,e){const i=decodeWeights(a,e),s={},o=[];return e.forEach(c=>{c.group==="optimizer"?o.push({name:c.name,tensor:i[c.name]}):s[c.name]=i[c.name]}),{modelWeights:s,optimizerWeights:o}}class Sequential extends LayersModel{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:getUid("sequential_"),e.layers!=null)for(const i of e.layers)this.add(i)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new ValueError(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const i=e instanceof Sequential||e instanceof LayersModel;let s;if(i){if(s=e,s.outputs.length!==1)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=Input({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(i)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new ValueError(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=getSourceInputs(this.outputs[0])}this.inboundNodes=[],new Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,i){return this.model==null&&this.build(),this.model.call(e,i)}build(e){if(getExactlyOneShape(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,i,s=console.log){this.built||this.build(),super.summary(e,i,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,i,s={}){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,i,s)}async evaluateDataset(e,i){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,i)}predict(e,i={}){return this.model==null&&this.build(),this.model.predict(e,i)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,i,s={}){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.fit(e,i,s)}async fitDataset(e,i){if(!this.built)throw new RuntimeError("The model needs to be compiled before being used.");return this.model.fitDataset(e,i)}async trainOnBatch(e,i){return this.model.trainOnBatch(e,i)}static fromConfig(e,i,s={},o=!1){let c,d={};if(i instanceof Array){if(i[0].className==null||i[0].className==="Merge")throw new ValueError("Legacy serialization format not supported yet.");c=i}else assert$1(i.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),c=i.layers,delete i.layers,d=i;const h=new e(d);if(!(h instanceof Sequential))throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${h}`);for(const g of c){const b=deserialize(g,void 0,o);o&&b.setFastWeightInitDuringBuild(!0),h.add(b)}return h}set stopTraining(e){if(this.model==null)throw new ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const i of this.layers){const s={};s.className=i.getClassName(),s.config=i.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Sequential.className="Sequential";registerClass(Sequential);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function model(a){return new LayersModel(a)}function sequential(a){return new Sequential(a)}function loadLayersModel(a,e){return e==null&&(e={}),loadLayersModelInternal(a,e)}function input(a){return Input(a)}function registerCallbackConstructor(a,e){CallbackConstructorRegistry.registerCallbackConstructor(a,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Activation$1=class extends Serializable{getConfig(){return{}}};class Elu extends Activation$1{apply(e,i=1){return elu$3(e,i)}}Elu.className="elu";registerClass(Elu);class Selu extends Activation$1{apply(e){return selu$2(e)}}Selu.className="selu";registerClass(Selu);class Relu extends Activation$1{apply(e){return relu$2(e)}}Relu.className="relu";registerClass(Relu);class Relu6 extends Activation$1{apply(e){return tidy(()=>minimum$3(6,relu$2(e)))}}Relu6.className="relu6";registerClass(Relu6);class Linear extends Activation$1{apply(e){return e}}Linear.className="linear";registerClass(Linear);class Sigmoid extends Activation$1{apply(e){return sigmoid$2(e)}}Sigmoid.className="sigmoid";registerClass(Sigmoid);class HardSigmoid extends Activation$1{apply(e){return hardSigmoid(e)}}HardSigmoid.className="hardSigmoid";registerClass(HardSigmoid);class Softplus extends Activation$1{apply(e){return softplus$2(e)}}Softplus.className="softplus";registerClass(Softplus);class Softsign extends Activation$1{apply(e){return softsign(e)}}Softsign.className="softsign";registerClass(Softsign);class Tanh extends Activation$1{apply(e){return tanh$3(e)}}Tanh.className="tanh";registerClass(Tanh);let Softmax$1=class extends Activation$1{apply(e,i=-1){return softmax$3(e,i)}};Softmax$1.className="softmax";registerClass(Softmax$1);class LogSoftmax extends Activation$1{apply(e,i=-1){return logSoftmax(e,i)}}LogSoftmax.className="logSoftmax";registerClass(LogSoftmax);class Swish extends Activation$1{apply(e,i=1){return tidy(()=>sigmoid$2(e.mul(i)).mul(e))}}Swish.className="swish";registerClass(Swish);function serializeActivation(a){return a.getClassName()}function deserializeActivation(a,e={}){return deserializeKerasObject(a,SerializationMap.getMap().classNameMap,e,"activation")}function getActivation(a){if(a==null){const e={};return e.className="linear",e.config={},deserializeActivation(e)}if(typeof a=="string"){const e={};return e.className=a,e.config={},deserializeActivation(e)}else return a instanceof Activation$1?a:deserializeActivation(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function assertObjectArgs(a){if(a!=null&&typeof a!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${a}`)}class Regularizer extends Serializable{}class L1L2 extends Regularizer{constructor(e){super(),assertObjectArgs(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return tidy(()=>{let i=zeros$4([1]);return this.hasL1&&(i=add$4(i,sum$3(mul$1(this.l1,abs$4(e))))),this.hasL2&&(i=add$4(i,sum$3(mul$1(this.l2,square$1(e))))),i.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,i){return new e({l1:i.l1,l2:i.l2})}}L1L2.className="L1L2";registerClass(L1L2);function l1$1(a){return assertObjectArgs(a),new L1L2({l1:a!=null?a.l1:null,l2:0})}function l2$1(a){return assertObjectArgs(a),new L1L2({l2:a!=null?a.l2:null,l1:0})}const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function serializeRegularizer(a){return serializeKerasObject(a)}function deserializeRegularizer(a,e={}){return deserializeKerasObject(a,SerializationMap.getMap().classNameMap,e,"regularizer")}function getRegularizer(a){if(a==null)return null;if(typeof a=="string"){const i={className:a in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP?REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[a]:a,config:{}};return deserializeRegularizer(i)}else return a instanceof Regularizer?a:deserializeRegularizer(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ReLU extends Layer{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,i){e=getExactlyOneTensor(e);let s=relu$2(e);return this.maxValue!=null&&(s=clipByValue$1(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},i=super.getConfig();return Object.assign(e,i),e}}ReLU.className="ReLU";registerClass(ReLU);class LeakyReLU extends Layer{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,i){const s=getExactlyOneTensor(e);return leakyRelu$2(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},i=super.getConfig();return Object.assign(e,i),e}}LeakyReLU.className="LeakyReLU";registerClass(LeakyReLU);class PReLU extends Layer{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=getInitializer(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=getRegularizer(e.alphaRegularizer),this.alphaConstraint=getConstraint(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=getExactlyOneShape(e);const i=e.slice(1);if(this.sharedAxes!=null)for(const o of this.sharedAxes)i[o-1]=1;this.alpha=this.addWeight("alpha",i,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)s[o]=e[o];this.inputSpec=[new InputSpec({ndim:e.length,axes:s})],this.built=!0}call(e,i){return e=getExactlyOneTensor(e),prelu$3(e,this.alpha.read())}getConfig(){const e={alphaInitializer:serializeInitializer(this.alphaInitializer),alphaRegularizer:serializeRegularizer(this.alphaRegularizer),alphaConstraint:serializeConstraint(this.alphaConstraint),sharedAxes:this.sharedAxes},i=super.getConfig();return Object.assign(e,i),e}}PReLU.className="PReLU";registerClass(PReLU);let ELU$3=class extends Layer{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new NotImplementedError(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,i){const s=getExactlyOneTensor(e);return elu$4(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},i=super.getConfig();return Object.assign(e,i),e}};ELU$3.className="ELU";registerClass(ELU$3);class ThresholdedReLU extends Layer{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,i){const s=getExactlyOneTensor(e);return s.mul(cast$2(s.greater(this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},i=super.getConfig();return Object.assign(e,i),e}}ThresholdedReLU.className="ThresholdedReLU";registerClass(ThresholdedReLU);class Softmax extends Layer{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Softmax$1().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,i){const s=getExactlyOneTensor(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},i=super.getConfig();return Object.assign(e,i),e}}Softmax.className="Softmax";registerClass(Softmax);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function normalizeArray(a,e,i){if(typeof a=="number")return pyListRepeat(a,e);if(a.length!==e)throw new ValueError(`The ${i} argument must be an integer or tuple of ${e} integers. Received: ${a.length} elements.`);for(let s=0;s<e;++s){const o=a[s];if(!isInteger$1(o))throw new ValueError(`The ${i} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(a)} including a non-integer number ${o}`)}return a}function convOutputLength(a,e,i,s,o=1){if(a==null)return a;const c=e+(e-1)*(o-1);let d;return i==="same"?d=a:d=a-c+1,Math.floor((d+s-1)/s)}function deconvLength(a,e,i,s){if(a==null)return null;if(s==="valid")a=a*e+max$3([i-e,0]);else if(s==="same")a=a*e;else throw new ValueError(`Unsupport padding mode: ${s}.`);return a}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function preprocessConv2DInput(a,e){return tidy(()=>(checkDataFormat(e),e==="channelsFirst"?transpose$3(a,[0,2,3,1]):a))}function preprocessConv3DInput(a,e){return tidy(()=>(checkDataFormat(e),e==="channelsFirst"?transpose$3(a,[0,2,3,4,1]):a))}function conv1dWithBias(a,e,i,s=1,o="valid",c,d=1){return tidy(()=>{if(c==null&&(c=imageDataFormat()),checkDataFormat(c),a.shape.length!==3)throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ${a.shape.length} instead.`);if(e.shape.length!==3)throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(i!=null&&i.shape.length!==1)throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(c==="channelsFirst"&&(a=transpose$3(a,[0,2,1])),o==="causal")throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let h=conv1d$1(a,e,s,o==="same"?"same":"valid","NWC",d);return i!=null&&(h=biasAdd(h,i)),h})}function conv2dWithBiasActivation(a,e,i,s=[1,1],o="valid",c,d,h=null){return tidy(()=>{if(c==null&&(c=imageDataFormat()),checkDataFormat(c),a.rank!==3&&a.rank!==4)throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${a.rank}.`);if(e.rank!==3&&e.rank!==4)throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${a.rank}.`);let g=preprocessConv2DInput(a,c);if(o==="causal")throw new NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return g=conv2d$2({x:g,filter:e,strides:s,pad:o==="same"?"same":"valid",dilations:d,dataFormat:"NHWC",bias:i,activation:h}),c==="channelsFirst"&&(g=transpose$3(g,[0,3,1,2])),g})}function conv3dWithBias(a,e,i,s=[1,1,1],o="valid",c,d){return tidy(()=>{if(c==null&&(c=imageDataFormat()),checkDataFormat(c),a.rank!==4&&a.rank!==5)throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ${a.rank}.`);if(e.rank!==4&&e.rank!==5)throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${a.rank}.`);let h=preprocessConv3DInput(a,c);if(o==="causal")throw new NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return h=conv3d$1(h,e,s,o==="same"?"same":"valid","NDHWC",d),i!=null&&(h=biasAdd(h,i)),c==="channelsFirst"&&(h=transpose$3(h,[0,4,1,2,3])),h})}class BaseConv extends Layer{constructor(e,i){if(super(i),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",BaseConv.verifyArgs(i),this.rank=e,assertPositiveInteger(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=normalizeArray(i.kernelSize,e,"kernelSize"),this.strides=normalizeArray(i.strides==null?1:i.strides,e,"strides"),this.padding=i.padding==null?"valid":i.padding,checkPaddingMode(this.padding),this.dataFormat=i.dataFormat==null?"channelsLast":i.dataFormat,checkDataFormat(this.dataFormat),this.activation=getActivation(i.activation),this.useBias=i.useBias==null?!0:i.useBias,this.biasInitializer=getInitializer(i.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=getConstraint(i.biasConstraint),this.biasRegularizer=getRegularizer(i.biasRegularizer),this.activityRegularizer=getRegularizer(i.activityRegularizer),this.dilationRate=normalizeArray(i.dilationRate==null?1:i.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ValueError(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ValueError(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ValueError(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(assert("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!checkArrayTypeAndLength(e.kernelSize,"number",1,3))throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:serializeActivation(this.activation),useBias:this.useBias,biasInitializer:serializeInitializer(this.biasInitializer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),biasConstraint:serializeConstraint(this.biasConstraint)},i=super.getConfig();return Object.assign(e,i),e}}class Conv extends BaseConv{constructor(e,i){super(e,i),this.kernel=null,Conv.verifyArgs(i),this.filters=i.filters,assertPositiveInteger(this.filters,"filters"),this.kernelInitializer=getInitializer(i.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=getConstraint(i.kernelConstraint),this.kernelRegularizer=getRegularizer(i.kernelRegularizer)}build(e){e=getExactlyOneShape(e);const i=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[i]==null)throw new ValueError(`The channel dimension of the input should be defined. Found ${e[i]}`);const s=e[i],o=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[i]:s}}],this.built=!0}call(e,i){return tidy(()=>{e=getExactlyOneTensor(e);let s;const o=this.bias==null?null:this.bias.read(),c=mapActivationToFusedKernel(this.activation.getClassName());if(c!=null&&this.rank===2)s=conv2dWithBiasActivation(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,c);else{if(this.rank===1)s=conv1dWithBias(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=conv2dWithBiasActivation(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=conv3dWithBias(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new NotImplementedError("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=getExactlyOneShape(e);const i=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let c=0;c<s.length;++c){const d=convOutputLength(s[c],this.kernelSize[c],this.padding,this.strides[c],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[c]);i.push(d)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(i),o.push(this.filters)):(o.push(this.filters),o=o.concat(i)),o}getConfig(){const e={filters:this.filters,kernelInitializer:serializeInitializer(this.kernelInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint)},i=super.getConfig();return Object.assign(e,i),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Conv2D extends Conv{constructor(e){super(2,e),Conv2D.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Conv2D.className="Conv2D";registerClass(Conv2D);class Conv3D extends Conv{constructor(e){super(3,e),Conv3D.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new ValueError(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Conv3D.className="Conv3D";registerClass(Conv3D);class Conv2DTranspose extends Conv2D{constructor(e){if(super(e),this.inputSpec=[new InputSpec({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=getExactlyOneShape(e),e.length!==4)throw new ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));const i=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[i]==null)throw new ValueError("The channel dimension of the inputs should be defined. Found `None`.");const s=e[i],o=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new InputSpec({ndim:4,axes:{[i]:s}})],this.built=!0}call(e,i){return tidy(()=>{let s=getExactlyOneTensor(e);if(s.shape.length!==4)throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const o=s.shape,c=o[0];let d,h;this.dataFormat==="channelsFirst"?(d=2,h=3):(d=1,h=2);const g=o[d],_=o[h],b=this.kernelSize[0],$=this.kernelSize[1],j=this.strides[0],_e=this.strides[1],tt=deconvLength(g,j,b,this.padding),et=deconvLength(_,_e,$,this.padding),nt=[c,tt,et,this.filters];this.dataFormat!=="channelsLast"&&(s=transpose$3(s,[0,2,3,1]));let rt=conv2dTranspose$1(s,this.kernel.read(),nt,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(rt=transpose$3(rt,[0,3,1,2])),this.bias!=null&&(rt=biasAdd(rt,this.bias.read(),this.dataFormat)),this.activation!=null&&(rt=this.activation.apply(rt)),rt})}computeOutputShape(e){e=getExactlyOneShape(e);const i=e.slice();let s,o,c;this.dataFormat==="channelsFirst"?(s=1,o=2,c=3):(s=3,o=1,c=2);const d=this.kernelSize[0],h=this.kernelSize[1],g=this.strides[0],_=this.strides[1];return i[s]=this.filters,i[o]=deconvLength(i[o],g,d,this.padding),i[c]=deconvLength(i[c],_,h,this.padding),i}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Conv2DTranspose.className="Conv2DTranspose";registerClass(Conv2DTranspose);class SeparableConv extends Conv{constructor(e,i){if(super(e,i),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,i.filters==null)throw new ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(i.kernelInitializer!=null||i.kernelRegularizer!=null||i.kernelConstraint!=null)throw new ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(i.padding!=null&&i.padding!=="same"&&i.padding!=="valid")throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(i.padding)}`);this.depthMultiplier=i.depthMultiplier==null?1:i.depthMultiplier,this.depthwiseInitializer=getInitializer(i.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=getRegularizer(i.depthwiseRegularizer),this.depthwiseConstraint=getConstraint(i.depthwiseConstraint),this.pointwiseInitializer=getInitializer(i.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=getRegularizer(i.pointwiseRegularizer),this.pointwiseConstraint=getConstraint(i.pointwiseConstraint)}build(e){if(e=getExactlyOneShape(e),e.length<this.rank+2)throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const i=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[i]==null||e[i]<0)throw new ValueError(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[i])}`);const s=e[i],o=this.kernelSize.concat([s,this.depthMultiplier]),c=[];for(let h=0;h<this.rank;++h)c.push(1);c.push(s*this.depthMultiplier,this.filters);const d=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,d,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",c,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,d,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,d,this.biasConstraint):this.bias=null,this.inputSpec=[new InputSpec({ndim:this.rank+2,axes:{[i]:s}})],this.built=!0}call(e,i){return tidy(()=>{e=getExactlyOneTensor(e);let s;if(this.rank===1)throw new NotImplementedError("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=transpose$3(e,[0,2,3,1])),s=separableConv2d$1(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=biasAdd(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=transpose$3(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),e.pointwiseInitializer=serializeInitializer(this.pointwiseInitializer),e.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),e.pointwiseRegularizer=serializeRegularizer(this.pointwiseRegularizer),e.depthwiseConstraint=serializeConstraint(this.depthwiseConstraint),e.pointwiseConstraint=serializeConstraint(this.pointwiseConstraint),e}}SeparableConv.className="SeparableConv";class SeparableConv2D extends SeparableConv{constructor(e){super(2,e)}}SeparableConv2D.className="SeparableConv2D";registerClass(SeparableConv2D);class Conv1D extends Conv{constructor(e){super(1,e),Conv1D.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Conv1D.className="Conv1D";registerClass(Conv1D);class Cropping2D extends Layer{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,i){return tidy(()=>{if(e=getExactlyOneTensor(e),this.dataFormat==="channelsLast"){const s=sliceAlongAxis(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return sliceAlongAxis(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=sliceAlongAxis(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return sliceAlongAxis(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}Cropping2D.className="Cropping2D";registerClass(Cropping2D);class UpSampling2D extends Layer{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,checkInterpolationFormat(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const i=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],i,s]}else{const i=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],i,s,e[3]]}}call(e,i){return tidy(()=>{let s=getExactlyOneTensor(e);const o=s.shape;if(this.dataFormat==="channelsFirst"){s=transpose$3(s,[0,2,3,1]);const c=this.size[0]*o[2],d=this.size[1]*o[3],h=this.interpolation==="nearest"?s.resizeNearestNeighbor([c,d]):s.resizeBilinear([c,d]);return transpose$3(h,[0,3,1,2])}else{const c=this.size[0]*o[1],d=this.size[1]*o[2];return this.interpolation==="nearest"?s.resizeNearestNeighbor([c,d]):s.resizeBilinear([c,d])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}UpSampling2D.className="UpSampling2D";registerClass(UpSampling2D);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function depthwiseConv2d$1(a,e,i=[1,1],s="valid",o,c){return tidy(()=>{o==null&&(o=imageDataFormat()),checkDataFormat(o);let d=preprocessConv2DInput(a,o);if(a.rank!==4)throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ${a.rank}-D`);if(e.rank!==4)throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return d=depthwiseConv2d$3(d,e,i,s==="same"?"same":"valid","NHWC",c),o==="channelsFirst"&&(d=transpose$3(d,[0,3,1,2])),d})}class DepthwiseConv2D extends BaseConv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=getInitializer(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=getConstraint(e.depthwiseConstraint),this.depthwiseRegularizer=getRegularizer(e.depthwiseRegularizer)}build(e){if(e=getExactlyOneShape(e),e.length<4)throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const i=this.dataFormat==="channelsFirst"?1:3;if(e[i]==null||e[i]<0)throw new ValueError(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[i]}).`);const s=e[i],o=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,i){return tidy(()=>{e=getExactlyOneTensor(e);let s=depthwiseConv2d$1(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=biasAdd(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=getExactlyOneShape(e);const i=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,c=convOutputLength(i,this.kernelSize[0],this.padding,this.strides[0]),d=convOutputLength(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,c,d]:[e[0],c,d,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=serializeInitializer(this.depthwiseInitializer),e.depthwiseRegularizer=serializeRegularizer(this.depthwiseRegularizer),e.depthwiseConstraint=serializeConstraint(this.depthwiseRegularizer),e}}DepthwiseConv2D.className="DepthwiseConv2D";registerClass(DepthwiseConv2D);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function standardizeArgs(a,e,i,s){if(Array.isArray(a)){if(e!=null||i!=null)throw new ValueError("When inputs is an array, neither initialState or constants should be provided");s!=null&&(i=a.slice(a.length-s,a.length),a=a.slice(0,a.length-s)),a.length>1&&(e=a.slice(1,a.length)),a=a[0]}function o(c){return c==null||Array.isArray(c)?c:[c]}return e=o(e),i=o(i),{inputs:a,initialState:e,constants:i}}function rnn$1(a,e,i,s=!1,o,c,d=!1,h=!1){return tidy(()=>{const g=e.shape.length;if(g<3)throw new ValueError(`Input should be at least 3D, but is ${g}D.`);const _=[1,0].concat(range$3(2,g));e=transpose$3(e,_),d&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=o.asType("bool").asType("float32"),o.rank===g-1&&(o=expandDims$3(o,-1)),o=transpose$3(o,_)),s&&(e=reverse$2(e,0),o!=null&&(o=reverse$2(o,0)));const b=[];let $,j=i;const _e=e.shape[0],tt=unstack(e);let et;o!=null&&(et=unstack(o));for(let rt=0;rt<_e;++rt){const it=tt[rt],at=tidy(()=>a(it,j));if(o==null)$=at[0],j=at[1];else{const st=tidy(()=>{const ot=et[rt],ct=onesLike$2(ot).sub(ot),lt=at[0].mul(ot).add(j[0].mul(ct)),dt=j.map((xt,ut)=>at[1][ut].mul(ot).add(xt.mul(ct)));return{output:lt,newStates:dt}});$=st.output,j=st.newStates}h&&b.push($)}let nt;return h&&(nt=stack(b,1)),[$,nt,j]})}class RNN extends Layer{constructor(e){super(e);let i;if(e.cell==null)throw new ValueError("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?i=new StackedRNNCells({cells:e.cell}):i=e.cell,i.stateSize==null)throw new ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=i,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new InputSpec({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return range$3(0,e).map(i=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){isArrayOfShapes(e)&&(e=e[0]),e=e;let i=this.cell.stateSize;Array.isArray(i)||(i=[i]);const s=i[0];let o;if(this.returnSequences?o=[e[0],e[1],s]:o=[e[0],s],this.returnState){const c=[];for(const d of i)c.push([e[0],d]);return[o].concat(c)}else return o}computeMask(e,i){return tidy(()=>{Array.isArray(i)&&(i=i[0]);const s=this.returnSequences?i:null;if(this.returnState){const o=this.states.map(c=>null);return[s].concat(o)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,i=[];for(let s=0;s<e;++s)i.push(null);return i}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new NotImplementedError("Constants support is not implemented in RNN yet.");isArrayOfShapes(e)&&(e=e[0]),e=e;const i=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new InputSpec({shape:[i,null,...s]});const o=[e[0]].concat(e.slice(2));this.cell.build(o);let c;if(Array.isArray(this.cell.stateSize)?c=this.cell.stateSize:c=[this.cell.stateSize],this.stateSpec!=null){if(!arraysEqual(this.stateSpec.map(d=>d.shape[d.shape.length-1]),c))throw new ValueError(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=c.map(d=>new InputSpec({shape:[null,d]}));this.stateful&&this.resetStates()}resetStates(e,i=!1){tidy(()=>{if(!this.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>zeros$4([s,o])):this.states_=[zeros$4([s,this.cell.stateSize])];else if(e==null)dispose(this.states_),this.keptStates!=null&&(dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>zeros$4([s,o])):this.states_[0]=zeros$4([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);i===!0?this.keptStates.push(this.states_.slice()):dispose(this.states_);for(let o=0;o<this.states_.length;++o){const c=e[o],d=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,h=[s,d];if(!arraysEqual(c.shape,h))throw new ValueError(`State ${o} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${c.shape}`);this.states_[o]=c}}this.states_=this.states_.map(o=>keep(o.clone()))})}apply(e,i){let s=i==null?null:i.initialState,o=i==null?null:i.constants;i==null&&(i={});const c=standardizeArgs(e,s,o,this.numConstants);e=c.inputs,s=c.initialState,o=c.constants;let d=[],h=[];if(s!=null){i.initialState=s,d=d.concat(s),this.stateSpec=[];for(const _ of s)this.stateSpec.push(new InputSpec({shape:_.shape}));h=h.concat(this.stateSpec)}if(o!=null&&(i.constants=o,d=d.concat(o),this.numConstants=o.length),d[0]instanceof SymbolicTensor){const _=[e].concat(d),b=this.inputSpec.concat(h),$=this.inputSpec;this.inputSpec=b;const j=super.apply(_,i);return this.inputSpec=$,j}else return super.apply(e,i)}call(e,i){return tidy(()=>{const s=i==null?null:i.mask,o=i==null?null:i.training;let c=i==null?null:i.initialState;e=getExactlyOneTensor(e),c==null&&(this.stateful?c=this.states_:c=this.getInitialState(e));const d=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(c.length!==d)throw new ValueError(`RNN Layer has ${d} state(s) but was passed ${c.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const h={training:o},_=rnn$1((tt,et)=>{const nt=this.cell.call([tt].concat(et),h);return[nt[0],nt.slice(1)]},e,c,this.goBackwards,s,null,this.unroll,this.returnSequences),b=_[0],$=_[1],j=_[2];this.stateful&&this.resetStates(j,o);const _e=this.returnSequences?$:b;return this.returnState?[_e].concat(j):_e})}getInitialState(e){return tidy(()=>{let i=zeros$4(e.shape);return i=sum$3(i,[1,2]),i=expandDims$2(i),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?tile$2(i,[1,s]):i):this.cell.stateSize>1?[tile$2(i,[1,this.cell.stateSize])]:[i]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),i={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(i.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===RNN.className&&(i.cell={className:this.cell.getClassName(),config:s}),Object.assign({},s,e,i)}static fromConfig(e,i,s={}){const o=i.cell,c=deserialize(o,s);return new e(Object.assign(i,{cell:c}))}}RNN.className="RNN";registerClass(RNN);class RNNCell extends Layer{}class SimpleRNNCell extends RNNCell{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.kernelConstraint=getConstraint(e.kernelConstraint),this.recurrentConstraint=getConstraint(e.recurrentConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.dropout=min$3([1,max$3([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=min$3([1,max$3([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=getExactlyOneShape(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,i){return tidy(()=>{if(e=e,e.length!==2)throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const o=i.training==null?!1:i.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike$2(e),rate:this.dropout,training:o})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike$2(s),rate:this.recurrentDropout,training:o}));let c;const d=this.dropoutMask,h=this.recurrentDropoutMask;d!=null?c=dot$2(mul$1(e,d),this.kernel.read()):c=dot$2(e,this.kernel.read()),this.bias!=null&&(c=biasAdd(c,this.bias.read())),h!=null&&(s=mul$1(s,h));let g=add$4(c,dot$2(s,this.recurrentKernel.read()));return this.activation!=null&&(g=this.activation.apply(g)),[g,g]})}getConfig(){const e=super.getConfig(),i={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,i)}}SimpleRNNCell.className="SimpleRNNCell";registerClass(SimpleRNNCell);class SimpleRNN extends RNN{constructor(e){e.cell=new SimpleRNNCell(e),super(e)}call(e,i){return tidy(()=>{this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=i==null?null:i.mask,o=i==null?null:i.training,c=i==null?null:i.initialState;return super.call(e,{mask:s,training:o,initialState:c})})}static fromConfig(e,i){return new e(i)}}SimpleRNN.className="SimpleRNN";registerClass(SimpleRNN);class GRUCell extends RNNCell{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ValueError("GRUCell does not support reset_after parameter set to true.");this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=getActivation(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.kernelConstraint=getConstraint(e.kernelConstraint),this.recurrentConstraint=getConstraint(e.recurrentConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.dropout=min$3([1,max$3([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=min$3([1,max$3([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=getExactlyOneShape(e);const i=e[e.length-1];this.kernel=this.addWeight("kernel",[i,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,i){return tidy(()=>{if(e=e,e.length!==2)throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=i.training==null?!1:i.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike$2(e),rate:this.dropout,training:s,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike$2(o),rate:this.recurrentDropout,training:s,count:3}));const c=this.dropoutMask,d=this.recurrentDropoutMask;let h,g,_;0<this.dropout&&this.dropout<1&&(e=mul$1(e,c[0]));let b=dot$2(e,this.kernel.read());this.useBias&&(b=biasAdd(b,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=mul$1(o,d[0]));const $=this.recurrentKernel.read(),[j,_e]=split$1($,[2*this.units,this.units],$.rank-1),tt=dot$2(o,j),[et,nt,rt]=split$1(b,3,b.rank-1),[it,at]=split$1(tt,2,tt.rank-1);h=this.recurrentActivation.apply(add$4(et,it)),g=this.recurrentActivation.apply(add$4(nt,at));const st=dot$2(mul$1(g,o),_e);_=this.activation.apply(add$4(rt,st));const ot=add$4(mul$1(h,o),mul$1(add$4(1,neg$2(h)),_));return[ot,ot]})}getConfig(){const e=super.getConfig(),i={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,i)}}GRUCell.className="GRUCell";registerClass(GRUCell);class GRU extends RNN{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new GRUCell(e),super(e)}call(e,i){return tidy(()=>{this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=i==null?null:i.mask,o=i==null?null:i.training,c=i==null?null:i.initialState;return super.call(e,{mask:s,training:o,initialState:c})})}static fromConfig(e,i){return i.implmentation===0&&(i.implementation=1),new e(i)}}GRU.className="GRU";registerClass(GRU);class LSTMCell extends RNNCell{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=getActivation(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=getInitializer(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.recurrentRegularizer=getRegularizer(e.recurrentRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.kernelConstraint=getConstraint(e.kernelConstraint),this.recurrentConstraint=getConstraint(e.recurrentConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.dropout=min$3([1,max$3([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=min$3([1,max$3([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var i;e=getExactlyOneShape(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){const c=this.biasInitializer,d=this.units;o=new(i=class extends Initializer{apply(g,_){const b=c.apply([d]),$=new Ones().apply([d]),j=c.apply([d*2]);return concatAlongFirstAxis(concatAlongFirstAxis(b,$),j)}},i.className="CustomInit",i)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,i){return tidy(()=>{const s=i.training==null?!1:i.training;if(e=e,e.length!==3)throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const c=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike$2(e),rate:this.dropout,training:s,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike$2(o),rate:this.recurrentDropout,training:s,count:4}));const d=this.dropoutMask,h=this.recurrentDropoutMask;let g,_,b,$;0<this.dropout&&this.dropout<1&&(e=mul$1(e,d[0]));let j=dot$2(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=mul$1(o,h[0])),j=add$4(j,dot$2(o,this.recurrentKernel.read())),this.useBias&&(j=biasAdd(j,this.bias.read()));const[_e,tt,et,nt]=split$1(j,4,j.rank-1);g=this.recurrentActivation.apply(_e),_=this.recurrentActivation.apply(tt),b=add$4(mul$1(_,c),mul$1(g,this.activation.apply(et))),$=this.recurrentActivation.apply(nt);const rt=mul$1($,this.activation.apply(b));return[rt,rt,b]})}getConfig(){const e=super.getConfig(),i={units:this.units,activation:serializeActivation(this.activation),recurrentActivation:serializeActivation(this.recurrentActivation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),recurrentInitializer:serializeInitializer(this.recurrentInitializer),biasInitializer:serializeInitializer(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:serializeRegularizer(this.kernelRegularizer),recurrentRegularizer:serializeRegularizer(this.recurrentRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),recurrentConstraint:serializeConstraint(this.recurrentConstraint),biasConstraint:serializeConstraint(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,i)}}LSTMCell.className="LSTMCell";registerClass(LSTMCell);class LSTM extends RNN{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new LSTMCell(e),super(e)}call(e,i){return tidy(()=>{this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=i==null?null:i.mask,o=i==null?null:i.training,c=i==null?null:i.initialState;return super.call(e,{mask:s,training:o,initialState:c})})}static fromConfig(e,i){return i.implmentation===0&&(i.implementation=1),new e(i)}}LSTM.className="LSTM";registerClass(LSTM);class StackedRNNCells extends RNNCell{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?e.push(...i.stateSize):e.push(i.stateSize);return e}call(e,i){return tidy(()=>{e=e;let s=e.slice(1);const o=[];for(const h of this.cells.slice().reverse())Array.isArray(h.stateSize)?o.push(s.splice(0,h.stateSize.length)):o.push(s.splice(0,1));o.reverse();const c=[];let d;for(let h=0;h<this.cells.length;++h){const g=this.cells[h];s=o[h],h===0?d=[e[0]].concat(s):d=[d[0]].concat(s),d=g.call(d,i),c.push(d.slice(1))}s=[];for(const h of c.slice().reverse())s.push(...h);return[d[0]].concat(s)})}build(e){isArrayOfShapes(e)&&(e=e[0]),e=e;let i;this.cells.forEach((s,o)=>{nameScope(`RNNCell_${o}`,()=>{s.build(e),Array.isArray(s.stateSize)?i=s.stateSize[0]:i=s.stateSize,e=[e[0],i]})}),this.built=!0}getConfig(){const e=super.getConfig(),i=c=>({className:c.getClassName(),config:c.getConfig()}),o={cells:this.cells.map(i)};return Object.assign({},e,o)}static fromConfig(e,i,s={}){const o=[];for(const c of i.cells)o.push(deserialize(c,s));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const i of this.cells)e.push(...i.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const i of this.cells)e.push(...i.nonTrainableWeights);if(!this.trainable){const i=[];for(const s of this.cells)i.push(...s.trainableWeights);return i.concat(e)}return e}getWeights(){const e=[];for(const i of this.cells)e.push(...i.weights);return batchGetValue(e)}setWeights(e){const i=[];for(const s of this.cells){const o=s.weights.length,c=e.splice(o);for(let d=0;d<s.weights.length;++d)i.push([s.weights[d],c[d]])}batchSetValue(i)}}StackedRNNCells.className="StackedRNNCells";registerClass(StackedRNNCells);function generateDropoutMask(a){const{ones:e,rate:i,training:s=!1,count:o=1}=a,c=()=>dropout$1(e(),i),d=()=>inTrainPhase(c,e,s);return!o||o<=1?keep(d().clone()):Array(o).fill(void 0).map(d).map(g=>keep(g.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var __rest=function(a,e){var i={};for(var s in a)Object.prototype.hasOwnProperty.call(a,s)&&e.indexOf(s)<0&&(i[s]=a[s]);if(a!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,s=Object.getOwnPropertySymbols(a);o<s.length;o++)e.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(a,s[o])&&(i[s[o]]=a[s[o]]);return i};class ConvRNN2D extends RNN{constructor(e){if(e.unroll)throw new NotImplementedError("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new NotImplementedError("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new InputSpec({ndim:5})]}call(e,i){return tidy(()=>{if(this.cell.dropoutMask!=null&&(dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),i&&i.constants)throw new ValueError("ConvRNN2D cell does not support constants");const s=i==null?null:i.mask,o=i==null?null:i.training,c=i==null?null:i.initialState;return super.call(e,{mask:s,training:o,initialState:c})})}computeOutputShape(e){let i=this.computeSingleOutputShape(e);return this.returnSequences||(i=[i[0],...i.slice(2)]),this.returnState&&(i=[i,...Array(2).fill([e[0],...i.slice(-3)])]),i}getInitialState(e){return tidy(()=>{const{stateSize:i}=this.cell,s=e.shape,o=this.computeSingleOutputShape(s),c=[o[0],...o.slice(2)],d=zeros$4(c);return Array.isArray(i)?Array(i.length).fill(d):[d]})}resetStates(e,i=!1){tidy(()=>{if(!this.stateful)throw new AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,o=this.computeSingleOutputShape(s),c=[o[0],...o.slice(2)];if(s[0]==null)throw new ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>zeros$4(c)):this.states_=[zeros$4(c)];else if(e==null)dispose(this.states_),this.keptStates!=null&&(dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>zeros$4(c)):this.states_[0]=zeros$4(c);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);i?this.keptStates.push(this.states_.slice()):dispose(this.states_);for(let h=0;h<this.states_.length;++h){const g=e[h],_=c;if(!arraysEqual(g.shape,_))throw new ValueError(`State ${h} is incompatible with layer ${this.name}: expected shape=${_}, received shape=${g.shape}`);this.states_[h]=g}}this.states_=this.states_.map(h=>keep(h.clone()))})}computeSingleOutputShape(e){const{dataFormat:i,filters:s,kernelSize:o,padding:c,strides:d,dilationRate:h}=this.cell,g=i==="channelsFirst",_=e[g?3:2],b=e[g?4:3],$=convOutputLength(_,o[0],c,d[0],h[0]),j=convOutputLength(b,o[1],c,d[1],h[1]);return[...e.slice(0,2),...g?[s,$,j]:[$,j,s]]}}ConvRNN2D.className="ConvRNN2D";class ConvLSTM2DCell extends LSTMCell{constructor(e){const{filters:i,kernelSize:s,strides:o,padding:c,dataFormat:d,dilationRate:h}=e;super(Object.assign({},e,{units:i})),this.filters=i,assertPositiveInteger(this.filters,"filters"),this.kernelSize=normalizeArray(s,2,"kernelSize"),this.kernelSize.forEach(g=>assertPositiveInteger(g,"kernelSize")),this.strides=normalizeArray(o||1,2,"strides"),this.strides.forEach(g=>assertPositiveInteger(g,"strides")),this.padding=c||"valid",checkPaddingMode(this.padding),this.dataFormat=d||"channelsLast",checkDataFormat(this.dataFormat),this.dilationRate=normalizeArray(h||1,2,"dilationRate"),this.dilationRate.forEach(g=>assertPositiveInteger(g,"dilationRate"))}build(e){var i;e=getExactlyOneShape(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new ValueError(`The channel dimension of the input should be defined. Found ${e[s]}`);const o=e[s],c=4,d=this.kernelSize.concat([o,this.filters*c]);this.kernel=this.addWeight("kernel",d,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const h=this.kernelSize.concat([this.filters,this.filters*c]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",h,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let g;if(this.unitForgetBias){const _=this.biasInitializer,b=this.filters;g=new(i=class extends Initializer{apply(j,_e){const tt=_.apply([b]),et=ones$1([b]),nt=_.apply([b*2]);return concatenate$1([tt,et,nt])}},i.className="CustomInit",i)}else g=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*c],null,g,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,i){return tidy(()=>{if(e.length!==3)throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=i.training||!1,o=e[0],c=e[1],d=e[2],h=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=generateDropoutMask({ones:()=>onesLike$2(o),rate:this.dropout,training:s,count:h}));const g=this.dropoutMask,_=(Ct,Mt,Ot)=>!Mt||!Mt[Ot]?Ct:mul$1(Mt[Ot],Ct);let b=_(o,g,0),$=_(o,g,1),j=_(o,g,2),_e=_(o,g,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=generateDropoutMask({ones:()=>onesLike$2(c),rate:this.recurrentDropout,training:s,count:h}));const tt=this.recurrentDropoutMask;let et=_(c,tt,0),nt=_(c,tt,1),rt=_(c,tt,2),it=_(c,tt,3);const at=3,[st,ot,ct,lt]=split$1(this.kernel.read(),h,at),[dt,xt,ut,ft]=this.useBias?split$1(this.bias.read(),h):[null,null,null,null];b=this.inputConv(b,st,dt,this.padding),$=this.inputConv($,ot,xt,this.padding),j=this.inputConv(j,ct,ut,this.padding),_e=this.inputConv(_e,lt,ft,this.padding);const[mt,yt,St,Et]=split$1(this.recurrentKernel.read(),h,at);et=this.recurrentConv(et,mt),nt=this.recurrentConv(nt,yt),rt=this.recurrentConv(rt,St),it=this.recurrentConv(it,Et);const vt=this.recurrentActivation.apply(add$4(b,et)),Nt=this.recurrentActivation.apply(add$4($,nt)),wt=add$4(mul$1(Nt,d),mul$1(vt,this.activation.apply(add$4(j,rt)))),$t=mul$1(this.recurrentActivation.apply(add$4(_e,it)),this.activation.apply(wt));return[$t,$t,wt]})}getConfig(){const e=super.getConfig(),i=__rest(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},i,s)}inputConv(e,i,s,o){const c=conv2d$3(e,i,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?biasAdd(c,s,this.dataFormat):c}recurrentConv(e,i){return conv2d$3(e,i,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}ConvLSTM2DCell.className="ConvLSTM2DCell";registerClass(ConvLSTM2DCell);class ConvLSTM2D extends ConvRNN2D{constructor(e){const i=new ConvLSTM2DCell(e);super(Object.assign({},e,{cell:i}))}static fromConfig(e,i){return new e(i)}}ConvLSTM2D.className="ConvLSTM2D";registerClass(ConvLSTM2D);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Dropout extends Layer{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const i=e.shape,s=[];for(let o=0;o<this.noiseShape.length;++o)s.push(this.noiseShape[o]==null?i[o]:this.noiseShape[o]);return s}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e);if(0<this.rate&&this.rate<1){const o=i.training==null?!1:i.training,c=this.getNoiseShape(s);return inTrainPhase(()=>dropout$1(s,this.rate,c,this.seed),()=>s,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},i=super.getConfig();return Object.assign(e,i),e}dispose(){return super.dispose()}}Dropout.className="Dropout";registerClass(Dropout);class SpatialDropout1D extends Dropout{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const i=e.shape;return[i[0],1,i[2]]}}SpatialDropout1D.className="SpatialDropout1D";registerClass(SpatialDropout1D);class Dense extends Layer{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),this.batchInputShape=[i,e.inputDim]}this.units=e.units,assertPositiveInteger(this.units,"units"),this.activation=getActivation(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=getInitializer(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=getInitializer(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=getConstraint(e.kernelConstraint),this.biasConstraint=getConstraint(e.biasConstraint),this.kernelRegularizer=getRegularizer(e.kernelRegularizer),this.biasRegularizer=getRegularizer(e.biasRegularizer),this.activityRegularizer=getRegularizer(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=getExactlyOneShape(e);const i=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[i,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:i}}],this.built=!0}computeOutputShape(e){e=getExactlyOneShape(e);const i=e.slice();return i[i.length-1]=this.units,i}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e),o=mapActivationToFusedKernel(this.activation.getClassName());let c;return o!=null?c=dot$2(s,this.kernel.read(),o,this.bias?this.bias.read():null):(c=dot$2(s,this.kernel.read()),this.bias!=null&&(c=biasAdd(c,this.bias.read())),this.activation!=null&&(c=this.activation.apply(c))),c})}getConfig(){const e={units:this.units,activation:serializeActivation(this.activation),useBias:this.useBias,kernelInitializer:serializeInitializer(this.kernelInitializer),biasInitializer:serializeInitializer(this.biasInitializer),kernelRegularizer:serializeRegularizer(this.kernelRegularizer),biasRegularizer:serializeRegularizer(this.biasRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),kernelConstraint:serializeConstraint(this.kernelConstraint),biasConstraint:serializeConstraint(this.biasConstraint)},i=super.getConfig();return Object.assign(e,i),e}}Dense.className="Dense";registerClass(Dense);class Flatten extends Layer{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=getExactlyOneShape(e);for(const i of e.slice(1))if(i==null)throw new ValueError(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],arrayProd(e,1)]}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);let s=getExactlyOneTensor(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const o=[0];for(let c=2;c<s.rank;++c)o.push(c);o.push(1),s=s.transpose(o)}return batchFlatten(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const i=super.getConfig();return Object.assign(e,i),e}}Flatten.className="Flatten";registerClass(Flatten);class Activation extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.activation=getActivation(e.activation)}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e);return this.activation.apply(s)})}getConfig(){const e={activation:serializeActivation(this.activation)},i=super.getConfig();return Object.assign(e,i),e}}Activation.className="Activation";registerClass(Activation);class RepeatVector extends Layer{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,i){return tidy(()=>(e=getExactlyOneTensor(e),repeat(e,this.n)))}getConfig(){const e={n:this.n},i=super.getConfig();return Object.assign(e,i),e}}RepeatVector.className="RepeatVector";registerClass(RepeatVector);class Reshape extends Layer{constructor(e){super(e),this.targetShape=e.targetShape;for(let i=0;i<this.targetShape.length;++i)this.isUnknown(this.targetShape[i])&&(this.targetShape[i]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,i){const s="Total size of new array must be unchanged.",o=i.slice();let c=1,d=null;for(let g=0;g<o.length;++g){const _=o[g];if(this.isUnknown(_))if(d===null)d=g;else throw new ValueError("Can only specifiy one unknown dimension.");else c*=_}const h=arrayProd(e);if(d!==null){if(c===0||h%c!==0)throw new ValueError(s);o[d]=h/c}else if(h!==c)throw new ValueError(s);return o}computeOutputShape(e){let i=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){i=!0;break}return i?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e),o=s.shape,c=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return s.reshape(c)})}getConfig(){const e={targetShape:this.targetShape},i=super.getConfig();return Object.assign(e,i),e}}Reshape.className="Reshape";registerClass(Reshape);class Permute extends Layer{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const i=range$3(1,e.dims.length+1);if(!arraysEqual(e.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new InputSpec({ndim:this.dims.length+1})]}computeOutputShape(e){e=getExactlyOneShape(e);const i=e.slice();return this.dims.forEach((s,o)=>{i[o+1]=e[s]}),i}call(e,i){return transpose$3(getExactlyOneTensor(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},i=super.getConfig();return Object.assign(e,i),e}}Permute.className="Permute";registerClass(Permute);class Masking extends Layer{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={maskValue:this.maskValue};return Object.assign(i,e),i}computeMask(e,i){const s=getExactlyOneTensor(e);return any$2(notEqual$2(s,this.maskValue),-1)}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e),d=any$2(notEqual$2(s,this.maskValue),-1,!0);return s.mul(d.asType(s.dtype))})}}Masking.className="Masking";registerClass(Masking);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Embedding extends Layer{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let i=null;e.batchSize!=null&&(i=e.batchSize),e.inputLength==null?this.batchInputShape=[i,null]:this.batchInputShape=[i].concat(toList(e.inputLength))}this.inputDim=e.inputDim,assertPositiveInteger(this.inputDim,"inputDim"),this.outputDim=e.outputDim,assertPositiveInteger(this.outputDim,"outputDim"),this.embeddingsInitializer=getInitializer(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=getRegularizer(e.embeddingsRegularizer),this.activityRegularizer=getRegularizer(e.activityRegularizer),this.embeddingsConstraint=getConstraint(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,i){return tidy(()=>this.maskZero?(e=getExactlyOneTensor(e),notEqual$2(e,zerosLike$2(e))):null)}computeOutputShape(e){if(e=getExactlyOneShape(e),this.inputLength==null)return[...e,this.outputDim];const i=toList(this.inputLength);if(i.length!==e.length-1)throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let o=0;o<i.length;++o){const c=i[o],d=e[o+1];if(c!=null&&d!=null&&c!==d)throw new ValueError(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);c==null&&(i[s]=d),s++}}return[e[0],...i,this.outputDim]}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);let s=getExactlyOneTensor(e);return s.dtype!=="int32"&&(s=cast$2(s,"int32")),gather(this.embeddings.read(),s.as1D()).reshape(getExactlyOneShape(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:serializeInitializer(this.embeddingsInitializer),embeddingsRegularizer:serializeRegularizer(this.embeddingsRegularizer),activityRegularizer:serializeRegularizer(this.activityRegularizer),embeddingsConstraint:serializeConstraint(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},i=super.getConfig();return Object.assign(e,i),e}}Embedding.className="Embedding";registerClass(Embedding);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Merge extends Layer{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new NotImplementedError}computeElementwiseOpOutputShape(e,i){if(e==null||i==null)return null;if(e.length<i.length)return this.computeElementwiseOpOutputShape(i,e);if(i.length===0)return e;const s=e.slice(0,e.length-i.length);for(let o=0;o<i.length;++o){const c=e[e.length-i.length+o],d=i[o];if(c==null||d==null||c<0||d<0)s.push(null);else if(c===1)s.push(d);else if(d===1)s.push(c);else{if(c!==d)throw new ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(i));s.push(c)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[getExactlyOneShape(e)]),e=e,e.length<2)throw new ValueError(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let i=[];for(const c of e)c!=null&&c[0]!==null&&i.push(c[0]);if(i=unique$2(i),i.length>1)throw new ValueError(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let c=1;c<e.length;++c){const d=e[c]==null?null:e[c].slice(1);s=this.computeElementwiseOpOutputShape(s,d)}const o=e.map(c=>c.length);e.indexOf(null)===-1&&unique$2(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,i){return tidy(()=>{if(e=e,this.reshapeRequired){const s=[],o=e.map(c=>c.rank);if(o.indexOf(null)===-1){const c=max$3(o);for(let d of e){const h=d.rank;for(let g=0;g<c-h;++g)d=expandDims$2(d,1);s.push(d)}return this.mergeFunction(s)}else{let c=!1;for(const g of e){const _=g.rank;if(_==null){const b=g.shape,$=b[0],j=b.slice(1).concat([$]);let _e=g.reshape([$].concat(arrayProd(b.slice(1))));_e=transpose$3(_e,[1,0]),_e=_e.reshape(j),s.push(_e),c=!0}else if(_>1){const b=range$3(1,_).concat([0]);s.push(transpose$3(g,b)),c=!0}else s.push(g)}let d=this.mergeFunction(s);const h=d.rank;if(c){if(h==null){const g=d.shape,_=g.length,b=g[_-1],$=[b].concat(g.slice(0,g.length-1));d=transpose$3(d.reshape([-1,b]),[1,0]).reshape($)}else if(h>1){const g=[h-1].concat(range$3(0,h-1));d=transpose$3(d,g)}}return d}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let i;e[0]==null?i=null:i=e[0].slice(1);for(let o=1;o<e.length;++o){const c=e[o]==null?null:e[o].slice(1);i=this.computeElementwiseOpOutputShape(i,c)}let s=[];for(const o of e)o!=null&&o[0]!==null&&s.push(o[0]);return s=unique$2(s),s.length===1?i=s.concat(i):i=[null].concat(i),i}computeMask(e,i){return tidy(()=>{if(i==null)return null;if(!Array.isArray(i))throw new ValueError("`mask` should be an Array");if(!Array.isArray(e))throw new ValueError("`inputs` should be an Array");if(i.length!==e.length)throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${i.length})`);if(i.every(o=>o==null))return null;i=i.map(o=>o==null?o:expandDims$3(o,0));let s=i[0];for(let o=1;o<i.length-1;++o)s=logicalAnd$2(s,i[o]);return s})}}class Add extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy(()=>{let i=e[0].clone();for(let s=1;s<e.length;++s)i=add$4(i,e[s]);return i})}}Add.className="Add";registerClass(Add);class Multiply extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy(()=>{let i=e[0].clone();for(let s=1;s<e.length;++s)i=mul$1(i,e[s]);return i})}}Multiply.className="Multiply";registerClass(Multiply);class Average extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy(()=>{let i=e[0].clone();for(let s=1;s<e.length;++s)i=add$4(i,e[s]);return mul$1(1/e.length,i)})}}Average.className="Average";registerClass(Average);class Maximum extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy(()=>{let i=e[0];for(let s=1;s<e.length;++s)i=maximum$3(i,e[s]);return i})}}Maximum.className="Maximum";registerClass(Maximum);class Minimum extends Merge{constructor(e){super(e)}mergeFunction(e){return tidy(()=>{let i=e[0];for(let s=1;s<e.length;++s)i=minimum$3(i,e[s]);return i})}}Minimum.className="Minimum";registerClass(Minimum);class Concatenate extends Merge{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let i=!0;for(const o of e)if(o!=null){i=!1;break}if(i)return;const s=[];for(let o=0;o<e.length;++o){const c=e[o].slice();c.splice(this.axis,1);let d=!1;for(const h of s)if(arraysEqual(h,c)){d=!0;break}d||s.push(c)}if(s.length>1)throw new ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return tidy(()=>concatenate$1(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ValueError("A `Concatenate` layer should be called on a list of inputs.");const i=e,s=i[0].slice(),o=this.axis<0?s.length+this.axis:this.axis;for(const c of i.slice(1)){if(s[o]==null||c[o]==null){s[o]=null;break}s[o]+=c[o]}return s}computeMask(e,i){if(i==null)return null;if(!Array.isArray(i))throw new ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ValueError("`inputs` should be an array for Concatenate");if(i.length!==e.length)throw new ValueError(`Mismatch in the length of mask (${i.length}) and the legnth of inputs (${e.length})`);return tidy(()=>{let s=!0;if(i.forEach(d=>{if(d!=null){s=!1;return}}),s)return null;const o=[];for(let d=0;d<e.length;++d)i[d]==null?o.push(onesLike$2(e[d]).asType("bool")):i[d].rank<e[d].rank?o.push(expandDims$3(i[d],-1)):o.push(i[d]);const c=concat$3(o,this.axis);return all$2(c,-1,!1)})}getConfig(){const e={axis:this.axis},i=super.getConfig();return Object.assign(e,i),e}}Concatenate.className="Concatenate";registerClass(Concatenate);function interpretAxis(a,e){for(;a<0;)a+=e;return a}function batchDot(a,e,i){if(a.shape.length>3||e.shape.length>3)throw new NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(assert$1(a.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${a.shape.length}`),assert$1(a.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof i=="number"&&(i=[i,i]),a.dtype==="complex64"||e.dtype==="complex64")throw new NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");const s=a.shape.length,o=e.shape.length;i==null&&(i=[s-1,o-2]);const c=i;return tidy(()=>{let d;if(s>o){d=s-o;const g=[];for(let _=0;_<d;++_)g.push(1);e=e.reshape(e.shape.concat(g))}else if(o>s){d=o-s;const g=[];for(let _=0;_<d;++_)g.push(1);a=a.reshape(a.shape.concat(g))}else d=0;let h;if(a.shape.length===2&&e.shape.length===2)c[0]===c[1]?h=a.mul(e).sum(c[0]):h=a.transpose([1,0]).mul(e).sum(c[1]);else{const g=c[0]!==a.shape.length-1,_=c[1]===e.shape.length-1;h=a.matMul(e,g,_)}if(d>0){let g;s>o?g=s+o-3:g=s-1;const _=[];for(let b=g;b<g+d;++b)_.push(b);h=h.squeeze(_)}return h.shape.length===1&&(h=h.expandDims(1)),h})}class Dot extends Merge{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){assert$1(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const i=e[0],s=e[1];if(i.length>3||s.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(i,s);if(i[o[0]]!==s[o[1]])throw new ValueError(`Dimension incompatibility: ${i[o[0]]} !== ${s[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ValueError(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i=e[0],s=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((c,d)=>interpretAxis(c,e[d].shape.length)):o=[interpretAxis(this.axes,i.shape.length),interpretAxis(this.axes,s.shape.length)],this.normalize&&(i=l2Normalize(i,o[0]),s=l2Normalize(s,o[1])),batchDot(i,s,o)}interpretAxes(e,i){let s;return Array.isArray(this.axes)?s=this.axes:s=[interpretAxis(this.axes,e.length),interpretAxis(this.axes,i.length)],s}computeOutputShape(e){assert$1(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const i=e[0].slice(),s=e[1].slice();if(i.length>3||s.length>3)throw new NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(i,s);i.splice(o[0],1),s.splice(o[1],1),s.splice(0,1);const c=i.concat(s);return c.length===1&&c.push(1),c}computeMask(e,i){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},i=super.getConfig();return Object.assign(e,i),e}}Dot.className="Dot";registerClass(Dot);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class GaussianNoise extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={stddev:this.stddev};return Object.assign(i,e),i}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e);return inTrainPhase(()=>randomNormal$1(s.shape,0,this.stddev).add(s),()=>s,i.training||!1)})}}GaussianNoise.className="GaussianNoise";registerClass(GaussianNoise);class GaussianDropout extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={rate:this.rate};return Object.assign(i,e),i}call(e,i){return tidy(()=>{this.invokeCallHook(e,i);const s=getExactlyOneTensor(e);return this.rate>0&&this.rate<1?inTrainPhase(()=>{const c=Math.sqrt(this.rate/(1-this.rate));return s.mul(randomNormal$1(s.shape,1,c))},()=>s,i.training||!1):s})}}GaussianDropout.className="GaussianDropout";registerClass(GaussianDropout);class AlphaDropout extends Layer{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||getExactlyOneTensor(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),i={rate:this.rate};return Object.assign(i,e),i}call(e,i){return tidy(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return inTrainPhase(()=>{const c=getExactlyOneTensor(e),g=-1.6732632423543772*1.0507009873554805;let _=greaterEqual$2(randomUniform$1(s),this.rate);_=cast$2(_,"float32");const b=((1-this.rate)*(1+this.rate*g**2))**-.5,$=-b*g*this.rate;return c.mul(_).add(_.add(-1).mul(g)).mul(b).add($)},()=>getExactlyOneTensor(e),i.training||!1)}return e})}}AlphaDropout.className="AlphaDropout";registerClass(AlphaDropout);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function batchNormalization$1(a,e,i,s,o,c=.001){let d;if(a.rank===2)d=batchNorm2d(a,e,i,s,o,c);else if(a.rank===3)d=batchNorm3d(a,e,i,s,o,c);else if(a.rank===4)d=batchNorm4d(a,e,i,s,o,c);else throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${a.rank} yet`);return d}function regularNormalizeBatchInTraining(a,e,i,s,o=.001){return tidy(()=>{const c=moments(a,s),d=c.mean,h=c.variance;return[batchNormalization$1(a,d,h,i,e,o),d,h]})}function broadcastNormalizeBatchInTraining(a,e,i,s,o=.001){return tidy(()=>{const c=moments(a,s),d=c.mean,h=c.variance,g=[];for(const tt of range$3(0,a.rank))s.indexOf(tt)!==-1?g.push(1):g.push(a.shape[tt]);const _=d.reshape(g),b=h.reshape(g),$=e==null?null:e.reshape(g),j=i==null?null:i.reshape(g);return[batchNormalization$1(a,_,b,j,$,o),d,h]})}function normalizeBatchInTraining(a,e,i,s,o=.001){return arraysEqual(s.slice().sort(),range$3(0,a.rank-1))?regularNormalizeBatchInTraining(a,e,i,s,o):broadcastNormalizeBatchInTraining(a,e,i,s,o)}class BatchNormalization extends Layer{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=getInitializer(e.betaInitializer||"zeros"),this.gammaInitializer=getInitializer(e.gammaInitializer||"ones"),this.movingMeanInitializer=getInitializer(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=getInitializer(e.movingVarianceInitializer||"ones"),this.betaConstraint=getConstraint(e.betaConstraint),this.gammaConstraint=getConstraint(e.gammaConstraint),this.betaRegularizer=getRegularizer(e.betaRegularizer),this.gammaRegularizer=getRegularizer(e.gammaRegularizer)}build(e){e=getExactlyOneShape(e);const i=this.axis>=0?this.axis:this.axis+e.length,s=e[i];if(s==null)throw new ValueError(`Axis ${i} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new InputSpec({ndim:e.length,axes:{[i]:s}})];const o=[s];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,i){return tidy(()=>{const s=i.training==null?!1:i.training,o=getExactlyOneTensor(e),c=o.shape,d=c.length,h=range$3(0,d),g=this.axis>=0?this.axis:this.axis+d;h.splice(g,1);const _=pyListRepeat(1,d);_[g]=c[g];const b=h.slice();b.sort();const $=!arraysEqual(b,range$3(0,d).slice(0,d-1)),j=()=>{if($){const it=this.movingMean.read().reshape(_),at=this.movingVariance.read().reshape(_),st=this.center?this.beta.read().reshape(_):null,ot=this.scale?this.gamma.read().reshape(_):null;return batchNormalization$1(o,it,at,st,ot,this.epsilon)}else return batchNormalization$1(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return j();const[_e,tt,et]=normalizeBatchInTraining(o,this.gamma.read(),this.beta.read(),h,this.epsilon),nt=(it,at,st)=>{tidy(()=>{const ot=1-st,ct=it.read(),lt=ct.sub(at).mul(ot);it.write(ct.sub(lt))})};return(()=>{nt(this.movingMean,tt,this.momentum),nt(this.movingVariance,et,this.momentum)})(),_e})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),movingMeanInitializer:serializeInitializer(this.movingMeanInitializer),movingVarianceInitializer:serializeInitializer(this.movingVarianceInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer),betaConstraint:serializeConstraint(this.betaConstraint),gammaConstraint:serializeConstraint(this.gammaConstraint)},i=super.getConfig();return Object.assign(e,i),e}}BatchNormalization.className="BatchNormalization";registerClass(BatchNormalization);class LayerNormalization extends Layer{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const i of this.axis)if(!Number.isInteger(i))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=getInitializer(e.betaInitializer||"zeros"),this.gammaInitializer=getInitializer(e.gammaInitializer||"ones"),this.betaRegularizer=getRegularizer(e.betaRegularizer),this.gammaRegularizer=getRegularizer(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=getExactlyOneShape(e);const i=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let c=0;c<this.axis.length;++c)this.axis[c]<0&&(this.axis[c]+=i);for(const c of this.axis)if(c<0||c>=i)throw new Error(`Invalid axis: ${c}`);if(this.axis.length!==unique$2(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(c=>e[c]),o=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,i){const s=getExactlyOneTensor(e),o=s.shape,c=o.length;return tidy(()=>{let{mean:h,variance:g}=moments(s,this.axis,!0);const _=pyListRepeat(1,c);for(const et of this.axis)_[et]=o[et];const b=et=>et!=null&&et.shape.length!==c&&this.axis!==[c-1]?et.reshape(_):et;let $=b(this.gamma.read()),j=b(this.beta.read());const _e=[],tt=[];for(let et=0;et<c;++et)this.axis.indexOf(et)!==-1?(_e.push(o[et]),tt.push(1)):(_e.push(1),tt.push(o[et]));return h=h.tile(_e),g=g.tile(_e),$=$.tile(tt),j=j.tile(tt),batchNormalization$1(s,h,g,j,$,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:serializeInitializer(this.betaInitializer),gammaInitializer:serializeInitializer(this.gammaInitializer),betaRegularizer:serializeRegularizer(this.betaRegularizer),gammaRegularizer:serializeRegularizer(this.gammaRegularizer)},i=super.getConfig();return Object.assign(e,i),e}}LayerNormalization.className="LayerNormalization";registerClass(LayerNormalization);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function spatial2dPadding(a,e,i){return tidy(()=>{if(a.rank!==4)throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ${a.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(i==null&&(i=imageDataFormat()),i!=="channelsLast"&&i!=="channelsFirst")throw new ValueError(`Unknown data format: ${i}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return i==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],pad(a,s)})}class ZeroPadding2D extends Layer{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?imageDataFormat():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let i,s;if(typeof e.padding[0]=="number")i=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(i=e.padding[0],e.padding[1].length!==2)throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[i,s]}this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(e){e=getExactlyOneShape(e);let i,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?i=e[2]+this.padding[0][0]+this.padding[0][1]:i=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],i,s]):(e[1]!=null&&e[1]>=0?i=e[1]+this.padding[0][0]+this.padding[0][1]:i=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],i,s,e[3]])}call(e,i){return tidy(()=>spatial2dPadding(getExactlyOneTensor(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}ZeroPadding2D.className="ZeroPadding2D";registerClass(ZeroPadding2D);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pool2d(a,e,i,s,o,c){return tidy(()=>{checkDataFormat(o),checkPoolMode(c),checkPaddingMode(s),i==null&&(i=[1,1]),s==null&&(s="valid"),o==null&&(o=imageDataFormat()),c==null&&(c="max"),a=preprocessConv2DInput(a,o);let d;const h=s==="same"?"same":"valid";return c==="max"?d=maxPool$2(a,e,i,h):d=avgPool$2(a,e,i,h),o==="channelsFirst"&&(d=transpose$3(d,[0,3,1,2])),d})}function pool3d$1(a,e,i,s,o,c){return tidy(()=>{checkDataFormat(o),checkPoolMode(c),checkPaddingMode(s),i==null&&(i=[1,1,1]),s==null&&(s="valid"),o==null&&(o=imageDataFormat()),c==null&&(c="max"),a=preprocessConv3DInput(a,o);let d;const h=s==="same"?"same":"valid";return c==="max"?d=maxPool3d$1(a,e,i,h):d=avgPool3d$1(a,e,i,h),o==="channelsFirst"&&(d=transpose$3(d,[0,4,1,2,3])),d})}class Pooling1D extends Layer{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ValueError(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(assertPositiveInteger(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ValueError(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);assertPositiveInteger(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:3})]}computeOutputShape(e){e=getExactlyOneShape(e);const i=convOutputLength(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],i,e[2]]}call(e,i){return tidy(()=>{this.invokeCallHook(e,i),e=expandDims$2(getExactlyOneTensor(e),2);const s=this.poolingFunction(getExactlyOneTensor(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return squeeze$1(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},i=super.getConfig();return Object.assign(e,i),e}}class MaxPooling1D extends Pooling1D{constructor(e){super(e)}poolingFunction(e,i,s,o,c){return checkDataFormat(c),checkPaddingMode(o),pool2d(e,i,s,o,c,"max")}}MaxPooling1D.className="MaxPooling1D";registerClass(MaxPooling1D);class AveragePooling1D extends Pooling1D{constructor(e){super(e)}poolingFunction(e,i,s,o,c){return checkDataFormat(c),checkPaddingMode(o),pool2d(e,i,s,o,c,"avg")}}AveragePooling1D.className="AveragePooling1D";registerClass(AveragePooling1D);class Pooling2D extends Layer{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ValueError(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];assertPositiveInteger(this.poolSize,"poolSize"),assertPositiveInteger(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(e){e=getExactlyOneShape(e);let i=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return i=convOutputLength(i,this.poolSize[0],this.padding,this.strides[0]),s=convOutputLength(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],i,s]:[e[0],i,s,e[3]]}call(e,i){return tidy(()=>(this.invokeCallHook(e,i),this.poolingFunction(getExactlyOneTensor(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}class MaxPooling2D extends Pooling2D{constructor(e){super(e)}poolingFunction(e,i,s,o,c){return checkDataFormat(c),checkPaddingMode(o),pool2d(e,i,s,o,c,"max")}}MaxPooling2D.className="MaxPooling2D";registerClass(MaxPooling2D);class AveragePooling2D extends Pooling2D{constructor(e){super(e)}poolingFunction(e,i,s,o,c){return checkDataFormat(c),checkPaddingMode(o),pool2d(e,i,s,o,c,"avg")}}AveragePooling2D.className="AveragePooling2D";registerClass(AveragePooling2D);class Pooling3D extends Layer{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ValueError(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];assertPositiveInteger(this.poolSize,"poolSize"),assertPositiveInteger(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),checkPaddingMode(this.padding),this.inputSpec=[new InputSpec({ndim:5})]}computeOutputShape(e){e=getExactlyOneShape(e);let i=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return i=convOutputLength(i,this.poolSize[0],this.padding,this.strides[0]),s=convOutputLength(s,this.poolSize[1],this.padding,this.strides[1]),o=convOutputLength(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],i,s,o]:[e[0],i,s,o,e[4]]}call(e,i){return tidy(()=>(this.invokeCallHook(e,i),this.poolingFunction(getExactlyOneTensor(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}class MaxPooling3D extends Pooling3D{constructor(e){super(e)}poolingFunction(e,i,s,o,c){return checkDataFormat(c),checkPaddingMode(o),pool3d$1(e,i,s,o,c,"max")}}MaxPooling3D.className="MaxPooling3D";registerClass(MaxPooling3D);class AveragePooling3D extends Pooling3D{constructor(e){super(e)}poolingFunction(e,i,s,o,c){return checkDataFormat(c),checkPaddingMode(o),pool3d$1(e,i,s,o,c,"avg")}}AveragePooling3D.className="AveragePooling3D";registerClass(AveragePooling3D);class GlobalPooling1D extends Layer{constructor(e){super(e),this.inputSpec=[new InputSpec({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,i){throw new NotImplementedError}}class GlobalAveragePooling1D extends GlobalPooling1D{constructor(e){super(e||{})}call(e,i){return tidy(()=>{const s=getExactlyOneTensor(e);return mean$1(s,1)})}}GlobalAveragePooling1D.className="GlobalAveragePooling1D";registerClass(GlobalAveragePooling1D);class GlobalMaxPooling1D extends GlobalPooling1D{constructor(e){super(e||{})}call(e,i){return tidy(()=>{const s=getExactlyOneTensor(e);return max$4(s,1)})}}GlobalMaxPooling1D.className="GlobalMaxPooling1D";registerClass(GlobalMaxPooling1D);class GlobalPooling2D extends Layer{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,checkDataFormat(this.dataFormat),this.inputSpec=[new InputSpec({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,i){throw new NotImplementedError}getConfig(){const e={dataFormat:this.dataFormat},i=super.getConfig();return Object.assign(e,i),e}}class GlobalAveragePooling2D extends GlobalPooling2D{call(e,i){return tidy(()=>{const s=getExactlyOneTensor(e);return this.dataFormat==="channelsLast"?mean$1(s,[1,2]):mean$1(s,[2,3])})}}GlobalAveragePooling2D.className="GlobalAveragePooling2D";registerClass(GlobalAveragePooling2D);class GlobalMaxPooling2D extends GlobalPooling2D{call(e,i){return tidy(()=>{const s=getExactlyOneTensor(e);return this.dataFormat==="channelsLast"?max$4(s,[1,2]):max$4(s,[2,3])})}}GlobalMaxPooling2D.className="GlobalMaxPooling2D";registerClass(GlobalMaxPooling2D);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wrapper extends Layer{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},i=super.getConfig();return Object.assign(e,i),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,i,s={}){const o=i.layer,c=deserialize(o,s);delete i.layer;const d={layer:c};return Object.assign(d,i),new e(d)}}class TimeDistributed extends Wrapper{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=getExactlyOneShape(e),e.length<3)throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const i=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(i),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=getExactlyOneShape(e);const i=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(i),o=e[1];return[s[0],o].concat(s.slice(1))}call(e,i){return tidy(()=>(e=getExactlyOneTensor(e),rnn$1((d,h)=>[getExactlyOneTensor(this.layer.call(d,i)),[]],e,[],!1,null,null,!1,!0)[1]))}}TimeDistributed.className="TimeDistributed";registerClass(TimeDistributed);function checkBidirectionalMergeMode(a){checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",a)}const DEFAULT_BIDIRECTIONAL_MERGE_MODE="concat";class Bidirectional extends Wrapper{constructor(e){super(e);const i=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=i,this.forwardLayer=deserialize(s),i.goBackwards=i.goBackwards!==!0;const o={};if(o.className=e.layer.getClassName(),o.config=i,this.backwardLayer=deserialize(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?DEFAULT_BIDIRECTIONAL_MERGE_MODE:e.mergeMode,checkBidirectionalMergeMode(this.mergeMode),e.weights)throw new NotImplementedError("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const i=e.length,s=Math.floor(i/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let i=this.forwardLayer.computeOutputShape(e);Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i;let s,o,c;return this.returnState&&(c=i.slice(1)),s=i[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,o=[s]):this.mergeMode==null?o=[s,s.slice()]:o=[s],this.returnState?this.mergeMode==null?o.concat(c).concat(c.slice()):[s].concat(c).concat(c.slice()):singletonOrArray(o)}apply(e,i){let s=i==null?null:i.initialState,o=i==null?null:i.constants;i==null&&(i={});const c=standardizeArgs(e,s,o,this.numConstants);if(e=c.inputs,s=c.initialState,o=c.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&o==null)return super.apply(e,i);const d=[],h=[];if(s!=null){const _=s.length;if(_%2>0)throw new ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");i.initialState=s,d.push(...s);const b=s.map($=>new InputSpec({shape:$.shape}));this.forwardLayer.stateSpec=b.slice(0,_/2),this.backwardLayer.stateSpec=b.slice(_/2),h.push(...b)}if(o!=null)throw new NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");const g=d[0]instanceof SymbolicTensor;for(const _ of d)if(_ instanceof SymbolicTensor!==g)throw new ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(g){const _=[e].concat(d),b=this.inputSpec.concat(h),$=this.inputSpec;this.inputSpec=b;const j=super.apply(_,i);return this.inputSpec=$,j}else return super.apply(e,i)}call(e,i){return tidy(()=>{const s=i.initialState;let o,c;if(s==null)o=this.forwardLayer.call(e,i),c=this.backwardLayer.call(e,i);else{const g=s.slice(0,s.length/2),_=s.slice(s.length/2);o=this.forwardLayer.call(e,Object.assign(i,{initialState:g})),c=this.backwardLayer.call(e,Object.assign(i,{initialState:_}))}let d;this.returnState&&(Array.isArray(o)&&(d=o.slice(1).concat(c.slice(1))),o=o[0],c=c[0]),this.returnSequences&&(c=reverse$2(c,1));let h;return this.mergeMode==="concat"?h=concatenate$1([o,c]):this.mergeMode==="sum"?h=add$4(o,c):this.mergeMode==="ave"?h=mul$1(.5,add$4(o,c)):this.mergeMode==="mul"?h=mul$1(o,c):this.mergeMode==null&&(h=[o,c]),this.returnState?this.mergeMode==null?h.concat(d):[h].concat(d):h})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){nameScope(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),nameScope(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,i){Array.isArray(i)&&(i=i[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[i,i]:s=i:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const c=this.forwardLayer.states.map(d=>null);return Array.isArray(s)?s.concat(c).concat(c):[s].concat(c).concat(c)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},i=super.getConfig();return Object.assign(e,i),e}static fromConfig(e,i){const s=deserialize(i.layer);if(delete i.layer,i.numConstants!=null)throw new NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=i;return o.layer=s,new e(o)}}Bidirectional.className="Bidirectional";registerClass(Bidirectional);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function inputLayer(a){return new InputLayer(a)}function elu$2(a){return new ELU$3(a)}function reLU(a){return new ReLU(a)}function leakyReLU(a){return new LeakyReLU(a)}function prelu$2(a){return new PReLU(a)}function softmax$2(a){return new Softmax(a)}function thresholdedReLU(a){return new ThresholdedReLU(a)}function conv1d(a){return new Conv1D(a)}function conv2d$1(a){return new Conv2D(a)}function conv2dTranspose(a){return new Conv2DTranspose(a)}function conv3d(a){return new Conv3D(a)}function separableConv2d(a){return new SeparableConv2D(a)}function cropping2D(a){return new Cropping2D(a)}function upSampling2d(a){return new UpSampling2D(a)}function depthwiseConv2d(a){return new DepthwiseConv2D(a)}function activation(a){return new Activation(a)}function dense(a){return new Dense(a)}function dropout(a){return new Dropout(a)}function spatialDropout1d(a){return new SpatialDropout1D(a)}function flatten$2(a){return new Flatten(a)}function repeatVector(a){return new RepeatVector(a)}function reshape$3(a){return new Reshape(a)}function permute(a){return new Permute(a)}function embedding(a){return new Embedding(a)}function add$3(a){return new Add(a)}function average(a){return new Average(a)}function concatenate(a){return new Concatenate(a)}function maximum$2(a){return new Maximum(a)}function minimum$2(a){return new Minimum(a)}function multiply$3(a){return new Multiply(a)}function dot$1(a){return new Dot(a)}function batchNormalization(a){return new BatchNormalization(a)}function layerNormalization(a){return new LayerNormalization(a)}function zeroPadding2d(a){return new ZeroPadding2D(a)}function averagePooling1d(a){return new AveragePooling1D(a)}function avgPool1d(a){return averagePooling1d(a)}function avgPooling1d(a){return averagePooling1d(a)}function averagePooling2d(a){return new AveragePooling2D(a)}function avgPool2d(a){return averagePooling2d(a)}function avgPooling2d(a){return averagePooling2d(a)}function averagePooling3d(a){return new AveragePooling3D(a)}function avgPool3d(a){return averagePooling3d(a)}function avgPooling3d(a){return averagePooling3d(a)}function globalAveragePooling1d(a){return new GlobalAveragePooling1D(a)}function globalAveragePooling2d(a){return new GlobalAveragePooling2D(a)}function globalMaxPooling1d(a){return new GlobalMaxPooling1D(a)}function globalMaxPooling2d(a){return new GlobalMaxPooling2D(a)}function maxPooling1d(a){return new MaxPooling1D(a)}function maxPooling2d(a){return new MaxPooling2D(a)}function maxPooling3d(a){return new MaxPooling3D(a)}function gru(a){return new GRU(a)}function gruCell(a){return new GRUCell(a)}function lstm(a){return new LSTM(a)}function lstmCell(a){return new LSTMCell(a)}function simpleRNN(a){return new SimpleRNN(a)}function simpleRNNCell(a){return new SimpleRNNCell(a)}function convLstm2d(a){return new ConvLSTM2D(a)}function convLstm2dCell(a){return new ConvLSTM2DCell(a)}function rnn(a){return new RNN(a)}function stackedRNNCells(a){return new StackedRNNCells(a)}function bidirectional(a){return new Bidirectional(a)}function timeDistributed(a){return new TimeDistributed(a)}const globalMaxPool1d=globalMaxPooling1d,globalMaxPool2d=globalMaxPooling2d,maxPool1d=maxPooling1d,maxPool2d=maxPooling2d;function gaussianNoise(a){return new GaussianNoise(a)}function gaussianDropout(a){return new GaussianDropout(a)}function alphaDropout(a){return new AlphaDropout(a)}function masking(a){return new Masking(a)}const exports_layers=Object.freeze(Object.defineProperty({__proto__:null,Layer,RNN,RNNCell,activation,add:add$3,alphaDropout,average,averagePooling1d,averagePooling2d,averagePooling3d,avgPool1d,avgPool2d,avgPool3d,avgPooling1d,avgPooling2d,avgPooling3d,batchNormalization,bidirectional,concatenate,conv1d,conv2d:conv2d$1,conv2dTranspose,conv3d,convLstm2d,convLstm2dCell,cropping2D,dense,depthwiseConv2d,dot:dot$1,dropout,elu:elu$2,embedding,flatten:flatten$2,gaussianDropout,gaussianNoise,globalAveragePooling1d,globalAveragePooling2d,globalMaxPool1d,globalMaxPool2d,globalMaxPooling1d,globalMaxPooling2d,gru,gruCell,input,inputLayer,layerNormalization,leakyReLU,lstm,lstmCell,masking,maxPool1d,maxPool2d,maxPooling1d,maxPooling2d,maxPooling3d,maximum:maximum$2,minimum:minimum$2,multiply:multiply$3,permute,prelu:prelu$2,reLU,repeatVector,reshape:reshape$3,rnn,separableConv2d,simpleRNN,simpleRNNCell,softmax:softmax$2,spatialDropout1d,stackedRNNCells,thresholdedReLU,timeDistributed,upSampling2d,zeroPadding2d},Symbol.toStringTag,{value:"Module"}));function binaryAccuracy(a,e){return binaryAccuracy$1(a,e)}function binaryCrossentropy(a,e){return binaryCrossentropy$1(a,e)}function sparseCategoricalAccuracy(a,e){return sparseCategoricalAccuracy$1(a,e)}function categoricalAccuracy(a,e){return categoricalAccuracy$1(a,e)}function categoricalCrossentropy(a,e){return categoricalCrossentropy$1(a,e)}function precision(a,e){return precision$1(a,e)}function recall(a,e){return recall$1(a,e)}function cosineProximity(a,e){return cosineProximity$1(a,e)}function meanAbsoluteError(a,e){return meanAbsoluteError$1(a,e)}function meanAbsolutePercentageError(a,e){return meanAbsolutePercentageError$1(a,e)}function MAPE(a,e){return meanAbsolutePercentageError$1(a,e)}function mape(a,e){return meanAbsolutePercentageError$1(a,e)}function meanSquaredError(a,e){return meanSquaredError$1(a,e)}function MSE(a,e){return meanSquaredError$1(a,e)}function mse(a,e){return meanSquaredError$1(a,e)}const exports_metrics=Object.freeze(Object.defineProperty({__proto__:null,MAPE,MSE,binaryAccuracy,binaryCrossentropy,categoricalAccuracy,categoricalCrossentropy,cosineProximity,mape,meanAbsoluteError,meanAbsolutePercentageError,meanSquaredError,mse,precision,recall,sparseCategoricalAccuracy},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const exports_models=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function l1l2(a){return new L1L2(a)}function l1(a){return l1$1(a)}function l2(a){return l2$1(a)}const exports_regularizers=Object.freeze(Object.defineProperty({__proto__:null,l1,l1l2,l2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Callback extends BaseCallback{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function less$2(a,e){return a<e}function greater$2(a,e){return a>e}class EarlyStopping extends Callback{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=less$2:this.mode==="max"?this.monitorFunc=greater$2:this.monitor.indexOf("acc")!==-1?this.monitorFunc=greater$2:this.monitorFunc=less$2,this.monitorFunc===less$2&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===less$2?1/0:-1/0}async onEpochEnd(e,i){await resolveScalarsInLogs(i);const s=this.getMonitorValue(i);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const i=e[this.monitor];return i==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),i}}function earlyStopping(a){return new EarlyStopping(a)}const callbacks={earlyStopping};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var DataType;(function(a){a[a.DT_INVALID=0]="DT_INVALID",a[a.DT_FLOAT=1]="DT_FLOAT",a[a.DT_DOUBLE=2]="DT_DOUBLE",a[a.DT_INT32=3]="DT_INT32",a[a.DT_UINT8=4]="DT_UINT8",a[a.DT_INT16=5]="DT_INT16",a[a.DT_INT8=6]="DT_INT8",a[a.DT_STRING=7]="DT_STRING",a[a.DT_COMPLEX64=8]="DT_COMPLEX64",a[a.DT_INT64=9]="DT_INT64",a[a.DT_BOOL=10]="DT_BOOL",a[a.DT_QINT8=11]="DT_QINT8",a[a.DT_QUINT8=12]="DT_QUINT8",a[a.DT_QINT32=13]="DT_QINT32",a[a.DT_BFLOAT16=14]="DT_BFLOAT16",a[a.DT_FLOAT_REF=101]="DT_FLOAT_REF",a[a.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",a[a.DT_INT32_REF=103]="DT_INT32_REF",a[a.DT_UINT8_REF=104]="DT_UINT8_REF",a[a.DT_INT16_REF=105]="DT_INT16_REF",a[a.DT_INT8_REF=106]="DT_INT8_REF",a[a.DT_STRING_REF=107]="DT_STRING_REF",a[a.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",a[a.DT_INT64_REF=109]="DT_INT64_REF",a[a.DT_BOOL_REF=110]="DT_BOOL_REF",a[a.DT_QINT8_REF=111]="DT_QINT8_REF",a[a.DT_QUINT8_REF=112]="DT_QUINT8_REF",a[a.DT_QINT32_REF=113]="DT_QINT32_REF",a[a.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(DataType||(DataType={}));var SaverDef;(function(a){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(a.CheckpointFormatVersion||(a.CheckpointFormatVersion={}))})(SaverDef||(SaverDef={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CUSTOM_OPS={};function registerOp(a,e){const i={tfOpName:a,category:"custom",inputs:[],attrs:[],customExecutor:e};CUSTOM_OPS[a]=i}function getRegisteredOp(a){return CUSTOM_OPS[a]}function deregisterOp(a){delete CUSTOM_OPS[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getParamValue(a,e,i,s,o){const c=e.inputParams[a];if(c&&c.inputIndexStart!==void 0){const h=c.inputIndexStart,g=c.inputIndexEnd===0?void 0:c.inputIndexEnd===void 0?h+1:c.inputIndexEnd;if(c.type==="tensor")return getTensor(e.inputNames[c.inputIndexStart],i,s,o);if(c.type==="tensors")return e.inputNames.slice(h,g).map(j=>getTensor(j,i,s,o));const _=getTensor(e.inputNames.slice(h)[0],i,s,o),b=_.dataSync();return c.type==="number"?b[0]:toNestedArray(_.shape,b)}const d=e.attrParams[a];return d&&d.value}function getTensor(a,e,i,s){const[o,c]=parseNodeName(a);if(s!=null){const h=s.getHashTableHandleByName(o);if(h!=null)return h}const d=i.currentContextIds.find(h=>!!e[getNodeNameWithContextId(o,h)]);return d!==void 0?e[getNodeNameWithContextId(o,d)][c]:void 0}function getTensorsForCurrentContenxt(a,e,i){return e[getNodeNameWithContextId(a,i.currentContextId)]}function getNodeNameAndIndex(a,e){const[i,s]=parseNodeName(a);return[getNodeNameWithContextId(i,e&&e.currentContextId),s]}function getNodeNameWithContextId(a,e){return e?`${a}-${e}`:a}function parseNodeName(a){const e=a.split(":");return e.length===1?[a,0]:[e[0],Number(e[e.length-1])]}function getPadding(a,e,i){let s=getParamValue("pad",a,e,i);if(s==="explicit"){s=getParamValue("explicitPaddings",a,e,i);const o=[[0,0],[0,0],[0,0],[0,0]];for(let c=0;c<4;c++)o[c][0]=s[c*2],o[c][1]=s[c*2+1];return o}return s}function cloneTensor(a){return a.kept?a:clone$2(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$g=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],arithmetic=Object.freeze(Object.defineProperty({__proto__:null,json:json$g},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$f=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],basicMath=Object.freeze(Object.defineProperty({__proto__:null,json:json$f},Symbol.toStringTag,{value:"Module"})),json$e=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],control=Object.freeze(Object.defineProperty({__proto__:null,json:json$e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$d=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],convolution=Object.freeze(Object.defineProperty({__proto__:null,json:json$d},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$c=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],creation=Object.freeze(Object.defineProperty({__proto__:null,json:json$c},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$b=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],dynamic=Object.freeze(Object.defineProperty({__proto__:null,json:json$b},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$a=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],evaluation=Object.freeze(Object.defineProperty({__proto__:null,json:json$a},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$9=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],graph=Object.freeze(Object.defineProperty({__proto__:null,json:json$9},Symbol.toStringTag,{value:"Module"})),json$8=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]}],hashTable=Object.freeze(Object.defineProperty({__proto__:null,json:json$8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$7=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],image=Object.freeze(Object.defineProperty({__proto__:null,json:json$7},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$6=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],logical=Object.freeze(Object.defineProperty({__proto__:null,json:json$6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$5=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],matrices=Object.freeze(Object.defineProperty({__proto__:null,json:json$5},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$4=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],normalization=Object.freeze(Object.defineProperty({__proto__:null,json:json$4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$3=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],reduction=Object.freeze(Object.defineProperty({__proto__:null,json:json$3},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$2=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sliceJoin=Object.freeze(Object.defineProperty({__proto__:null,json:json$2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json$1=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],spectral=Object.freeze(Object.defineProperty({__proto__:null,json:json$1},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const json=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}],transformation=Object.freeze(Object.defineProperty({__proto__:null,json},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OperationMapper{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[arithmetic,basicMath,control,convolution,creation,dynamic,evaluation,logical,image,graph,matrices,normalization,reduction,sliceJoin,spectral,transformation,hashTable],i=[].concat(...e.map(s=>s.json));this.opMappers=i.reduce((s,o)=>(s[o.tfOpName]=o,s),{})}transformGraph(e,i={}){const s=e.node,o=[],c=[],d=[],h=s.reduce((et,nt)=>(et[nt.name]=this.mapNode(nt),nt.op.startsWith("Placeholder")?o.push(et[nt.name]):nt.op==="Const"?c.push(et[nt.name]):(nt.input==null||nt.input.length===0)&&d.push(et[nt.name]),et),{});let g=[];const _=[];let b={},$={};i!=null&&(b=this.mapSignatureEntries(i.inputs),$=this.mapSignatureEntries(i.outputs));const j=Object.keys(h);j.forEach(et=>{const nt=h[et];nt.inputNames.forEach(rt=>{const[it]=getNodeNameAndIndex(rt);nt.inputs.push(h[it]),h[it].children.push(nt)})}),Object.keys($).length===0?j.forEach(et=>{const nt=h[et];nt.children.length===0&&_.push(nt)}):Object.keys($).forEach(et=>{const[nt]=getNodeNameAndIndex(et),rt=h[nt];rt!=null&&(rt.signatureKey=$[et],_.push(rt))}),Object.keys(b).length>0?Object.keys(b).forEach(et=>{const[nt]=getNodeNameAndIndex(et),rt=h[nt];rt&&(rt.signatureKey=b[et],g.push(rt))}):g=o;let _e={};e.library!=null&&e.library.function!=null&&(_e=e.library.function.reduce((et,nt)=>(et[nt.signature.name]=this.mapFunction(nt),et),{}));const tt={nodes:h,inputs:g,outputs:_,weights:c,placeholders:o,signature:i,functions:_e};return d.length>0&&(tt.initNodes=d),tt}mapSignatureEntries(e){return Object.keys(e||{}).reduce((i,s)=>(i[e[s].name]=s,i),{})}mapNode(e){const i=getRegisteredOp(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:i.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.substr(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr};return i.inputs!=null&&(s.inputParams=i.inputs.reduce((o,c)=>(o[c.name]={type:c.type,inputIndexStart:c.start,inputIndexEnd:c.end},o),{})),i.attrs!=null&&(s.attrParams=i.attrs.reduce((o,c)=>{const d=c.type;let h;switch(c.type){case"string":h=getStringParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getStringParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"string[]":h=getStringArrayParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getStringArrayParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"number":h=getNumberParam(e.attr,c.tfName,c.defaultValue||0),h===void 0&&c.tfDeprecatedName&&(h=getNumberParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"number[]":h=getNumericArrayParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getNumericArrayParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"bool":h=getBoolParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getBoolParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"bool[]":h=getBoolArrayParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getBoolArrayParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"shape":h=getTensorShapeParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getTensorShapeParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"shape[]":h=getTensorShapeArrayParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getTensorShapeArrayParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"dtype":h=getDtypeParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getDtypeParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"dtype[]":h=getDtypeArrayParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getDtypeArrayParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"func":h=getFuncParam(e.attr,c.tfName,c.defaultValue),h===void 0&&c.tfDeprecatedName&&(h=getFuncParam(e.attr,c.tfDeprecatedName,c.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${c.type} for op: ${e.op}`)}return o[c.name]={value:h,type:d},o},{})),s}mapFunction(e){const i=e.nodeDef,s=[],o=[];let c={};i!=null&&(c=i.reduce(($,j)=>($[j.name]=this.mapNode(j),j.op==="Const"&&o.push($[j.name]),$),{}));const d=[],h=[];e.signature.inputArg.forEach($=>{const[j]=getNodeNameAndIndex($.name),_e={name:j,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:parseDtypeParam($.type),type:"dtype"}},children:[]};_e.signatureKey=$.name,d.push(_e),c[j]=_e}),Object.keys(c).forEach($=>{const j=c[$];j.inputNames.forEach(_e=>{const[tt]=getNodeNameAndIndex(_e);j.inputs.push(c[tt]),c[tt].children.push(j)})});const _=e.ret;e.signature.outputArg.forEach($=>{const[j,_e]=getNodeNameAndIndex(_[$.name]),tt=c[j];tt!=null&&(tt.defaultOutput=_e,h.push(tt))});const b=this.mapArgsToSignature(e);return{nodes:c,inputs:d,outputs:h,weights:o,placeholders:s,signature:b}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((i,s)=>(i[s.name]=this.mapArgToTensorInfo(s),i),{}),outputs:e.signature.outputArg.reduce((i,s)=>(i[s.name]=this.mapArgToTensorInfo(s,e.ret),i),{})}}mapArgToTensorInfo(e,i){let s=e.name;return i!=null&&(s=i[s]),{name:s,dtype:e.type}}}function decodeBase64$1(a){const e=env$1().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function parseStringParam(a,e){const i=Array.isArray(a)?String.fromCharCode.apply(null,a):decodeBase64$1(a);return e?i:i.toLowerCase()}function getStringParam(a,e,i,s=!1){const o=a[e];return o!=null?parseStringParam(o.s,s):i}function getBoolParam(a,e,i){const s=a[e];return s?s.b:i}function getNumberParam(a,e,i){const s=a[e]||{},o=s.i!=null?s.i:s.f!=null?s.f:i;return typeof o=="number"?o:parseInt(o,10)}function parseDtypeParam(a){switch(typeof a=="string"&&(a=DataType[a]),a){case DataType.DT_FLOAT:return"float32";case DataType.DT_INT32:case DataType.DT_INT64:case DataType.DT_INT8:case DataType.DT_UINT8:return"int32";case DataType.DT_BOOL:return"bool";case DataType.DT_DOUBLE:return"float32";case DataType.DT_STRING:return"string";default:return null}}function getFuncParam(a,e,i){const s=a[e];return s&&s.func?s.func.name:i}function getDtypeParam(a,e,i){const s=a[e];return s&&s.type?parseDtypeParam(s.type):i}function getDtypeArrayParam(a,e,i){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(o=>parseDtypeParam(o)):i}function parseTensorShapeParam(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function getTensorShapeParam(a,e,i){const s=a[e];return s&&s.shape?parseTensorShapeParam(s.shape):i}function getNumericArrayParam(a,e,i){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):i}function getStringArrayParam(a,e,i,s=!1){const o=a[e];return o&&o.list&&o.list.s?o.list.s.map(c=>parseStringParam(c,s)):i}function getTensorShapeArrayParam(a,e,i){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(o=>parseTensorShapeParam(o)):i}function getBoolArrayParam(a,e,i){const s=a[e];return s&&s.list&&s.list.b?s.list.b:i}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NodeValueImpl{constructor(e,i,s){this.node=e,this.tensorMap=i,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,c)=>(o[c]=this.getAttr(c),o),{}))}getInput(e){return getTensor(e,this.tensorMap,this.context)}getAttr(e,i){const s=this.node.rawAttrs[e];if(s.tensor!=null)return getTensor(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return getNumberParam(this.node.rawAttrs,e,i);if(s.s!=null)return getStringParam(this.node.rawAttrs,e,i);if(s.b!=null)return getBoolParam(this.node.rawAttrs,e,i);if(s.shape!=null)return getTensorShapeParam(this.node.rawAttrs,e,i);if(s.type!=null)return getDtypeParam(this.node.rawAttrs,e,i);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return getNumericArrayParam(this.node.rawAttrs,e,i);if(s.list.s!=null)return getStringArrayParam(this.node.rawAttrs,e,i);if(s.list.shape!=null)return getTensorShapeArrayParam(this.node.rawAttrs,e,i);if(s.list.b!=null)return getBoolArrayParam(this.node.rawAttrs,e,i);if(s.list.type!=null)return getDtypeArrayParam(this.node.rawAttrs,e,i)}return i}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$h=(a,e,i)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[add$4(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"AddN":return[addN$2(getParamValue("tensors",a,e,i))];case"FloorMod":case"Mod":return[mod$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Mul":return[mul$1(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"RealDiv":case"Div":return[div$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"DivNoNan":return[divNoNan(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"FloorDiv":return[floorDiv$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Sub":return[sub$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Minimum":return[minimum$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Maximum":return[maximum$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Pow":return[pow$4(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"SquaredDifference":return[squaredDifference$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$g=(a,e,i)=>{switch(a.op){case"Abs":case"ComplexAbs":return[abs$4(getParamValue("x",a,e,i))];case"Acos":return[acos$3(getParamValue("x",a,e,i))];case"Acosh":return[acosh$3(getParamValue("x",a,e,i))];case"Asin":return[asin$3(getParamValue("x",a,e,i))];case"Asinh":return[asinh$3(getParamValue("x",a,e,i))];case"Atan":return[atan$4(getParamValue("x",a,e,i))];case"Atan2":return[atan2$3(getParamValue("x",a,e,i),getParamValue("y",a,e,i))];case"Atanh":return[atanh$3(getParamValue("x",a,e,i))];case"Ceil":return[ceil$3(getParamValue("x",a,e,i))];case"Complex":return[complex$4(getParamValue("real",a,e,i),getParamValue("imag",a,e,i))];case"Cos":return[cos$4(getParamValue("x",a,e,i))];case"Cosh":return[cosh$3(getParamValue("x",a,e,i))];case"Elu":return[elu$4(getParamValue("x",a,e,i))];case"Erf":return[erf$2(getParamValue("x",a,e,i))];case"Exp":return[exp$3(getParamValue("x",a,e,i))];case"Expm1":return[expm1$2(getParamValue("x",a,e,i))];case"Floor":return[floor$3(getParamValue("x",a,e,i))];case"Log":return[log$4(getParamValue("x",a,e,i))];case"Log1p":return[log1p$2(getParamValue("x",a,e,i))];case"Imag":return[imag$2(getParamValue("x",a,e,i))];case"Neg":return[neg$2(getParamValue("x",a,e,i))];case"Reciprocal":return[reciprocal$2(getParamValue("x",a,e,i))];case"Real":return[real$2(getParamValue("x",a,e,i))];case"Relu":return[relu$2(getParamValue("x",a,e,i))];case"Round":return[round$3(getParamValue("x",a,e,i))];case"Selu":return[selu$2(getParamValue("x",a,e,i))];case"Sigmoid":return[sigmoid$2(getParamValue("x",a,e,i))];case"Sin":return[sin$4(getParamValue("x",a,e,i))];case"Sign":return[sign$5(getParamValue("x",a,e,i))];case"Sinh":return[sinh$3(getParamValue("x",a,e,i))];case"Softplus":return[softplus$2(getParamValue("x",a,e,i))];case"Sqrt":return[sqrt$4(getParamValue("x",a,e,i))];case"Square":return[square$2(getParamValue("x",a,e,i))];case"Tanh":return[tanh$3(getParamValue("x",a,e,i))];case"Tan":return[tan$3(getParamValue("x",a,e,i))];case"ClipByValue":return[clipByValue$1(getParamValue("x",a,e,i),getParamValue("clipValueMin",a,e,i),getParamValue("clipValueMax",a,e,i))];case"Relu6":return[relu6$2(getParamValue("x",a,e,i))];case"Rsqrt":return[rsqrt$2(getTensor(a.inputNames[0],e,i))];case"Prod":return[prod$2(getParamValue("x",a,e,i),getParamValue("axes",a,e,i))];case"LeakyRelu":return[leakyRelu$2(getParamValue("x",a,e,i),getParamValue("alpha",a,e,i))];case"Prelu":return[prelu$3(getParamValue("x",a,e,i),getParamValue("alpha",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertShapesMatchAllowUndefinedSize(a,e,i=""){if(!(typeof a=="number"||typeof e=="number")){assert$1(a.length===e.length,()=>i+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const o=a[s],c=e[s];assert$1(o<0||c<0||o===c,()=>i+` Shapes ${a} and ${e} must match`)}}}function fullDefinedShape(a){return!(typeof a=="number"||a.some(e=>e<0))}function inferElementShape(a,e,i){let s=mergeElementShape(a,i);const o=!fullDefinedShape(s);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(o&&e.forEach(c=>{s=mergeElementShape(c.shape,s)}),!fullDefinedShape(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function mergeElementShape(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const i=[];for(let s=0;s<a.length;++s){const o=a[s],c=e[s];if(o>=0&&c>=0&&o!==c)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);i[s]=o>=0?o:c}return i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TensorArray{constructor(e,i,s,o,c,d,h){this.name=e,this.dtype=i,this.maxSize=s,this.elementShape=o,this.identicalElementShapes=c,this.dynamicSize=d,this.clearAfterRead=h,this.tensors=[],this.closed_=!1,this.idTensor=scalar(0),keep(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(i=>{(e==null||!e.has(i.tensor.id))&&i.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const i=this.tensors[e];if(i.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(i.cleared=!0),i.read=!0,i.tensor}readMany(e){return e.map(i=>this.read(i))}write(e,i){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(i.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${i.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=i.shape),assertShapesMatchAllowUndefinedSize(this.elementShape,i.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=i,keep(i),s.written=!0,this.tensors[e]=s}writeMany(e,i){if(e.length!==i.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${i.length}.`);e.forEach((s,o)=>this.write(s,i[o]))}gather(e,i){if(i&&i!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${i}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return tensor([],[0].concat(this.elementShape));const s=this.readMany(e);return assertShapesMatchAllowUndefinedSize(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),stack(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return tensor([],[0].concat(this.elementShape));const i=[];for(let o=0;o<this.size();o++)i.push(o);const s=this.readMany(i);return assertShapesMatchAllowUndefinedSize(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),concat$3(s,0)}scatter(e,i){if(i.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${i.dtype}`);if(e.length!==i.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${i.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,unstack(i,0))}split(e,i){if(i.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${i.dtype}`);let s=0;const o=e.map(g=>(s+=g,s));if(s!==i.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${i.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const c=s===0?0:i.size/s,d=[];tidy(()=>{i=reshape$4(i,[1,s,c]);for(let g=0;g<e.length;++g){const b=[0,g===0?0:o[g-1],0],$=[1,e[g],c];d[g]=reshape$4(slice$2(i,b,$),this.elementShape)}return d});const h=[];for(let g=0;g<e.length;g++)h[g]=g;this.writeMany(h,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TensorList{constructor(e,i,s,o=-1){this.tensors=e,this.elementShape=i,this.elementDtype=s,e!=null&&e.forEach(c=>{if(s!==c.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${c.dtype}`);assertShapesMatchAllowUndefinedSize(i,c.shape,"TensorList shape mismatch: "),keep(c)}),this.idTensor=scalar(0),this.maxNumElements=o,keep(this.idTensor)}get id(){return this.idTensor.id}copy(){return new TensorList([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(i=>{(e==null||!e.has(i.id))&&i.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,i,s=-1){if(i!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);assertShapesMatchAllowUndefinedSize(e,this.elementShape,"TensorList shape mismatch: ");const o=inferElementShape(this.elementShape,this.tensors,e);return tidy(()=>{const c=this.tensors.map(d=>reshape$4(d,o));return stack(c,0)})}popBack(e,i){if(i!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=inferElementShape(this.elementShape,this.tensors,e),o=this.tensors.pop();return assertShapesMatchAllowUndefinedSize(o.shape,e,"TensorList shape mismatch: "),reshape$4(o,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(assertShapesMatchAllowUndefinedSize(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");keep(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,i,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);assertShapesMatchAllowUndefinedSize(this.tensors[e].shape,i,"TensorList shape mismatch: ");const o=inferElementShape(this.elementShape,this.tensors,i);return reshape$4(this.tensors[e],o)}setItem(e,i){if(i.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);assertShapesMatchAllowUndefinedSize(this.elementShape,i.shape,"TensorList shape mismatch: "),keep(i),this.tensors[e]=i}gather(e,i,s){if(i!==this.elementDtype)throw new Error(`Invalid data types; op elements ${i}, but list elements ${this.elementDtype}`);assertShapesMatchAllowUndefinedSize(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const o=inferElementShape(this.elementShape,this.tensors,s);return e.length===0?tensor([],[0].concat(o)):tidy(()=>{const c=e.map(d=>reshape$4(this.tensors[d],o));return stack(c,0)})}concat(e,i){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);assertShapesMatchAllowUndefinedSize(this.elementShape,i,"TensorList shape mismatch: ");const s=inferElementShape(this.elementShape,this.tensors,i);return this.size()===0?tensor([],[0].concat(s)):tidy(()=>{const o=this.tensors.map(c=>reshape$4(c,s));return concat$3(o,0)})}}function fromTensor(a,e,i){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==i)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${i}`);const o=a.shape.slice(1);assertShapesMatchAllowUndefinedSize(o,e,"TensorList shape mismatch: ");const c=unstack(a);return new TensorList(c,e,s)}function reserve(a,e,i){return new TensorList([],a,e,i)}function scatter(a,e,i,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const o=Math.max(...e);if(s!=null&&s!==-1&&o>=s)throw new Error(`Max index must be < array size (${o}  vs. ${s})`);const c=new TensorList([],i,a.dtype,s),d=unstack(a,0);return e.forEach((h,g)=>{c.setItem(h,d[g])}),c}function split(a,e,i){let s=0;const o=e.map(b=>(s+=b,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const c=a.shape.slice(1),d=mergeElementShape(c,i),h=s===0?0:a.size/s,g=tidy(()=>{const b=[];a=reshape$4(a,[1,s,h]);for(let $=0;$<e.length;++$){const _e=[0,$===0?0:o[$-1],0],tt=[1,e[$],h];b[$]=reshape$4(slice$2(a,_e,tt),d)}return a.dispose(),b}),_=new TensorList([],i,a.dtype,e.length);for(let b=0;b<g.length;b++)_.setItem(b,g[b]);return _}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$f=async(a,e,i)=>{switch(a.op){case"If":case"StatelessIf":{const s=getParamValue("thenBranch",a,e,i),o=getParamValue("elseBranch",a,e,i),c=getParamValue("cond",a,e,i),d=getParamValue("args",a,e,i);return(await c.data())[0]?i.functionMap[s].executeFunctionAsync(d,i.tensorArrayMap,i.tensorListMap):i.functionMap[o].executeFunctionAsync(d,i.tensorArrayMap,i.tensorListMap)}case"While":case"StatelessWhile":{const s=getParamValue("body",a,e,i),o=getParamValue("cond",a,e,i),c=getParamValue("args",a,e,i),d=await i.functionMap[o].executeFunctionAsync(c,i.tensorArrayMap,i.tensorListMap),h=c.map(b=>b.id);let g=await d[0].data();d.forEach(b=>{!b.kept&&h.indexOf(b.id)===-1&&b.dispose()});let _=c;for(;g[0];){const b=_;_=await i.functionMap[s].executeFunctionAsync(_,i.tensorArrayMap,i.tensorListMap);const $=_.map(_e=>_e.id);b.forEach(_e=>{!_e.kept&&h.indexOf(_e.id)===-1&&$.indexOf(_e.id)===-1&&_e.dispose()});const j=await i.functionMap[o].executeFunctionAsync(_,i.tensorArrayMap,i.tensorListMap);g=await j[0].data(),j.forEach(_e=>{!_e.kept&&h.indexOf(_e.id)===-1&&$.indexOf(_e.id)===-1&&_e.dispose()})}return _}case"LoopCond":{const s=getParamValue("pred",a,e,i);return[cloneTensor(s)]}case"Switch":{const s=getParamValue("pred",a,e,i);let o=getParamValue("data",a,e,i);return o.kept||(o=cloneTensor(o)),(await s.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{const s=a.inputNames.find(o=>getTensor(o,e,i)!==void 0);if(s){const o=getTensor(s,e,i);return[cloneTensor(o)]}return}case"Enter":{const s=getParamValue("frameName",a,e,i),o=getParamValue("tensor",a,e,i);return i.enterFrame(s),[cloneTensor(o)]}case"Exit":{const s=getParamValue("tensor",a,e,i);return i.exitFrame(),[cloneTensor(s)]}case"NextIteration":{const s=getParamValue("tensor",a,e,i);return i.nextIteration(),[cloneTensor(s)]}case"TensorArrayV3":{const s=getParamValue("size",a,e,i),o=getParamValue("dtype",a,e,i),c=getParamValue("elementShape",a,e,i),d=getParamValue("dynamicSize",a,e,i),h=getParamValue("clearAfterRead",a,e,i),g=getParamValue("identicalElementShapes",a,e,i),_=getParamValue("name",a,e,i),b=new TensorArray(_,o,s,c,g,d,h);return i.addTensorArray(b),[b.idTensor,scalar(1)]}case"TensorArrayWriteV3":{const s=getParamValue("tensorArrayId",a,e,i),o=getParamValue("index",a,e,i),c=getParamValue("tensor",a,e,i),d=i.getTensorArray(s.id);return d.write(o,c),[d.idTensor]}case"TensorArrayReadV3":{const s=getParamValue("tensorArrayId",a,e,i),o=getParamValue("index",a,e,i);return[i.getTensorArray(s.id).read(o)]}case"TensorArrayGatherV3":{const s=getParamValue("tensorArrayId",a,e,i),o=getParamValue("indices",a,e,i),c=getParamValue("dtype",a,e,i);return[i.getTensorArray(s.id).gather(o,c)]}case"TensorArrayScatterV3":{const s=getParamValue("tensorArrayId",a,e,i),o=getParamValue("indices",a,e,i),c=getParamValue("tensor",a,e,i),d=i.getTensorArray(s.id);return d.scatter(o,c),[d.idTensor]}case"TensorArrayConcatV3":{const s=getParamValue("tensorArrayId",a,e,i),o=i.getTensorArray(s.id),c=getParamValue("dtype",a,e,i);return[o.concat(c)]}case"TensorArraySplitV3":{const s=getParamValue("tensorArrayId",a,e,i),o=getParamValue("tensor",a,e,i),c=getParamValue("lengths",a,e,i),d=i.getTensorArray(s.id);return d.split(c,o),[d.idTensor]}case"TensorArraySizeV3":{const s=getParamValue("tensorArrayId",a,e,i),o=i.getTensorArray(s.id);return[scalar(o.size(),"int32")]}case"TensorArrayCloseV3":{const s=getParamValue("tensorArrayId",a,e,i),o=i.getTensorArray(s.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{const s=getParamValue("tensorListId",a,e,i),o=getParamValue("index",a,e,i),c=getParamValue("tensor",a,e,i),d=i.getTensorList(s.id);return d.setItem(o,c),[d.idTensor]}case"TensorListGetItem":{const s=getParamValue("tensorListId",a,e,i),o=getParamValue("index",a,e,i),c=getParamValue("elementShape",a,e,i),d=getParamValue("elementDType",a,e,i);return[i.getTensorList(s.id).getItem(o,c,d)]}case"TensorListScatterV2":case"TensorListScatter":{const s=getParamValue("indices",a,e,i),o=getParamValue("tensor",a,e,i),c=getParamValue("elementShape",a,e,i),d=getParamValue("numElements",a,e,i),h=scatter(o,s,c,d);return i.addTensorList(h),[h.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=getParamValue("elementShape",a,e,i),o=getParamValue("elementDType",a,e,i);let c;a.op==="TensorListReserve"?c="numElements":c="maxNumElements";const d=getParamValue(c,a,e,i),h=reserve(s,o,d);return i.addTensorList(h),[h.idTensor]}case"TensorListGather":{const s=getParamValue("tensorListId",a,e,i),o=getParamValue("indices",a,e,i),c=getParamValue("elementShape",a,e,i),d=getParamValue("elementDType",a,e,i);return[i.getTensorList(s.id).gather(o,d,c)]}case"TensorListStack":{const s=getParamValue("tensorListId",a,e,i),o=getParamValue("elementShape",a,e,i),c=getParamValue("elementDType",a,e,i),d=getParamValue("numElements",a,e,i);return[i.getTensorList(s.id).stack(o,c,d)]}case"TensorListFromTensor":{const s=getParamValue("tensor",a,e,i),o=getParamValue("elementShape",a,e,i),c=getParamValue("elementDType",a,e,i),d=fromTensor(s,o,c);return i.addTensorList(d),[d.idTensor]}case"TensorListConcat":{const s=getParamValue("tensorListId",a,e,i),o=i.getTensorList(s.id),c=getParamValue("dtype",a,e,i),d=getParamValue("elementShape",a,e,i);return[o.concat(c,d)]}case"TensorListPushBack":{const s=getParamValue("tensorListId",a,e,i),o=getParamValue("tensor",a,e,i),c=i.getTensorList(s.id);return c.pushBack(o),[c.idTensor]}case"TensorListPopBack":{const s=getParamValue("tensorListId",a,e,i),o=getParamValue("elementShape",a,e,i),c=getParamValue("elementDType",a,e,i);return[i.getTensorList(s.id).popBack(o,c)]}case"TensorListSplit":{const s=getParamValue("tensor",a,e,i),o=getParamValue("elementShape",a,e,i),c=getParamValue("lengths",a,e,i),d=split(s,c,o);return i.addTensorList(d),[d.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConvAndDepthWiseParams(a,e,i){const[s,o]=getParamValue("fusedOps",a,e,i),c=s==="biasadd",d=o==="prelu",h=s==="fusedbatchnorm",g=getParamValue("numArgs",a,e,i);if(c){if(d&&g!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!d&&g!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(h)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const _=getParamValue("strides",a,e,i),b=getPadding(a,e,i),$=getParamValue("dataFormat",a,e,i).toUpperCase(),j=getParamValue("dilations",a,e,i),[_e,tt]=getParamValue("args",a,e,i),et=getParamValue("leakyreluAlpha",a,e,i);return{stride:_,pad:b,dataFormat:$,dilations:j,biasArg:_e,preluArg:tt,activationFunc:o,leakyreluAlpha:et}}const executeOp$e=(a,e,i)=>{switch(a.op){case"Conv1D":{const s=getParamValue("stride",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("dataFormat",a,e,i).toUpperCase(),d=getParamValue("dilation",a,e,i);return[conv1d$1(getParamValue("x",a,e,i),getParamValue("filter",a,e,i),s,o,c,d)]}case"Conv2D":{const s=getParamValue("strides",a,e,i),o=getPadding(a,e,i),c=getParamValue("dataFormat",a,e,i).toUpperCase(),d=getParamValue("dilations",a,e,i);return[conv2d$3(getParamValue("x",a,e,i),getParamValue("filter",a,e,i),[s[1],s[2]],o,c,[d[1],d[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:c,dilations:d,biasArg:h,preluArg:g,activationFunc:_,leakyreluAlpha:b}=fusedConvAndDepthWiseParams(a,e,i);return[conv2d$2({x:getParamValue("x",a,e,i),filter:getParamValue("filter",a,e,i),strides:[s[1],s[2]],pad:o,dataFormat:c,dilations:[d[1],d[2]],bias:h,activation:_,preluActivationWeights:g,leakyreluAlpha:b})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:c,dilations:d,biasArg:h,preluArg:g,activationFunc:_,leakyreluAlpha:b}=fusedConvAndDepthWiseParams(a,e,i);return[depthwiseConv2d$2({x:getParamValue("x",a,e,i),filter:getParamValue("filter",a,e,i),strides:[s[1],s[2]],pad:o,dataFormat:c,dilations:[d[1],d[2]],bias:h,activation:_,preluActivationWeights:g,leakyreluAlpha:b})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=getParamValue("outputShape",a,e,i),o=getParamValue("strides",a,e,i),c=getPadding(a,e,i);return[conv2dTranspose$1(getParamValue("x",a,e,i),getParamValue("filter",a,e,i),s,[o[1],o[2]],c)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=getParamValue("strides",a,e,i),o=getPadding(a,e,i),c=getParamValue("dilations",a,e,i),d=getParamValue("dataFormat",a,e,i).toUpperCase();return[depthwiseConv2d$3(getParamValue("input",a,e,i),getParamValue("filter",a,e,i),[s[1],s[2]],o,d,[c[1],c[2]])]}case"Conv3D":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("dataFormat",a,e,i).toUpperCase(),d=getParamValue("dilations",a,e,i);return[conv3d$1(getParamValue("x",a,e,i),getParamValue("filter",a,e,i),[s[1],s[2],s[3]],o,c,[d[1],d[2],d[3]])]}case"AvgPool":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("kernelSize",a,e,i);return[avgPool$2(getParamValue("x",a,e,i),[c[1],c[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("kernelSize",a,e,i);return[maxPool$2(getParamValue("x",a,e,i),[c[1],c[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("kernelSize",a,e,i),d=getParamValue("includeBatchInIndex",a,e,i),{result:h,indexes:g}=maxPoolWithArgmax(getParamValue("x",a,e,i),[c[1],c[2]],[s[1],s[2]],o,d);return[h,g]}case"AvgPool3D":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("kernelSize",a,e,i);return[avgPool3d$1(getParamValue("x",a,e,i),[c[1],c[2],c[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("kernelSize",a,e,i);return[maxPool3d$1(getParamValue("x",a,e,i),[c[1],c[2],c[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=getParamValue("strides",a,e,i),o=getParamValue("pad",a,e,i),c=getParamValue("dilations",a,e,i),d=s[1],h=s[2],g=c[1],_=c[2];return[dilation2d(getParamValue("x",a,e,i),getParamValue("filter",a,e,i),[d,h],o,[g,_],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$d=(a,e,i)=>{switch(a.op){case"Fill":{const s=getParamValue("shape",a,e,i),o=getParamValue("dtype",a,e,i),c=getParamValue("value",a,e,i);return[fill$2(s,c,o)]}case"LinSpace":{const s=getParamValue("start",a,e,i),o=getParamValue("stop",a,e,i),c=getParamValue("num",a,e,i);return[linspace(s,o,c)]}case"Multinomial":{const s=getParamValue("logits",a,e,i),o=getParamValue("numSamples",a,e,i),c=getParamValue("seed",a,e,i);return[multinomial$2(s,o,c)]}case"OneHot":{const s=getParamValue("indices",a,e,i),o=getParamValue("depth",a,e,i),c=getParamValue("onValue",a,e,i),d=getParamValue("offValue",a,e,i);return[oneHot$2(s,o,c,d)]}case"Ones":return[ones$1(getParamValue("shape",a,e,i),getParamValue("dtype",a,e,i))];case"OnesLike":return[onesLike$2(getParamValue("x",a,e,i))];case"RandomUniform":return[randomUniform$1(getParamValue("shape",a,e,i),getParamValue("minval",a,e,i),getParamValue("maxval",a,e,i),getParamValue("dtype",a,e,i))];case"Range":{const s=getParamValue("start",a,e,i),o=getParamValue("stop",a,e,i),c=getParamValue("step",a,e,i);return[range$4(s,o,c,getParamValue("dtype",a,e,i))]}case"TruncatedNormal":{const s=getParamValue("shape",a,e,i),o=getParamValue("mean",a,e,i),c=getParamValue("stdDev",a,e,i),d=getParamValue("seed",a,e,i);return[truncatedNormal$1(s,o,c,getParamValue("dtype",a,e,i),d)]}case"Zeros":return[zeros$4(getParamValue("shape",a,e,i),getParamValue("dtype",a,e,i))];case"ZerosLike":return[zerosLike$2(getParamValue("x",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nmsParams(a,e,i){const s=getParamValue("boxes",a,e,i),o=getParamValue("scores",a,e,i),c=getParamValue("maxOutputSize",a,e,i),d=getParamValue("iouThreshold",a,e,i),h=getParamValue("scoreThreshold",a,e,i),g=getParamValue("softNmsSigma",a,e,i);return{boxes:s,scores:o,maxOutputSize:c,iouThreshold:d,scoreThreshold:h,softNmsSigma:g}}const executeOp$c=async(a,e,i)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:c,iouThreshold:d,scoreThreshold:h,softNmsSigma:g}=nmsParams(a,e,i),_=await image$1.nonMaxSuppressionWithScoreAsync(s,o,c,d,h,g);return[_.selectedIndices,_.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:c,iouThreshold:d,scoreThreshold:h}=nmsParams(a,e,i),g=getParamValue("padToMaxOutputSize",a,e,i),_=await image$1.nonMaxSuppressionPaddedAsync(s,o,c,d,h,g);return[_.selectedIndices,_.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:c,iouThreshold:d,scoreThreshold:h}=nmsParams(a,e,i);return[await image$1.nonMaxSuppressionAsync(s,o,c,d,h)]}case"Where":{const s=cast$3(getParamValue("condition",a,e,i),"bool"),o=[await whereAsync(s)];return s.dispose(),o}case"ListDiff":return setdiff1dAsync(getParamValue("x",a,e,i),getParamValue("y",a,e,i));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$b=(a,e,i)=>{switch(a.op){case"TopKV2":{const s=getParamValue("x",a,e,i),o=getParamValue("k",a,e,i),c=getParamValue("sorted",a,e,i),d=topk(s,o,c);return[d.values,d.indices]}case"Unique":{const s=getParamValue("x",a,e,i),o=unique$3(s);return[o.values,o.indices]}case"UniqueV2":{const s=getParamValue("x",a,e,i),o=getParamValue("axis",a,e,i),c=unique$3(s,o);return[c.values,c.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$a=(a,e,i)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const s=getParamValue("default",a,e,i);return[getTensor(a.name,e,i)||s];case"Placeholder":return[getTensor(a.name,e,i)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const _=getParamValue("x",a,e,i);return[cloneTensor(_)]}case"IdentityN":return getParamValue("x",a,e,i).map(_=>cloneTensor(_));case"Snapshot":const o=getParamValue("x",a,e,i);return[cloneTensor(o)];case"Shape":return[tensor1d(getParamValue("x",a,e,i).shape,"int32")];case"ShapeN":return getParamValue("x",a,e,i).map(_=>tensor1d(_.shape));case"Size":return[scalar(getParamValue("x",a,e,i).size,"int32")];case"Rank":return[scalar(getParamValue("x",a,e,i).rank,"int32")];case"NoOp":return[scalar(1)];case"Print":const c=getParamValue("x",a,e,i),d=getParamValue("data",a,e,i),h=getParamValue("message",a,e,i),g=getParamValue("summarize",a,e,i);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(h);for(let _=0;_<d.length;_++)console.log(Array.prototype.slice.call(d[_].dataSync()).slice(0,g));return[c];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HashTable{constructor(e,i){this.keyDType=e,this.valueDType=i,this.handle=scalar(0),this.tensorMap=new Map,keep(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}async import(e,i){this.checkKeyAndValueTensor(e,i);const s=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),tidy(()=>{const o=unstack(i),c=s.length,d=o.length;assert$1(c===d,()=>`The number of elements doesn't match, keys has ${c} elements, the values has ${d} elements.`);for(let h=0;h<c;h++){const g=s[h],_=o[h];keep(_),this.tensorMap.set(g,_)}return this.handle})}async find(e,i){this.checkKeyAndValueTensor(e,i);const s=await e.data();return tidy(()=>{const o=[];for(let c=0;c<s.length;c++){const d=s[c],h=this.findWithDefault(d,i);o.push(h)}return stack(o)})}findWithDefault(e,i){const s=this.tensorMap.get(e);return s??i}checkKeyAndValueTensor(e,i){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(i.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${i.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$9=async(a,e,i,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const o=getParamValue("keyDType",a,e,i),c=getParamValue("valueDType",a,e,i),d=new HashTable(o,c);return s.addHashTable(a.name,d),[d.handle]}case"LookupTableImport":case"LookupTableImportV2":{const o=getParamValue("tableHandle",a,e,i,s),c=getParamValue("keys",a,e,i),d=getParamValue("values",a,e,i);return[await s.getHashTableById(o.id).import(c,d)]}case"LookupTableFind":case"LookupTableFindV2":{const o=getParamValue("tableHandle",a,e,i,s),c=getParamValue("keys",a,e,i),d=getParamValue("defaultValue",a,e,i);return[await s.getHashTableById(o.id).find(c,d)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$8=(a,e,i)=>{switch(a.op){case"ResizeBilinear":{const s=getParamValue("images",a,e,i),o=getParamValue("size",a,e,i),c=getParamValue("alignCorners",a,e,i),d=getParamValue("halfPixelCenters",a,e,i);return[image$1.resizeBilinear(s,[o[0],o[1]],c,d)]}case"ResizeNearestNeighbor":{const s=getParamValue("images",a,e,i),o=getParamValue("size",a,e,i),c=getParamValue("alignCorners",a,e,i),d=getParamValue("halfPixelCenters",a,e,i);return[image$1.resizeNearestNeighbor(s,[o[0],o[1]],c,d)]}case"CropAndResize":{const s=getParamValue("image",a,e,i),o=getParamValue("boxes",a,e,i),c=getParamValue("boxInd",a,e,i),d=getParamValue("cropSize",a,e,i),h=getParamValue("method",a,e,i),g=getParamValue("extrapolationValue",a,e,i);return[image$1.cropAndResize(s,o,c,d,h,g)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$7=(a,e,i)=>{switch(a.op){case"Equal":return[equal$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"NotEqual":return[notEqual$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Greater":return[greater$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"GreaterEqual":return[greaterEqual$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Less":return[less$3(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"LessEqual":return[lessEqual$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"LogicalAnd":return[logicalAnd$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"LogicalNot":return[logicalNot$2(getParamValue("a",a,e,i))];case"LogicalOr":return[logicalOr$2(getParamValue("a",a,e,i),getParamValue("b",a,e,i))];case"Select":case"SelectV2":return[where(getParamValue("condition",a,e,i),getParamValue("a",a,e,i),getParamValue("b",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$6=(a,e,i)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[matMul$1(getParamValue("a",a,e,i),getParamValue("b",a,e,i),getParamValue("transposeA",a,e,i),getParamValue("transposeB",a,e,i))];case"Transpose":return[transpose$3(getParamValue("x",a,e,i),getParamValue("perm",a,e,i))];case"_FusedMatMul":const[s,o]=getParamValue("fusedOps",a,e,i),c=s==="biasadd",d=o==="prelu",h=getParamValue("numArgs",a,e,i),g=getParamValue("leakyreluAlpha",a,e,i);if(c){if(d&&h!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!d&&h!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[_,b]=getParamValue("args",a,e,i);return[matMul({a:getParamValue("a",a,e,i),b:getParamValue("b",a,e,i),transposeA:getParamValue("transposeA",a,e,i),transposeB:getParamValue("transposeB",a,e,i),bias:_,activation:o,preluActivationWeights:b,leakyreluAlpha:g})];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$5=(a,e,i)=>{switch(a.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[batchNorm$2(getParamValue("x",a,e,i),getParamValue("mean",a,e,i),getParamValue("variance",a,e,i),getParamValue("offset",a,e,i),getParamValue("scale",a,e,i),getParamValue("epsilon",a,e,i))];case"FusedBatchNormV3":return[batchNorm$2(getParamValue("x",a,e,i),getParamValue("mean",a,e,i),getParamValue("variance",a,e,i),getParamValue("offset",a,e,i),getParamValue("scale",a,e,i),getParamValue("epsilon",a,e,i))];case"LRN":return[localResponseNormalization(getParamValue("x",a,e,i),getParamValue("radius",a,e,i),getParamValue("bias",a,e,i),getParamValue("alpha",a,e,i),getParamValue("beta",a,e,i))];case"Softmax":return[softmax$3(getParamValue("x",a,e,i))];case"LogSoftmax":return[logSoftmax(getParamValue("x",a,e,i))];case"SparseToDense":return[sparseToDense$2(getParamValue("sparseIndices",a,e,i),getParamValue("outputShape",a,e,i),getParamValue("sparseValues",a,e,i),getParamValue("defaultValue",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$4=(a,e,i)=>{switch(a.op){case"Max":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[max$4(getParamValue("x",a,e,i),d,h)]}case"Mean":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[mean$1(getParamValue("x",a,e,i),d,h)]}case"Min":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[min$4(getParamValue("x",a,e,i),d,h)]}case"Sum":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[sum$3(getParamValue("x",a,e,i),d,h)]}case"All":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[all$2(getParamValue("x",a,e,i),d,h)]}case"Any":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[any$2(getParamValue("x",a,e,i),d,h)]}case"ArgMax":{const d=getParamValue("axis",a,e,i);return[argMax$2(getParamValue("x",a,e,i),d)]}case"ArgMin":{const d=getParamValue("axis",a,e,i);return[argMin$2(getParamValue("x",a,e,i),d)]}case"Prod":{const d=getParamValue("axis",a,e,i),h=getParamValue("keepDims",a,e,i);return[prod$2(getParamValue("x",a,e,i),d,h)]}case"Cumsum":{const d=getParamValue("axis",a,e,i),h=getParamValue("exclusive",a,e,i),g=getParamValue("reverse",a,e,i);return[cumsum$2(getParamValue("x",a,e,i),d,h,g)]}case"Bincount":const s=getParamValue("x",a,e,i),o=getParamValue("weights",a,e,i),c=getParamValue("size",a,e,i);return[bincount$2(s,o,c)];case"DenseBincount":{const d=getParamValue("x",a,e,i),h=getParamValue("weights",a,e,i),g=getParamValue("size",a,e,i),_=getParamValue("binaryOutput",a,e,i);return[denseBincount$2(d,h,g,_)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$3=(a,e,i)=>{switch(a.op){case"ConcatV2":case"Concat":{const s=getParamValue("n",a,e,i),o=getParamValue("axis",a,e,i);let c=getParamValue("tensors",a,e,i);return c=c.slice(0,s),[concat$3(c,o)]}case"Gather":{const s=getParamValue("x",a,e,i),o=getParamValue("indices",a,e,i);return[gather$1(s,cast$3(o,"int32"),0)]}case"GatherV2":{const s=getParamValue("axis",a,e,i),o=getParamValue("batchDims",a,e,i),c=getParamValue("x",a,e,i),d=getParamValue("indices",a,e,i);return[gather$1(c,cast$3(d,"int32"),s,o)]}case"Reverse":{const s=getParamValue("dims",a,e,i),o=[];for(let d=0;d<s.length;d++)s[d]&&o.push(d);const c=getParamValue("x",a,e,i);return[reverse$2(c,o)]}case"ReverseV2":{const s=getParamValue("axis",a,e,i),o=getParamValue("x",a,e,i);return[reverse$2(o,s)]}case"Slice":{const s=getParamValue("begin",a,e,i),o=getParamValue("size",a,e,i);return[slice$2(getParamValue("x",a,e,i),s,o)]}case"StridedSlice":{const s=getParamValue("begin",a,e,i),o=getParamValue("end",a,e,i),c=getParamValue("strides",a,e,i),d=getParamValue("beginMask",a,e,i),h=getParamValue("endMask",a,e,i),g=getParamValue("ellipsisMask",a,e,i),_=getParamValue("newAxisMask",a,e,i),b=getParamValue("shrinkAxisMask",a,e,i),$=getParamValue("x",a,e,i);return[stridedSlice$2($,s,o,c,d,h,g,_,b)]}case"Pack":return tidy(()=>{const s=getParamValue("axis",a,e,i),o=getParamValue("tensors",a,e,i),c=o[0].shape,d=squeeze$1(o[0]).shape,h=o.map(g=>{const _=arraysEqual(g.shape,c);if(!_&&!arraysEqual(squeeze$1(g).shape,d))throw new Error("the input tensors shape does not match");return _?g:reshape$4(g,c)});return[stack(h,s)]});case"Unpack":{const s=getParamValue("axis",a,e,i),o=getParamValue("tensor",a,e,i);return unstack(o,s)}case"Tile":{const s=getParamValue("reps",a,e,i);return[tile$3(getParamValue("x",a,e,i),s)]}case"Split":case"SplitV":{const s=getParamValue("axis",a,e,i),o=getParamValue("numOrSizeSplits",a,e,i),c=getParamValue("x",a,e,i);return split$1(c,o,s)}case"ScatterNd":{const s=getParamValue("indices",a,e,i),o=getParamValue("values",a,e,i),c=getParamValue("shape",a,e,i);return[scatterND(s,o,c)]}case"GatherNd":{const s=getParamValue("x",a,e,i),o=getParamValue("indices",a,e,i);return[gatherND(s,o)]}case"SparseToDense":{const s=getParamValue("sparseIndices",a,e,i),o=getParamValue("outputShape",a,e,i),c=getParamValue("sparseValues",a,e,i),d=getParamValue("defaultValue",a,e,i);return[sparseToDense$2(s,c,o,c.dtype===d.dtype?d:cast$3(d,c.dtype))]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$2=(a,e,i)=>{switch(a.op){case"FFT":return[fft$2(getParamValue("x",a,e,i))];case"IFFT":return[ifft$2(getParamValue("x",a,e,i))];case"RFFT":return[rfft(getParamValue("x",a,e,i))];case"IRFFT":return[irfft(getParamValue("x",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const executeOp$1=(a,e,i)=>{switch(a.op){case"Cast":return[cast$3(getParamValue("x",a,e,i),getParamValue("dtype",a,e,i))];case"ExpandDims":{const s=getParamValue("axis",a,e,i);return[expandDims$3(getParamValue("x",a,e,i),s)]}case"Squeeze":{const s=getParamValue("axis",a,e,i);return[squeeze$1(getParamValue("x",a,e,i),s)]}case"Reshape":return[reshape$4(getParamValue("x",a,e,i),getParamValue("shape",a,e,i))];case"MirrorPad":return[mirrorPad$1(getParamValue("x",a,e,i),getParamValue("padding",a,e,i),getParamValue("mode",a,e,i))];case"PadV2":case"Pad":return[pad(getParamValue("x",a,e,i),getParamValue("padding",a,e,i),getParamValue("constantValue",a,e,i))];case"SpaceToBatchND":{const s=getParamValue("blockShape",a,e,i),o=getParamValue("paddings",a,e,i);return[spaceToBatchND$2(getParamValue("x",a,e,i),s,o)]}case"BatchToSpaceND":{const s=getParamValue("blockShape",a,e,i),o=getParamValue("crops",a,e,i);return[batchToSpaceND$2(getParamValue("x",a,e,i),s,o)]}case"DepthToSpace":{const s=getParamValue("blockSize",a,e,i),o=getParamValue("dataFormat",a,e,i).toUpperCase();return[depthToSpace$2(getParamValue("x",a,e,i),s,o)]}case"BroadcastTo":return[broadcastTo(getParamValue("x",a,e,i),getParamValue("shape",a,e,i))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function executeOp(a,e,i,s){const o=((c,d,h)=>{switch(c.category){case"arithmetic":return tidy(()=>executeOp$h(c,d,h));case"basic_math":return tidy(()=>executeOp$g(c,d,h));case"control":return executeOp$f(c,d,h);case"convolution":return tidy(()=>executeOp$e(c,d,h));case"creation":return tidy(()=>executeOp$d(c,d,h));case"dynamic":return executeOp$c(c,d,h);case"evaluation":return tidy(()=>executeOp$b(c,d,h));case"image":return tidy(()=>executeOp$8(c,d,h));case"graph":return tidy(()=>executeOp$a(c,d,h));case"logical":return tidy(()=>executeOp$7(c,d,h));case"matrices":return tidy(()=>executeOp$6(c,d,h));case"normalization":return tidy(()=>executeOp$5(c,d,h));case"reduction":return tidy(()=>executeOp$4(c,d,h));case"slice_join":return tidy(()=>executeOp$3(c,d,h));case"spectral":return tidy(()=>executeOp$2(c,d,h));case"transformation":return tidy(()=>executeOp$1(c,d,h));case"hash_table":return executeOp$9(c,d,h,s);case"custom":const g=getRegisteredOp(c.op);if(g&&g.customExecutor)return g.customExecutor(new NodeValueImpl(c,d,h));throw TypeError(`Custom op ${c.op} is not registered.`);default:throw TypeError(`Unknown op '${c.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,i);return isPromise(o)?o.then(c=>[].concat(c)):[].concat(o)}class ExecutionContext{constructor(e={},i={},s={},o={}){this.weightMap=e,this.tensorArrayMap=i,this.tensorListMap=s,this.functionMap=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,i){return{id:e,frameName:i,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let i=0;i<this.contexts.length-1;i++){const s=this.contexts.slice(0,this.contexts.length-i);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(i=>i.id===0&&i.iterationId===0?"":`${i.frameName}-${i.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const i in this.tensorArrayMap)this.tensorArrayMap[i].clearAndClose(e);for(const i in this.tensorListMap)this.tensorListMap[i].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getExecutionSubgraph(a,e,i,s){const o=new Set,c=[];let d=null,h=null;const g=new Set,_=Object.keys(a).map(j=>parseNodeName(j)[0]);let b=[];s!=null&&(b=s.map(j=>parseNodeName(j.name)[0]));const $=[...e];for(;$.length>0;){const j=$.pop();if((isControlFlow(j)||isDynamicShape(j)||isHashTable(j))&&d==null&&(d=j,h=d.children.map(_e=>_e.name).filter(_e=>o.has(_e))),o.add(j.name),i[j.name]==null&&_.indexOf(j.name)===-1&&b.indexOf(j.name)===-1){if(j.inputs.length===0){c.push(j.name);continue}j.inputs.forEach(_e=>{g.has(_e.name)||(g.add(_e.name),$.push(_e))})}}return{inputs:a,outputs:e,usedNodes:o,missingInputs:c,dynamicNode:d,syncInputs:h}}function getNodesInTopologicalOrder(a,e,i){const{usedNodes:s,inputs:o}=i,c=[],d=Object.keys(o).map(b=>parseNodeName(b)[0]).map(b=>a.nodes[b]),h=a.initNodes;d.forEach(b=>{s.has(b.name)&&c.push(b)}),a.weights.forEach(b=>{s.has(b.name)&&c.push(b)}),h!=null&&h.forEach(b=>{s.has(b.name)&&c.push(b)});const g=new Set,_=[];for(;c.length>0;){const b=c.pop();g.add(b.name),e[b.name]||_.push(b),b.children.forEach($=>{!g.has($.name)&&s.has($.name)&&$.inputs.every(j=>g.has(j.name))&&c.push($)})}return _}const CONTROL_FLOW_OPS=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],DYNAMIC_SHAPE_OPS=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],HASH_TABLE_OPS=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2"];function isControlFlow(a){return CONTROL_FLOW_OPS.indexOf(a.op)>=0}function isDynamicShape(a){return DYNAMIC_SHAPE_OPS.indexOf(a.op)>=0}function isHashTable(a){return HASH_TABLE_OPS.indexOf(a.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GraphExecutor{constructor(e,i){this.graph=e,this.parent=i,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new GraphExecutor(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const i=Object.keys(e).map(s=>e[s].map(o=>o.id));this._weightIds=[].concat(...i),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const i=e.signatureKey||e.name;return e.defaultOutput?`${i}:${e.defaultOutput}`:i})}get functions(){return Object.keys(this._functions).reduce((e,i)=>(e[i]=this._functions[i].signature,e),{})}getCompilationKey(e,i){const s=e.map(c=>c.name).sort(),o=i.map(c=>c.name).sort();return s.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,i){const s=getExecutionSubgraph(e,i,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:c,syncInputs:d}=s;if(c!=null)throw new Error(`This execution contains the node '${c.name}', which has the dynamic op '${c.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${d}]`);if(o.length>0){const h=i.map(_=>_.name),g=Object.keys(e);throw new Error(`Cannot compute the outputs [${h}] from the provided inputs [${g}]. Missing the following inputs: [${o}]`)}return getNodesInTopologicalOrder(this.graph,this.weightMap,s)}execute(e,i){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),i=this.mapOutputs(i),this.checkOutputs(i);const o=s.map($=>this.graph.nodes[parseNodeName($)[0]]),c=i.map($=>parseNodeName($)[0]);let d=c.map($=>this.graph.nodes[$]);d.length===0&&(d=this._outputs);const h=this.getCompilationKey(o,d);let g=this.compiledMap.get(h);g==null&&(g=this.compile(e,d),this.compiledMap.set(h,g));const _={},b={};return tidy(()=>{const $=new ExecutionContext(this.weightMap,_,b,this.functionExecutorMap),j=Object.assign({},this.weightMap);Object.keys(e).forEach(et=>{const[nt,rt]=parseNodeName(et),it=[];it[rt]=e[et],j[nt]=it});const _e=this.getFrozenTensorIds(j),tt={};for(let et=0;et<g.length;et++){const nt=g[et];if(!j[nt.name]){const rt=executeOp(nt,j,$,this._resourceManager);if(isPromise(rt))throw new Error(`The execution of the op '${nt.op}' returned a promise. Please use model.executeAsync() instead.`);j[nt.name]=rt,this.checkTensorForDisposal(nt.name,nt,j,$,_e,c,tt)}}return this.parent==null&&$.dispose(_e),i.map(et=>getTensor(et,j,$))})}getFrozenTensorIds(e){const i=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(o=>o.id)));return new Set(i)}checkTensorForDisposal(e,i,s,o,c,d,h){i.category==="control"||d.indexOf(e)!==-1||(s[e].forEach(g=>{g!=null&&(h[g.id]=(h[g.id]||0)+i.children.length)}),i.inputs.forEach(g=>{if(g.category!=="control"){const _=getTensorsForCurrentContenxt(g.name,s,o);_!=null&&_.forEach(b=>{if(b&&!c.has(b.id)){const $=h[b.id];$===1?(b.dispose(),delete h[b.id]):$!=null&&h[b.id]--}})}}))}async executeAsync(e,i){return this._executeAsync(e,i)}async _executeAsync(e,i,s=!1,o={},c={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),i=this.mapOutputs(i),this.checkOutputs(i));const d=new ExecutionContext(this.weightMap,o,c,this.functionExecutorMap),h=await this.executeWithControlFlow(e,d,i,s),g=i.map(j=>getTensor(j,h,d)),_=g.map(j=>j.id),b=Object.keys(e).map(j=>e[j].id),$=new Set([..._,...b,...this.weightIds]);return Object.keys(h).forEach(j=>{h[j].forEach(tt=>{tt&&!tt.isDisposed&&!$.has(tt.id)&&tt.dispose()})}),this.parent==null&&d.dispose($),g}async executeFunctionAsync(e,i,s){const o=e.reduce((c,d,h)=>(c[this.inputs[h].name]=d,c),{});return this._executeAsync(o,this.outputNodes,!0,i,s)}async executeWithControlFlow(e,i,s,o){const c=Object.keys(e),d=c.map(at=>this.graph.nodes[parseNodeName(at)[0]]),h=s.map(at=>parseNodeName(at)[0]);let g=h.map(at=>this.graph.nodes[at]);g.length===0&&(g=this._outputs);const{usedNodes:_,missingInputs:b,dynamicNode:$,syncInputs:j}=getExecutionSubgraph(e,g,this.weightMap,this._initNodes),_e=[...d,...this.graph.weights,...this._initNodes||[]].map(at=>({node:at,contexts:i.currentContext})),tt=Object.assign({},this.weightMap);Object.keys(e).forEach(at=>{const[st,ot]=parseNodeName(at),ct=[];ct[ot]=e[at],tt[st]=ct});const et={},nt=this.getFrozenTensorIds(tt),rt={};for(;_e.length>0;){const at=this.processStack(d,_e,i,tt,rt,nt,h,et,_);await Promise.all(at)}$==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const it=g.filter(at=>!isControlFlow(at)&&!getTensor(at.name,tt,i)).map(at=>at.name);if(it.length>0){let at="";throw $!=null&&(at=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${j}]`),new Error(`Cannot compute the outputs [${it}] from the provided inputs [${c}]. Consider providing the following inputs: [${b}]. ${at}`)}return tt}processStack(e,i,s,o,c,d,h,g,_){const b=[];for(;i.length>0;){const $=i.pop();s.currentContext=$.contexts;let j="";if($.node.op==="Enter"&&getParamValue("isConstant",$.node,o,s)&&([j]=getNodeNameAndIndex($.node.name,s)),o[$.node.name]==null){const _e=executeOp($.node,o,s,this._resourceManager);j||([j]=getNodeNameAndIndex($.node.name,s));const tt=s.currentContext;isPromise(_e)?b.push(_e.then(et=>(o[j]=et,s.currentContext=tt,this.checkTensorForDisposal(j,$.node,o,s,d,h,g),this.processChildNodes($.node,i,s,o,c,_),et))):(o[j]=_e,this.checkTensorForDisposal(j,$.node,o,s,d,h,g),this.processChildNodes($.node,i,s,o,c,_))}else this.processChildNodes($.node,i,s,o,c,_)}return b}processChildNodes(e,i,s,o,c,d){e.children.forEach(h=>{const[g]=getNodeNameAndIndex(h.name,s);c[g]||!d.has(h.name)||(h.op==="Merge"?h.inputNames.some(_=>!!getTensor(_,o,s))&&(c[g]=!0,i.push({contexts:s.currentContext,node:h})):h.inputNames.every(_=>!!getTensor(_,o,s))&&(c[g]=!0,i.push({contexts:s.currentContext,node:h})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(i=>i.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(i=>{const s=e[i],[o]=parseNodeName(i),c=this.graph.nodes[o];if(c.attrParams.shape&&c.attrParams.shape.value){const d=c.attrParams.shape.value,h=d.length===s.shape.length&&s.shape.every((g,_)=>d[_]===-1||d[_]===g);assert$1(h,()=>`The shape of dict['${c.name}'] provided in model.execute(dict) must be [${d}], but was [${s.shape}]`)}c.attrParams.dtype&&c.attrParams.dtype.value&&assert$1(s.dtype===c.attrParams.dtype.value,()=>`The dtype of dict['${c.name}'] provided in model.execute(dict) must be ${c.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const i={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const o=this._signature.inputs[s];i[o.name]=e[s]}else i[s]=e[s];return i}checkInputs(e){const i=Object.keys(e).filter(s=>{const[o]=parseNodeName(s);return this.graph.nodes[o]==null});if(i.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${i}] that are not part of graph`)}mapOutputs(e){return e.map(i=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[i]!=null?this._signature.outputs[i].name:i,{})}checkOutputs(e){e.forEach(i=>{const[s]=parseNodeName(i);if(!this.graph.nodes[s])throw new Error(`The output '${i}' is not found in the graph`)})}}class ResourceManager{constructor(e={},i={}){this.hashTableNameToHandle=e,this.hashTableMap=i}addHashTable(e,i){this.hashTableNameToHandle[e]=i.handle,this.hashTableMap[i.id]=i}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TFHUB_SEARCH_PARAM="?tfjs-format=file",DEFAULT_MODEL_NAME="model.json";class GraphModel{constructor(e,i={}){this.modelUrl=e,this.loadOptions=i,this.version="n/a",i==null&&(this.loadOptions={}),this.resourceManager=new ResourceManager}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=browserHTTPRequest(e,this.loadOptions);else{const i=getLoadHandlers(e,this.loadOptions);if(i.length===0)i.push(browserHTTPRequest(e,this.loadOptions));else if(i.length>1)throw new Error(`Found more than one (${i.length}) load handlers for URL '${[e]}'`);this.handler=i[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const i=this.artifacts.modelTopology;let s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${i.versions.producer}.${i.versions.minConsumer}`;const o=decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new GraphExecutor(OperationMapper.Instance.transformGraph(i,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const c=OperationMapper.Instance.transformGraph(e.modelInitializer);this.initializer=new GraphExecutor(c),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,i){if(typeof e=="string"){const s=getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,i){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Tensor)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((i,s,o)=>(i[s]=e[o],i),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,i){e=this.normalizeInputs(e),i=this.normalizeOutputs(i);const s=this.executor.execute(e,i);return s.length>1?s:s[0]}async executeAsync(e,i){e=this.normalizeInputs(e),i=this.normalizeOutputs(i);const s=await this.executor.executeAsync(e,i);return s.length>1?s:s[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((i,s)=>(i[s]=[e[s]],i),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function loadGraphModel(a,e={}){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&a.load==null&&(a.endsWith("/")||(a=a+"/"),a=`${a}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`);const i=new GraphModel(a,e);return await i.load(),i}/** @license See the LICENSE file. */const version$7="3.1.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function deepMap$1(a,e){return deepMapInternal(a,e)}function deepMapInternal(a,e,i=new Map,s=new Set){if(a==null)return null;if(s.has(a))throw new Error("Circular references are not supported.");if(i.has(a))return i.get(a);const o=e(a);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(isIterable(a)){const c=Array.isArray(a)?[]:{};s.add(a);for(const d in a){const h=a[d],g=deepMapInternal(h,e,i,s);c[d]=g}return s.delete(a),c}else throw new Error(`Can't recurse into non-iterable type: ${a}`);else return i.set(a,o.value),o.value}function deepZip(a,e=zipToList){return deepZipInternal(a,e)}function deepZipInternal(a,e,i=new Set){const s=a[0];if(i.has(s))throw new Error("Circular references are not supported.");const o=e(a);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(isIterable(s)){const c=Array.isArray(s)?[]:{};i.add(s);for(const d in s){const h=a.map(_=>_[d]),g=deepZipInternal(h,e,i);c[d]=g}return i.delete(s),c}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return o.value}function zipToList(a){return a===null?null:isIterable(a[0])?{value:null,recurse:!0}:{value:a,recurse:!1}}async function deepMapAndAwaitAll(a,e){const i=new Map;deepMapInternal(a,e,i);for(const o of Array.from(i.keys())){const c=i.get(o);if(isPromise(c)){const d=await c;i.set(o,d)}}return deepMapInternal(a,e,i)}function isIterable(a){return a!=null&&!ArrayBuffer.isView(a)&&(Array.isArray(a)||typeof a=="object"&&!(a instanceof Tensor))}function canTensorify(a){return a==null||isPrimitive(a)||Array.isArray(a)||typeof a=="object"&&a instanceof Tensor||isTypedArray(a)}function isPrimitive(a){return a===null||typeof a!="object"&&typeof a!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function deepClone(a){return deepMap$1(a,cloneIfTensor)}function cloneIfTensor(a){return a instanceof Tensor?{value:a.clone(),recurse:!1}:isIterable(a)?{value:null,recurse:!0}:{value:a,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class RingBuffer{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,i){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=i}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const i of e)this.push(i)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const i=this.wrap(this.begin+e),s=this.get(i);return this.set(i,this.pop()),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class GrowingRingBuffer extends RingBuffer{constructor(){super(GrowingRingBuffer.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,i=new Array(e),s=this.length();for(let o=0;o<s;o++)i[o]=this.get(this.wrap(this.begin+o));this.data=i,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}GrowingRingBuffer.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function iteratorFromItems(a){return new ArrayIterator(a)}function iteratorFromFunction(a){return new FunctionCallIterator(a)}function iteratorFromConcatenated(a,e){return new ChainedIterator(a,e)}function iteratorFromZipped(a,e=ZipMismatchMode.FAIL){return new ZipIterator(a,e)}class LazyIterator{async toArray(){const e=[];let i=await this.next();for(;!i.done;)e.push(i.value),i=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),i=[];let s=await e.next();for(;!s.done;)i.push(s.value),s=await e.next();return i}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let i=await this.next(),s=e(i.value);for(;!i.done&&s;)i=await this.next(),s=e(i.value)}handleErrors(e){return new ErrorHandlingLazyIterator(this,e)}filter(e){return new FilterIterator(this,e)}map(e){return new MapIterator(this,e)}mapAsync(e){return new AsyncMapIterator(this,e)}serialMapAsync(e){return new AsyncMapIterator(this,e).serial()}flatmap(e){return new FlatmapIterator(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(i=>i===!0)}rowMajorBatch(e,i=!0){return new RowMajorBatchIterator(this,e,i)}columnMajorBatch(e,i=!0,s=zipToList){return this.rowMajorBatch(e,i).map(c=>deepZip(c,s))}concatenate(e,i){return new ChainedIterator(iteratorFromItems([this,e]),i)}take(e){return e<0||e==null?this:new TakeIterator(this,e)}skip(e){return e<0||e==null?this:new SkipIterator(this,e)}prefetch(e){return new PrefetchIterator(this,e)}shuffle(e,i){return new ShuffleIterator(this,e,i)}serial(){return new SerialIterator(this)}}class ArrayIterator extends LazyIterator{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:deepClone(e),done:!1}}}class FunctionCallIterator extends LazyIterator{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class SerialIterator extends LazyIterator{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class SkipIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.maxCount=i,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;dispose(e.value)}return this.upstream.next()}}class TakeIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.maxCount=i,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class RowMajorBatchIterator extends LazyIterator{constructor(e,i,s=!0){super(),this.upstream=e,this.batchSize=i,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const i=await this.upstream.next();if(i.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(i.value)}return{value:e,done:!1}}}class FilterIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.predicate=i,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;dispose(e.value)}}}class MapIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.transform=i}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const i=getTensorsInContainer(e.value),s=this.transform(e.value),o=getTensorsInContainer(s);for(const c of i)isTensorInList(c,o)||c.dispose();return{value:s,done:!1}}}class ErrorHandlingLazyIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.handler=i,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class AsyncMapIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.transform=i}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const i=getTensorsInContainer(e.value),s=await this.transform(e.value),o=getTensorsInContainer(s);for(const c of i)isTensorInList(c,o)||c.dispose();return{value:s,done:!1}}}class OneToManyIterator extends LazyIterator{constructor(){super(),this.outputQueue=new GrowingRingBuffer,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class FlatmapIterator extends OneToManyIterator{constructor(e,i){super(),this.upstream=e,this.transform=i}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const i=getTensorsInContainer(e.value),s=this.transform(e.value),o=getTensorsInContainer(s);this.outputQueue.pushAll(s);for(const c of i)isTensorInList(c,o)||c.dispose();return!0}}class ChainedIterator extends LazyIterator{constructor(e,i){super(),this.baseErrorHandler=i,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const i=await this.iterator.next();return i.done?(this.iterator=null,this.readFromChain(e)):i}}var ZipMismatchMode;(function(a){a[a.FAIL=0]="FAIL",a[a.SHORTEST=1]="SHORTEST",a[a.LONGEST=2]="LONGEST"})(ZipMismatchMode||(ZipMismatchMode={}));class ZipIterator extends LazyIterator{constructor(e,i=ZipMismatchMode.FAIL){super(),this.iterators=e,this.mismatchMode=i,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let i=0,s=0;function o(d){return d instanceof LazyIterator?{value:d.next().then(g=>(i++,g.done&&s++,g.value)),recurse:!1}:{value:null,recurse:!0}}const c=await deepMapAndAwaitAll(this.iterators,o);if(i===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case ZipMismatchMode.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case ZipMismatchMode.SHORTEST:return{value:null,done:!0};case ZipMismatchMode.LONGEST:}return this.count++,{value:c,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class PrefetchIterator extends LazyIterator{constructor(e,i){super(),this.upstream=e,this.bufferSize=i,this.buffer=new RingBuffer(i)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class ShuffleIterator extends PrefetchIterator{constructor(e,i,s){super(e,i),this.upstream=e,this.windowSize=i,this.upstreamExhausted=!1,this.random=seedrandom.alea(s||now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),i=await this.buffer.shuffleExcise(e);if(i.done)this.upstreamExhausted=!0;else return this.refill(),i}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Dataset{constructor(){this.size=null}batch(e,i=!0){const s=this;assert$1(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===1/0||this.size==null?o=this.size:i?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),datasetFromIteratorFn(async()=>(await s.iterator()).columnMajorBatch(e,i,deepBatchConcat),o)}concatenate(e){const i=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,datasetFromIteratorFn(async()=>(await i.iterator()).concatenate(await e.iterator()),s)}filter(e){const i=this;let s;return this.size===1/0?s=1/0:s=null,datasetFromIteratorFn(async()=>(await i.iterator()).filter(o=>tidy(()=>e(o))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const i=this;return datasetFromIteratorFn(async()=>(await i.iterator()).map(s=>tidy(()=>e(s))),this.size)}mapAsync(e){const i=this;return datasetFromIteratorFn(async()=>(await i.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const i=this;return datasetFromIteratorFn(async()=>(await i.iterator()).prefetch(e),this.size)}repeat(e){const i=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,datasetFromIteratorFn(async()=>{const o=iteratorFromFunction(async()=>({value:await i.iterator(),done:!1}));return iteratorFromConcatenated(o.take(e))},s)}skip(e){const i=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,datasetFromIteratorFn(async()=>(await i.iterator()).skip(e),s)}shuffle(e,i,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const o=this,c=seedrandom.alea(i||now().toString());return datasetFromIteratorFn(async()=>{let d=c.int32();return s&&(d+=c.int32()),(await o.iterator()).shuffle(e,d.toString())},this.size)}take(e){const i=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,datasetFromIteratorFn(async()=>(await i.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}Dataset.MAX_BUFFER_SIZE=1e4;function datasetFromIteratorFn(a,e=null){return new class extends Dataset{constructor(){super(...arguments),this.size=e}async iterator(){return a()}}}function array(a){return datasetFromIteratorFn(async()=>iteratorFromItems(a),a.length)}function zip(a){if(!isIterable(a))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(a))for(let i=0;i<a.length;i++)e=e==null?a[i].size:Math.min(e,a[i].size);else if(a instanceof Object)for(const i in a)e=e==null?a[i].size:Math.min(e,a[i].size);return datasetFromIteratorFn(async()=>{const i=await deepMapAndAwaitAll(a,s=>{if(s instanceof Dataset)return{value:s.iterator(),recurse:!1};if(isIterable(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return iteratorFromZipped(i,ZipMismatchMode.SHORTEST)},e)}function deepBatchConcat(a){if(a===null)return null;const e=a[0];return canTensorify(e)?{value:batchConcat(a),recurse:!1}:{value:null,recurse:!0}}function batchConcat(a){if(a.length===0)throw new Error("Can't make a batch of zero elements.");return a[0]instanceof Tensor?stack(a):tensor(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class TextLineDataset extends Dataset{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const CODE_QUOTE='"',STATE_OUT=Symbol("out"),STATE_FIELD=Symbol("field"),STATE_QUOTE=Symbol("quote"),STATE_QUOTE_AFTER_QUOTE=Symbol("quoteafterquote"),STATE_WITHIN_QUOTE_IN_QUOTE=Symbol("quoteinquote");class CSVDataset extends Dataset{constructor(e,i){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new TextLineDataset(e),i||(i={}),this.hasHeader=i.hasHeader!==!1,this.fullColumnNames=i.columnNames,this.columnConfigs=i.columnConfigs,this.configuredColumnsOnly=i.configuredColumnsOnly,i.delimWhitespace?(assert$1(i.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=i.delimiter?i.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&assert$1(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const i=this.fullColumnNames.reduce((o,c)=>(o[c]=o[c]+1||1,o),{}),s=Object.keys(i).filter(o=>i[o]>1);if(assert$1(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const i=await(await this.base.iterator()).next();if(i.done)throw new Error("No data was found for CSV parsing.");const s=i.value;return this.parseRow(s,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(i=>this.makeDataElement(i))}makeDataElement(e){const i=this.parseRow(e),s={},o={};for(let c=0;c<this.fullColumnNames.length;c++){const d=this.fullColumnNames[c],h=this.columnConfigs?this.columnConfigs[d]:null;if(!(this.configuredColumnsOnly&&!h)){const g=i[c];let _=null;if(g==="")if(h&&h.default!==void 0)_=h.default;else{if(h&&(h.required||h.isLabel))throw new Error(`Required column ${d} is empty in this line: ${e}`);_=void 0}else{const b=Number(g);if(isNaN(b))h&&h.dtype==="bool"?_=this.getBoolean(g):_=g;else if(!h||!h.dtype)_=b;else switch(h.dtype){case"float32":_=b;break;case"int32":_=Math.floor(b);break;case"bool":_=this.getBoolean(g);break;default:_=b}}h&&h.isLabel?o[d]=_:s[d]=_}}return Object.keys(o).length===0?s:{xs:s,ys:o}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,i=!0){const s=[];let o=0;const c=e.length;let d=STATE_OUT;for(let h=0;h<c;h++)switch(d){case STATE_OUT:switch(e.charAt(h)){case CODE_QUOTE:o=h+1,d=STATE_QUOTE;break;case this.delimiter:if(o=h+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),d=STATE_OUT;break;default:d=STATE_FIELD,o=h;break}break;case STATE_FIELD:switch(e.charAt(h)){case this.delimiter:s.push(e.substring(o,h)),d=STATE_OUT,o=h+1;break}break;case STATE_QUOTE:switch(e.charAt(h)){case CODE_QUOTE:d=STATE_QUOTE_AFTER_QUOTE;break}break;case STATE_QUOTE_AFTER_QUOTE:switch(e.charAt(h)){case this.delimiter:s.push(e.substring(o,h-1)),d=STATE_OUT,o=h+1;break;case CODE_QUOTE:d=STATE_QUOTE;break;default:d=STATE_WITHIN_QUOTE_IN_QUOTE;break}break;case STATE_WITHIN_QUOTE_IN_QUOTE:switch(e.charAt(h)){case CODE_QUOTE:d=STATE_QUOTE;break}break}if(d===STATE_QUOTE_AFTER_QUOTE?s.push(e.substring(o,c-1)):s.push(e.substring(o)),i&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class MicrophoneIterator extends LazyIterator{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const i=Math.log2(this.fftSize);if(this.fftSize<0||i<4||i>14||!Number.isInteger(i))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(env$1().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");const i=new MicrophoneIterator(e);return await i.start(),i}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const i=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,i.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,i;const s=await this.getAudioData();if(this.includeSpectrogram){const o=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const o=this.flattenQueue(s.timeDataQueue);i=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:i},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],i=[];let s=0;return new Promise(o=>{const c=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:e,timeDataQueue:i}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),i.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(c),o({freqDataQueue:e,timeDataQueue:i}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const i=e[0].length,s=new Float32Array(e.length*i);return e.forEach((o,c)=>s.set(o,c*i)),s}getTensorFromAudioDataArray(e,i){const s=new Float32Array(sizeFromShape(i));return s.set(e,s.length-e.length),tensor(s,i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class WebcamIterator extends LazyIterator{constructor(e,i){if(super(),this.webcamVideoElement=e,this.webcamConfig=i,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=tensor1d([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,c=(1-s)/2,d=(1-o)/2,h=c+s,g=o+d;this.cropBox=tensor2d([d,c,g,h],[1,4])}else this.cropBox=tensor2d([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,i={}){if(env$1().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!i.resizeWidth||!i.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=i.resizeWidth,e.height=i.resizeHeight}const s=new WebcamIterator(e,i);return await s.start(),s}async start(){this.webcamConfig.facingMode&&assert$1(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=fromPixels$1(this.webcamVideoElement)}catch(i){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(i)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(i){throw new Error(`Error thrown cropping the video: ${i.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return tidy(()=>{const i=expandDims$3(cast$3(e,"float32"),0);let s;s=image$1.cropAndResize(i,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const o=s.shape;return reshape$4(s,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(i=>i.stop());try{this.webcamVideoElement.srcObject=null}catch(i){console.log(i),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class DataSource{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class StringIterator extends LazyIterator{split(e){return new SplitIterator(this,e)}}class SplitIterator extends StringIterator{constructor(e,i){super(),this.upstream=e,this.impl=new SplitIteratorImpl(e,i)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class SplitIteratorImpl extends OneToManyIterator{constructor(e,i){super(),this.upstream=e,this.separator=i,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const i=e.value.split(this.separator);i[0]=this.carryover+i[0];for(const s of i.slice(0,-1))this.outputQueue.push(s);return this.carryover=i[i.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ByteChunkIterator extends LazyIterator{decodeUTF8(){return new Utf8Iterator(this)}}class Utf8Iterator extends StringIterator{constructor(e){super(),this.upstream=e,this.impl=new Utf8IteratorImpl(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Utf8IteratorImpl extends OneToManyIterator{constructor(e){if(super(),this.upstream=e,env$1().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:i}=require("string_decoder");this.decoder=new i("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let i;if(e.done)return!1;i=e.value;let s;return env$1().get("IS_BROWSER")?s=this.decoder.decode(i,{stream:!0}):s=this.decoder.write(Buffer.from(i.buffer)),this.outputQueue.push(s),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class FileChunkIterator extends ByteChunkIterator{constructor(e,i={}){super(),this.file=e,this.options=i,assert$1(e instanceof Uint8Array||(env$1().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=i.offset||0,this.chunkSize=i.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((i,s)=>{const o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)i(new Uint8Array(this.file.slice(this.offset,o)));else{const c=new FileReader;c.onload=h=>{let g=c.result;if(g instanceof ArrayBuffer&&(g=new Uint8Array(g)),!(g instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));i(g)},c.onabort=h=>s(new Error("Aborted")),c.onerror=h=>s(new Error(h.type));const d=this.file.slice(this.offset,o);c.readAsArrayBuffer(d)}this.offset=o}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function urlChunkIterator(a,e={}){let i,s;typeof a=="string"?i=a:(i=a.url,s=getRequestInitFromRequest(a));const o=await fetch$1(i,s);if(o.ok){const c=new Uint8Array(await o.arrayBuffer());return new FileChunkIterator(c,e)}else throw new Error(o.statusText)}const getRequestInitFromRequest=a=>({method:a.method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function isLocalPath(a){return typeof a=="string"&&a.substr(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class FileDataSource extends DataSource{constructor(e,i={}){super(),this.input=e,this.options=i}async iterator(){if(isLocalPath(this.input)&&env$1().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.substr(7))}return new FileChunkIterator(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class URLDataSource extends DataSource{constructor(e,i={}){super(),this.url=e,this.fileOptions=i}async iterator(){return isLocalPath(this.url)?new FileDataSource(this.url,this.fileOptions).iterator():urlChunkIterator(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function csv(a,e={}){return new CSVDataset(new URLDataSource(a),e)}function func(a){const e=iteratorFromFunction(a);return datasetFromIteratorFn(async()=>e)}function generator(a){return datasetFromIteratorFn(async()=>{const e=await a();return iteratorFromFunction(()=>e.next())})}async function webcam(a,e){return WebcamIterator.create(a,e)}async function microphone(a){return MicrophoneIterator.create(a)}/** @license See the LICENSE file. */const version$6="3.1.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const index=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset,Dataset,FileDataSource,TextLineDataset,URLDataSource,array,csv,func,generator,microphone,version_data:version$6,webcam,zip},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertNotComplex$1(a,e){Array.isArray(a)||(a=[a]),a.forEach(i=>{i!=null&&assert$1(i.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const whereImpl$1=whereImpl$2;class MathBackendCPU extends KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new DataStorage(this,engine())}nextDataId(){return MathBackendCPU.nextDataId++}write(e,i,s){this.firstUse&&(this.firstUse=!1,env$1().get("IS_NODE")&&warn(`
============================
Hi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));const o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,i,s){let o;if(i==="string"&&s!=null&&s.length>0&&isString$1(s[0])){const c=s.map(d=>encodeString(d));o=this.write(c,e,i)}else o=this.write(s,e,i);return{dataId:o,shape:e,dtype:i}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const i=this.data.get(e);i.refCount++}decRef(e){if(this.data.has(e)){const i=this.data.get(e);i.refCount--}}move(e,i,s,o,c){this.data.set(e,{values:i,dtype:o,refCount:c})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:i,complexTensorInfos:s}=this.data.get(e);if(i==="complex64"){const o=this.readSync(s.real.dataId),c=this.readSync(s.imag.dataId);return mergeRealAndImagArrays(o,c)}return this.data.get(e).values}bufferSync(e){const i=this.readSync(e.dataId);let s=i;if(e.dtype==="string")try{s=i.map(o=>decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(e.shape,e.dtype,s)}makeOutput(e,i,s){const o=this.write(e,i,s);return engine().makeTensorFromDataId(o,i,s,this)}disposeData(e,i=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!i&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const i=now();return e(),{kernelMs:now()-i}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){assertNotComplex$1([e],"where");const i=this.readSync(e.dataId);return whereImpl$1(e.shape,i)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}MathBackendCPU.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function simpleAbsImpl(a){const e=new Float32Array(a.length);for(let i=0;i<a.length;++i)e[i]=Math.abs(a[i]);return e}const abs$3=a=>{const{x:e}=a.inputs,i=a.backend;assertNotComplex$1(e,"abs");let s=new Float32Array(sizeFromShape(e.shape));const o=i.data.get(e.dataId).values;return s=simpleAbsImpl(o),i.makeOutput(s,e.shape,"float32")},absConfig$1={kernelName:Abs,backendName:"cpu",kernelFunc:abs$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleBinaryKernelImpl(a){return(e,i,s,o,c)=>{const d=assertAndGetBroadcastShape(e,i),h=d.length,g=computeStrides(d),_=sizeFromShape(d),b=getTypedArrayFromDType(c,_),$=e.length,j=i.length,_e=computeStrides(e),tt=computeStrides(i),et=getBroadcastDims$1(e,d),nt=getBroadcastDims$1(i,d);if(et.length+nt.length===0)for(let rt=0;rt<b.length;++rt)b[rt]=a(s[rt%s.length],o[rt%o.length]);else for(let rt=0;rt<b.length;++rt){const it=indexToLoc(rt,h,g),at=it.slice(-$);et.forEach(lt=>at[lt]=0);const st=locToIndex(at,$,_e),ot=it.slice(-j);nt.forEach(lt=>ot[lt]=0);const ct=locToIndex(ot,j,tt);b[rt]=a(s[st],o[ct])}return[b,d]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex$3(a){const{inputs:e,backend:i}=a,{real:s,imag:o}=e,c=i.data.get(s.dataId).values,d=i.data.get(o.dataId).values,h=i.makeTensorInfo(s.shape,"complex64"),g=i.data.get(h.dataId);return g.complexTensorInfos={real:i.makeTensorInfo(s.shape,"float32",c),imag:i.makeTensorInfo(o.shape,"float32",d)},h}const complexConfig$1={kernelName:Complex$2,backendName:"cpu",kernelFunc:complex$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros$2(a,e,i="float32"){if(i==="complex64"){const o=zeros$2(a,e,"float32"),c=zeros$2(a,e,"float32");return complex$3({inputs:{real:o,imag:c},backend:a})}const s=makeZerosTypedArray(sizeFromShape(e),i);return a.makeTensorInfo(e,i,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity$2(a){const{inputs:e,backend:i}=a,{x:s}=e;return i.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const identityConfig$1={kernelName:Identity$1,backendName:"cpu",kernelFunc:identity$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real$1(a){const{inputs:e,backend:i}=a,{input:s}=e,o=i.data.get(s.dataId).complexTensorInfos.real,c=i.data.get(o.dataId).values;return i.makeTensorInfo(o.shape,o.dtype,c)}const realConfig$1={kernelName:Real,backendName:"cpu",kernelFunc:real$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{dtype:c}=s;if(c==="complex64"){if(o.dtype==="complex64")return identity$2({inputs:{x:o},backend:i});const d=zeros$2(i,o.shape,o.dtype),h=cast$1({inputs:{x:o},backend:i,attrs:{dtype:"float32"}}),g=complex$3({inputs:{real:h,imag:d},backend:i});return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),g}if(o.dtype==="complex64"){const d=real$1({inputs:{input:o},backend:i}),h=cast$1({inputs:{x:d},backend:i,attrs:{dtype:c}});return i.disposeIntermediateTensorInfo(d),h}if(!hasEncodingLoss(o.dtype,c)){const d=identity$2({inputs:{x:o},backend:i});return{dataId:d.dataId,shape:d.shape,dtype:c}}if(c==="int32"){const d=i.data.get(o.dataId).values,h=Int32Array.from(d);return i.makeTensorInfo(o.shape,"int32",h)}if(c==="bool"){const d=i.data.get(o.dataId).values,h=toTypedArray([0],o.dtype),[g,_]=createSimpleBinaryKernelImpl((b,$)=>b!==$?1:0)(o.shape,[],d,h,"bool");return i.makeTensorInfo(_,"bool",g)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${c}`)}const castConfig$1={kernelName:Cast,backendName:"cpu",kernelFunc:cast$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryKernelFunc$1(a,e,i,s){return i==null?({inputs:o,backend:c})=>{const{a:d,b:h}=o,g=c;assertNotComplex$1([d,h],a);const _=g.data.get(d.dataId).values,b=g.data.get(h.dataId).values,$=s||d.dtype,[j,_e]=e(d.shape,h.shape,_,b,$);return g.makeTensorInfo(_e,$,j)}:({inputs:o,backend:c})=>{const{a:d,b:h}=o,g=c;if(d.dtype==="complex64"||h.dtype==="complex64"){const _=cast$1({inputs:{x:d},backend:g,attrs:{dtype:"complex64"}}),b=g.data.get(_.dataId),$=b.complexTensorInfos.real,j=b.complexTensorInfos.imag,_e=g.data.get($.dataId).values,tt=g.data.get(j.dataId).values,et=cast$1({inputs:{x:h},backend:g,attrs:{dtype:"complex64"}}),nt=g.data.get(et.dataId),rt=nt.complexTensorInfos.real,it=nt.complexTensorInfos.imag,at=g.data.get(rt.dataId).values,st=g.data.get(it.dataId).values,[ot,ct,lt]=i(d.shape,h.shape,_e,tt,at,st),dt=g.makeTensorInfo(lt,"float32",ot),xt=g.makeTensorInfo(lt,"float32",ct),ut=complex$3({inputs:{real:dt,imag:xt},backend:g});return g.disposeIntermediateTensorInfo(_),g.disposeIntermediateTensorInfo(et),g.disposeIntermediateTensorInfo(dt),g.disposeIntermediateTensorInfo(xt),ut}else{const _=g.data.get(d.dataId).values,b=g.data.get(h.dataId).values,$=s||d.dtype,[j,_e]=e(d.shape,h.shape,_,b,$);return g.makeTensorInfo(_e,$,j)}}}function createComplexBinaryKernelImpl(a){return(e,i,s,o,c,d)=>{const h=assertAndGetBroadcastShape(e,i),g=sizeFromShape(h),_=h.length,b=computeStrides(h),$=getTypedArrayFromDType("float32",g),j=getTypedArrayFromDType("float32",g),_e=getBroadcastDims$1(e,h),tt=getBroadcastDims$1(i,h),et=mergeRealAndImagArrays(s,o),nt=mergeRealAndImagArrays(c,d),rt=e.length,it=computeStrides(e),at=i.length,st=computeStrides(i);if(_e.length+tt.length===0)for(let ot=0;ot<$.length;ot++){const ct=ot%et.length,lt=ot%nt.length,dt=a(et[ct*2],et[ct*2+1],nt[lt*2],nt[lt*2+1]);$[ot]=dt.real,j[ot]=dt.imag}else for(let ot=0;ot<$.length;ot++){const ct=indexToLoc(ot,_,b),lt=ct.slice(-rt);_e.forEach(mt=>lt[mt]=0);const dt=locToIndex(lt,rt,it),xt=ct.slice(-at);tt.forEach(mt=>xt[mt]=0);const ut=locToIndex(xt,at,st),ft=a(et[dt*2],et[dt*2+1],nt[ut*2],nt[ut*2+1]);$[ot]=ft.real,j[ot]=ft.imag}return[$,j,h]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const addImpl=createSimpleBinaryKernelImpl((a,e)=>a+e),addComplexImpl=createComplexBinaryKernelImpl((a,e,i,s)=>({real:a+i,imag:e+s})),add$2=binaryKernelFunc$1(Add$1,addImpl,addComplexImpl),addConfig$1={kernelName:Add$1,backendName:"cpu",kernelFunc:add$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincountImpl(a,e,i,s,o){const c=sizeFromShape(s),d=makeZerosTypedArray(o,i);for(let h=0;h<a.length;h++){const g=a[h];if(g<0)throw new Error("Input x must be non-negative!");g>=o||(c>0?d[g]+=e[h]:d[g]+=1)}return d}function bincountReduceImpl(a,e,i,s=!1){const o=a.shape[0],c=a.shape[1],d=buffer([o,i],e.dtype);for(let h=0;h<o;h++)for(let g=0;g<c;g++){const _=a.get(h,g);if(_<0)throw new Error("Input x must be non-negative!");_>=i||(s?d.set(1,h,_):e.size>0?d.set(d.get(h,_)+e.get(h,g),h,_):d.set(d.get(h,_)+1,h,_))}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleUnaryImpl(a){return(e,i,s)=>{const o=getTypedArrayFromDType(i,e.length);for(let c=0;c<e.length;++c)o[c]=a(e[c],s);return o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unaryKernelFunc$1(a,e,i){return({inputs:s,attrs:o,backend:c})=>{const{x:d}=s;if(assertNotComplex$1(d,a),d.dtype==="string"||i==="string")throw new Error("unaryKernelFunc does not support string input/output");const h=c,g=h.data.get(d.dataId).values,_=sizeFromShape(d.shape),b=i||d.dtype,$=getArrayFromDType(b,_);for(let j=0;j<_;++j)$[j]=e(g[j],o);return h.makeTensorInfo(d.shape,b,$)}}function unaryKernelFuncFromImpl(a,e,i){return({inputs:s,attrs:o,backend:c})=>{const{x:d}=s;if(assertNotComplex$1(d,a),d.dtype==="string"||i==="string")throw new Error("unaryKernelFunc does not support string input/output");const h=c,g=h.data.get(d.dataId).values,_=d.dtype,b=e(g,_,o);return h.makeTensorInfo(d.shape,_,b)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ceilImpl=createSimpleUnaryImpl(a=>Math.ceil(a)),ceil$2=unaryKernelFuncFromImpl(Ceil,ceilImpl),ceilConfig$1={kernelName:Ceil,backendName:"cpu",kernelFunc:ceil$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl$1(a,e,i,s){const o=getArrayFromDType(i,sizeFromShape(e));if(s&&i!=="string"){let c=0;a.forEach(d=>{const h=sizeFromShape(d.shape);o.set(d.vals,c),c+=h})}else{let c=0;a.forEach(d=>{const h=i==="string"?fromUint8ToStringArray(d.vals):d.vals;let g=0;for(let _=0;_<d.shape[0];++_){const b=_*e[1]+c;for(let $=0;$<d.shape[1];++$)o[b+$]=h[g++]}c+=d.shape[1]})}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expImpl=createSimpleUnaryImpl(a=>Math.exp(a)),exp$2=unaryKernelFuncFromImpl(Exp,expImpl),expConfig$1={kernelName:Exp,backendName:"cpu",kernelFunc:exp$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const expm1Impl=createSimpleUnaryImpl(a=>Math.expm1(a)),expm1$1=unaryKernelFuncFromImpl(Expm1,expm1Impl),expm1Config$1={kernelName:Expm1,backendName:"cpu",kernelFunc:expm1$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const floorImpl=createSimpleUnaryImpl(a=>Math.floor(a)),floor$2=unaryKernelFuncFromImpl(Floor,floorImpl),floorConfig$1={kernelName:Floor,backendName:"cpu",kernelFunc:floor$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2Impl(a,e,i){const s=buffer(i,a.dtype);for(let o=0;o<s.size;++o){const d=s.indexToLoc(o).slice(),h=d[0],g=d[2],_=e.locToIndex([h,g]);d[2]=e.values[_];const b=a.locToIndex(d);s.values[o]=a.values[b]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const greaterImpl=createSimpleBinaryKernelImpl((a,e)=>a>e?1:0),greater$1=binaryKernelFunc$1(Greater,greaterImpl,null,"bool"),greaterConfig$1={kernelName:Greater,backendName:"cpu",kernelFunc:greater$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lessImpl=createSimpleBinaryKernelImpl((a,e)=>a<e?1:0),less$1=binaryKernelFunc$1(Less,lessImpl,null,"bool"),lessConfig$1={kernelName:Less,backendName:"cpu",kernelFunc:less$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpaceImpl(a,e,i){const s=(e-a)/(i-1),o=makeZerosTypedArray(i,"float32");o[0]=a;for(let c=1;c<o.length;c++)o[c]=o[c-1]+s;return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logImpl=createSimpleUnaryImpl(a=>Math.log(a)),log$2=unaryKernelFuncFromImpl(Log,logImpl),logConfig$1={kernelName:Log,backendName:"cpu",kernelFunc:log$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxImpl$1(a,e,i,s){const o=getTypedArrayFromDType(s,sizeFromShape(i));for(let c=0;c<o.length;++c){const d=c*e;let h=a[d];for(let g=0;g<e;++g){const _=a[d+g];_>h&&(h=_)}o[c]=h}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maximumImpl=createSimpleBinaryKernelImpl((a,e)=>Math.max(a,e)),maximum$1=binaryKernelFunc$1(Maximum$1,maximumImpl),maximumConfig$1={kernelName:Maximum$1,backendName:"cpu",kernelFunc:maximum$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const minimumImpl=createSimpleBinaryKernelImpl((a,e)=>Math.min(a,e)),minimum$1=binaryKernelFunc$1(Minimum$1,minimumImpl),minimumConfig$1={kernelName:Minimum$1,backendName:"cpu",kernelFunc:minimum$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const multiplyImpl=createSimpleBinaryKernelImpl((a,e)=>a*e),multiplyComplexImpl=createComplexBinaryKernelImpl((a,e,i,s)=>({real:a*i-e*s,imag:a*s+e*i})),multiply$2=binaryKernelFunc$1(Multiply$1,multiplyImpl,multiplyComplexImpl),multiplyConfig$1={kernelName:Multiply$1,backendName:"cpu",kernelFunc:multiply$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function negImpl(a,e,i){const s=createScalarValue(-1,i);return multiplyImpl([],e,s,a,i)}function neg$1(a){const{inputs:e,backend:i}=a,{x:s}=e;assertNotComplex$1(s,"neg");const o=i.data.get(s.dataId).values,[c,d]=negImpl(o,s.shape,s.dtype);return i.makeTensorInfo(d,s.dtype,c)}const negConfig$1={kernelName:Neg,backendName:"cpu",kernelFunc:neg$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const notEqualImpl=createSimpleBinaryKernelImpl((a,e)=>a!==e?1:0),notEqual$1=binaryKernelFunc$1(NotEqual,notEqualImpl,null,"bool"),notEqualConfig$1={kernelName:NotEqual,backendName:"cpu",kernelFunc:notEqual$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl$1(a,e,i,s,o){const c=e.length,d=sizeFromShape(e),h=computeStrides(e),g=computeStrides(o),_=getTypedArrayFromDType(i,sizeFromShape(o));for(let b=0;b<d;++b){const $=indexToLoc(b,c,h),j=new Array($.length);for(let tt=0;tt<j.length;tt++)j[tt]=$[s[tt]];const _e=locToIndex(j,c,g);_[_e]=a[b]}return _}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose$2(a){const{inputs:e,attrs:i,backend:s}=a,{x:o}=e,{perm:c}=i;assertNotComplex$1(o,"transpose");const d=o.shape.length,h=new Array(d);for(let $=0;$<h.length;$++)h[$]=o.shape[c[$]];const g=s.data.get(o.dataId).values,_=transposeImpl$1(g,o.shape,o.dtype,c,h);return{dataId:s.write(_,h,o.dtype),shape:h,dtype:o.dtype}}const transposeConfig$1={kernelName:Transpose,backendName:"cpu",kernelFunc:transpose$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prodImpl(a,e,i,s){const[o,c]=computeOutAndReduceShapes(a,s),d=upcastType(e,"int32"),h=makeZerosTypedArray(sizeFromShape(o),d),g=sizeFromShape(c);for(let _=0;_<h.length;++_){const b=_*g;let $=1;for(let j=0;j<g;++j)$*=i[b+j];h[_]=$}return{outVals:h,outShape:o,outDtype:d}}function prod$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s;assertNotComplex$1(o,"prod");const h=o.shape.length,g=parseAxisParam(c,o.shape),_=getAxesPermutation(g,h);let b=g,$=o;const j=[];_!=null&&($=transpose$2({inputs:{x:o},backend:i,attrs:{perm:_}}),j.push($),b=getInnerMostAxes(b.length,h));const _e=i.data.get($.dataId).values,{outVals:tt,outShape:et,outDtype:nt}=prodImpl($.shape,$.dtype,_e,b);let rt=et;return d&&(rt=expandShapeToKeepDim(et,g)),j.forEach(it=>i.disposeIntermediateTensorInfo(it)),i.makeTensorInfo(rt,nt,tt)}const prodConfig$1={kernelName:Prod,backendName:"cpu",kernelFunc:prod$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rangeImpl(a,e,i,s){const o=a===e,c=a<e&&i<0,d=e<a&&i>1;if(o||c||d)return makeZerosTypedArray(0,s);const h=Math.abs(Math.ceil((e-a)/i)),g=makeZerosTypedArray(h,s);e<a&&i===1&&(i=-1),g[0]=a;for(let _=1;_<g.length;_++)g[_]=g[_-1]+i;return g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rsqrtImpl=createSimpleUnaryImpl(a=>1/Math.sqrt(a)),rsqrt$1=unaryKernelFuncFromImpl(Rsqrt,rsqrtImpl),rsqrtConfig$1={kernelName:Rsqrt,backendName:"cpu",kernelFunc:rsqrt$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sliceImpl(a,e,i,s,o){const c=isSliceContinous(s,e,i),d=sizeFromShape(i),h=computeStrides(s);if(c){const $=computeFlatOffset(e,h);return o==="string"?a.slice($,$+d):a.subarray($,$+d)}const g=o==="string"?fromUint8ToStringArray(a):a,_=buffer(s,o,g),b=buffer(i,o);for(let $=0;$<b.size;++$){const j=b.indexToLoc($),_e=j.map((tt,et)=>tt+e[et]);b.set(_.get(..._e),...j)}return o==="string"?fromStringArrayToUint8(b.values):b.values}function slice$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{begin:c,size:d}=s;assertNotComplex$1(o,"slice");const[h,g]=parseSliceParams(o,c,d);assertParamsValid(o,h,g);const _=i.data.get(o.dataId).values,b=sliceImpl(_,h,g,o.shape,o.dtype);return i.makeTensorInfo(g,o.dtype,b)}const sliceConfig$1={kernelName:Slice,backendName:"cpu",kernelFunc:slice$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const squaredDifferenceImpl=createSimpleBinaryKernelImpl((a,e)=>{const i=a-e;return i*i}),squaredDifference$1=binaryKernelFunc$1(SquaredDifference,squaredDifferenceImpl),squaredDifferenceConfig$1={kernelName:SquaredDifference,backendName:"cpu",kernelFunc:squaredDifference$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSliceImpl(a,e,i,s){const o=buffer(a,e.dtype);for(let c=0;c<o.size;c++){const d=o.indexToLoc(c),h=new Array(d.length);for(let g=0;g<h.length;g++)h[g]=d[g]*i[g]+s[g];o.set(e.get(...h),...d)}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const subImpl=createSimpleBinaryKernelImpl((a,e)=>a-e),subComplexImpl=createComplexBinaryKernelImpl((a,e,i,s)=>({real:a-i,imag:e-s})),sub$2=binaryKernelFunc$1(Sub,subImpl,subComplexImpl),subConfig$1={kernelName:Sub,backendName:"cpu",kernelFunc:sub$2};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tileImpl(a,e){const i=new Array(a.rank);for(let o=0;o<i.length;o++)i[o]=a.shape[o]*e[o];const s=buffer(i,a.dtype);for(let o=0;o<s.values.length;++o){const c=s.indexToLoc(o),d=new Array(a.rank);for(let g=0;g<d.length;g++)d[g]=c[g]%a.shape[g];const h=a.locToIndex(d);s.values[o]=a.values[h]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topKImpl(a,e,i,s,o){const c=e[e.length-1],[d,h]=[a.length/c,c],g=getTypedArrayFromDType(i,d*s),_=getTypedArrayFromDType("int32",d*s);for(let $=0;$<d;$++){const j=$*h,_e=a.subarray(j,j+h),tt=[];for(let it=0;it<_e.length;it++)tt.push({value:_e[it],index:it});tt.sort((it,at)=>at.value-it.value);const et=$*s,nt=g.subarray(et,et+s),rt=_.subarray(et,et+s);for(let it=0;it<s;it++)nt[it]=tt[it].value,rt[it]=tt[it].index}const b=e.slice();return b[b.length-1]=s,[buffer(b,i,g),buffer(b,"int32",_)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uniqueImpl(a,e,i,s){const o=parseAxisParam(e,i)[0],c=[1,i[0],1];for(let tt=0;tt<o;tt++)c[0]*=i[tt];c[1]=i[o];for(let tt=o+1;tt<i.length;tt++)c[2]*=i[tt];const d={},h=new Int32Array(i[o]),g=new TensorBuffer(c,s,a),_=[],b=c[0]===1&&c[2]===1;for(let tt=0;tt<i[o];tt++){let et;if(b)et=a[tt].toString();else{const nt=[];for(let rt=0;rt<c[0];rt++)for(let it=0;it<c[2];it++)nt.push(g.get(rt,tt,it));et=nt.join(",")}if(d[et]!==void 0)h[tt]=d[et];else{const nt=Object.keys(d).length;d[et]=nt,h[tt]=nt,_.push(tt)}}const $=c.slice();$[1]=Object.keys(d).length;const j=new TensorBuffer($,s);_.forEach((tt,et)=>{for(let nt=0;nt<c[0];nt++)for(let rt=0;rt<c[2];rt++)j.set(g.get(nt,tt,rt),nt,et,rt)});const _e=i.slice();return _e[o]=$[1],{outputValues:j.values,outputShape:_e,indices:h}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const shared=Object.freeze(Object.defineProperty({__proto__:null,addImpl,bincountImpl,bincountReduceImpl,ceilImpl,concatImpl:concatImpl$1,expImpl,expm1Impl,floorImpl,gatherV2Impl,greaterImpl,lessImpl,linSpaceImpl,logImpl,maxImpl:maxImpl$1,maximumImpl,minimumImpl,multiplyImpl,negImpl,notEqualImpl,prodImpl,rangeImpl,rsqrtImpl,simpleAbsImpl,sliceImpl,squaredDifferenceImpl,stridedSliceImpl,subImpl,tileImpl,topKImpl,transposeImpl:transposeImpl$1,uniqueImpl},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const version$5="3.1.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */registerBackend("cpu",()=>new MathBackendCPU,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const elu$1=unaryKernelFunc$1(Elu$1,a=>a>=0?a:Math.exp(a)-1),eluConfig$1={kernelName:Elu$1,backendName:"cpu",kernelFunc:elu$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function leakyRelu$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{alpha:c}=s;assertNotComplex$1([o],"leakyRelu");const d=sizeFromShape(o.shape),h=i.data.get(o.dataId).values,g=getTypedArrayFromDType("float32",d);for(let _=0;_<h.length;_++)g[_]=h[_]<0?c*h[_]:h[_];return i.makeTensorInfo(o.shape,"float32",g)}const leakyReluConfig$1={kernelName:LeakyRelu,backendName:"cpu",kernelFunc:leakyRelu$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const preluImpl=createSimpleBinaryKernelImpl((a,e)=>a<0?e*a:a);function prelu$1(a){const{inputs:e,backend:i}=a,{x:s,alpha:o}=e;assertNotComplex$1([s,o],"prelu");const c=i.data.get(s.dataId).values,d=i.data.get(o.dataId).values,[h,g]=preluImpl(s.shape,o.shape,c,d,s.dtype);return i.makeTensorInfo(g,s.dtype,h)}const preluConfig$1={kernelName:Prelu,backendName:"cpu",kernelFunc:prelu$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const relu$1=unaryKernelFunc$1(Relu$1,a=>Math.max(0,a)),reluConfig$1={kernelName:Relu$1,backendName:"cpu",kernelFunc:relu$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const relu6$1=unaryKernelFunc$1(Relu6$1,a=>Math.min(Math.max(0,a),6)),relu6Config$1={kernelName:Relu6$1,backendName:"cpu",kernelFunc:relu6$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function applyActivation(a,e,i,s,o){if(i==="linear")return identity$2({inputs:{x:e},backend:a});if(i==="relu")return relu$1({inputs:{x:e},backend:a});if(i==="elu")return elu$1({inputs:{x:e},backend:a});if(i==="relu6")return relu6$1({inputs:{x:e},backend:a});if(i==="prelu")return prelu$1({inputs:{x:e,alpha:s},backend:a});if(i==="leakyrelu")return leakyRelu$1({inputs:{x:e},backend:a,attrs:{alpha:o}});throw new Error(`Activation ${i} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape$2(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{shape:c}=s,d=sizeFromShape(o.shape),h=inferFromImplicitShape(c,d),g=sizeFromShape(h);assert$1(d===g,()=>`The new shape (${h}) has ${g} elements and the old shape (${o.shape}) has ${d} elements. The new shape and old shape must have the same number of elements.`),i.incRef(o.dataId);const _=i.data.get(o.dataId);if(_.complexTensorInfos!=null){const b=_.complexTensorInfos.real,$=_.complexTensorInfos.imag;b.shape=h,$.shape=h}return{dataId:o.dataId,shape:h,dtype:o.dtype}}const reshapeConfig$1={kernelName:Reshape$1,backendName:"cpu",kernelFunc:reshape$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchMatMul$1(a){const{inputs:e,backend:i,attrs:s}=a,{a:o,b:c}=e,{transposeA:d,transposeB:h}=s;assertNotComplex$1([o,c],"matMul");const g=o.shape.length,_=c.shape.length,b=d?o.shape[g-2]:o.shape[g-1],$=h?c.shape[_-1]:c.shape[_-2],j=d?o.shape[g-1]:o.shape[g-2],_e=h?c.shape[_-2]:c.shape[_-1],tt=o.shape.slice(0,-2),et=c.shape.slice(0,-2),nt=sizeFromShape(tt),rt=sizeFromShape(et),it=nt===rt||nt===1||rt===1;assert$1(g>=2&&_>=2&&it,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${tt}) and (${et}).`);const st=(nt>rt?o.shape.slice(0,-2):c.shape.slice(0,-2)).concat([j,_e]);assert$1(b===$,()=>`Error in matMul: inner shapes (${b}) and (${$}) of Tensors with shapes ${o.shape} and ${c.shape} and transposeA=${d} and transposeB=${h} must match.`);const ot=d?[nt,b,j]:[nt,j,b],ct=h?[rt,_e,$]:[rt,$,_e],lt=reshape$2({inputs:{x:o},backend:i,attrs:{shape:ot}}),dt=reshape$2({inputs:{x:c},backend:i,attrs:{shape:ct}}),xt=d?lt.shape[1]:lt.shape[2],ut=d?lt.shape[2]:lt.shape[1],ft=h?dt.shape[1]:dt.shape[2],mt=Math.max(nt,rt),yt=i.data.get(lt.dataId).values,St=i.data.get(dt.dataId).values,Et=computeStrides(lt.shape),vt=computeStrides(dt.shape),[Nt,wt,$t]=d?[Et[0],1,Et[1]]:[Et[0],Et[1],1],[Ct,Mt,Ot]=h?[1,vt[1],vt[0]]:[vt[1],1,vt[0]],Dt=ut*ft,At=buffer([mt,ut,ft],lt.dtype),kt=At.values,Ft=i.blockSize;for(let Bt=0;Bt<mt;Bt++)for(let Ht=0;Ht<ut;Ht+=Ft)for(let Wt=0;Wt<ft;Wt+=Ft)for(let Ut=0;Ut<xt;Ut+=Ft){const Rt=Math.min(Ht+Ft,ut),un=Math.min(Wt+Ft,ft),rn=Math.min(Ut+Ft,xt);for(let mn=Ht;mn<Rt;mn++)for(let sn=Wt;sn<un;sn++){let hn=0;for(let gn=Ut;gn<rn;gn++){const Xt=Math.min(Bt,nt-1)*Nt,En=Math.min(Bt,rt-1)*Ot,bt=yt[Xt+mn*wt+gn*$t],gt=St[gn*Ct+sn*Mt+En];hn+=bt*gt}kt[Bt*Dt+(mn*ft+sn)]+=hn}}return i.disposeIntermediateTensorInfo(lt),i.disposeIntermediateTensorInfo(dt),i.makeTensorInfo(st,At.dtype,At.values)}const batchMatMulConfig$1={kernelName:BatchMatMul,backendName:"cpu",kernelFunc:batchMatMul$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fusedMatMul$1(a){const{inputs:e,backend:i,attrs:s}=a,{a:o,b:c,bias:d,preluActivationWeights:h}=e,{transposeA:g,transposeB:_,activation:b,leakyreluAlpha:$}=s;let j,_e,tt;const et=[];j=batchMatMul$1({inputs:{a:o,b:c},attrs:{transposeA:g,transposeB:_},backend:i}),d&&(_e=add$2({inputs:{a:j,b:d},backend:i}),et.push(j),j=_e),b&&(tt=applyActivation(i,j,b,h,$),et.push(j),j=tt);for(const rt of et)i.disposeIntermediateTensorInfo(rt);return j}const _fusedMatMulConfig$1={kernelName:_FusedMatMul,backendName:"cpu",kernelFunc:_fusedMatMul$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const acos$2=unaryKernelFunc$1(Acos,a=>Math.acos(a)),acosConfig$1={kernelName:Acos,backendName:"cpu",kernelFunc:acos$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const acosh$2=unaryKernelFunc$1(Acosh,a=>Math.acosh(a)),acoshConfig$1={kernelName:Acosh,backendName:"cpu",kernelFunc:acosh$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN$1(a){const{inputs:e,backend:i}=a,s=e;assertNotComplex$1(e,"addN");const o=s.map(h=>i.data.get(h.dataId).values),c=buffer(s[0].shape,s[0].dtype),d=c.values;for(let h=0;h<s.length;h++){const g=o[h];for(let _=0;_<d.length;_++)d[_]+=g[_]}return i.makeTensorInfo(c.shape,c.dtype,c.values)}const addNConfig$1={kernelName:AddN,backendName:"cpu",kernelFunc:addN$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function all$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s;assertNotComplex$1(o,"all");const h=parseAxisParam(c,o.shape);let g=h;const _=getAxesPermutation(g,o.shape.length);let b=o;_!=null&&(b=transpose$2({inputs:{x:o},backend:i,attrs:{perm:_}}),g=getInnerMostAxes(g.length,o.shape.length)),assertAxesAreInnerMostDims("all",g,b.shape.length);const[$,j]=computeOutAndReduceShapes(b.shape,g),_e=sizeFromShape(j),tt=makeZerosTypedArray(sizeFromShape($),b.dtype),et=i.data.get(b.dataId).values;for(let rt=0;rt<tt.length;++rt){const it=rt*_e;let at=et[it];for(let st=0;st<_e;++st){const ot=et[it+st];at=at&&ot}tt[rt]=at}_!=null&&i.disposeIntermediateTensorInfo(b);const nt=i.makeTensorInfo($,b.dtype,tt);if(d){const rt=expandShapeToKeepDim($,h),it=reshape$2({inputs:{x:nt},backend:i,attrs:{shape:rt}});return i.disposeIntermediateTensorInfo(nt),it}return nt}const allConfig$1={kernelName:All,backendName:"cpu",kernelFunc:all$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function any$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s;assertNotComplex$1(o,"any");const h=parseAxisParam(c,o.shape);let g=h;const _=getAxesPermutation(g,o.shape.length);let b=o;_!=null&&(b=transpose$2({inputs:{x:o},backend:i,attrs:{perm:_}}),g=getInnerMostAxes(g.length,o.shape.length)),assertAxesAreInnerMostDims("any",g,b.shape.length);const[$,j]=computeOutAndReduceShapes(b.shape,g),_e=sizeFromShape(j),tt=makeZerosTypedArray(sizeFromShape($),b.dtype),et=i.data.get(b.dataId).values;for(let rt=0;rt<tt.length;++rt){const it=rt*_e;let at=et[it];for(let st=0;st<_e;++st){const ot=et[it+st];at=at||ot}tt[rt]=at}_!=null&&i.disposeIntermediateTensorInfo(b);const nt=i.makeTensorInfo($,b.dtype,tt);if(d){const rt=expandShapeToKeepDim($,h),it=reshape$2({inputs:{x:nt},backend:i,attrs:{shape:rt}});return i.disposeIntermediateTensorInfo(nt),it}return nt}const anyConfig$1={kernelName:Any,backendName:"cpu",kernelFunc:any$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMax$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c}=s;assertNotComplex$1(o,"argMax");let d=parseAxisParam(c,o.shape);const h=getAxesPermutation(d,o.shape.length);let g=o;const _=[];h!=null&&(g=transpose$2({inputs:{x:o},backend:i,attrs:{perm:h}}),_.push(g),d=getInnerMostAxes(d.length,g.shape.length)),d=[d[0]],assertAxesAreInnerMostDims("argMax",d,g.shape.length);const[b,$]=computeOutAndReduceShapes(g.shape,d),j=sizeFromShape(b),_e=makeZerosTypedArray(j,"int32"),tt=sizeFromShape($),et=i.data.get(g.dataId).values;for(let nt=0;nt<_e.length;++nt){const rt=nt*tt;let it=et[rt],at=0;for(let st=0;st<tt;++st){const ot=et[rt+st];ot>it&&(it=ot,at=st)}_e[nt]=at}return _.forEach(nt=>i.disposeIntermediateTensorInfo(nt)),i.makeTensorInfo(b,"int32",_e)}const argMaxConfig$1={kernelName:ArgMax,backendName:"cpu",kernelFunc:argMax$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMin$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c}=s;assertNotComplex$1(o,"argMin");let d=parseAxisParam(c,o.shape);const h=getAxesPermutation(d,o.shape.length);let g=o;const _=[];h!=null&&(g=transpose$2({inputs:{x:o},backend:i,attrs:{perm:h}}),_.push(g),d=getInnerMostAxes(d.length,g.shape.length)),d=[d[0]],assertAxesAreInnerMostDims("argMin",d,g.shape.length);const[b,$]=computeOutAndReduceShapes(g.shape,d),j=sizeFromShape(b),_e=makeZerosTypedArray(j,"int32"),tt=sizeFromShape($),et=i.data.get(g.dataId).values;for(let nt=0;nt<_e.length;++nt){const rt=nt*tt;let it=et[rt],at=0;for(let st=0;st<tt;++st){const ot=et[rt+st];ot<it&&(it=ot,at=st)}_e[nt]=at}return _.forEach(nt=>i.disposeIntermediateTensorInfo(nt)),i.makeTensorInfo(b,"int32",_e)}const argMinConfig$1={kernelName:ArgMin,backendName:"cpu",kernelFunc:argMin$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const asin$2=unaryKernelFunc$1(Asin,a=>Math.asin(a)),asinConfig$1={kernelName:Asin,backendName:"cpu",kernelFunc:asin$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const asinh$2=unaryKernelFunc$1(Asinh,a=>Math.asinh(a)),asinhConfig$1={kernelName:Asinh,backendName:"cpu",kernelFunc:asinh$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atan$3=unaryKernelFunc$1(Atan,a=>Math.atan(a)),atanConfig$1={kernelName:Atan,backendName:"cpu",kernelFunc:atan$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atan2Impl=createSimpleBinaryKernelImpl((a,e)=>Math.atan2(a,e)),atan2$2=binaryKernelFunc$1(Atan2,atan2Impl),atan2Config$1={kernelName:Atan2,backendName:"cpu",kernelFunc:atan2$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const atanh$2=unaryKernelFunc$1(Atanh,a=>Math.atanh(a)),atanhConfig$1={kernelName:Atanh,backendName:"cpu",kernelFunc:atanh$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pool$1(a,e,i,s,o,c){const d=o.strideHeight,h=o.strideWidth,g=o.dilationHeight,_=o.dilationWidth,b=o.effectiveFilterHeight,$=o.effectiveFilterWidth,j=o.padInfo.top,_e=o.padInfo.left,tt=c==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,et=buffer(o.outShape,i),nt=et.values,rt=o.outShape[1]*o.outShape[2]*o.outShape[3],it=o.outShape[2]*o.outShape[3],at=o.outShape[3];for(let st=0;st<o.batchSize;++st){const ot=st*rt,ct=st*s[0];for(let lt=0;lt<o.inChannels;++lt)for(let dt=0;dt<o.outHeight;++dt){const xt=dt*d-j,ut=Math.max(0,xt),ft=Math.min(o.inHeight,b+xt),mt=ot+dt*it;for(let yt=0;yt<o.outWidth;++yt){const St=yt*h-_e,Et=Math.max(0,St),vt=Math.min(o.inWidth,$+St);let Nt=tt,wt=0,$t=0;for(let Mt=ut;Mt<ft;Mt+=g){const Ot=ct+Mt*s[1];for(let Dt=Et;Dt<vt;Dt+=_){const At=Ot+Dt*s[2],kt=a[At+lt];c==="max"&&kt>Nt?Nt=kt:c==="avg"&&(wt+=kt,$t++)}if(isNaN(Nt))break}const Ct=mt+yt*at+lt;nt[Ct]=c==="avg"?wt/$t:Nt}}}return et}function maxPoolPositions(a,e,i,s,o=!1,c=!1){const d=buffer(s.outShape,"int32"),h=s.strideHeight,g=s.strideWidth,_=s.dilationHeight,b=s.dilationWidth,$=s.effectiveFilterHeight,j=s.effectiveFilterWidth,_e=s.padInfo.top,tt=s.padInfo.left,et=buffer(e,i,a);for(let nt=0;nt<s.batchSize;++nt)for(let rt=0;rt<s.inChannels;++rt)for(let it=0;it<s.outHeight;++it){const at=it*h-_e;let st=at;for(;st<0;)st+=_;const ot=Math.min(s.inHeight,$+at);for(let ct=0;ct<s.outWidth;++ct){const lt=ct*g-tt;let dt=lt;for(;dt<0;)dt+=b;const xt=Math.min(s.inWidth,j+lt);let ut=Number.NEGATIVE_INFINITY,ft=-1;for(let mt=st;mt<ot;mt+=_){const yt=mt-at;for(let St=dt;St<xt;St+=b){const Et=St-lt,vt=et.get(nt,mt,St,rt);vt>ut&&(ut=vt,o?ft=c?((nt*s.inHeight+mt)*s.inWidth+St)*s.inChannels+rt:(mt*s.inWidth+St)*s.inChannels+rt:ft=yt*j+Et)}}d.set(ft,nt,it,ct,rt)}}return d}function pool3d(a,e,i,s,o,c){const d=o.strideDepth,h=o.strideHeight,g=o.strideWidth,_=o.dilationDepth,b=o.dilationHeight,$=o.dilationWidth,j=o.effectiveFilterDepth,_e=o.effectiveFilterHeight,tt=o.effectiveFilterWidth,et=o.padInfo.front,nt=o.padInfo.top,rt=o.padInfo.left,it=c==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,at=buffer(o.outShape,i),st=at.values,ot=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],ct=o.outShape[2]*o.outShape[3]*o.outShape[4],lt=o.outShape[3]*o.outShape[4],dt=o.outShape[4];for(let xt=0;xt<o.batchSize;++xt){const ut=xt*ot,ft=xt*s[0];for(let mt=0;mt<o.inChannels;++mt)for(let yt=0;yt<o.outDepth;++yt){const St=yt*d-et;let Et=St;for(;Et<0;)Et+=_;const vt=Math.min(o.inDepth,j+St),Nt=ut+yt*ct;for(let wt=0;wt<o.outHeight;++wt){const $t=wt*h-nt;let Ct=$t;for(;Ct<0;)Ct+=b;const Mt=Math.min(o.inHeight,_e+$t),Ot=Nt+wt*lt;for(let Dt=0;Dt<o.outWidth;++Dt){const At=Dt*g-rt;let kt=At;for(;kt<0;)kt+=$;const Ft=Math.min(o.inWidth,tt+At),Bt=Ot+Dt*dt;let Ht=it,Wt=0,Ut=0;for(let un=Et;un<vt;un+=_){const rn=ft+un*s[1];for(let mn=Ct;mn<Mt;mn+=b){const sn=rn+mn*s[2];for(let hn=kt;hn<Ft;hn+=$){const gn=sn+hn*s[3],Xt=a[gn+mt];if(c==="max"&&Xt>Ht?Ht=Xt:c==="avg"&&(Wt+=Xt,Ut++),isNaN(Ht))break}if(isNaN(Ht))break}if(isNaN(Ht))break}const Rt=Bt+mt;st[Rt]=c==="avg"?Wt/Ut:Ht}}}}return at}function maxPool3dPositions(a,e){const i=buffer(e.outShape,"int32"),s=e.strideDepth,o=e.strideHeight,c=e.strideWidth,d=e.dilationDepth,h=e.dilationHeight,g=e.dilationWidth,_=e.effectiveFilterDepth,b=e.effectiveFilterHeight,$=e.effectiveFilterWidth,j=e.padInfo.front,_e=e.padInfo.top,tt=e.padInfo.left;for(let et=0;et<e.batchSize;++et)for(let nt=0;nt<e.inChannels;++nt)for(let rt=0;rt<e.outDepth;++rt){const it=rt*s-j;let at=it;for(;at<0;)at+=d;const st=Math.min(e.inDepth,_+it);for(let ot=0;ot<e.outHeight;++ot){const ct=ot*o-_e;let lt=ct;for(;lt<0;)lt+=h;const dt=Math.min(e.inHeight,b+ct);for(let xt=0;xt<e.outWidth;++xt){const ut=xt*c-tt;let ft=ut;for(;ft<0;)ft+=g;const mt=Math.min(e.inWidth,$+ut);let yt=Number.NEGATIVE_INFINITY,St=-1;for(let Et=at;Et<st;Et+=d){const vt=Et-it;for(let Nt=lt;Nt<dt;Nt+=h){const wt=Nt-ct;for(let $t=ft;$t<mt;$t+=g){const Ct=$t-ut,Mt=a.get(et,Et,Nt,$t,nt);Mt>=yt&&(yt=Mt,St=vt*b*$+wt*b+Ct)}}}i.set(St,et,rt,ot,xt,nt)}}}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e;assertNotComplex$1(o,"avgPool");const{filterSize:c,strides:d,pad:h,dimRoundingMode:g}=s,_=1;assert$1(eitherStridesOrDilationsAreOne(d,_),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '${_}'`);const b=computePool2DInfo(o.shape,c,d,_,h,g);let $;if(b.filterWidth===1&&b.filterHeight===1&&arraysEqual(b.inShape,b.outShape))$=identity$2({inputs:{x:o},backend:i});else{const j=i.data.get(o.dataId).values,_e=computeStrides(o.shape),tt=pool$1(j,o.shape,o.dtype,_e,b,"avg");$=i.makeTensorInfo(b.outShape,o.dtype,tt.values)}return $}const avgPoolConfig$1={kernelName:AvgPool,backendName:"cpu",kernelFunc:avgPool$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3D$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{filterSize:c,strides:d,pad:h,dimRoundingMode:g,dataFormat:_}=s;assertNotComplex$1(o,"avgPool3d");const b=computePool3DInfo(o.shape,c,d,1,h,g,_),$=i.data.get(o.dataId).values,j=pool3d($,o.shape,o.dtype,computeStrides(o.shape),b,"avg");return i.makeTensorInfo(j.shape,"float32",j.values)}const avgPool3DConfig$1={kernelName:AvgPool3D,backendName:"cpu",kernelFunc:avgPool3D$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3DGrad$1(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c}=e,{filterSize:d,strides:h,pad:g,dimRoundingMode:_}=s;assertNotComplex$1([o,c],"avgPool3DGrad");const b=computePool3DInfo(c.shape,d,h,1,g,_),$=b.strideDepth,j=b.strideHeight,_e=b.strideWidth,tt=b.filterDepth,et=b.filterHeight,nt=b.filterWidth,rt=b.dilationDepth,it=b.dilationHeight,at=b.dilationWidth,st=b.effectiveFilterDepth,ot=b.effectiveFilterHeight,ct=b.effectiveFilterWidth,lt=st-1-b.padInfo.front,dt=ct-1-b.padInfo.left,xt=ot-1-b.padInfo.top,ut=buffer(c.shape,"float32"),ft=1/(tt*et*nt),mt=i.bufferSync(o);for(let yt=0;yt<b.batchSize;++yt)for(let St=0;St<b.inChannels;++St)for(let Et=0;Et<b.inDepth;++Et)for(let vt=0;vt<b.inHeight;++vt)for(let Nt=0;Nt<b.inWidth;++Nt){const wt=Et-lt,$t=vt-xt,Ct=Nt-dt;let Mt=0;for(let Ot=0;Ot<st;Ot+=rt){const Dt=(wt+Ot)/$;if(!(Dt<0||Dt>=b.outDepth||Math.floor(Dt)!==Dt))for(let At=0;At<ot;At+=it){const kt=($t+At)/j;if(!(kt<0||kt>=b.outHeight||Math.floor(kt)!==kt))for(let Ft=0;Ft<ct;Ft+=at){const Bt=(Ct+Ft)/_e;if(Bt<0||Bt>=b.outWidth||Math.floor(Bt)!==Bt)continue;const Ht=mt.get(yt,Dt,kt,Bt,St);Mt+=Ht}}}ut.set(Mt*ft,yt,Et,vt,Nt,St)}return i.makeTensorInfo(ut.shape,ut.dtype,ut.values)}const avgPool3DGradConfig={kernelName:AvgPool3DGrad,backendName:"cpu",kernelFunc:avgPool3DGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPoolGrad$1(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c}=e,d=c;assertNotComplex$1([o,c],"avgPoolGrad");const{filterSize:h,strides:g,pad:_}=s,b=computePool2DInfo(d.shape,h,g,1,_),$=b.strideHeight,j=b.strideWidth,_e=b.filterHeight,tt=b.filterWidth,et=b.dilationHeight,nt=b.dilationWidth,rt=b.effectiveFilterHeight,it=b.effectiveFilterWidth,at=it-1-b.padInfo.left,st=rt-1-b.padInfo.top,ot=buffer(d.shape,"float32"),ct=1/(_e*tt),lt=i.data.get(o.dataId).values,dt=buffer(o.shape,"float32",lt);for(let xt=0;xt<b.batchSize;++xt)for(let ut=0;ut<b.inChannels;++ut)for(let ft=0;ft<b.inHeight;++ft)for(let mt=0;mt<b.inWidth;++mt){const yt=ft-st,St=mt-at;let Et=0;for(let vt=0;vt<rt;vt+=et){const Nt=(yt+vt)/$;if(!(Nt<0||Nt>=b.outHeight||Math.floor(Nt)!==Nt))for(let wt=0;wt<it;wt+=nt){const $t=(St+wt)/j;if($t<0||$t>=b.outWidth||Math.floor($t)!==$t)continue;const Ct=dt.get(xt,Nt,$t,ut);Et+=Ct}}ot.set(Et*ct,xt,ft,mt,ut)}return i.makeTensorInfo(ot.shape,ot.dtype,ot.values)}const avgPoolGradConfig$1={kernelName:AvgPoolGrad,backendName:"cpu",kernelFunc:avgPoolGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchNorm$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,scale:c,offset:d,mean:h,variance:g}=e;assert$1(h.shape.length===g.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),assert$1(d==null||h.shape.length===d.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),assert$1(c==null||h.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),assertNotComplex$1([o,h,g,c,d],"batchNorm");let{varianceEpsilon:_}=s;_==null&&(_=.001);const b=i.data.get(o.dataId).values,$=i.data.get(h.dataId).values,j=i.data.get(g.dataId).values,_e=c?i.data.get(c.dataId).values:new Float32Array([1]),tt=d?i.data.get(d.dataId).values:new Float32Array([0]),et=new Float32Array(b.length),nt=tt.length,rt=_e.length,it=j.length,at=$.length;let st=0,ot=0,ct=0,lt=0;for(let dt=0;dt<b.length;++dt)et[dt]=tt[st++]+(b[dt]-$[ot++])*_e[ct++]/Math.sqrt(j[lt++]+_),st>=nt&&(st=0),ot>=at&&(ot=0),ct>=rt&&(ct=0),lt>=it&&(lt=0);return i.makeTensorInfo(o.shape,o.dtype,et)}const batchNormConfig$1={kernelName:FusedBatchNorm,backendName:"cpu",kernelFunc:batchNorm$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchToSpaceND$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{blockShape:c,crops:d}=s;assertNotComplex$1([o],"batchToSpaceND");const h=c.reduce((rt,it)=>rt*it),g=getReshaped(o.shape,c,h),_=getPermuted(g.length,c.length),b=getReshapedPermuted(o.shape,c,h),$=getSliceBeginCoords(d,c.length),j=getSliceSize(b,d,c.length),_e=reshape$2({inputs:{x:o},backend:i,attrs:{shape:g}}),tt=transpose$2({inputs:{x:_e},backend:i,attrs:{perm:_}}),et=reshape$2({inputs:{x:tt},backend:i,attrs:{shape:b}}),nt=slice$1({inputs:{x:et},backend:i,attrs:{begin:$,size:j}});return i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(tt),i.disposeIntermediateTensorInfo(et),nt}const batchToSpaceNDConfig$1={kernelName:BatchToSpaceND,backendName:"cpu",kernelFunc:batchToSpaceND$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincount$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,weights:c}=e,{size:d}=s,h=i.data.get(o.dataId).values,g=i.data.get(c.dataId).values,_=bincountImpl(h,g,c.dtype,c.shape,d);return i.makeTensorInfo([d],c.dtype,_)}const bincountConfig$1={kernelName:Bincount,backendName:"cpu",kernelFunc:bincount$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const clip=unaryKernelFunc$1(ClipByValue,(a,e)=>{const i=e;return a>i.clipValueMax?i.clipValueMax:a<i.clipValueMin?i.clipValueMin:a}),clipConfig={kernelName:ClipByValue,backendName:"cpu",kernelFunc:clip};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const complexAbs$1=a=>{const{x:e}=a.inputs,i=a.backend,s=new Float32Array(sizeFromShape(e.shape)),o=i.data.get(e.dataId),c=o.complexTensorInfos.real,d=o.complexTensorInfos.imag,h=i.data.get(c.dataId).values,g=i.data.get(d.dataId).values;for(let _=0;_<h.length;_++){const b=h[_],$=g[_];s[_]=Math.hypot(b,$)}return i.makeOutput(s,e.shape,"float32")},complexAbsConfig$1={kernelName:ComplexAbs,backendName:"cpu",kernelFunc:complexAbs$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag$1(a){const{inputs:e,backend:i}=a,{input:s}=e,o=i.data.get(s.dataId).complexTensorInfos.imag,c=i.data.get(o.dataId).values;return i.makeTensorInfo(o.shape,o.dtype,c)}const imagConfig$1={kernelName:Imag,backendName:"cpu",kernelFunc:imag$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat$2(a){const{inputs:e,backend:i,attrs:s}=a,{axis:o}=s,c=parseAxisParam(o,e[0].shape)[0];let d=computeOutShape$1(e.map(et=>et.shape),c);if(sizeFromShape(d)===0)return i.makeTensorInfo(d,e[0].dtype,[]);const h=e.filter(et=>sizeFromShape(et.shape)>0);if(h.length===1)return identity$2({inputs:{x:h[0]},backend:i});const g=h.map(et=>et.shape);if(assertParamsConsistent(g,c),h[0].dtype==="complex64"){const et=h.map(st=>real$1({inputs:{input:st},backend:i})),nt=h.map(st=>imag$1({inputs:{input:st},backend:i})),rt=concat$2({inputs:et,backend:i,attrs:{axis:c}}),it=concat$2({inputs:nt,backend:i,attrs:{axis:c}}),at=complex$3({inputs:{real:rt,imag:it},backend:i});return et.forEach(st=>i.disposeIntermediateTensorInfo(st)),nt.forEach(st=>i.disposeIntermediateTensorInfo(st)),i.disposeIntermediateTensorInfo(rt),i.disposeIntermediateTensorInfo(it),at}const _=h.map(et=>{const rt=[-1,sizeFromShape(et.shape.slice(c))];return reshape$2({inputs:{x:et},backend:i,attrs:{shape:rt}})}),b=_.map(et=>({vals:i.data.get(et.dataId).values,shape:et.shape}));d=computeOutShape$1(_.map(et=>et.shape),1);const $=_[0].shape[0]===1,j=concatImpl$1(b,d,e[0].dtype,$),_e=computeOutShape$1(h.map(et=>et.shape),c),tt=i.makeTensorInfo(_e,e[0].dtype,j);return _.forEach(et=>i.disposeIntermediateTensorInfo(et)),tt}const concatConfig$1={kernelName:Concat,backendName:"cpu",kernelFunc:concat$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dataFormat:g,dilations:_,dimRoundingMode:b}=s;assertNotComplex$1([o,c],"conv2d");const $=convertConv2DDataFormat(g),j=computeConv2DInfo(o.shape,c.shape,d,_,h,b,!1,$),_e=j.filterHeight,tt=j.filterWidth,et=j.dilationHeight,nt=j.dilationWidth,rt=j.padInfo.left,it=j.padInfo.top,at=j.dataFormat==="channelsLast",st=new TensorBuffer(j.outShape,o.dtype),ot=computeStrides(o.shape),ct=computeStrides(c.shape),lt=ot[0],dt=at?ot[1]:ot[2],xt=at?ot[2]:1,ut=at?1:ot[1],ft=st.strides[0],mt=at?st.strides[1]:st.strides[2],yt=at?st.strides[2]:1,St=at?1:st.strides[1],Et=i.data.get(o.dataId).values,vt=i.data.get(c.dataId).values,Nt=st.values;for(let wt=0;wt<j.batchSize;++wt){const $t=wt*lt,Ct=wt*ft;for(let Mt=0;Mt<j.outHeight;++Mt){const Ot=Ct+Mt*mt,Dt=Mt*j.strideHeight-it;for(let At=0;At<_e;++At){const kt=Dt+At*et;if(kt<0||kt>=j.inHeight)continue;const Ft=At*ct[0],Bt=$t+kt*dt;for(let Ht=0;Ht<j.outWidth;++Ht){const Wt=Ot+Ht*yt,Ut=Ht*j.strideWidth-rt;for(let Rt=0;Rt<tt;++Rt){const un=Ut+Rt*nt;if(un<0||un>=j.inWidth)continue;const rn=Ft+Rt*ct[1],mn=Bt+un*xt;let sn=rn;for(let hn=0;hn<j.inChannels;++hn){const gn=Et[mn+hn*ut];for(let Xt=0;Xt<j.outChannels;++Xt)Nt[Wt+Xt*St]+=gn*vt[sn+Xt];sn+=j.outChannels}}}}}}return i.makeTensorInfo(st.shape,st.dtype,Nt)}const conv2DConfig$1={kernelName:Conv2D$1,backendName:"cpu",kernelFunc:conv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropFilter$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,dy:c}=e,{strides:d,pad:h,dataFormat:g,dimRoundingMode:_,filterShape:b}=s;assertNotComplex$1([o,c],"conv2dBackpropFilter");const $=convertConv2DDataFormat(g),j=computeConv2DInfo(o.shape,b,d,1,h,_,!1,$),{strideHeight:_e,strideWidth:tt,filterHeight:et,filterWidth:nt}=j,rt=j.dataFormat==="channelsLast",it=new TensorBuffer(j.filterShape,"float32"),at=j.padInfo.left,st=j.padInfo.top,ot=i.data.get(o.dataId).values,ct=i.data.get(c.dataId).values,lt=new TensorBuffer(o.shape,o.dtype,ot),dt=new TensorBuffer(c.shape,c.dtype,ct);for(let xt=0;xt<et;++xt){const ut=Math.max(0,Math.ceil((st-xt)/_e)),ft=Math.min(j.outHeight,(j.inHeight+st-xt)/_e);for(let mt=0;mt<nt;++mt){const yt=Math.max(0,Math.ceil((at-mt)/tt)),St=Math.min(j.outWidth,(j.inWidth+at-mt)/tt);for(let Et=0;Et<j.inChannels;++Et)for(let vt=0;vt<j.outChannels;++vt){let Nt=0;for(let wt=0;wt<j.batchSize;++wt)for(let $t=ut;$t<ft;++$t){const Ct=xt+$t*_e-st;for(let Mt=yt;Mt<St;++Mt){const Ot=mt+Mt*tt-at;rt?Nt+=lt.get(wt,Ct,Ot,Et)*dt.get(wt,$t,Mt,vt):Nt+=lt.get(wt,Et,Ct,Ot)*dt.get(wt,vt,$t,Mt)}}it.set(Nt,xt,mt,Et,vt)}}}return i.makeTensorInfo(it.shape,it.dtype,it.values)}const conv2DBackpropFilterConfig$1={kernelName:Conv2DBackpropFilter,backendName:"cpu",kernelFunc:conv2DBackpropFilter$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropInput$1(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,filter:c}=e,{inputShape:d,strides:h,pad:g,dataFormat:_,dimRoundingMode:b}=s;assertNotComplex$1([o,c],"conv2dBackpropInput");const $=computeStrides(c.shape),j=computeStrides(o.shape);let _e=convertConv2DDataFormat(_);const tt=computeConv2DInfo(d,c.shape,h,1,g,b,!1,_e),et=new TensorBuffer(tt.inShape,"float32"),nt=et.values,rt=i.data.get(o.dataId).values,it=i.data.get(c.dataId).values,[at,st,ot]=$,{batchSize:ct,filterHeight:lt,filterWidth:dt,inChannels:xt,inHeight:ut,inWidth:ft,outChannels:mt,outHeight:yt,outWidth:St,strideHeight:Et,strideWidth:vt}=tt;_e=tt.dataFormat;const Nt=lt-1-tt.padInfo.top,wt=dt-1-tt.padInfo.left,$t=_e==="channelsLast",Ct=et.strides[0],Mt=$t?et.strides[1]:et.strides[2],Ot=$t?et.strides[2]:1,Dt=$t?1:et.strides[1],At=j[0],kt=$t?j[1]:j[2],Ft=$t?j[2]:1,Bt=$t?1:j[1];for(let Ht=0;Ht<ct;++Ht)for(let Wt=0;Wt<xt;++Wt)for(let Ut=0;Ut<ut;++Ut){const Rt=Ut-Nt,un=Math.max(0,Math.ceil(Rt/Et)),rn=Math.min(yt,(lt+Rt)/Et);for(let mn=0;mn<ft;++mn){const sn=mn-wt,hn=Math.max(0,Math.ceil(sn/vt)),gn=Math.min(St,(dt+sn)/vt);let Xt=0;for(let bt=un;bt<rn;++bt){const gt=bt*Et-Rt;for(let Pt=hn;Pt<gn;++Pt){const Lt=Pt*vt-sn,Vt=At*Ht+kt*bt+Ft*Pt,jt=at*(lt-1-gt)+st*(dt-1-Lt)+ot*Wt;for(let cn=0;cn<mt;++cn){const en=rt[Vt+Bt*cn],Zt=it[jt+cn];Xt+=en*Zt}}}const En=Ct*Ht+Mt*Ut+Ot*mn+Dt*Wt;nt[En]=Xt}}return i.makeTensorInfo(et.shape,et.dtype,et.values)}const conv2DBackpropInputConfig$1={kernelName:Conv2DBackpropInput,backendName:"cpu",kernelFunc:conv2DBackpropInput$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3D$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dilations:g}=s;assertNotComplex$1([o,c],"conv3d");const _=computeConv3DInfo(o.shape,c.shape,d,g,h),{filterDepth:b,filterHeight:$,filterWidth:j,dilationDepth:_e,dilationHeight:tt,dilationWidth:et,padInfo:nt}=_,rt=nt.front,it=nt.left,at=nt.top,st=new TensorBuffer(_.outShape,o.dtype),ot=i.data.get(o.dataId).values,ct=i.data.get(c.dataId).values,lt=st.values,dt=computeStrides(o.shape),xt=computeStrides(c.shape);for(let ut=0;ut<_.batchSize;++ut){const ft=ut*dt[0],mt=ut*st.strides[0];for(let yt=0;yt<_.outDepth;++yt){const St=mt+yt*st.strides[1],Et=yt*_.strideDepth-rt;for(let vt=0;vt<b;++vt){const Nt=Et+vt*_e;if(Nt<0||Nt>=_.inDepth)continue;const wt=vt*xt[0],$t=ft+Nt*dt[1];for(let Ct=0;Ct<_.outHeight;++Ct){const Mt=St+Ct*st.strides[2],Ot=Ct*_.strideHeight-at;for(let Dt=0;Dt<$;++Dt){const At=Ot+Dt*tt;if(At<0||At>=_.inHeight)continue;const kt=wt+Dt*xt[1],Ft=$t+At*dt[2];for(let Bt=0;Bt<_.outWidth;++Bt){const Ht=Mt+Bt*_.outChannels,Wt=Bt*_.strideWidth-it;for(let Ut=0;Ut<j;++Ut){const Rt=Wt+Ut*et;if(Rt<0||Rt>=_.inWidth)continue;const un=kt+Ut*xt[2],rn=Ft+Rt*_.inChannels;let mn=un;for(let sn=0;sn<_.inChannels;++sn){const hn=ot[rn+sn];for(let gn=0;gn<_.outChannels;++gn)lt[Ht+gn]+=hn*ct[mn+gn];mn+=_.outChannels}}}}}}}}return i.makeTensorInfo(st.shape,st.dtype,st.values)}const conv3DConfig$1={kernelName:Conv3D$1,backendName:"cpu",kernelFunc:conv3D$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropFilterV2$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,dy:c}=e,{strides:d,pad:h,filterShape:g}=s;assertNotComplex$1([o,c],"conv3dBackpropFilterV2");const _=computeStrides(o.shape),b=computeStrides(c.shape),$=computeConv3DInfo(o.shape,g,d,1,h),j=$.strideDepth,_e=$.strideHeight,tt=$.strideWidth,et=$.filterDepth,nt=$.filterHeight,rt=$.filterWidth,it=new TensorBuffer($.filterShape,"float32"),at=it.values,[st,ot,ct,lt]=it.strides,dt=i.data.get(c.dataId).values,[xt,ut,ft,mt]=b,yt=i.data.get(o.dataId).values,[St,Et,vt,Nt]=_,wt=$.padInfo.front,$t=$.padInfo.left,Ct=$.padInfo.top;for(let Mt=0;Mt<et;++Mt){const Ot=Math.max(0,Math.ceil((wt-Mt)/j)),Dt=Math.min($.outDepth,($.inDepth+wt-Mt)/j),At=Mt*st;for(let kt=0;kt<nt;++kt){const Ft=Math.max(0,Math.ceil((Ct-kt)/_e)),Bt=Math.min($.outHeight,($.inHeight+Ct-kt)/_e),Ht=kt*ot+At;for(let Wt=0;Wt<rt;++Wt){const Ut=Math.max(0,Math.ceil(($t-Wt)/tt)),Rt=Math.min($.outWidth,($.inWidth+$t-Wt)/tt),un=Wt*ct+Ht;for(let rn=0;rn<$.inChannels;++rn){const mn=rn*lt+un;for(let sn=0;sn<$.outChannels;++sn){let hn=0;for(let gn=0;gn<$.batchSize;++gn){const Xt=gn*St,En=gn*xt;for(let bt=Ot;bt<Dt;++bt){const Pt=(Mt+bt*j-wt)*Et+Xt,Lt=bt*ut+En;for(let Vt=Ft;Vt<Bt;++Vt){const cn=(kt+Vt*_e-Ct)*vt+Pt,en=Vt*ft+Lt;for(let Zt=Ut;Zt<Rt;++Zt){const pn=(Wt+Zt*tt-$t)*Nt+cn,wn=Zt*mt+en;hn+=yt[pn+rn]*dt[wn+sn]}}}}at[mn+sn]=hn}}}}}return i.makeTensorInfo(it.shape,it.dtype,it.values)}const conv3DBackpropFilterV2Config$1={kernelName:Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:conv3DBackpropFilterV2$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInputV2(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,filter:c}=e,{pad:d,strides:h,inputShape:g}=s;assertNotComplex$1([o],"conv3dBackpropInputV2");const _=computeStrides(o.shape),b=computeStrides(c.shape),$=computeConv3DInfo(g,c.shape,h,1,d),j=new TensorBuffer($.inShape,"float32"),_e=j.values,[tt,et,nt,rt]=j.strides,it=i.data.get(o.dataId).values,[at,st,ot,ct]=_,lt=i.data.get(c.dataId).values,[dt,xt,ut,ft]=b,{batchSize:mt,filterDepth:yt,filterHeight:St,filterWidth:Et,inChannels:vt,inDepth:Nt,inHeight:wt,inWidth:$t,outChannels:Ct,outDepth:Mt,outHeight:Ot,outWidth:Dt,strideDepth:At,strideHeight:kt,strideWidth:Ft}=$,Bt=yt-1-$.padInfo.front,Ht=St-1-$.padInfo.top,Wt=Et-1-$.padInfo.left;for(let Ut=0;Ut<mt;++Ut)for(let Rt=0;Rt<vt;++Rt)for(let un=0;un<Nt;++un){const rn=un-Bt,mn=Math.max(0,Math.ceil(rn/At)),sn=Math.min(Mt,(yt+rn)/At);for(let hn=0;hn<wt;++hn){const gn=hn-Ht,Xt=Math.max(0,Math.ceil(gn/kt)),En=Math.min(Ot,(St+gn)/kt);for(let bt=0;bt<$t;++bt){const gt=bt-Wt,Pt=Math.max(0,Math.ceil(gt/Ft)),Lt=Math.min(Dt,(Et+gt)/Ft);let Vt=0;for(let jt=mn;jt<sn;++jt){const cn=jt*At-rn;for(let en=Xt;en<En;++en){const Zt=en*kt-gn;for(let yn=Pt;yn<Lt;++yn){const pn=yn*Ft-gt,wn=at*Ut+st*jt+ot*en+ct*yn,Pn=dt*(yt-1-cn)+xt*(St-1-Zt)+ut*(Et-1-pn)+ft*Rt;for(let Rn=0;Rn<Ct;++Rn){const Sn=it[wn+Rn],On=lt[Pn+Rn];Vt+=Sn*On}}}}_e[tt*Ut+et*un+nt*hn+rt*bt+Rt]=Vt}}}return i.makeTensorInfo(j.shape,j.dtype,j.values)}const conv3DBackpropInputV2Config={kernelName:Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:conv3DBackpropInputV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cos$3=unaryKernelFunc$1(Cos,a=>Math.cos(a)),cosConfig$1={kernelName:Cos,backendName:"cpu",kernelFunc:cos$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cosh$2=unaryKernelFunc$1(Cosh,a=>Math.cosh(a)),coshConfig$1={kernelName:Cosh,backendName:"cpu",kernelFunc:cosh$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cropAndResize$1(a){const{inputs:e,backend:i,attrs:s}=a,{image:o,boxes:c,boxInd:d}=e,{cropSize:h,method:g,extrapolationValue:_}=s,[b,$,j,_e]=o.shape,tt=c.shape[0],[et,nt]=h,rt=buffer([tt,et,nt,_e],"float32"),it=i.data.get(c.dataId).values,at=i.data.get(d.dataId).values,st=i.data.get(o.dataId).values,ot=computeStrides(o.shape),ct=computeStrides(rt.shape);for(let lt=0;lt<tt;lt++){const dt=lt*4,xt=it[dt],ut=it[dt+1],ft=it[dt+2],mt=it[dt+3],yt=at[lt];if(yt>=b)continue;const St=et>1?(ft-xt)*($-1)/(et-1):0,Et=nt>1?(mt-ut)*(j-1)/(nt-1):0;for(let vt=0;vt<et;vt++){const Nt=et>1?xt*($-1)+vt*St:.5*(xt+ft)*($-1);if(Nt<0||Nt>$-1){for(let wt=0;wt<nt;wt++)for(let $t=0;$t<_e;$t++){const Ct=$t+wt*ct[2]+vt*ct[1]+lt*ct[0];rt.values[Ct]=_}continue}if(g==="bilinear"){const wt=Math.floor(Nt),$t=Math.ceil(Nt),Ct=Nt-wt;for(let Mt=0;Mt<nt;Mt++){const Ot=nt>1?ut*(j-1)+Mt*Et:.5*(ut+mt)*(j-1);if(Ot<0||Ot>j-1){for(let Ft=0;Ft<_e;Ft++){const Bt=Ft+Mt*ct[2]+vt*ct[1]+lt*ct[0];rt.values[Bt]=_}continue}const Dt=Math.floor(Ot),At=Math.ceil(Ot),kt=Ot-Dt;for(let Ft=0;Ft<_e;Ft++){let Bt=Ft+Dt*ot[2]+wt*ot[1]+yt*ot[0];const Ht=st[Bt];Bt=Ft+At*ot[2]+wt*ot[1]+yt*ot[0];const Wt=st[Bt];Bt=Ft+Dt*ot[2]+$t*ot[1]+yt*ot[0];const Ut=st[Bt];Bt=Ft+At*ot[2]+$t*ot[1]+yt*ot[0];const Rt=st[Bt],un=Ht+(Wt-Ht)*kt,rn=Ut+(Rt-Ut)*kt;Bt=Ft+Mt*ct[2]+vt*ct[1]+lt*ct[0],rt.values[Bt]=un+(rn-un)*Ct}}}else for(let wt=0;wt<nt;++wt){const $t=nt>1?ut*(j-1)+wt*Et:.5*(ut+mt)*(j-1);if($t<0||$t>j-1){for(let Ot=0;Ot<_e;Ot++){const Dt=Ot+wt*ct[2]+vt*ct[1]+lt*ct[0];rt.values[Dt]=_}continue}const Ct=Math.round($t),Mt=Math.round(Nt);for(let Ot=0;Ot<_e;Ot++){const Dt=Ot+Ct*ot[2]+Mt*ot[1]+yt*ot[0],At=Ot+wt*ct[2]+vt*ct[1]+lt*ct[0];rt.values[At]=st[Dt]}}}}return i.makeTensorInfo(rt.shape,rt.dtype,rt.values)}const cropAndResizeConfig$1={kernelName:CropAndResize,backendName:"cpu",kernelFunc:cropAndResize$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumsum$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,exclusive:d,reverse:h}=s;assertNotComplex$1(o,"cumsum");const g=getAxesPermutation([c],o.shape.length);let _=o;g!=null&&(_=transpose$2({inputs:{x:o},backend:i,attrs:{perm:g}}));const b=getInnerMostAxes(1,o.shape.length)[0];if(b!==_.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${_.shape.length-1} but got axis=${b}`);const $=upcastType(_.dtype,"int32"),j=makeZerosTypedArray(sizeFromShape(_.shape),$),_e=i.data.get(_.dataId).values,tt=_.shape[_.shape.length-1],et=h?(rt,it)=>rt+tt-it-1:(rt,it)=>rt+it;for(let rt=0;rt<_e.length;rt+=tt)for(let it=0;it<tt;it++){const at=et(rt,it);if(it===0)j[at]=d?0:_e[at];else{const st=et(rt,it-1);j[at]=d?_e[st]+j[st]:_e[at]+j[st]}}const nt=i.makeTensorInfo(_.shape,$,j);if(g!=null){const rt=getUndoAxesPermutation(g),it=transpose$2({inputs:{x:nt},backend:i,attrs:{perm:rt}});return i.disposeIntermediateTensorInfo(nt),i.disposeIntermediateTensorInfo(_),it}return nt}const cumsumConfig$1={kernelName:Cumsum,backendName:"cpu",kernelFunc:cumsum$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function denseBincount$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,weights:c}=e,{size:d,binaryOutput:h}=s;if(o.shape.length===1){const g=i.data.get(o.dataId).values,_=i.data.get(c.dataId).values,b=bincountImpl(g,_,c.dtype,c.shape,d);return i.makeTensorInfo([d],c.dtype,b)}else if(o.shape.length===2){const g=i.bufferSync(o),_=i.bufferSync(c),b=bincountReduceImpl(g,_,d,h);return i.makeTensorInfo(b.shape,c.dtype,b.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}const denseBincountConfig$1={kernelName:DenseBincount,backendName:"cpu",kernelFunc:denseBincount$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthToSpace$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{blockSize:c,dataFormat:d}=s;assert$1(d==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${d}`),assert$1(c>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${c}`);const h=o.shape[0],g=o.shape[1],_=o.shape[2],b=o.shape[3],$=g*c,j=_*c,_e=b/(c*c),tt=i.data.get(o.dataId).values,et=new Float32Array(h*$*j*_e);let nt=0;for(let rt=0;rt<h;++rt)for(let it=0;it<$;++it){const at=Math.floor(it/c),st=it%c;for(let ot=0;ot<j;++ot){const ct=Math.floor(ot/c),lt=ot%c,dt=(st*c+lt)*_e;for(let xt=0;xt<_e;++xt){const ft=xt+dt+b*(ct+_*(at+g*rt));et[nt++]=tt[ft]}}}return i.makeTensorInfo([h,$,j,_e],o.dtype,et)}const depthToSpaceConfig$1={kernelName:DepthToSpace,backendName:"cpu",kernelFunc:depthToSpace$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNative$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dilations:g,dimRoundingMode:_}=s;assertNotComplex$1([o,c],"depthwiseConv2DNative");const b=computeStrides(o.shape),$=computeStrides(c.shape);let j=g;j==null&&(j=[1,1]),assert$1(eitherStridesOrDilationsAreOne(d,j),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${j}'`);const _e=computeConv2DInfo(o.shape,c.shape,d,j,h,_,!0),{filterHeight:tt,filterWidth:et,dilationHeight:nt,dilationWidth:rt,padInfo:it}=_e,at=it.left,st=it.top,ot=_e.outChannels/_e.inChannels,ct=new TensorBuffer(_e.outShape,o.dtype),lt=i.data.get(o.dataId).values,dt=i.data.get(c.dataId).values,xt=ct.values;for(let ut=0;ut<_e.batchSize;++ut){const ft=ut*b[0],mt=ut*ct.strides[0];for(let yt=0;yt<_e.outHeight;++yt){const St=mt+yt*ct.strides[1],Et=yt*_e.strideHeight-at;for(let vt=0;vt<tt;++vt){const Nt=Et+vt*nt;if(Nt<0||Nt>=_e.inHeight)continue;const wt=vt*$[0],$t=ft+Nt*b[1];for(let Ct=0;Ct<_e.outWidth;++Ct){const Mt=St+Ct*ct.strides[2],Ot=Ct*_e.strideWidth-st;for(let Dt=0;Dt<et;++Dt){const At=Ot+Dt*rt;if(At<0||At>=_e.inWidth)continue;const kt=wt+Dt*$[1],Ft=$t+At*_e.inChannels;let Bt=Mt,Ht=kt;for(let Wt=0;Wt<_e.inChannels;++Wt){const Ut=lt[Ft+Wt];for(let Rt=0;Rt<ot;++Rt)xt[Bt+Rt]+=Ut*dt[Ht+Rt];Bt+=ot,Ht+=ot}}}}}}return i.makeTensorInfo(ct.shape,ct.dtype,ct.values)}const depthwiseConv2dNativeConfig$1={kernelName:DepthwiseConv2dNative,backendName:"cpu",kernelFunc:depthwiseConv2dNative$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropFilter$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,dy:c}=e,{strides:d,dilations:h,pad:g,dimRoundingMode:_,filterShape:b}=s;assertNotComplex$1([o,c],"depthwiseConv2dNativeBackpropFilter");const $=computeConv2DInfo(o.shape,b,d,h,g,_,!0),{strideHeight:j,strideWidth:_e,filterHeight:tt,filterWidth:et}=$,nt=new TensorBuffer($.filterShape,"float32"),rt=$.padInfo.left,it=$.padInfo.top,at=$.outChannels/$.inChannels,st=i.data.get(o.dataId).values,ot=new TensorBuffer(o.shape,o.dtype,st),ct=i.data.get(c.dataId).values,lt=new TensorBuffer(c.shape,c.dtype,ct);for(let dt=0;dt<tt;++dt){const xt=Math.max(0,Math.ceil((it-dt)/j)),ut=Math.min($.outHeight,($.inHeight+it-dt)/j);for(let ft=0;ft<et;++ft){const mt=Math.max(0,Math.ceil((rt-ft)/_e)),yt=Math.min($.outWidth,($.inWidth+rt-ft)/_e);for(let St=0;St<$.outChannels;++St){const Et=Math.trunc(St/at),vt=St%at;let Nt=0;for(let wt=0;wt<$.batchSize;++wt)for(let $t=xt;$t<ut;++$t){const Ct=dt+$t*j-it;for(let Mt=mt;Mt<yt;++Mt){const Ot=ft+Mt*_e-rt;Nt+=ot.get(wt,Ct,Ot,Et)*lt.get(wt,$t,Mt,St)}}nt.set(Nt,dt,ft,Et,vt)}}}return i.makeTensorInfo(nt.shape,nt.dtype,nt.values)}const depthwiseConv2dNativeBackpropFilterConfig$1={kernelName:DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropFilter$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropInput$1(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,filter:c}=e,{strides:d,dilations:h,pad:g,dimRoundingMode:_,inputShape:b}=s;assertNotComplex$1([o,c],"depthwiseConv2DNativeBackpropInput");const $=computeStrides(o.shape),j=computeStrides(c.shape),_e=computeConv2DInfo(b,c.shape,d,h,g,_,!0),tt=new TensorBuffer(_e.inShape,"float32"),et=tt.values,[nt,rt,it]=tt.strides,at=i.data.get(o.dataId).values,[st,ot,ct]=$,lt=i.data.get(c.dataId).values,[dt,xt,ut]=j,{batchSize:ft,filterHeight:mt,filterWidth:yt,inChannels:St,inHeight:Et,inWidth:vt,outChannels:Nt,outHeight:wt,outWidth:$t,strideHeight:Ct,strideWidth:Mt}=_e,Ot=mt-1-_e.padInfo.top,Dt=yt-1-_e.padInfo.left,At=Nt/St;for(let kt=0;kt<ft;++kt)for(let Ft=0;Ft<St;++Ft)for(let Bt=0;Bt<Et;++Bt){const Ht=Bt-Ot,Wt=Math.max(0,Math.ceil(Ht/Ct)),Ut=Math.min(wt,(mt+Ht)/Ct);for(let Rt=0;Rt<vt;++Rt){const un=Rt-Dt,rn=Math.max(0,Math.ceil(un/Mt)),mn=Math.min($t,(yt+un)/Mt);let sn=0;for(let hn=Wt;hn<Ut;++hn){const gn=hn*Ct-Ht;for(let Xt=rn;Xt<mn;++Xt){const En=Xt*Mt-un,bt=st*kt+ot*hn+ct*Xt,gt=dt*(mt-1-gn)+xt*(yt-1-En)+ut*Ft;for(let Pt=0;Pt<At;++Pt){const Lt=Ft*At+Pt,Vt=at[bt+Lt],jt=lt[gt+Pt];sn+=Vt*jt}}}et[nt*kt+rt*Bt+it*Rt+Ft]=sn}}return i.makeTensorInfo(tt.shape,tt.dtype,tt.values)}const depthwiseConv2dNativeBackpropInputConfig$1={kernelName:DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:depthwiseConv2dNativeBackpropInput$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function diag$2(a){const{inputs:e,backend:i}=a,{x:s}=e,o=sizeFromShape(s.shape),c=i.data.get(s.dataId).values,d=buffer([o,o],s.dtype),h=d.values;for(let _=0;_<c.length;_++)h[_*o+_]=c[_];const g=[...s.shape,...s.shape];return i.makeTensorInfo(g,d.dtype,d.values)}const diagConfig$1={kernelName:Diag,backendName:"cpu",kernelFunc:diag$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2dConfig={kernelName:Dilation2D,backendName:"cpu",kernelFunc:({inputs:a,backend:e,attrs:i})=>{const{x:s,filter:o}=a,{strides:c,pad:d,dilations:h}=i,g=e,_=g.data.get(s.dataId).values,b=s.shape.length,$=g.data.get(o.dataId).values,j=o.shape.length,{batchSize:_e,inHeight:tt,inWidth:et,inChannels:nt,outHeight:rt,outWidth:it,padInfo:at,strideHeight:st,strideWidth:ot,filterHeight:ct,filterWidth:lt,dilationHeight:dt,dilationWidth:xt,outShape:ut}=computeDilation2DInfo(s.shape,o.shape,c,d,"NHWC",h),ft=sizeFromShape(ut),mt=ut.length,yt=getArrayFromDType(s.dtype,ft);for(let Et=0;Et<_e;++Et)for(let vt=0;vt<rt;++vt){const Nt=vt*st-at.top;for(let wt=0;wt<it;++wt){const $t=wt*ot-at.left;for(let Ct=0;Ct<nt;++Ct){let Mt=Number.MIN_SAFE_INTEGER;for(let Dt=0;Dt<ct;++Dt){const At=Nt+Dt*dt;if(At>=0&&At<tt)for(let kt=0;kt<lt;++kt){const Ft=$t+kt*xt;if(Ft>=0&&Ft<et){const Bt=locToIndex([Et,At,Ft,Ct],b,computeStrides(s.shape)),Ht=locToIndex([Dt,kt,Ct],j,computeStrides(o.shape)),Wt=_[Bt]+$[Ht];Wt>Mt&&(Mt=Wt)}}}const Ot=locToIndex([Et,vt,wt,Ct],mt,computeStrides(ut));yt[Ot]=Mt}}}return{dataId:g.write(toTypedArray(yt,s.dtype),ut,s.dtype),shape:ut,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2dBackpropFilterConfig={kernelName:Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:a,backend:e,attrs:i})=>{const{x:s,filter:o,dy:c}=a,{strides:d,pad:h,dilations:g}=i,_=e,b=toNestedArray(s.shape,_.data.get(s.dataId).values),$=toNestedArray(o.shape,_.data.get(o.dataId).values),{batchSize:j,inHeight:_e,inWidth:tt,inChannels:et,outHeight:nt,outWidth:rt,padInfo:it,strideHeight:at,strideWidth:st,filterHeight:ot,filterWidth:ct,dilationHeight:lt,dilationWidth:dt,outShape:xt}=computeDilation2DInfo(s.shape,o.shape,d,h,"NHWC",g);assert$1(c.rank===xt.length,()=>`Error in ${Dilation2DBackpropFilter}, dy must have the same rank as output ${xt.length}, but got ${c.rank}`);const ut=toNestedArray(xt,_.data.get(c.dataId).values),ft=makeZerosNestedTypedArray(o.shape,o.dtype);for(let yt=0;yt<j;++yt)for(let St=0;St<nt;++St){const Et=St*at-it.top;for(let vt=0;vt<rt;++vt){const Nt=vt*st-it.left;for(let wt=0;wt<et;++wt){let $t=Number.MIN_SAFE_INTEGER,Ct=0,Mt=0;for(let Ot=0;Ot<ot;++Ot){const Dt=Et+Ot*lt;if(Dt>=0&&Dt<_e)for(let At=0;At<ct;++At){const kt=Nt+At*dt;if(kt>=0&&kt<tt){const Ft=b[yt][Dt][kt][wt]+$[Ot][At][wt];Ft>$t&&($t=Ft,Ct=Ot,Mt=At)}}}ft[Ct][Mt][wt]+=ut[yt][St][vt][wt]}}}return{dataId:_.write(toTypedArray(ft,s.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dilation2dBackpropInputConfig={kernelName:Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:a,backend:e,attrs:i})=>{const{x:s,filter:o,dy:c}=a,{strides:d,pad:h,dilations:g}=i,_=e,b=toNestedArray(s.shape,_.data.get(s.dataId).values),$=toNestedArray(o.shape,_.data.get(o.dataId).values),{batchSize:j,inHeight:_e,inWidth:tt,inChannels:et,outHeight:nt,outWidth:rt,padInfo:it,strideHeight:at,strideWidth:st,filterHeight:ot,filterWidth:ct,dilationHeight:lt,dilationWidth:dt,outShape:xt}=computeDilation2DInfo(s.shape,o.shape,d,h,"NHWC",g);assert$1(c.rank===xt.length,()=>`Error in ${Dilation2DBackpropInput}, dy must have the same rank as output ${xt.length}, but got ${c.rank}`);const ut=toNestedArray(xt,_.data.get(c.dataId).values),ft=makeZerosNestedTypedArray(s.shape,s.dtype);for(let yt=0;yt<j;++yt)for(let St=0;St<nt;++St){const Et=St*at-it.top;for(let vt=0;vt<rt;++vt){const Nt=vt*st-it.left;for(let wt=0;wt<et;++wt){let $t=Number.MIN_SAFE_INTEGER,Ct=Et<0?0:Et,Mt=Nt<0?0:Nt;for(let Ot=0;Ot<ot;++Ot){const Dt=Et+Ot*lt;if(Dt>=0&&Dt<_e)for(let At=0;At<ct;++At){const kt=Nt+At*dt;if(kt>=0&&kt<tt){const Ft=b[yt][Dt][kt][wt]+$[Ot][At][wt];Ft>$t&&($t=Ft,Ct=Dt,Mt=kt)}}}ft[yt][Ct][Mt][wt]+=ut[yt][St][vt][wt]}}}return{dataId:_.write(toTypedArray(ft,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eluGrad$1(a){const{inputs:e,backend:i}=a,{dy:s,y:o}=e;assertNotComplex$1([s,o],"eluGrad");const c=new Float32Array(sizeFromShape(o.shape)),d=i.data.get(o.dataId).values,h=i.data.get(s.dataId).values;for(let g=0;g<d.length;++g){const _=d[g];_>=1?c[g]=h[g]:c[g]=h[g]*(_+1)}return i.makeTensorInfo(o.shape,"float32",c)}const eluGradConfig$1={kernelName:EluGrad,backendName:"cpu",kernelFunc:eluGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const equalImpl=createSimpleBinaryKernelImpl((a,e)=>a===e?1:0),equal$2=binaryKernelFunc$1(Equal,equalImpl,null,"bool"),equalConfig$1={kernelName:Equal,backendName:"cpu",kernelFunc:equal$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p=ERF_P,a1=ERF_A1,a2=ERF_A2,a3=ERF_A3,a4=ERF_A4,a5=ERF_A5,erf$1=unaryKernelFunc$1(Erf,a=>{const e=Math.sign(a),i=Math.abs(a),s=1/(1+p*i);return e*(1-((((a5*s+a4)*s+a3)*s+a2)*s+a1)*s*Math.exp(-i*i))}),erfConfig$1={kernelName:Erf,backendName:"cpu",kernelFunc:erf$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims$1(a){const{inputs:e,backend:i,attrs:s}=a,{input:o}=e,{dim:c}=s,d=o.shape.length,h=o.shape.slice();let g=c;return c<0&&(assert$1(-(d+1)<=c,()=>`Axis must be in the interval [${-(d+1)}, ${d}]`),g=d+c+1),h.splice(g,0,1),reshape$2({inputs:{x:o},backend:i,attrs:{shape:h}})}const expandDimsConfig$1={kernelName:ExpandDims,backendName:"cpu",kernelFunc:expandDims$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const realDivImpl=createSimpleBinaryKernelImpl((a,e)=>a/e),div$1=binaryKernelFunc$1(RealDiv,realDivImpl),realDivConfig$1={kernelName:RealDiv,backendName:"cpu",kernelFunc:div$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftBatch(a,e,i){const s=a.shape,o=s[0],c=s[1],d=i.data.get(a.dataId),h=d.complexTensorInfos.real,g=d.complexTensorInfos.imag,_=[o,c],b=sizeFromShape(_),$=getTypedArrayFromDType("float32",b),j=getTypedArrayFromDType("float32",b);for(let nt=0;nt<o;nt++){const rt=slice$1({inputs:{x:h},backend:i,attrs:{begin:[nt,0],size:[1,c]}}),it=slice$1({inputs:{x:g},backend:i,attrs:{begin:[nt,0],size:[1,c]}}),at=complex$3({inputs:{real:rt,imag:it},backend:i}),{real:st,imag:ot}=fftImpl$1(at,e,i),ct=mergeRealAndImagArrays(st,ot);for(let lt=0;lt<c;lt++){const dt=getComplexWithIndex(ct,lt);$[nt*c+lt]=dt.real,j[nt*c+lt]=dt.imag}i.disposeIntermediateTensorInfo(rt),i.disposeIntermediateTensorInfo(it),i.disposeIntermediateTensorInfo(at)}const _e=i.makeTensorInfo(_,"float32",$),tt=i.makeTensorInfo(_,"float32",j),et=complex$3({inputs:{real:_e,imag:tt},backend:i});return i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(tt),et}function fftImpl$1(a,e,i){const s=sizeFromShape(a.shape),o=i.data.get(a.dataId),c=i.data.get(o.complexTensorInfos.real.dataId).values,d=i.data.get(o.complexTensorInfos.imag.dataId).values;if(isExponentOf2(s)){const h=fftRadix2(c,d,s,e,i),g=[a.shape[0],a.shape[1]];if(e){const _=i.makeTensorInfo(g,"float32",h.real),b=i.makeTensorInfo(g,"float32",h.imag),$=i.makeTensorInfo([],"float32",createScalarValue(s,"float32")),j=identity$2({inputs:{x:$},backend:i}),_e=realDivConfig$1.kernelFunc({inputs:{a:_,b:$},backend:i}),tt=realDivConfig$1.kernelFunc({inputs:{a:b,b:j},backend:i}),et=i.data.get(_e.dataId).values,nt=i.data.get(tt.dataId).values;return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(tt),{real:et,imag:nt}}return h}else{const h=mergeRealAndImagArrays(c,d),g=fourierTransformByMatmul(h,s,e);return splitRealAndImagArrays(g)}}function isExponentOf2(a){return(a&a-1)===0}function fftRadix2(a,e,i,s,o){if(i===1)return{real:a,imag:e};const c=mergeRealAndImagArrays(a,e),d=i/2,h=complexWithEvenIndex(c),g=h.real,_=h.imag,b=[g.length],$=o.makeTensorInfo(b,"float32",g),j=o.makeTensorInfo(b,"float32",_),_e=complex$3({inputs:{real:$,imag:j},backend:o}),tt=complexWithOddIndex(c),et=tt.real,nt=tt.imag,rt=[et.length],it=o.makeTensorInfo(rt,"float32",et),at=o.makeTensorInfo(rt,"float32",nt),st=complex$3({inputs:{real:it,imag:at},backend:o}),ot=fftRadix2(g,_,d,s,o),ct=ot.real,lt=ot.imag,dt=[ct.length],xt=o.makeTensorInfo(dt,"float32",ct),ut=o.makeTensorInfo(dt,"float32",lt),ft=complex$3({inputs:{real:xt,imag:ut},backend:o}),mt=fftRadix2(et,nt,d,s,o),yt=mt.real,St=mt.imag,Et=[yt.length],vt=o.makeTensorInfo(Et,"float32",yt),Nt=o.makeTensorInfo(Et,"float32",St),wt=complex$3({inputs:{real:vt,imag:Nt},backend:o}),$t=exponents(i,s),Ct=[$t.real.length],Mt=o.makeTensorInfo(Ct,"float32",$t.real),Ot=o.makeTensorInfo(Ct,"float32",$t.imag),Dt=complex$3({inputs:{real:Mt,imag:Ot},backend:o}),At=multiply$2({inputs:{a:Dt,b:wt},backend:o}),kt=add$2({inputs:{a:ft,b:At},backend:o}),Ft=sub$2({inputs:{a:ft,b:At},backend:o}),Bt=real$1({inputs:{input:kt},backend:o}),Ht=real$1({inputs:{input:Ft},backend:o}),Wt=imag$1({inputs:{input:kt},backend:o}),Ut=imag$1({inputs:{input:Ft},backend:o}),Rt=concat$2({inputs:[Bt,Ht],backend:o,attrs:{axis:0}}),un=concat$2({inputs:[Wt,Ut],backend:o,attrs:{axis:0}}),rn=o.data.get(Rt.dataId).values,mn=o.data.get(un.dataId).values;return o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(j),o.disposeIntermediateTensorInfo(_e),o.disposeIntermediateTensorInfo(it),o.disposeIntermediateTensorInfo(at),o.disposeIntermediateTensorInfo(st),o.disposeIntermediateTensorInfo(xt),o.disposeIntermediateTensorInfo(ut),o.disposeIntermediateTensorInfo(ft),o.disposeIntermediateTensorInfo(vt),o.disposeIntermediateTensorInfo(Nt),o.disposeIntermediateTensorInfo(wt),o.disposeIntermediateTensorInfo(Mt),o.disposeIntermediateTensorInfo(Ot),o.disposeIntermediateTensorInfo(Dt),o.disposeIntermediateTensorInfo(At),o.disposeIntermediateTensorInfo(kt),o.disposeIntermediateTensorInfo(Ft),o.disposeIntermediateTensorInfo(Bt),o.disposeIntermediateTensorInfo(Wt),o.disposeIntermediateTensorInfo(Ht),o.disposeIntermediateTensorInfo(Ut),o.disposeIntermediateTensorInfo(Rt),o.disposeIntermediateTensorInfo(un),{real:rn,imag:mn}}function fourierTransformByMatmul(a,e,i){const s=new Float32Array(e*2);for(let o=0;o<e;o++){let c=0,d=0;for(let h=0;h<e;h++){const g=exponent(o*h,e,i),_=getComplexWithIndex(a,h);c+=_.real*g.real-_.imag*g.imag,d+=_.real*g.imag+_.imag*g.real}i&&(c/=e,d/=e),assignToTypedArray(s,c,d,o)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fft$1(a){const{inputs:e,backend:i}=a,{input:s}=e,o=sizeFromShape(s.shape),c=s.shape[s.shape.length-1],d=o/c,h=reshape$2({inputs:{x:s},backend:i,attrs:{shape:[d,c]}}),g=fftBatch(h,!1,i),_=reshape$2({inputs:{x:g},backend:i,attrs:{shape:s.shape}});return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(g),_}const fftConfig$1={kernelName:FFT,backendName:"cpu",kernelFunc:fft$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill$1(a){const{backend:e,attrs:i}=a,{shape:s,value:o,dtype:c}=i,d=c||inferDtype(o),h=getArrayFromDType(d,sizeFromShape(s));return fillValues(h,o,d),e.makeTensorInfo(s,d,h)}const fillConfig$1={kernelName:Fill,backendName:"cpu",kernelFunc:fill$1};function fillValues(a,e,i){a.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const flipLeftRightConfig$1={kernelName:FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:a,attrs:e,backend:i})=>{const{image:s}=a,o=i,c=getTypedArrayFromDType(s.dtype,sizeFromShape(s.shape)),[d,h,g,_]=s.shape,b=o.data.get(s.dataId).values;for(let j=0;j<d;j++){const _e=j*g*h*_;for(let tt=0;tt<h;tt++){const et=tt*(g*_);for(let nt=0;nt<g;nt++){const rt=nt*_;for(let it=0;it<_;it++){const st=[d,tt,nt,it][2],ot=Math.round(g-st),ct=_e+et+rt+it;let lt=b[ct];if(ot>=0&&ot<g){const dt=ot*_,xt=_e+et+dt+it;lt=b[xt]}c[ct]=lt}}}}return{dataId:o.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const floorDivImpl=createSimpleBinaryKernelImpl((a,e)=>Math.floor(a/e)),floorDiv$1=binaryKernelFunc$1(FloorDiv,floorDivImpl,null,"int32"),floorDivConfig$1={kernelName:FloorDiv,backendName:"cpu",kernelFunc:floorDiv$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c,bias:d,preluActivationWeights:h}=e,{strides:g,pad:_,dataFormat:b,dilations:$,dimRoundingMode:j,activation:_e,leakyreluAlpha:tt}=s;let et=conv2D({inputs:{x:o,filter:c},backend:i,attrs:{strides:g,pad:_,dataFormat:b,dilations:$,dimRoundingMode:j}});if(d){const nt=et;et=add$2({inputs:{a:et,b:d},backend:i}),i.disposeIntermediateTensorInfo(nt)}if(_e){const nt=et;et=applyActivation(i,et,_e,h,tt),i.disposeIntermediateTensorInfo(nt)}return et}const fusedConv2DConfig$1={kernelName:FusedConv2D,backendName:"cpu",kernelFunc:fusedConv2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedDepthwiseConv2D$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c,bias:d,preluActivationWeights:h}=e,{strides:g,pad:_,dataFormat:b,dilations:$,dimRoundingMode:j,activation:_e,leakyreluAlpha:tt}=s;let et=depthwiseConv2dNative$1({inputs:{x:o,filter:c},backend:i,attrs:{strides:g,pad:_,dataFormat:b,dilations:$,dimRoundingMode:j}});if(d){const nt=et;et=add$2({inputs:{a:et,b:d},backend:i}),i.disposeIntermediateTensorInfo(nt)}if(_e){const nt=et;et=applyActivation(i,et,_e,h,tt),i.disposeIntermediateTensorInfo(nt)}return et}const fusedDepthwiseConv2DConfig$1={kernelName:FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:fusedDepthwiseConv2D$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNd$1(a){const{inputs:e,backend:i}=a,{params:s,indices:o}=e,c=sizeFromShape(s.shape),d=o.shape,h=d[d.length-1],[g,_,b,$]=prepareAndValidate(s,o);if(_===0)return i.makeTensorInfo(g,s.dtype,[]);const j=buffer([_,b],s.dtype),_e=i.data.get(o.dataId).values,tt=i.data.get(s.dataId).values;for(let et=0;et<_;et++){const nt=[];let rt=0;for(let it=0;it<h;it++){const at=_e[et*h+it];rt+=at*$[it],nt.push(at)}if(rt<0||rt>=c/b)throw new Error(`Invalid indices: ${nt} does not index into ${s.shape}`);for(let it=0;it<b;it++)j.values[et*b+it]=tt[rt*b+it]}return i.makeTensorInfo(g,j.dtype,j.values)}const gatherNdConfig$1={kernelName:GatherNd,backendName:"cpu",kernelFunc:gatherNd$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,indices:c}=e,{axis:d,batchDims:h}=s;assertNotComplex$1([o,c],"gatherV2");let g=h;h==null&&(g=0);const _=sizeFromShape(c.shape),b=parseAxisParam(d,o.shape)[0],$=collectGatherOpShapeInfo(o,c,b,g),j=reshape$2({inputs:{x:o},backend:i,attrs:{shape:[$.batchSize,$.outerSize,$.dimSize,$.sliceSize]}}),_e=reshape$2({inputs:{x:c},backend:i,attrs:{shape:[$.batchSize,_/$.batchSize]}}),tt=[$.batchSize,$.outerSize,_/$.batchSize,$.sliceSize],et=i.bufferSync(_e),nt=i.bufferSync(j),rt=gatherV2Impl(nt,et,tt);return i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(_e),i.makeTensorInfo($.outputShape,rt.dtype,rt.values)}const gatherV2Config$1={kernelName:GatherV2,backendName:"cpu",kernelFunc:gatherV2$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const greaterEqualImpl=createSimpleBinaryKernelImpl((a,e)=>a>=e?1:0),greaterEqual$1=binaryKernelFunc$1(GreaterEqual,greaterEqualImpl,null,"bool"),greaterEqualConfig$1={kernelName:GreaterEqual,backendName:"cpu",kernelFunc:greaterEqual$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ifft$1(a){const{inputs:e,backend:i}=a,{input:s}=e,o=sizeFromShape(s.shape),c=s.shape[s.shape.length-1],d=o/c,h=reshape$2({inputs:{x:s},backend:i,attrs:{shape:[d,c]}}),g=fftBatch(h,!0,i),_=reshape$2({inputs:{x:g},backend:i,attrs:{shape:s.shape}});return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(g),_}const ifftConfig$1={kernelName:IFFT,backendName:"cpu",kernelFunc:ifft$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isFinite$2=unaryKernelFunc$1(IsFinite,a=>Number.isFinite(a)?1:0,"bool"),isFiniteConfig$1={kernelName:IsFinite,backendName:"cpu",kernelFunc:isFinite$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isInf$1=unaryKernelFunc$1(IsInf,a=>Math.abs(a)===1/0?1:0,"bool"),isInfConfig$1={kernelName:IsInf,backendName:"cpu",kernelFunc:isInf$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const isNaN$2=unaryKernelFunc$1(IsNan,a=>Number.isNaN(a)?1:0,"bool"),isNaNConfig$1={kernelName:IsNan,backendName:"cpu",kernelFunc:isNaN$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lessEqualImpl=createSimpleBinaryKernelImpl((a,e)=>a<=e?1:0),lessEqual$1=binaryKernelFunc$1(LessEqual,lessEqualImpl,null,"bool"),lessEqualConfig$1={kernelName:LessEqual,backendName:"cpu",kernelFunc:lessEqual$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpace$1(a){const{backend:e,attrs:i}=a,{start:s,stop:o,num:c}=i,d=linSpaceImpl(s,o,c);return e.makeTensorInfo([d.length],"float32",d)}const linSpaceConfig$1={kernelName:LinSpace,backendName:"cpu",kernelFunc:linSpace$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const log1p$1=unaryKernelFunc$1(Log1p,a=>Math.log1p(a)),log1pConfig$1={kernelName:Log1p,backendName:"cpu",kernelFunc:log1p$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logicalAndImpl=createSimpleBinaryKernelImpl((a,e)=>a&&e),logicalAnd$1=binaryKernelFunc$1(LogicalAnd,logicalAndImpl,null,"bool"),logicalAndConfig$1={kernelName:LogicalAnd,backendName:"cpu",kernelFunc:logicalAnd$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logicalNot$1=unaryKernelFunc$1(LogicalNot,a=>a?0:1,"bool"),logicalNotConfig$1={kernelName:LogicalNot,backendName:"cpu",kernelFunc:logicalNot$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const logicalOrImpl=createSimpleBinaryKernelImpl((a,e)=>a||e),logicalOr$1=binaryKernelFunc$1(LogicalOr,logicalOrImpl,null,"bool"),logicalOrConfig$1={kernelName:LogicalOr,backendName:"cpu",kernelFunc:logicalOr$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lRN(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{depthRadius:c,bias:d,alpha:h,beta:g}=s;assertNotComplex$1(o,"LRN");const _=o.shape[3],b=_-1,$=i.data.get(o.dataId).values,j=sizeFromShape(o.shape),_e=new Float32Array(j);function tt(et){const nt=et%_;let rt=et-nt+Math.max(0,nt-c);const it=et-nt+Math.min(nt+c,b);let at=0;for(;rt<=it;rt++){const st=$[rt];at+=st*st}return at}for(let et=0;et<j;et++){const nt=tt(et),rt=$[et]*Math.pow(d+h*nt,-g);_e[et]=rt}return i.makeTensorInfo(o.shape,o.dtype,_e)}const lRNConfig={kernelName:LRN,backendName:"cpu",kernelFunc:lRN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lRNGrad(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,y:c,dy:d}=e,{depthRadius:h,bias:g,alpha:_,beta:b}=s;assertNotComplex$1(d,"LRNGrad");const $=sizeFromShape(d.shape),j=d.shape[3],_e=i.data.get(d.dataId).values,tt=i.data.get(o.dataId).values,et=i.data.get(c.dataId).values,nt=new Float32Array($),rt=$;for(let it=0;it<rt;it++){const at=it%j,st=it-at+Math.max(0,at-h),ot=it-at+Math.min(j,at+h+1);let ct=0;for(let lt=st;lt<ot;lt++)ct+=Math.pow(tt[lt],2);ct=_*ct+g;for(let lt=st;lt<ot;lt++){let dt=-2*_*b*tt[lt]*et[it]/ct;it===lt&&(dt+=Math.pow(ct,-b)),dt*=_e[it],nt[lt]+=dt}}return i.makeTensorInfo(d.shape,o.dtype,nt)}const lRNGradConfig={kernelName:LRNGrad,backendName:"cpu",kernelFunc:lRNGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max$2(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{reductionIndices:c,keepDims:d}=s,h=i;let g=o.shape;const _=g.length,b=parseAxisParam(c,g);let $=b;const j=getAxesPermutation($,_);let _e=h.data.get(o.dataId).values;if(j!=null){const st=new Array(_);for(let ot=0;ot<st.length;ot++)st[ot]=g[j[ot]];_e=transposeImpl$1(_e,g,o.dtype,j,st),$=getInnerMostAxes($.length,_),g=st}assertNotComplex$1(o,"max"),assertAxesAreInnerMostDims("max",$,_);const[tt,et]=computeOutAndReduceShapes(g,$),nt=sizeFromShape(et),rt=maxImpl$1(_e,nt,tt,o.dtype),it=h.write(rt,tt,o.dtype);let at=tt;return d&&(at=expandShapeToKeepDim(tt,b)),{dataId:it,shape:at,dtype:o.dtype}}const maxConfig$1={kernelName:Max,backendName:"cpu",kernelFunc:max$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e;assertNotComplex$1(o,"maxPool");const{filterSize:c,strides:d,pad:h,dimRoundingMode:g}=s,_=1;assert$1(eitherStridesOrDilationsAreOne(d,_),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${d} and dilations '${_}'`);const b=computePool2DInfo(o.shape,c,d,_,h,g);let $;if(b.filterWidth===1&&b.filterHeight===1&&arraysEqual(b.inShape,b.outShape))$=identity$2({inputs:{x:o},backend:i});else{const j=i.data.get(o.dataId).values,_e=computeStrides(o.shape),tt=pool$1(j,o.shape,o.dtype,_e,b,"max");$=i.makeTensorInfo(b.outShape,o.dtype,tt.values)}return $}const maxPoolConfig$1={kernelName:MaxPool,backendName:"cpu",kernelFunc:maxPool$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{filterSize:c,strides:d,pad:h,dimRoundingMode:g,dataFormat:_}=s;assertNotComplex$1(o,"maxPool3d");const b=computePool3DInfo(o.shape,c,d,1,h,g,_),$=i.data.get(o.dataId).values,j=pool3d($,o.shape,o.dtype,computeStrides(o.shape),b,"max");return i.makeTensorInfo(j.shape,"float32",j.values)}const maxPool3DConfig$1={kernelName:MaxPool3D,backendName:"cpu",kernelFunc:maxPool3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3DGrad$1(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c}=e,{filterSize:d,strides:h,pad:g,dimRoundingMode:_}=s;assertNotComplex$1([o,c],"maxPool3DGrad");const b=computePool3DInfo(c.shape,d,h,1,g,_),$=i.bufferSync(c),j=maxPool3dPositions($,b),_e=b.strideDepth,tt=b.strideHeight,et=b.strideWidth,nt=b.dilationDepth,rt=b.dilationHeight,it=b.dilationWidth,at=b.effectiveFilterDepth,st=b.effectiveFilterHeight,ot=b.effectiveFilterWidth,ct=at-1-b.padInfo.front,lt=ot-1-b.padInfo.left,dt=st-1-b.padInfo.top,xt=buffer(c.shape,"float32"),ut=i.bufferSync(o);for(let ft=0;ft<b.batchSize;++ft)for(let mt=0;mt<b.inChannels;++mt)for(let yt=0;yt<b.inDepth;++yt)for(let St=0;St<b.inHeight;++St)for(let Et=0;Et<b.inWidth;++Et){const vt=yt-ct,Nt=St-dt,wt=Et-lt;let $t=0;for(let Ct=0;Ct<at;Ct+=nt){const Mt=(vt+Ct)/_e;if(!(Mt<0||Mt>=b.outDepth||Math.floor(Mt)!==Mt))for(let Ot=0;Ot<st;Ot+=rt){const Dt=(Nt+Ot)/tt;if(!(Dt<0||Dt>=b.outHeight||Math.floor(Dt)!==Dt))for(let At=0;At<ot;At+=it){const kt=(wt+At)/et;if(kt<0||kt>=b.outWidth||Math.floor(kt)!==kt)continue;const Ft=at*st*ot-1-j.get(ft,Mt,Dt,kt,mt),Bt=Ct*st*ot+Ot*ot+At,Ht=Ft===Bt?1:0;if(Ht===0)continue;const Wt=ut.get(ft,Mt,Dt,kt,mt);$t+=Wt*Ht}}}xt.set($t,ft,yt,St,Et,mt)}return i.makeTensorInfo(xt.shape,xt.dtype,xt.values)}const maxPool3DGradConfig={kernelName:MaxPool3DGrad,backendName:"cpu",kernelFunc:maxPool3DGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolGrad$1(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c,output:d}=e,h=c;assertNotComplex$1([c,d],"maxPoolGrad");const{filterSize:g,strides:_,pad:b,dimRoundingMode:$}=s,j=computePool2DInfo(h.shape,g,_,1,b,$),_e=i.data.get(h.dataId).values,tt=buffer(j.outShape,h.dtype,maxPoolPositions(_e,h.shape,h.dtype,j).values),et=j.strideHeight,nt=j.strideWidth,rt=j.dilationHeight,it=j.dilationWidth,at=j.effectiveFilterHeight,st=j.effectiveFilterWidth,ot=st-1-j.padInfo.left,ct=at-1-j.padInfo.top,lt=buffer(h.shape,"float32"),dt=i.data.get(o.dataId).values,xt=buffer(o.shape,"float32",dt);for(let ut=0;ut<j.batchSize;++ut)for(let ft=0;ft<j.inChannels;++ft)for(let mt=0;mt<j.inHeight;++mt)for(let yt=0;yt<j.inWidth;++yt){const St=mt-ct,Et=yt-ot;let vt=0;for(let Nt=0;Nt<at;Nt+=rt){const wt=(St+Nt)/et;if(!(wt<0||wt>=j.outHeight||Math.floor(wt)!==wt))for(let $t=0;$t<st;$t+=it){const Ct=(Et+$t)/nt;if(Ct<0||Ct>=j.outWidth||Math.floor(Ct)!==Ct)continue;const Mt=at*st-1-tt.get(ut,wt,Ct,ft),Ot=Nt*st+$t,Dt=Mt===Ot?1:0;if(Dt===0)continue;const At=xt.get(ut,wt,Ct,ft);vt+=At*Dt}}lt.set(vt,ut,mt,yt,ft)}return i.makeTensorInfo(lt.shape,lt.dtype,lt.values)}const maxPoolGradConfig$1={kernelName:MaxPoolGrad,backendName:"cpu",kernelFunc:maxPoolGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolWithArgmaxImpl$1(a,e,i,s,o){const c=computeStrides(e),d=pool$1(a,e,i,c,o,"max"),h=maxPoolPositions(a,e,i,o,!0,s);return[d.values,h.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maxPoolWithArgmaxConfig$1={kernelName:MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:a,attrs:e,backend:i})=>{const{x:s}=a,{filterSize:o,strides:c,pad:d,includeBatchInIndex:h}=e,g=i;assertNotComplex$1(s,"MaxPoolWithArgmax");const _=g.data.get(s.dataId).values,b=computePool2DInfo(s.shape,o,c,[1,1],d),[$,j]=maxPoolWithArgmaxImpl$1(_,s.shape,s.dtype,h,b),_e=g.write($,b.outShape,s.dtype),tt=g.write(j,b.outShape,s.dtype);return[{dataId:_e,shape:b.outShape,dtype:s.dtype},{dataId:tt,shape:b.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum$2(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s;assertNotComplex$1(o,"sum");let h;o.dtype==="bool"?h=cast$1({inputs:{x:o},backend:i,attrs:{dtype:"int32"}}):h=identity$2({inputs:{x:o},backend:i});const g=h.shape.length,_=parseAxisParam(c,h.shape),b=getAxesPermutation(_,g);let $=_,j=h;b!=null&&(j=transpose$2({inputs:{x:h},backend:i,attrs:{perm:b}}),$=getInnerMostAxes($.length,g)),assertAxesAreInnerMostDims("sum",$,j.shape.length);const[_e,tt]=computeOutAndReduceShapes(j.shape,$),et=upcastType(j.dtype,"int32");let nt=zeros$2(i,_e,et);const rt=sizeFromShape(tt),it=i.data.get(nt.dataId).values,at=i.data.get(j.dataId).values;for(let st=0;st<it.length;++st){const ot=st*rt;let ct=0;for(let lt=0;lt<rt;++lt)ct+=at[ot+lt];it[st]=ct}if(d){const st=expandShapeToKeepDim(nt.shape,_),ot=nt;nt=reshape$2({inputs:{x:nt},backend:i,attrs:{shape:st}}),i.disposeIntermediateTensorInfo(ot)}return i.disposeIntermediateTensorInfo(h),b!=null&&i.disposeIntermediateTensorInfo(j),nt}const sumConfig$1={kernelName:Sum,backendName:"cpu",kernelFunc:sum$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mean(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s,h=parseAxisParam(c,o.shape),_=computeOutAndReduceShapes(o.shape,h)[1],b=sizeFromShape(_),$=[],j=i.makeTensorInfo([],"float32",new Float32Array([b]));$.push(j);const _e=cast$1({inputs:{x:o},backend:i,attrs:{dtype:"float32"}});$.push(_e);const tt=div$1({inputs:{a:_e,b:j},backend:i});$.push(tt);const et=sum$2({inputs:{x:tt},backend:i,attrs:{axis:c,keepDims:d}});return $.forEach(nt=>i.disposeIntermediateTensorInfo(nt)),et}const meanConfig$1={kernelName:Mean,backendName:"cpu",kernelFunc:mean};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function min$2(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s;assertNotComplex$1(o,"min");const h=parseAxisParam(c,o.shape);let g=h;const _=getAxesPermutation(g,o.shape.length);let b=o;_!=null&&(b=transpose$2({inputs:{x:o},backend:i,attrs:{perm:_}}),g=getInnerMostAxes(g.length,o.shape.length)),assertAxesAreInnerMostDims("min",g,b.shape.length);const[$,j]=computeOutAndReduceShapes(b.shape,g),_e=sizeFromShape(j),tt=makeZerosTypedArray(sizeFromShape($),b.dtype),et=i.data.get(b.dataId).values;for(let rt=0;rt<tt.length;++rt){const it=rt*_e;let at=et[it];for(let st=0;st<_e;++st){const ot=et[it+st];ot<at&&(at=ot)}tt[rt]=at}_!=null&&i.disposeIntermediateTensorInfo(b);const nt=i.makeTensorInfo($,b.dtype,tt);if(d){const rt=expandShapeToKeepDim($,h),it=reshape$2({inputs:{x:nt},backend:i,attrs:{shape:rt}});return i.disposeIntermediateTensorInfo(nt),it}return nt}const minConfig$1={kernelName:Min,backendName:"cpu",kernelFunc:min$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mirrorPad(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{paddings:c,mode:d}=s;assertNotComplex$1(o,"mirrorPad");const h=c.map((at,st)=>at[0]+o.shape[st]+at[1]),g=c.map(at=>at[0]),_=c.map((at,st)=>at[0]+o.shape[st]),b=d==="reflect"?0:1,$=i.data.get(o.dataId).values,j=o.shape.length,_e=computeStrides(o.shape),tt=sizeFromShape(h),et=h.length,nt=computeStrides(h),rt=getTypedArrayFromDType(o.dtype,tt);for(let at=0;at<tt;at++){let st=indexToLoc(at,et,nt);for(let ct=0;ct<et;ct++)st[ct]<g[ct]?st[ct]=g[ct]*2-st[ct]-b:st[ct]>=_[ct]&&(st[ct]=(_[ct]-1)*2-st[ct]+b);st=st.map((ct,lt)=>ct-g[lt]);const ot=locToIndex(st,j,_e);rt[at]=$[ot]}return{dataId:i.write(rt,h,o.dtype),shape:h,dtype:o.dtype}}const mirrorPadConfig$1={kernelName:MirrorPad,backendName:"cpu",kernelFunc:mirrorPad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const modImpl=createSimpleBinaryKernelImpl((a,e)=>{const i=a%e;return a<0&&e<0||a>=0&&e>=0?i:(i+e)%e}),mod$2=binaryKernelFunc$1(Mod,modImpl),modConfig$1={kernelName:Mod,backendName:"cpu",kernelFunc:mod$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax$1(a){const{inputs:e,backend:i,attrs:s}=a,{logits:o}=e,{dim:c}=s,d=o.shape.length;let h=c;if(h===-1&&(h=d-1),h!==d-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${d} and dim was ${h}`);const g=parseAxisParam([h],o.shape),_=max$2({inputs:{x:o},backend:i,attrs:{reductionIndices:g,keepDims:!1}}),b=expandShapeToKeepDim(_.shape,g),$=reshape$2({inputs:{x:_},backend:i,attrs:{shape:b}}),j=sub$2({inputs:{a:o,b:$},backend:i}),_e=exp$2({inputs:{x:j},backend:i}),tt=sum$2({inputs:{x:_e},backend:i,attrs:{axis:g,keepDims:!1}}),et=reshape$2({inputs:{x:tt},backend:i,attrs:{shape:b}}),nt=div$1({inputs:{a:_e,b:et},backend:i});return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(tt),i.disposeIntermediateTensorInfo(et),nt}const softmaxConfig$1={kernelName:Softmax$2,backendName:"cpu",kernelFunc:softmax$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function multinomial$1(a){const{inputs:e,backend:i,attrs:s}=a,{logits:o}=e,{numSamples:c,seed:d,normalized:h}=s;assertNotComplex$1(o,"multinomial");const g=h?o:softmax$1({inputs:{logits:o},backend:i,attrs:{dim:-1}}),_=g.shape[0],b=g.shape[1],$=i.data.get(g.dataId).values,j=[_,c],_e=makeZerosTypedArray(sizeFromShape(j),"int32");for(let tt=0;tt<_;++tt){const et=tt*b,nt=new Float32Array(b-1);nt[0]=$[et];for(let at=1;at<nt.length;++at)nt[at]=nt[at-1]+$[et+at];const rt=seedrandom.alea(d.toString()),it=tt*c;for(let at=0;at<c;++at){const st=rt();_e[it+at]=nt.length;for(let ot=0;ot<nt.length;ot++)if(st<nt[ot]){_e[it+at]=ot;break}}}return h||i.disposeIntermediateTensorInfo(g),i.makeTensorInfo(j,"int32",_e)}const multinomialConfig$1={kernelName:Multinomial,backendName:"cpu",kernelFunc:multinomial$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV3Impl$1=nonMaxSuppressionV3Impl$2;function nonMaxSuppressionV3$1(a){const{inputs:e,backend:i,attrs:s}=a,{boxes:o,scores:c}=e,{maxOutputSize:d,iouThreshold:h,scoreThreshold:g}=s;assertNotComplex$1(o,"NonMaxSuppression");const _=i.data.get(o.dataId).values,b=i.data.get(c.dataId).values,{selectedIndices:$}=nonMaxSuppressionV3Impl$1(_,b,d,h,g);return i.makeTensorInfo([$.length],"int32",new Int32Array($))}const nonMaxSuppressionV3Config$1={kernelName:NonMaxSuppressionV3,backendName:"cpu",kernelFunc:nonMaxSuppressionV3$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV4Impl$1=nonMaxSuppressionV4Impl$2;function nonMaxSuppressionV4$1(a){const{inputs:e,backend:i,attrs:s}=a,{boxes:o,scores:c}=e,{maxOutputSize:d,iouThreshold:h,scoreThreshold:g,padToMaxOutputSize:_}=s;assertNotComplex$1(o,"NonMaxSuppressionPadded");const b=i.data.get(o.dataId).values,$=i.data.get(c.dataId).values,{selectedIndices:j,validOutputs:_e}=nonMaxSuppressionV4Impl$1(b,$,d,h,g,_);return[i.makeTensorInfo([j.length],"int32",new Int32Array(j)),i.makeTensorInfo([],"int32",new Int32Array([_e]))]}const nonMaxSuppressionV4Config$1={kernelName:NonMaxSuppressionV4,backendName:"cpu",kernelFunc:nonMaxSuppressionV4$1};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV5Impl$1=nonMaxSuppressionV5Impl$2;function nonMaxSuppressionV5$1(a){const{inputs:e,backend:i,attrs:s}=a,{boxes:o,scores:c}=e,{maxOutputSize:d,iouThreshold:h,scoreThreshold:g,softNmsSigma:_}=s;assertNotComplex$1(o,"NonMaxSuppressionWithScore");const b=i.data.get(o.dataId).values,$=i.data.get(c.dataId).values,j=d,_e=h,tt=g,et=_,{selectedIndices:nt,selectedScores:rt}=nonMaxSuppressionV5Impl$1(b,$,j,_e,tt,et);return[i.makeTensorInfo([nt.length],"int32",new Int32Array(nt)),i.makeTensorInfo([rt.length],"float32",new Float32Array(rt))]}const nonMaxSuppressionV5Config$1={kernelName:NonMaxSuppressionV5,backendName:"cpu",kernelFunc:nonMaxSuppressionV5$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oneHot$1(a){const{inputs:e,backend:i,attrs:s}=a,{indices:o}=e,{depth:c,onValue:d,offValue:h}=s;assertNotComplex$1(o,"oneHot");const g=sizeFromShape(o.shape),_=new Float32Array(g*c);_.fill(h);const b=i.data.get(o.dataId).values;for(let $=0;$<g;++$)b[$]>=0&&b[$]<c&&(_[$*c+b[$]]=d);return i.makeTensorInfo([...o.shape,c],"int32",_)}const oneHotConfig$1={kernelName:OneHot,backendName:"cpu",kernelFunc:oneHot$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike$1(a){const{inputs:e,backend:i}=a,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const o=real$1({inputs:{input:s},backend:i}),c=zerosLike$1({inputs:{x:o},backend:i}),d=imag$1({inputs:{input:s},backend:i}),h=zerosLike$1({inputs:{x:d},backend:i}),g=complex$3({inputs:{real:c,imag:h},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),g}else return fill$1({backend:i,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const zerosLikeConfig$1={kernelName:ZerosLike,backendName:"cpu",kernelFunc:zerosLike$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike$1(a){const{inputs:e,backend:i}=a,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const o=real$1({inputs:{input:s},backend:i}),c=onesLike$1({inputs:{x:o},backend:i}),d=imag$1({inputs:{input:s},backend:i}),h=zerosLike$1({inputs:{x:d},backend:i}),g=complex$3({inputs:{real:c,imag:h},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),g}else return fill$1({backend:i,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const onesLikeConfig$1={kernelName:OnesLike,backendName:"cpu",kernelFunc:onesLike$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pack$1(a){const{inputs:e,backend:i,attrs:s}=a,{axis:o}=s;if(e.length===1)return expandDims$1({inputs:{input:e[0]},backend:i,attrs:{dim:o}});const c=e[0].shape,d=e[0].dtype;e.forEach(b=>{assertShapesMatch(c,b.shape,"All tensors passed to stack must have matching shapes"),assert$1(d===b.dtype,()=>"All tensors passed to stack must have matching dtypes")});const h=[],g=e.map(b=>{const $=expandDims$1({inputs:{input:b},backend:i,attrs:{dim:o}});return h.push($),$}),_=concat$2({inputs:g,backend:i,attrs:{axis:o}});return h.forEach(b=>i.disposeIntermediateTensorInfo(b)),_}const packConfig$1={kernelName:Pack,backendName:"cpu",kernelFunc:pack$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function padV2$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{paddings:c,constantValue:d}=s;assertNotComplex$1(o,"pad");const h=c.map((it,at)=>it[0]+o.shape[at]+it[1]),g=c.map(it=>it[0]),_=i.data.get(o.dataId).values,b=sizeFromShape(o.shape),$=o.shape.length,j=computeStrides(o.shape),_e=sizeFromShape(h),tt=h.length,et=computeStrides(h),nt=getTypedArrayFromDType(o.dtype,_e);d!==0&&nt.fill(d);for(let it=0;it<b;it++){const st=indexToLoc(it,$,j).map((ct,lt)=>ct+g[lt]),ot=locToIndex(st,tt,et);nt[ot]=_[it]}return{dataId:i.write(nt,h,o.dtype),shape:h,dtype:o.dtype}}const padV2Config$1={kernelName:PadV2,backendName:"cpu",kernelFunc:padV2$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const powImpl=createSimpleBinaryKernelImpl((a,e)=>Math.pow(a,e)),pow$3=binaryKernelFunc$1(Pow,powImpl),powConfig$1={kernelName:Pow,backendName:"cpu",kernelFunc:pow$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function range$2(a){const{backend:e,attrs:i}=a,{start:s,stop:o,dtype:c,step:d}=i,h=rangeImpl(s,o,d,c);return e.makeTensorInfo([h.length],c,h)}const rangeConfig$1={kernelName:Range,backendName:"cpu",kernelFunc:range$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const reciprocal$1=unaryKernelFunc$1(Reciprocal,a=>1/a),reciprocalConfig$1={kernelName:Reciprocal,backendName:"cpu",kernelFunc:reciprocal$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinear$1(a){const{inputs:e,backend:i,attrs:s}=a,{images:o}=e,{alignCorners:c,halfPixelCenters:d,size:h}=s;assertNotComplex$1(o,"resizeBilinear");const g=computeStrides(o.shape),[_,b]=h,[$,j,_e,tt]=o.shape,et=i.data.get(o.dataId).values,nt=new Float32Array(sizeFromShape([$,_,b,tt])),rt=[c&&_>1?j-1:j,c&&b>1?_e-1:_e],it=[c&&_>1?_-1:_,c&&b>1?b-1:b];let at=0;const st=rt[0]/it[0],ot=rt[1]/it[1];for(let ct=0;ct<$;ct++)for(let lt=0;lt<_;lt++){let dt;d?dt=st*(lt+.5)-.5:dt=st*lt;const xt=Math.max(0,Math.floor(dt)),ut=dt-xt,ft=Math.min(j-1,Math.ceil(dt)),mt=ct*g[0]+xt*g[1],yt=ct*g[0]+ft*g[1];for(let St=0;St<b;St++){let Et;d?Et=ot*(St+.5)-.5:Et=ot*St;const vt=Math.max(0,Math.floor(Et)),Nt=Et-vt,wt=Math.min(_e-1,Math.ceil(Et)),$t=mt+vt*g[2],Ct=yt+vt*g[2],Mt=mt+wt*g[2],Ot=yt+wt*g[2];for(let Dt=0;Dt<tt;Dt++){const At=et[$t+Dt],kt=et[Ct+Dt],Ft=et[Mt+Dt],Bt=et[Ot+Dt],Ht=At+(Ft-At)*Nt,Wt=kt+(Bt-kt)*Nt,Ut=Ht+(Wt-Ht)*ut;nt[at++]=Ut}}}return i.makeTensorInfo([$,_,b,tt],"float32",nt)}const resizeBilinearConfig$1={kernelName:ResizeBilinear,backendName:"cpu",kernelFunc:resizeBilinear$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinearGrad$1(a){const{inputs:e,backend:i,attrs:s}=a,{images:o,dy:c}=e,{alignCorners:d}=s;assertNotComplex$1([c,o],"resizeBilinearGrad");const h=computeStrides(o.shape),[g,_,b,$]=o.shape,[,j,_e]=c.shape,tt=new Float32Array(g*_*b*$),et=[d&&j>1?_-1:_,d&&_e>1?b-1:b],nt=[d&&j>1?j-1:j,d&&_e>1?_e-1:_e],rt=et[0]/nt[0],it=et[1]/nt[1],at=i.data.get(c.dataId).values;let st=0;for(let ot=0;ot<g;ot++){const ct=ot*h[0];for(let lt=0;lt<j;lt++){const dt=lt*rt,xt=Math.floor(dt),ut=Math.min(Math.ceil(dt),_-1),ft=ct+xt*h[1],mt=ct+ut*h[1],yt=dt-xt,St=1-yt;for(let Et=0;Et<_e;Et++){const vt=Et*it,Nt=Math.floor(vt),wt=Math.min(Math.ceil(vt),b-1),$t=vt-Nt,Ct=1-$t,Mt=ft+Nt*h[2],Ot=ft+wt*h[2],Dt=mt+Nt*h[2],At=mt+wt*h[2],kt=St*Ct,Ft=St*$t,Bt=yt*Ct,Ht=yt*$t;for(let Wt=0;Wt<$;Wt++){const Ut=at[st++];tt[Mt+Wt]+=Ut*kt,tt[Ot+Wt]+=Ut*Ft,tt[Dt+Wt]+=Ut*Bt,tt[At+Wt]+=Ut*Ht}}}}return i.makeTensorInfo([g,b,_,$],"float32",tt)}const resizeBilinearGradConfig$1={kernelName:ResizeBilinearGrad,backendName:"cpu",kernelFunc:resizeBilinearGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighbor$1(a){const{inputs:e,backend:i,attrs:s}=a,{images:o}=e,{alignCorners:c,halfPixelCenters:d,size:h}=s;assertNotComplex$1(o,"resizeNearestNeighbor");const g=computeStrides(o.shape),[_,b]=h,[$,j,_e,tt]=o.shape,et=i.data.get(o.dataId).values,nt=new Float32Array($*_*b*tt),rt=[c&&_>1?j-1:j,c&&b>1?_e-1:_e],it=[c&&_>1?_-1:_,c&&b>1?b-1:b],at=rt[0]/it[0],st=rt[1]/it[1];let ot=0;for(let ct=0;ct<$;ct++){const lt=ct*g[0];for(let dt=0;dt<_;dt++){const xt=d?at*(dt+.5):at*dt;let ut=Math.min(j-1,c?Math.round(xt):Math.floor(xt));d&&(ut=Math.max(0,ut));const ft=lt+ut*g[1];for(let mt=0;mt<b;mt++){const yt=d?st*(mt+.5):st*mt;let St=Math.min(_e-1,c?Math.round(yt):Math.floor(yt));d&&(St=Math.max(0,St));const Et=ft+St*g[2];for(let vt=0;vt<tt;vt++){const Nt=et[Et+vt];nt[ot++]=Nt}}}}return i.makeTensorInfo([$,_,b,tt],o.dtype,nt)}const resizeNearestNeighborConfig$1={kernelName:ResizeNearestNeighbor,backendName:"cpu",kernelFunc:resizeNearestNeighbor$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighborGrad$1(a){const{inputs:e,backend:i,attrs:s}=a,{images:o,dy:c}=e,{alignCorners:d}=s;assertNotComplex$1([c,o],"resizeNearestNeighborGrad");const h=computeStrides(o.shape),g=computeStrides(c.shape),[_,b,$,j]=o.shape,[,_e,tt]=c.shape,et=new Float32Array(_*b*$*j),nt=i.data.get(c.dataId).values,rt=[d&&_e>1?b-1:b,d&&tt>1?$-1:$],it=[d&&_e>1?_e-1:_e,d&&tt>1?tt-1:tt],at=rt[0]/it[0],st=rt[1]/it[1],ot=1/at,ct=1/st,lt=Math.ceil(ot)*2+2,dt=Math.ceil(ct)*2+2;for(let xt=0;xt<_;xt++){const ut=xt*h[0];for(let ft=0;ft<b;ft++){const mt=ut+ft*h[1],yt=Math.floor(ft*ot),St=Math.floor(yt-lt/2);for(let Et=0;Et<$;Et++){const vt=mt+Et*h[2],Nt=Math.floor(Et*ct),wt=Math.floor(Nt-dt/2);for(let $t=0;$t<j;$t++){let Ct=0;for(let Mt=0;Mt<lt;Mt++){const Ot=Mt+St;if(Ot<0||Ot>=_e)continue;const Dt=ut+Ot*g[1],At=Ot*at,kt=Math.min(b-1,d?Math.round(At):Math.floor(At));if(ft===kt)for(let Ft=0;Ft<dt;Ft++){const Bt=Ft+wt;if(Bt<0||Bt>=tt)continue;const Ht=Dt+Bt*g[2],Wt=Bt*st,Ut=Math.min($-1,d?Math.round(Wt):Math.floor(Wt));Et===Ut&&(Ct+=nt[Ht+$t])}}et[vt+$t]=Ct}}}}return i.makeTensorInfo(o.shape,o.dtype,et)}const resizeNearestNeighborGradConfig$1={kernelName:ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:resizeNearestNeighborGrad$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{dims:c}=s;assertNotComplex$1(o,"reverse");const d=o.shape.length,h=parseAxisParam(c,o.shape);if(d===0)return identity$2({inputs:{x:o},backend:i});const g=new TensorBuffer(o.shape,o.dtype),_=i.bufferSync(o);for(let b=0;b<g.size;b++){const $=g.indexToLoc(b),j=$.slice();h.forEach(_e=>j[_e]=o.shape[_e]-1-j[_e]),g.set(_.get(...j),...$)}return i.makeTensorInfo(g.shape,g.dtype,g.values)}const reverseConfig$1={kernelName:Reverse,backendName:"cpu",kernelFunc:reverse$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rotateWithOffsetConfig$1={kernelName:RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:a,attrs:e,backend:i})=>{const{image:s}=a,{radians:o,fillValue:c,center:d}=e,h=i,g=getTypedArrayFromDType(s.dtype,sizeFromShape(s.shape)),[_,b,$,j]=s.shape,[_e,tt]=getImageCenter(d,b,$),et=255,nt=Math.sin(o),rt=Math.cos(o),it=h.data.get(s.dataId).values;for(let st=0;st<_;st++){const ot=st*$*b*j;for(let ct=0;ct<b;ct++){const lt=ct*($*j);for(let dt=0;dt<$;dt++){const xt=dt*j;for(let ut=0;ut<j;ut++){const ft=[_,ct,dt,ut],mt=ft[2],yt=ft[1];let St=(mt-_e)*rt-(yt-tt)*nt,Et=(mt-_e)*nt+(yt-tt)*rt;St=Math.round(St+_e),Et=Math.round(Et+tt);let vt=c;if(typeof c!="number"&&(ut===3?vt=et:vt=c[ut]),St>=0&&St<$&&Et>=0&&Et<b){const wt=Et*($*j),$t=St*j,Ct=ot+wt+$t+ut;vt=it[Ct]}const Nt=ot+lt+xt+ut;g[Nt]=vt}}}}return{dataId:h.write(g,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const round$2=unaryKernelFunc$1(Round,a=>{const e=Math.floor(a);return a-e<.5?Math.floor(a):a-e>.5?Math.ceil(a):e%2===0?e:e+1}),roundConfig$1={kernelName:Round,backendName:"cpu",kernelFunc:round$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterImpl(a,e,i,s,o,c,d,h,g,_){const b=[s/o,o],$=a.values,j=e.values;if(s===0)return buffer(i,e.dtype);const _e=buffer(b,e.dtype);_e.values.fill(g);for(let tt=0;tt<c;tt++){const et=[];let nt=0;for(let rt=0;rt<d;rt++){const it=$[tt*d+rt];et.push(it),nt+=it*h[rt]}if(nt<0||nt>=s/o)throw new Error(`Invalid indices: ${et} does not index into ${i}`);for(let rt=0;rt<o;rt++)_?_e.values[nt*o+rt]+=j[tt*o+rt]:_e.values[nt*o+rt]=e.rank===0?j[0]:j[tt*o+rt]}return _e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterNd$1(a){const{inputs:e,backend:i,attrs:s}=a,{indices:o,updates:c}=e,{shape:d}=s,{sliceRank:h,numUpdates:g,sliceSize:_,strides:b,outputSize:$}=calculateShapes(c,o,d),j=!0,_e=i.bufferSync(o),tt=i.bufferSync(c),et=scatterImpl(_e,tt,d,$,_,g,h,b,0,j);return i.makeTensorInfo(d,et.dtype,et.values)}const scatterNdConfig$1={kernelName:ScatterNd,backendName:"cpu",kernelFunc:scatterNd$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function select$1(a){const{inputs:e,backend:i}=a,{condition:s,t:o,e:c}=e;assertNotComplex$1([s,o,c],"select");const d=s.shape.length,h=i.data.get(s.dataId).values,g=i.data.get(o.dataId).values,_=i.data.get(c.dataId).values,b=upcastType(o.dtype,c.dtype),$=makeZerosTypedArray(sizeFromShape(o.shape),b);let j=0;const _e=d===0||d>1||o.shape.length===1?1:sizeFromShape(o.shape.slice(1));for(let tt=0;tt<h.length;tt++)for(let et=0;et<_e;et++)h[tt]===1?$[j++]=g[tt]:$[j++]=_[tt];return i.makeTensorInfo(o.shape,b,$)}const selectConfig$1={kernelName:Select,backendName:"cpu",kernelFunc:select$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const scaleAlpha=SELU_SCALEALPHA,scale=SELU_SCALE,selu$1=unaryKernelFunc$1(Selu$1,a=>a>=0?scale*a:scaleAlpha*(Math.exp(a)-1)),seluConfig$1={kernelName:Selu$1,backendName:"cpu",kernelFunc:selu$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sigmoid$1=unaryKernelFunc$1(Sigmoid$1,a=>1/(1+Math.exp(-a))),sigmoidConfig$1={kernelName:Sigmoid$1,backendName:"cpu",kernelFunc:sigmoid$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sign$4=unaryKernelFunc$1(Sign,a=>a<0?-1:a>0?1:0),signConfig$1={kernelName:Sign,backendName:"cpu",kernelFunc:sign$4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sin$3=unaryKernelFunc$1(Sin,a=>Math.sin(a)),sinConfig$1={kernelName:Sin,backendName:"cpu",kernelFunc:sin$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sinh$2=unaryKernelFunc$1(Sinh,a=>Math.sinh(a)),sinhConfig$1={kernelName:Sinh,backendName:"cpu",kernelFunc:sinh$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const epsilon=11920928955078125e-23,threshold=Math.log(epsilon)+2,softplus$1=unaryKernelFunc$1(Softplus$1,a=>{const e=a>-threshold,i=a<threshold,s=Math.exp(a);let o;return i?o=s:e?o=a:o=Math.log(1+s),o}),softplusConfig$1={kernelName:Softplus$1,backendName:"cpu",kernelFunc:softplus$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function spaceToBatchND$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{blockShape:c,paddings:d}=s;assertNotComplex$1([o],"spaceToBatchND");const h=sizeFromShape(c),g=[[0,0]];g.push(...d);for(let ct=1+c.length;ct<o.shape.length;++ct)g.push([0,0]);const _=padV2Config$1.kernelFunc({inputs:{x:o},backend:i,attrs:{paddings:g,constantValue:0}}),b=getReshaped(_.shape,c,h,!1),$=getPermuted(b.length,c.length,!1),j=getReshapedPermuted(_.shape,c,h,!1),et=reshape$2({inputs:{x:_},backend:i,attrs:{shape:b}}),it=transpose$2({inputs:{x:et},backend:i,attrs:{perm:$}}),ot=reshape$2({inputs:{x:it},backend:i,attrs:{shape:j}});return i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(et),i.disposeIntermediateTensorInfo(it),ot}const spaceToBatchNDConfig$1={kernelName:SpaceToBatchND,backendName:"cpu",kernelFunc:spaceToBatchND$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseToDense$1(a){const{inputs:e,backend:i,attrs:s}=a,{sparseIndices:o,sparseValues:c,defaultValue:d}=e,{outputShape:h}=s,{sliceRank:g,numUpdates:_,sliceSize:b,strides:$,outputSize:j}=calculateShapes(c,o,h),_e=!1,tt=i.bufferSync(o),et=i.bufferSync(c),nt=i.data.get(d.dataId).values[0],rt=scatterImpl(tt,et,h,j,b,_,g,$,nt,_e);return i.makeTensorInfo(h,rt.dtype,rt.values)}const sparseToDenseConfig$1={kernelName:SparseToDense,backendName:"cpu",kernelFunc:sparseToDense$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function splitV$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{numOrSizeSplits:c,axis:d}=s,h=parseAxisParam(d,o.shape)[0],g=prepareSplitSize(o,c,h),_=new Array(o.shape.length).fill(0),b=o.shape.slice();return g.map($=>{const j=[...b];j[h]=$;const _e=slice$1({inputs:{x:o},backend:i,attrs:{begin:_,size:j}});return _[h]+=$,_e})}const splitVConfig$1={kernelName:SplitV,backendName:"cpu",kernelFunc:splitV$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sqrt$3=unaryKernelFunc$1(Sqrt,a=>Math.sqrt(a)),sqrtConfig$1={kernelName:Sqrt,backendName:"cpu",kernelFunc:sqrt$3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const squareConfig$1={kernelName:Square,backendName:"cpu",kernelFunc:({inputs:a,backend:e})=>{const{x:i}=a,s=e;assertNotComplex$1(i,"square");const o=s.data.get(i.dataId).values,c=new Float32Array(o.length);for(let h=0;h<o.length;++h){const g=o[h];c[h]=g*g}return{dataId:s.write(c,i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const step$1=unaryKernelFunc$1(Step,(a,e)=>{const i=e;return isNaN(a)?NaN:a>0?1:i.alpha}),stepConfig$1={kernelName:Step,backendName:"cpu",kernelFunc:step$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSlice$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{begin:c,end:d,strides:h,beginMask:g,endMask:_,ellipsisMask:b,newAxisMask:$,shrinkAxisMask:j}=s;assertNotComplex$1(o,"stridedSlice");const{nonStrided:_e,$begin:tt,$strides:et,size:nt,newShape:rt,outShape:it}=sliceInfo(o.shape,c,d,h,g,_,b,$,j),at=reshape$2({inputs:{x:o},backend:i,attrs:{shape:rt}});let st;if(_e){const ct=slice$1({inputs:{x:at},backend:i,attrs:{begin:tt,size:nt}});st=reshape$2({inputs:{x:ct},backend:i,attrs:{shape:it}}),i.disposeIntermediateTensorInfo(ct)}else if(it.some(ct=>ct===0))st=i.makeTensorInfo(it,o.dtype,[]);else{const ct=i.bufferSync(at),lt=stridedSliceImpl(it,ct,et,tt);st=i.makeTensorInfo(lt.shape,lt.dtype,lt.values)}const ot=reshape$2({inputs:{x:st},backend:i,attrs:{shape:it}});return i.disposeIntermediateTensorInfo(at),i.disposeIntermediateTensorInfo(st),ot}const stridedSliceConfig$1={kernelName:StridedSlice,backendName:"cpu",kernelFunc:stridedSlice$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tan$2=unaryKernelFunc$1(Tan,a=>Math.tan(a)),tanConfig$1={kernelName:Tan,backendName:"cpu",kernelFunc:tan$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tanh$2=unaryKernelFunc$1(Tanh$1,a=>Math.tanh(a)),tanhConfig$1={kernelName:Tanh$1,backendName:"cpu",kernelFunc:tanh$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{reps:c}=s;assertNotComplex$1(o,"tile");const d=tileImpl(i.bufferSync(o),c);return i.makeTensorInfo(d.shape,d.dtype,d.values)}const tileConfig$1={kernelName:Tile,backendName:"cpu",kernelFunc:tile$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topK$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{k:c,sorted:d}=s;assertNotComplex$1(o,"topk");const h=i.data.get(o.dataId).values,[g,_]=topKImpl(h,o.shape,o.dtype,c);return[i.makeTensorInfo(g.shape,g.dtype,g.values),i.makeTensorInfo(_.shape,_.dtype,_.values)]}const topKConfig$1={kernelName:TopK,backendName:"cpu",kernelFunc:topK$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unique$1(a){const{inputs:e,attrs:i,backend:s}=a,{axis:o}=i,{x:c}=e;assertNotComplex$1(c,"unique");const d=s.data.get(c.dataId).values,{outputValues:h,outputShape:g,indices:_}=uniqueImpl(d,o,c.shape,c.dtype);return[s.makeTensorInfo(g,c.dtype,h),s.makeTensorInfo([_.length],"int32",_)]}const uniqueConfig$1={kernelName:Unique,backendName:"cpu",kernelFunc:unique$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unpack$1(a){const{inputs:e,backend:i,attrs:s}=a,{value:o}=e;let{axis:c}=s;c<0&&(c+=o.shape.length);const d=o.shape.length,h=o.shape[c],g=new Array(d-1);let _=0;for(let _e=0;_e<d;_e++)_e!==c&&(g[_++]=o.shape[_e]);const b=new Array(d).fill(0),$=o.shape.slice();$[c]=1;const j=new Array(h);for(let _e=0;_e<j.length;_e++){b[c]=_e;const tt=slice$1({inputs:{x:o},backend:i,attrs:{begin:b,size:$}});j[_e]=reshape$2({inputs:{x:tt},backend:i,attrs:{shape:g}}),i.disposeIntermediateTensorInfo(tt)}return j}const unpackConfig$1={kernelName:Unpack,backendName:"cpu",kernelFunc:unpack$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unsortedSegmentSum$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,segmentIds:c}=e,{numSegments:d}=s;assertNotComplex$1(o,"unsortedSegmentSum");const h=o.shape.length,g=c.shape.length,_=[],b=[],$=h-g;let j=c;for(let tt=0;tt<$;++tt){const et=expandDims$1({inputs:{input:j},backend:i,attrs:{dim:tt+1}});j=et,b.push(et)}for(let tt=0;tt<d;++tt){const et=createScalarValue(tt,"int32"),nt=i.makeTensorInfo([],"int32",et),rt=equal$2({inputs:{a:nt,b:j},backend:i}),it=cast$1({inputs:{x:rt},backend:i,attrs:{dtype:"float32"}}),at=multiply$2({inputs:{a:it,b:o},backend:i}),st=sum$2({inputs:{x:at},backend:i,attrs:{axis:0,keepDims:!1}});_.push(st),b.push(nt),b.push(rt),b.push(it),b.push(at),b.push(st)}const _e=pack$1({inputs:_,backend:i,attrs:{axis:0}});return b.forEach(tt=>i.disposeIntermediateTensorInfo(tt)),_e}const unsortedSegmentSumConfig$1={kernelName:UnsortedSegmentSum,backendName:"cpu",kernelFunc:unsortedSegmentSum$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kernelConfigs$1=[_fusedMatMulConfig$1,absConfig$1,acosConfig$1,acoshConfig$1,addConfig$1,addNConfig$1,allConfig$1,anyConfig$1,argMaxConfig$1,argMinConfig$1,asinConfig$1,asinhConfig$1,atanConfig$1,atan2Config$1,atanhConfig$1,avgPoolConfig$1,avgPool3DConfig$1,avgPool3DGradConfig,avgPoolGradConfig$1,batchMatMulConfig$1,batchNormConfig$1,batchToSpaceNDConfig$1,bincountConfig$1,castConfig$1,ceilConfig$1,clipConfig,complexConfig$1,complexAbsConfig$1,concatConfig$1,conv2DBackpropFilterConfig$1,conv2DBackpropInputConfig$1,conv2DConfig$1,conv3DBackpropFilterV2Config$1,conv3DBackpropInputV2Config,conv3DConfig$1,cosConfig$1,coshConfig$1,cropAndResizeConfig$1,cumsumConfig$1,denseBincountConfig$1,depthToSpaceConfig$1,depthwiseConv2dNativeConfig$1,depthwiseConv2dNativeBackpropFilterConfig$1,depthwiseConv2dNativeBackpropInputConfig$1,diagConfig$1,dilation2dConfig,dilation2dBackpropInputConfig,dilation2dBackpropFilterConfig,realDivConfig$1,eluConfig$1,eluGradConfig$1,equalConfig$1,erfConfig$1,expConfig$1,expandDimsConfig$1,expm1Config$1,fftConfig$1,fillConfig$1,flipLeftRightConfig$1,floorConfig$1,floorDivConfig$1,fusedConv2DConfig$1,fusedDepthwiseConv2DConfig$1,gatherNdConfig$1,gatherV2Config$1,greaterConfig$1,greaterEqualConfig$1,identityConfig$1,ifftConfig$1,imagConfig$1,isFiniteConfig$1,isInfConfig$1,isNaNConfig$1,leakyReluConfig$1,lessConfig$1,lessEqualConfig$1,linSpaceConfig$1,logConfig$1,log1pConfig$1,logicalAndConfig$1,logicalNotConfig$1,logicalOrConfig$1,lRNConfig,lRNGradConfig,maximumConfig$1,maxPoolConfig$1,maxPool3DConfig$1,maxPool3DGradConfig,maxPoolGradConfig$1,maxPoolWithArgmaxConfig$1,maxConfig$1,meanConfig$1,minConfig$1,minimumConfig$1,mirrorPadConfig$1,modConfig$1,multinomialConfig$1,multiplyConfig$1,negConfig$1,nonMaxSuppressionV3Config$1,nonMaxSuppressionV4Config$1,nonMaxSuppressionV5Config$1,notEqualConfig$1,oneHotConfig$1,onesLikeConfig$1,packConfig$1,padV2Config$1,powConfig$1,preluConfig$1,prodConfig$1,rangeConfig$1,realConfig$1,reciprocalConfig$1,reluConfig$1,relu6Config$1,reshapeConfig$1,resizeBilinearConfig$1,resizeBilinearGradConfig$1,resizeNearestNeighborConfig$1,resizeNearestNeighborGradConfig$1,reverseConfig$1,rotateWithOffsetConfig$1,roundConfig$1,rsqrtConfig$1,scatterNdConfig$1,selectConfig$1,seluConfig$1,sigmoidConfig$1,signConfig$1,sinConfig$1,sinhConfig$1,sliceConfig$1,softmaxConfig$1,softplusConfig$1,spaceToBatchNDConfig$1,sparseToDenseConfig$1,splitVConfig$1,sqrtConfig$1,squareConfig$1,squaredDifferenceConfig$1,stepConfig$1,stridedSliceConfig$1,subConfig$1,sumConfig$1,tanConfig$1,tanhConfig$1,tileConfig$1,topKConfig$1,transposeConfig$1,uniqueConfig$1,unpackConfig$1,unsortedSegmentSumConfig$1,zerosLikeConfig$1];for(const a of kernelConfigs$1)registerKernel(a);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const contexts={},WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function setWebGLContext(a,e){contexts[a]=e}function getWebGLContext(a){if(!(a in contexts)){const i=getWebGLRenderingContext(a);if(i!==null)contexts[a]=i;else return console.log("Could not get context for WebGL version",a),null}const e=contexts[a];return e.isContextLost()?(delete contexts[a],getWebGLContext(a)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),contexts[a])}function createCanvas(a){if(typeof OffscreenCanvas<"u"&&a===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function getWebGLRenderingContext(a){if(a!==1&&a!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=createCanvas(a);return e.addEventListener("webglcontextlost",i=>{i.preventDefault(),delete contexts[a]},!1),a===1?e.getContext("webgl",WEBGL_ATTRIBUTES)||e.getContext("experimental-webgl",WEBGL_ATTRIBUTES):e.getContext("webgl2",WEBGL_ATTRIBUTES)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var PackingScheme;(function(a){a[a.DENSE=0]="DENSE",a[a.SHARED_BATCH=1]="SHARED_BATCH"})(PackingScheme||(PackingScheme={}));var TextureUsage;(function(a){a[a.RENDER=0]="RENDER",a[a.UPLOAD=1]="UPLOAD",a[a.PIXELS=2]="PIXELS",a[a.DOWNLOAD=3]="DOWNLOAD"})(TextureUsage||(TextureUsage={}));var PhysicalTextureType;(function(a){a[a.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",a[a.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",a[a.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",a[a.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",a[a.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(PhysicalTextureType||(PhysicalTextureType={}));function getUnpackedMatrixTextureShapeWidthHeight(a,e){return[e,a]}function getUnpackedArraySizeFromMatrixSize(a,e){return a*e}function getDenseTexShape(a){const e=sizeFromShape(a),i=Math.ceil(e/4);return sizeToSquarishShape(i)}function getPackedMatrixTextureShapeWidthHeight(a,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(a/2))]}function getPackedRGBAArraySizeFromMatrixShape(a,e){const[i,s]=getPackedMatrixTextureShapeWidthHeight(a,e);return i*s*4}function getTextureConfig(a,e){const i=a;let s,o,c,d,h,g,_,b,$,j;return env$1().getNumber("WEBGL_VERSION")===2?(s=i.R32F,o=i.R16F,c=i.RGBA16F,d=i.RGBA32F,h=i.RED,_=4,b=1,$=i.HALF_FLOAT,j=i.FLOAT):(s=a.RGBA,o=a.RGBA,c=a.RGBA,d=i.RGBA,h=a.RGBA,_=4,b=4,$=e!=null?e.HALF_FLOAT_OES:null,j=a.FLOAT),g=a.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:c,internalFormatPackedFloat:d,textureFormatFloat:h,downloadTextureFormat:g,downloadUnpackNumChannels:_,defaultNumChannels:b,textureTypeHalfFloat:$,textureTypeFloat:j}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function callAndCheck(a,e){const i=e();return env$1().getBool("DEBUG")&&checkWebGLError(a),i}function checkWebGLError(a){const e=a.getError();if(e!==a.NO_ERROR)throw new Error("WebGL Error: "+getWebGLErrorMessage(a,e))}const MIN_FLOAT16=596e-10,MAX_FLOAT16=65504;function canBeRepresented(a){return!!(env$1().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||a===0||MIN_FLOAT16<Math.abs(a)&&Math.abs(a)<MAX_FLOAT16)}function getWebGLErrorMessage(a,e){switch(e){case a.NO_ERROR:return"NO_ERROR";case a.INVALID_ENUM:return"INVALID_ENUM";case a.INVALID_VALUE:return"INVALID_VALUE";case a.INVALID_OPERATION:return"INVALID_OPERATION";case a.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case a.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case a.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function getExtensionOrThrow(a,e){return throwIfNull(a,()=>a.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function createVertexShader$1(a,e){const i=throwIfNull(a,()=>a.createShader(a.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(callAndCheck(a,()=>a.shaderSource(i,e)),callAndCheck(a,()=>a.compileShader(i)),a.getShaderParameter(i,a.COMPILE_STATUS)===!1)throw console.log(a.getShaderInfoLog(i)),new Error("Failed to compile vertex shader.");return i}function createFragmentShader(a,e){const i=throwIfNull(a,()=>a.createShader(a.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(callAndCheck(a,()=>a.shaderSource(i,e)),callAndCheck(a,()=>a.compileShader(i)),a.getShaderParameter(i,a.COMPILE_STATUS)===!1)throw logShaderSourceAndInfoLog(e,a.getShaderInfoLog(i)),new Error("Failed to compile fragment shader.");return i}const lineNumberRegex=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(a,e){const i=lineNumberRegex.exec(e);if(i==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(a);return}const s=+i[1],o=a.split(`
`),c=o.length.toString().length+2,d=o.map(($,j)=>rightPad((j+1).toString(),c)+$);let h=0;for(let $=0;$<d.length;$++)h=Math.max(d[$].length,h);const g=d.slice(0,s-1),_=d.slice(s-1,s),b=d.slice(s);console.log(g.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${rightPad(_[0],h)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(b.join(`
`))}function createProgram(a){return throwIfNull(a,()=>a.createProgram(),"Unable to create WebGLProgram.")}function linkProgram(a,e){if(callAndCheck(a,()=>a.linkProgram(e)),a.getProgramParameter(e,a.LINK_STATUS)===!1)throw console.log(a.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function validateProgram(a,e){if(callAndCheck(a,()=>a.validateProgram(e)),a.getProgramParameter(e,a.VALIDATE_STATUS)===!1)throw console.log(a.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function createStaticVertexBuffer(a,e){const i=throwIfNull(a,()=>a.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(a,()=>a.bindBuffer(a.ARRAY_BUFFER,i)),callAndCheck(a,()=>a.bufferData(a.ARRAY_BUFFER,e,a.STATIC_DRAW)),i}function createStaticIndexBuffer(a,e){const i=throwIfNull(a,()=>a.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(a,()=>a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,i)),callAndCheck(a,()=>a.bufferData(a.ELEMENT_ARRAY_BUFFER,e,a.STATIC_DRAW)),i}function createTexture(a){return throwIfNull(a,()=>a.createTexture(),"Unable to create WebGLTexture.")}function validateTextureSize(a,e){const i=env$1().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(a<=0||e<=0){const s=`[${a}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(a>i||e>i){const s=`[${a}x${e}]`,o=`[${i}x${i}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+o+".")}}function createFramebuffer(a){return throwIfNull(a,()=>a.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(a,e,i,s,o,c,d){const h=a.getAttribLocation(e,i);return h===-1?!1:(callAndCheck(a,()=>a.bindBuffer(a.ARRAY_BUFFER,s)),callAndCheck(a,()=>a.vertexAttribPointer(h,o,a.FLOAT,!1,c,d)),callAndCheck(a,()=>a.enableVertexAttribArray(h)),!0)}function bindTextureUnit(a,e,i){validateTextureUnit(a,i),callAndCheck(a,()=>a.activeTexture(a.TEXTURE0+i)),callAndCheck(a,()=>a.bindTexture(a.TEXTURE_2D,e))}function getProgramUniformLocationOrThrow(a,e,i){return throwIfNull(a,()=>a.getUniformLocation(e,i),'uniform "'+i+'" not present in program.')}function getProgramUniformLocation(a,e,i){return a.getUniformLocation(e,i)}function bindTextureToProgramUniformSampler(a,e,i,s){callAndCheck(a,()=>bindTextureUnit(a,e,s)),callAndCheck(a,()=>a.uniform1i(i,s))}function bindColorTextureToFramebuffer(a,e,i){callAndCheck(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,i)),callAndCheck(a,()=>a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0))}function unbindColorTextureFromFramebuffer(a,e){callAndCheck(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,e)),callAndCheck(a,()=>a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,null,0))}function validateFramebuffer(a){const e=a.checkFramebufferStatus(a.FRAMEBUFFER);if(e!==a.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+getFramebufferErrorMessage(a,e))}function getFramebufferErrorMessage(a,e){switch(e){case a.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case a.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case a.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case a.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function throwIfNull(a,e,i){const s=callAndCheck(a,()=>e());if(s==null)throw new Error(i);return s}function validateTextureUnit(a,e){const i=a.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+a.TEXTURE0;if(s<a.TEXTURE0||s>i){const o=`[gl.TEXTURE0, gl.TEXTURE${i}]`;throw new Error(`textureUnit must be in ${o}.`)}}function getBatchDim(a,e=2){return sizeFromShape(a.slice(0,a.length-e))}function getRowsCols(a){if(a.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[a.length>1?a[a.length-2]:1,a[a.length-1]]}function getShapeAs3D(a){let e=[1,1,1];return a.length===0||a.length===1&&a[0]===1||(e=[getBatchDim(a),...getRowsCols(a)]),e}function getTextureShapeFromLogicalShape(a,e=!1){let i=env$1().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(i=i*2,a=a.map((o,c)=>c>=a.length-2?nearestLargerEven(a[c]):a[c]),a.length===1&&(a=[2,a[0]])),a.length!==2&&(a=squeezeShape(a).newShape);let s=sizeFromShape(a);if(a.length<=1&&s<=i)return[1,s];if(a.length===2&&a[0]<=i&&a[1]<=i)return a;if(a.length===3&&a[0]*a[1]<=i&&a[2]<=i)return[a[0]*a[1],a[2]];if(a.length===3&&a[0]<=i&&a[1]*a[2]<=i)return[a[0],a[1]*a[2]];if(a.length===4&&a[0]*a[1]*a[2]<=i&&a[3]<=i)return[a[0]*a[1]*a[2],a[3]];if(a.length===4&&a[0]<=i&&a[1]*a[2]*a[3]<=i)return[a[0],a[1]*a[2]*a[3]];if(e){const o=getBatchDim(a);let c=2,d=2;return a.length&&([c,d]=getRowsCols(a)),s=o*(c/2)*(d/2),sizeToSquarishShape(s).map(h=>h*2)}return sizeToSquarishShape(s)}function isEven(a){return a%2===0}function isReshapeFree(a,e){if(a=a.slice(-2),e=e.slice(-2),arraysEqual(a,e)||!a.length||!e.length||a[0]===0||a[1]===0||e[0]===0||e[1]===0)return!0;if(a.length!==e.length){const i=a.slice(-1)[0],s=e.slice(-1)[0];if(i===s||isEven(i)&&isEven(s)&&(a[0]===1||e[0]===1))return!0}return a[1]===e[1]&&isEven(a[0])&&isEven(e[0])}let MAX_TEXTURE_SIZE,MAX_TEXTURES_IN_SHADER;function getWebGLMaxTextureSize(a){if(MAX_TEXTURE_SIZE==null){const e=getWebGLContext(a);MAX_TEXTURE_SIZE=e.getParameter(e.MAX_TEXTURE_SIZE)}return MAX_TEXTURE_SIZE}function getMaxTexturesInShader(a){if(MAX_TEXTURES_IN_SHADER==null){const e=getWebGLContext(a);MAX_TEXTURES_IN_SHADER=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,MAX_TEXTURES_IN_SHADER)}function getWebGLDisjointQueryTimerVersion(a){if(a===0)return 0;let e;const i=getWebGLContext(a);return hasExtension(i,"EXT_disjoint_timer_query_webgl2")&&a===2?e=2:hasExtension(i,"EXT_disjoint_timer_query")?e=1:e=0,e}function hasExtension(a,e){return a.getExtension(e)!=null}function isWebGLVersionEnabled(a){try{if(getWebGLContext(a)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function isCapableOfRenderingToFloatTexture(a){if(a===0)return!1;const e=getWebGLContext(a);if(a===1){if(!hasExtension(e,"OES_texture_float"))return!1}else if(!hasExtension(e,"EXT_color_buffer_float"))return!1;return createFloatTextureAndBindToFramebuffer(e)}function isDownloadFloatTextureEnabled(a){if(a===0)return!1;const e=getWebGLContext(a);if(a===1){if(!hasExtension(e,"OES_texture_float")||!hasExtension(e,"WEBGL_color_buffer_float"))return!1}else{if(hasExtension(e,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer(e);const s="EXT_color_buffer_half_float";if(hasExtension(e,s)){const o=e.getExtension(s);return createHalfFloatTextureAndBindToFramebuffer(e,o)}return!1}return createFloatTextureAndBindToFramebuffer(e)}function createFloatTextureAndBindToFramebuffer(a){const e=getTextureConfig(a),i=a.createTexture();a.bindTexture(a.TEXTURE_2D,i),a.texImage2D(a.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const c=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,c),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,i,0);const d=a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE;return a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteTexture(i),a.deleteFramebuffer(c),d}function createHalfFloatTextureAndBindToFramebuffer(a,e){const i=getTextureConfig(a,e),s=a.createTexture();a.bindTexture(a.TEXTURE_2D,s),a.texImage2D(a.TEXTURE_2D,0,i.internalFormatHalfFloat,1,1,0,i.textureFormatFloat,i.textureTypeHalfFloat,null);const d=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,d),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,s,0);const h=a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE;return a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null),a.deleteTexture(s),a.deleteFramebuffer(d),h}function isWebGLFenceEnabled(a){return a!==2?!1:getWebGLContext(a).fenceSync!=null}function assertNotComplex(a,e){Array.isArray(a)||(a=[a]),a.forEach(i=>{i!=null&&assert$1(i.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ENV=env$1();ENV.registerFlag("HAS_WEBGL",()=>ENV.getNumber("WEBGL_VERSION")>0);ENV.registerFlag("WEBGL_VERSION",()=>isWebGLVersionEnabled(2)?2:isWebGLVersionEnabled(1)?1:0);ENV.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ENV.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ENV.get("WEBGL_VERSION")===2);ENV.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ENV.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ENV.registerFlag("WEBGL_PACK",()=>ENV.getBool("HAS_WEBGL"));ENV.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_PACK_CLIP",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1);ENV.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_PACK_REDUCE",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_LAZILY_UNPACK",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_CONV_IM2COL",()=>ENV.getBool("WEBGL_PACK"));ENV.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>getWebGLMaxTextureSize(ENV.getNumber("WEBGL_VERSION")));ENV.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>getMaxTexturesInShader(ENV.getNumber("WEBGL_VERSION")));ENV.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const a=ENV.getNumber("WEBGL_VERSION");return a===0?0:getWebGLDisjointQueryTimerVersion(a)});ENV.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ENV.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!isMobile());ENV.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>isCapableOfRenderingToFloatTexture(ENV.getNumber("WEBGL_VERSION")));ENV.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ENV.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ENV.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ENV.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>isDownloadFloatTextureEnabled(ENV.getNumber("WEBGL_VERSION")));ENV.registerFlag("WEBGL_FENCE_API_ENABLED",()=>isWebGLFenceEnabled(ENV.getNumber("WEBGL_VERSION")));ENV.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ENV.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ENV.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,a=>{if(a<0&&a!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${a}.`)});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getGlslDifferences(){let a,e,i,s,o,c,d,h,g,_;return env$1().getNumber("WEBGL_VERSION")===2?(a="#version 300 es",e="in",i="out",s="in",o="texture",c="outputColor",d="out vec4 outputColor;",h=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,g="",_=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(a="",e="attribute",i="varying",s="varying",o="texture2D",c="gl_FragColor",d="",h=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,g=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,_=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:a,attribute:e,varyingVs:i,varyingFs:s,texture2D:o,output:c,defineOutput:d,defineSpecialNaN:h,defineSpecialInf:g,defineRound:_}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getLogicalCoordinatesFromFlatIndex(a,e,i="index"){const s=computeStrides(e);return s.map((o,c)=>{const d=`int ${a[c]} = ${i} / ${o}`,h=c===s.length-1?`int ${a[c+1]} = ${i} - ${a[c]} * ${o}`:`index -= ${a[c]} * ${o}`;return`${d}; ${h};`}).join("")}function getFlatIndexFrom3D(a){const e=computeStrides(a).map(i=>i.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}const ENCODE_FLOAT_SNIPPET=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DecodeMatrixProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE;const i=getDenseTexShape(e),s=getGlslDifferences();this.outputShape=e,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${i[0]}, ${i[1]}));
        int index = 4 * (resTexRC.x * ${i[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DecodeMatrixPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=PackingScheme.DENSE;const i=getDenseTexShape(e),s=getGlslDifferences();this.outputShape=e,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${i[0]}, ${i[1]}));
        int index = 4 * (resTexRC.x * ${i[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EncodeFloatProgram{constructor(e){this.variableNames=["A"],this.outTexUsage=TextureUsage.DOWNLOAD;const i=getGlslDifferences();this.outputShape=e,this.userCode=`
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        float x = getAAtOutCoords();
        ${i.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EncodeFloatPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TextureUsage.DOWNLOAD;const i=getGlslDifferences();this.outputShape=e,this.userCode=`
      ${ENCODE_FLOAT_SNIPPET}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${i.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EncodeMatrixProgram{constructor(e,i,s=!1){this.variableNames=["A"];const o=getGlslDifferences(),[c,d]=i;this.outputShape=e;let h="result";s&&(h="floor(result * 255. + 0.5)"),this.userCode=`
      ${getFlatIndexFrom3D(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${d};
        int c = imod(flatIndex, ${d});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${d}.0, ${c}.0);
        vec4 values = ${o.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${o.output} = vec4(${h}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EncodeMatrixPackedProgram{constructor(e,i,s=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const o=getGlslDifferences(),[c,d]=i;this.outputShape=e;let h="",g="result";s&&(g="floor(result * 255. + 0.5)");for(let _=0;_<=1;_++)for(let b=0;b<=1;b++){const $=_*2+b;h+=`
          localCoords = coords;
          if(localCoords[2] + ${b} < ${e[2]}) {
            localCoords[2] += ${b};
            if(localCoords[1] + ${_} < ${e[1]}) {
              localCoords[1] += ${_};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${d};
              c = imod(flatIndex, ${d});
              uv = (vec2(c, r) + halfCR) / vec2(${d}.0, ${c}.0);
              values = ${o.texture2D}(A, uv);

              if(offset == 0) {
                result[${$}] = values[0];
              } else if(offset == 1) {
                result[${$}] = values[1];
              } else if(offset == 2) {
                result[${$}] = values[2];
              } else {
                result[${$}] = values[3];
              }
            }
          }
        `}this.userCode=`
      ${getFlatIndexFrom3D(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${h}

        ${o.output} = ${g};
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createVertexShader(a){const e=getGlslDifferences(),i=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return createVertexShader$1(a,i)}function createVertexBuffer(a){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return createStaticVertexBuffer(a,e)}function createIndexBuffer(a){const e=new Uint16Array([0,1,2,2,1,3]);return createStaticIndexBuffer(a,e)}function createAndConfigureTexture(a,e,i,s,o,c){validateTextureSize(e,i);const d=createTexture(a),h=a.TEXTURE_2D;return callAndCheck(a,()=>a.bindTexture(h,d)),callAndCheck(a,()=>a.texParameteri(h,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE)),callAndCheck(a,()=>a.texParameteri(h,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE)),callAndCheck(a,()=>a.texParameteri(h,a.TEXTURE_MIN_FILTER,a.NEAREST)),callAndCheck(a,()=>a.texParameteri(h,a.TEXTURE_MAG_FILTER,a.NEAREST)),callAndCheck(a,()=>a.texImage2D(h,0,s,e,i,0,o,c,null)),callAndCheck(a,()=>a.bindTexture(a.TEXTURE_2D,null)),d}function getInternalFormatForFloat32MatrixTexture(a){return a.internalFormatFloat}function createFloat32MatrixTexture(a,e,i,s){const[o,c]=getUnpackedMatrixTextureShapeWidthHeight(e,i);return createAndConfigureTexture(a,o,c,getInternalFormatForFloat32MatrixTexture(s),s.textureFormatFloat,a.FLOAT)}function getInternalFormatForFloat16MatrixTexture(a){return a.internalFormatHalfFloat}function createFloat16MatrixTexture(a,e,i,s){const[o,c]=getUnpackedMatrixTextureShapeWidthHeight(e,i);return createAndConfigureTexture(a,o,c,getInternalFormatForFloat16MatrixTexture(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function getInternalFormatForUnsignedBytesMatrixTexture(a){return a.downloadTextureFormat}function createUnsignedBytesMatrixTexture(a,e,i,s){const[o,c]=getUnpackedMatrixTextureShapeWidthHeight(e,i);return createAndConfigureTexture(a,o,c,getInternalFormatForUnsignedBytesMatrixTexture(s),a.RGBA,a.UNSIGNED_BYTE)}function getInternalFormatForPackedMatrixTexture(a){return a.internalFormatPackedFloat}function createPackedMatrixTexture(a,e,i,s){const[o,c]=getPackedMatrixTextureShapeWidthHeight(e,i);return createAndConfigureTexture(a,o,c,getInternalFormatForPackedMatrixTexture(s),a.RGBA,a.FLOAT)}function getInternalFormatForFloat16PackedMatrixTexture(a){return a.internalFormatPackedHalfFloat}function createFloat16PackedMatrixTexture(a,e,i,s){const[o,c]=getPackedMatrixTextureShapeWidthHeight(e,i);return createAndConfigureTexture(a,o,c,getInternalFormatForFloat16PackedMatrixTexture(s),a.RGBA,s.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(a,e,i){return callAndCheck(a,()=>a.bindBuffer(a.ARRAY_BUFFER,i)),bindVertexBufferToProgramAttribute(a,e,"clipSpacePos",i,3,20,0)&&bindVertexBufferToProgramAttribute(a,e,"uv",i,2,20,12)}function uploadDenseMatrixToTexture(a,e,i,s,o,c){callAndCheck(a,()=>a.bindTexture(a.TEXTURE_2D,e));let d,h,g;o instanceof Uint8Array?(d=new Uint8Array(i*s*4),h=a.UNSIGNED_BYTE,g=a.RGBA):(d=new Float32Array(i*s*4),h=a.FLOAT,g=c.internalFormatPackedFloat),d.set(o),callAndCheck(a,()=>a.texImage2D(a.TEXTURE_2D,0,g,i,s,0,a.RGBA,h,d)),callAndCheck(a,()=>a.bindTexture(a.TEXTURE_2D,null))}function uploadPixelDataToTexture(a,e,i){callAndCheck(a,()=>a.bindTexture(a.TEXTURE_2D,e)),i.data instanceof Uint8Array?callAndCheck(a,()=>a.texImage2D(a.TEXTURE_2D,0,a.RGBA,i.width,i.height,0,a.RGBA,a.UNSIGNED_BYTE,i.data)):callAndCheck(a,()=>a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,i)),callAndCheck(a,()=>a.bindTexture(a.TEXTURE_2D,null))}function createBufferFromOutputTexture(a,e,i,s){const o=a.createBuffer();callAndCheck(a,()=>a.bindBuffer(a.PIXEL_PACK_BUFFER,o));const h=4*4*e*i;return callAndCheck(a,()=>a.bufferData(a.PIXEL_PACK_BUFFER,h,a.STREAM_READ)),callAndCheck(a,()=>a.readPixels(0,0,i,e,a.RGBA,a.FLOAT,0)),callAndCheck(a,()=>a.bindBuffer(a.PIXEL_PACK_BUFFER,null)),o}function downloadFloat32MatrixFromBuffer(a,e,i){const s=a,o=new Float32Array(i);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,o),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),o}function downloadByteEncodedFloatMatrixFromOutputTexture(a,e,i,s){const[o,c]=getUnpackedMatrixTextureShapeWidthHeight(e,i),d=4,h=new Uint8Array(getUnpackedArraySizeFromMatrixSize(e*i,d));return callAndCheck(a,()=>a.readPixels(0,0,o,c,s.downloadTextureFormat,a.UNSIGNED_BYTE,h)),new Float32Array(h.buffer)}function downloadPackedMatrixFromBuffer(a,e,i,s,o,c,d,h){const g=a,_=new Float32Array(getPackedRGBAArraySizeFromMatrixShape(c,d));return g.bindBuffer(g.PIXEL_PACK_BUFFER,e),g.getBufferSubData(g.PIXEL_PACK_BUFFER,0,_),g.bindBuffer(g.PIXEL_PACK_BUFFER,null),_}function downloadMatrixFromPackedOutputTexture(a,e,i){const s=new Float32Array(e*i*4);return callAndCheck(a,()=>a.readPixels(0,0,i,e,a.RGBA,a.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GPGPUContext{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const i=env$1().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,setWebGLContext(i,e)):this.gl=getWebGLContext(i);let s="WEBGL_color_buffer_float";const o="EXT_color_buffer_half_float";if(env$1().getNumber("WEBGL_VERSION")===1){const c="OES_texture_float",d="OES_texture_half_float";if(this.textureFloatExtension=getExtensionOrThrow(this.gl,c),hasExtension(this.gl,d))this.textureHalfFloatExtension=getExtensionOrThrow(this.gl,d);else if(env$1().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),hasExtension(this.gl,o))this.colorBufferHalfFloatExtension=getExtensionOrThrow(this.gl,o);else if(env$1().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",hasExtension(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(hasExtension(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=createVertexBuffer(this.gl),this.indexBuffer=createIndexBuffer(this.gl),this.framebuffer=createFramebuffer(this.gl),this.textureConfig=getTextureConfig(this.gl,this.textureHalfFloatExtension)}get debug(){return env$1().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;callAndCheck(e,()=>e.finish()),callAndCheck(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),callAndCheck(e,()=>e.deleteFramebuffer(this.framebuffer)),callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),callAndCheck(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),callAndCheck(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,i){return this.throwIfDisposed(),createFloat32MatrixTexture(this.gl,e,i,this.textureConfig)}createFloat16MatrixTexture(e,i){return this.throwIfDisposed(),createFloat16MatrixTexture(this.gl,e,i,this.textureConfig)}createUnsignedBytesMatrixTexture(e,i){return this.throwIfDisposed(),createUnsignedBytesMatrixTexture(this.gl,e,i,this.textureConfig)}uploadPixelDataToTexture(e,i){this.throwIfDisposed(),uploadPixelDataToTexture(this.gl,e,i)}uploadDenseMatrixToTexture(e,i,s,o){this.throwIfDisposed(),uploadDenseMatrixToTexture(this.gl,e,i,s,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,i){return this.throwIfDisposed(),createFloat16PackedMatrixTexture(this.gl,e,i,this.textureConfig)}createPackedMatrixTexture(e,i){return this.throwIfDisposed(),createPackedMatrixTexture(this.gl,e,i,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),callAndCheck(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,i,s){return this.downloadMatrixDriver(e,()=>downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,i,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,i,s,o,c,d){return downloadPackedMatrixFromBuffer(this.gl,e,i,s,o,c,d,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,i){return downloadFloat32MatrixFromBuffer(this.gl,e,i)}createBufferFromTexture(e,i,s){this.bindTextureToFrameBuffer(e);const o=createBufferFromOutputTexture(this.gl,i,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let i,s;if(env$1().getBool("WEBGL_FENCE_API_ENABLED")){const o=e,c=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const d=o.clientWaitSync(c,0,0);return d===o.ALREADY_SIGNALED||d===o.CONDITION_SATISFIED},i=c}else env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(i=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(i,env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:i,isFencePassed:s}}downloadMatrixFromPackedTexture(e,i,s){return this.downloadMatrixDriver(e,()=>downloadMatrixFromPackedOutputTexture(this.gl,i,s))}createProgram(e){this.throwIfDisposed();const i=this.gl,s=createFragmentShader(i,e),o=createVertexShader(i),c=createProgram(i);return callAndCheck(i,()=>i.attachShader(c,o)),callAndCheck(i,()=>i.attachShader(c,s)),linkProgram(i,c),this.debug&&validateProgram(i,c),this.vertexAttrsAreBound||(this.setProgram(c),this.vertexAttrsAreBound=bindVertexProgramAttributeStreams(i,this.program,this.vertexBuffer)),c}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&callAndCheck(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&validateProgram(this.gl,this.program),callAndCheck(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,i,s=!0){return this.throwIfDisposed(),s?getProgramUniformLocationOrThrow(this.gl,e,i):getProgramUniformLocation(this.gl,e,i)}getAttributeLocation(e,i){return this.throwIfDisposed(),callAndCheck(this.gl,()=>this.gl.getAttribLocation(e,i))}getUniformLocationNoThrow(e,i){return this.throwIfDisposed(),this.gl.getUniformLocation(e,i)}setInputMatrixTexture(e,i,s){this.throwIfDisposed(),this.throwIfNoProgram(),bindTextureToProgramUniformSampler(this.gl,e,i,s)}setOutputMatrixTexture(e,i,s){this.setOutputMatrixTextureDriver(e,s,i)}setOutputPackedMatrixTexture(e,i,s){this.throwIfDisposed();const[o,c]=getPackedMatrixTextureShapeWidthHeight(i,s);this.setOutputMatrixTextureDriver(e,o,c)}setOutputMatrixWriteRegion(e,i,s,o){this.setOutputMatrixWriteRegionDriver(s,e,o,i)}setOutputPackedMatrixWriteRegion(e,i,s,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&validateProgram(this.gl,this.program),validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),callAndCheck(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),callAndCheck(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=getExtensionOrThrow(this.gl,env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,o=this.getQueryTimerExtensionWebGL2(),c=s.createQuery();return s.beginQuery(o.TIME_ELAPSED_EXT,c),c}const e=this.getQueryTimerExtensionWebGL1(),i=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,i),i}endQuery(){if(env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const i=this.gl,s=this.getQueryTimerExtensionWebGL2();i.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await repeatedTry(()=>this.disposed||this.isQueryAvailable(e,env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,i){if(i===0)return null;if(i===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,i){if(i===0)return!0;if(i===2){const s=this.gl,o=this.getQueryTimerExtensionWebGL2(),c=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),c&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),o=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(i=>{this.addItemToPoll(()=>e.isFencePassed(),()=>i())})}pollItems(){const e=linearSearchLastTrue(this.itemsToPoll.map(i=>i.isDoneFn));for(let i=0;i<=e;++i){const{resolveFn:s}=this.itemsToPoll[i];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,i){this.itemsToPoll.push({isDoneFn:e,resolveFn:i}),!(this.itemsToPoll.length>1)&&repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.debug&&validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&validateFramebuffer(this.gl)):unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(e,i){this.bindTextureToFrameBuffer(e);const s=i();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,i,s){this.throwIfDisposed();const o=this.gl;bindColorTextureToFramebuffer(o,e,this.framebuffer),this.debug&&validateFramebuffer(o),this.outputTexture=e,callAndCheck(o,()=>o.viewport(0,0,i,s)),callAndCheck(o,()=>o.scissor(0,0,i,s))}setOutputMatrixWriteRegionDriver(e,i,s,o){this.throwIfDisposed(),callAndCheck(this.gl,()=>this.gl.scissor(e,i,s,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function linearSearchLastTrue(a){let e=0;for(;e<a.length&&a[e]();++e);return e-1}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims}=backend_util;function makeShader(a,e,i,s){const o=[];a.forEach(tt=>{const et=sizeFromShape(tt.shapeInfo.logicalShape);tt.shapeInfo.isUniform?o.push(`uniform float ${tt.name}${et>1?`[${et}]`:""};`):(o.push(`uniform sampler2D ${tt.name};`),o.push(`uniform int offset${tt.name};`))});const c=o.join(`
`),d=a.map(tt=>getInputSamplingSnippet(tt,e,s)).join(`
`),h=e.texShape,g=getGlslDifferences(),_=getFloatTextureSampleSnippet(g);let b,$,j=getShaderPrefix(g);return e.isPacked?(b=getPackedOutputSamplingSnippet(e.logicalShape,h),$=getFloatTextureSetRGBASnippet(g)):(b=getOutputSamplingSnippet(e.logicalShape,h),$=getFloatTextureSetRSnippet(g)),s&&(j+=SHADER_PACKED_PREFIX),[j,_,$,c,b,d,i].join(`
`)}function getSamplerFromInInfo(a){const e=a.shapeInfo.logicalShape;switch(e.length){case 0:return getSamplerScalar(a);case 1:return getSampler1D(a);case 2:return getSampler2D(a);case 3:return getSampler3D(a);case 4:return getSampler4D(a);case 5:return getSampler5D(a);case 6:return getSampler6D(a);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function getPackedSamplerFromInInfo(a){switch(a.shapeInfo.logicalShape.length){case 0:return getPackedSamplerScalar(a);case 1:return getPackedSampler1D(a);case 2:return getPackedSampler2D(a);case 3:return getPackedSampler3D(a);default:return getPackedSamplerND(a)}}function getInputSamplingSnippet(a,e,i=!1){let s="";i?s+=getPackedSamplerFromInInfo(a):s+=getSamplerFromInInfo(a);const o=a.shapeInfo.logicalShape,c=e.logicalShape;return o.length<=c.length&&(i?s+=getPackedSamplerAtOutputCoords(a,e):s+=getSamplerAtOutputCoords(a,e)),s}function getPackedOutputSamplingSnippet(a,e){switch(a.length){case 0:return getOutputScalarCoords();case 1:return getOutputPacked1DCoords(a,e);case 2:return getOutputPacked2DCoords(a,e);case 3:return getOutputPacked3DCoords(a,e);default:return getOutputPackedNDCoords(a,e)}}function getOutputSamplingSnippet(a,e){switch(a.length){case 0:return getOutputScalarCoords();case 1:return getOutput1DCoords(a,e);case 2:return getOutput2DCoords(a,e);case 3:return getOutput3DCoords(a,e);case 4:return getOutput4DCoords(a,e);case 5:return getOutput5DCoords(a,e);case 6:return getOutput6DCoords(a,e);default:throw new Error(`${a.length}-D output sampling is not yet supported`)}}function getFloatTextureSampleSnippet(a){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${a.texture2D}(textureSampler, uv).r;
    }
  `}function getFloatTextureSetRSnippet(a){return`
    void setOutput(float val) {
      ${a.output} = vec4(val, 0, 0, 0);
    }
  `}function getFloatTextureSetRGBASnippet(a){return`
    void setOutput(vec4 val) {
      ${a.output} = val;
    }
  `}function getShaderPrefix(a){return`${a.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${a.varyingFs} vec2 resultUV;
    ${a.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${a.defineSpecialNaN}
    ${a.defineSpecialInf}
    ${a.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${SAMPLE_1D_SNIPPET}
    ${SAMPLE_2D_SNIPPET}
    ${SAMPLE_3D_SNIPPET}
  `}const SAMPLE_1D_SNIPPET=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SAMPLE_2D_SNIPPET=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SAMPLE_3D_SNIPPET=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SHADER_PACKED_PREFIX=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function getOutputScalarCoords(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function getOutputPacked1DCoords(a,e){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return i[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${i[1]}.0);
      }
    `:i[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${i[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      return 2 * (resTexRC.x * ${i[1]} + resTexRC.y);
    }
  `}function getOutput1DCoords(a,e){return e[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function getOutputPacked3DCoords(a,e){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(a[2]/2),o=s*Math.ceil(a[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function getOutput3DCoords(a,e){const i=getLogicalCoordinatesFromFlatIndex(["r","c","d"],a);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${i}
      return ivec3(r, c, d);
    }
  `}function getOutputPackedNDCoords(a,e){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(a[a.length-1]/2),o=s*Math.ceil(a[a.length-2]/2);let c=o,d="",h="b, r, c";for(let g=2;g<a.length-1;g++)c*=a[a.length-g-1],d=`
      int b${g} = index / ${c};
      index -= b${g} * ${c};
    `+d,h=`b${g}, `+h;return`
    ivec${a.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));
      int index = resTexRC.x * ${i[1]} + resTexRC.y;

      ${d}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${a.length}(${h});
    }
  `}function getOutput4DCoords(a,e){const i=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],a);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${i}
      return ivec4(r, c, d, d2);
    }
  `}function getOutput5DCoords(a,e){const i=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],a);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${i}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function getOutput6DCoords(a,e){const i=getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],a);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${i}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function getOutputPacked2DCoords(a,e){const i=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(arraysEqual(a,e))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));
      }
    `;const s=Math.ceil(a[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${i[0]}, ${i[1]}));

      int index = resTexRC.x * ${i[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function getOutput2DCoords(a,e){return arraysEqual(a,e)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:a[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:a[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${a[1]};
      int c = index - r * ${a[1]};
      return ivec2(r, c);
    }
  `}function getFlatOffsetUniformName(a){return`offset${a}`}function getPackedSamplerScalar(a){const e=a.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),s=getGlslDifferences();return`
    vec4 ${i}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function getSamplerScalar(a){const e=a.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1);if(a.shapeInfo.isUniform)return`float ${i}() {return ${e};}`;const[s,o]=a.shapeInfo.texShape;if(s===1&&o===1)return`
      float ${i}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const[c,d]=a.shapeInfo.texShape,h=getFlatOffsetUniformName(e);return`
    float ${i}() {
      vec2 uv = uvFromFlat(${c}, ${d}, ${h});
      return sampleTexture(${e}, uv);
    }
  `}function getPackedSampler1D(a){const e=a.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),s=a.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=getGlslDifferences();return`
    vec4 ${i}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${c.texture2D}(${e}, uv);
    }
  `}function getSampler1D(a){const e=a.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1);if(a.shapeInfo.isUniform)return`
      float ${i}(int index) {
        ${getUniformSampler(a)}
      }
    `;const s=a.shapeInfo.texShape,o=s[0],c=s[1];if(c===1&&o===1)return`
      float ${i}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const d=getFlatOffsetUniformName(e);return c===1?`
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${d}) + 0.5) / ${o}.0);
        return sampleTexture(${e}, uv);
      }
    `:o===1?`
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${d}) + 0.5) / ${c}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${o}, ${c}, index + ${d});
      return sampleTexture(${e}, uv);
    }
  `}function getPackedSampler2D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),o=a.shapeInfo.texShape,c=o[0],d=o[1],h=getGlslDifferences();if(o!=null&&arraysEqual(e,o))return`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${c}.0);

        return ${h.texture2D}(${i}, uv);
      }
    `;const g=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],_=Math.ceil(e[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${_}, ${g[0]}, ${g[1]}, row, col);
      return ${h.texture2D}(${i}, uv);
    }
  `}function getSampler2D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),o=a.shapeInfo.texShape;if(o!=null&&arraysEqual(e,o)){const $=o[0],j=o[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${j}.0, ${$}.0);
      return sampleTexture(${i}, uv);
    }
  `}const{newShape:c,keptDims:d}=squeezeShape(e),h=c;if(h.length<e.length){const $=squeezeInputInfo(a,h),j=["row","col"];return`
      ${getSamplerFromInInfo($)}
      float ${s}(int row, int col) {
        return ${s}(${getSqueezedParams(j,d)});
      }
    `}if(a.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${getUniformSampler(a)}
      }
    `;const g=o[0],_=o[1],b=getFlatOffsetUniformName(i);return _===1?`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${b}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${g}.0);
      return sampleTexture(${i}, uv);
    }
  `:g===1?`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${b}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${_}.0, 0.5);
      return sampleTexture(${i}, uv);
    }
  `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${b};
    vec2 uv = uvFromFlat(${g}, ${_}, index);
    return sampleTexture(${i}, uv);
  }
`}function getPackedSampler3D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),o=a.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(e[0]===1){const $=e.slice(1),j=[1,2],_e=squeezeInputInfo(a,$),tt=["b","row","col"];return`
        ${getPackedSamplerFromInInfo(_e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${getSqueezedParams(tt,j)});
        }
      `}const d=c[0],h=c[1],g=Math.ceil(e[2]/2),_=g*Math.ceil(e[1]/2),b=getGlslDifferences();return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${d}, ${h}, ${_}, ${g}, b, row, col);
      return ${b.texture2D}(${i}, uv);
    }
  `}function getSampler3D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),o=e[1]*e[2],c=e[2],{newShape:d,keptDims:h}=squeezeShape(e),g=d;if(g.length<e.length){const tt=squeezeInputInfo(a,g),et=["row","col","depth"];return`
        ${getSamplerFromInInfo(tt)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${getSqueezedParams(et,h)});
        }
      `}if(a.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${c}, 1)));
        ${getUniformSampler(a)}
      }
    `;const _=a.shapeInfo.texShape,b=_[0],$=_[1],j=a.shapeInfo.flatOffset;if($===o&&j==null)return`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${c}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${$}.0, ${b}.0);
          return sampleTexture(${i}, uv);
        }
      `;if($===c&&j==null)return`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${$}.0, ${b}.0);
      return sampleTexture(${i}, uv);
    }
  `;const _e=getFlatOffsetUniformName(i);return`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${c} + depth + ${_e};
        vec2 uv = uvFromFlat(${b}, ${$}, index);
        return sampleTexture(${i}, uv);
      }
  `}function getPackedSamplerND(a){const e=a.shapeInfo.logicalShape,i=e.length,s=a.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),c=a.shapeInfo.texShape,d=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],h=d[0],g=d[1],_=Math.ceil(e[i-1]/2);let b=_*Math.ceil(e[i-2]/2),$="int b, int row, int col",j=`b * ${b} + (row / 2) * ${_} + (col / 2)`;for(let tt=2;tt<i-1;tt++)$=`int b${tt}, `+$,b*=e[i-tt-1],j=`b${tt} * ${b} + `+j;const _e=getGlslDifferences();return`
    vec4 ${o}(${$}) {
      int index = ${j};
      int texR = index / ${g};
      int texC = index - texR * ${g};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${g}, ${h});
      return ${_e.texture2D}(${s}, uv);
    }
  `}function getSampler4D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),o=e[3],c=e[2]*o,d=e[1]*c,{newShape:h,keptDims:g}=squeezeShape(e);if(h.length<e.length){const tt=squeezeInputInfo(a,h),et=["row","col","depth","depth2"];return`
      ${getSamplerFromInInfo(tt)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${getSqueezedParams(et,g)});
      }
    `}if(a.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${d}, ${c}, ${o}, 1)));
        ${getUniformSampler(a)}
      }
    `;const _=a.shapeInfo.flatOffset,b=a.shapeInfo.texShape,$=b[0],j=b[1];if(j===d&&_==null)return`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${c}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${j}.0, ${$}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(j===o&&_==null)return`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${j}.0, ${$}.0);
        return sampleTexture(${i}, uv);
      }
    `;const _e=getFlatOffsetUniformName(i);return`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${d} + col * ${c} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${$}, ${j}, index + ${_e});
      return sampleTexture(${i}, uv);
    }
  `}function getSampler5D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),o=e[4],c=e[3]*o,d=e[2]*c,h=e[1]*d,{newShape:g,keptDims:_}=squeezeShape(e);if(g.length<e.length){const et=squeezeInputInfo(a,g),nt=["row","col","depth","depth2","depth3"];return`
      ${getSamplerFromInInfo(et)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${getSqueezedParams(nt,_)});
      }
    `}if(a.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${d}, ${c}, ${o})) +
          depth3;
        ${getUniformSampler(a)}
      }
    `;const b=a.shapeInfo.flatOffset,$=a.shapeInfo.texShape,j=$[0],_e=$[1];if(_e===h&&b==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${d}, ${c}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${_e}.0, ${j}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(_e===o&&b==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${_e}.0, ${j}.0);
        return sampleTexture(${i}, uv);
      }
    `;const tt=getFlatOffsetUniformName(i);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${d} + depth * ${c} +
          depth2 * ${o} + depth3 + ${tt};
      vec2 uv = uvFromFlat(${j}, ${_e}, index);
      return sampleTexture(${i}, uv);
    }
  `}function getSampler6D(a){const e=a.shapeInfo.logicalShape,i=a.name,s="get"+i.charAt(0).toUpperCase()+i.slice(1),{newShape:o,keptDims:c}=squeezeShape(e);if(o.length<e.length){const nt=squeezeInputInfo(a,o),rt=["row","col","depth","depth2","depth3","depth4"];return`
      ${getSamplerFromInInfo(nt)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${getSqueezedParams(rt,c)});
      }
    `}const d=e[5],h=e[4]*d,g=e[3]*h,_=e[2]*g,b=e[1]*_;if(a.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${b}, ${_}, ${g}, ${h})) +
          dot(
            vec2(depth3, depth4),
            vec2(${d}, 1)));
        ${getUniformSampler(a)}
      }
    `;const $=a.shapeInfo.flatOffset,j=a.shapeInfo.texShape,_e=j[0],tt=j[1];if(tt===b&&$==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${_}, ${g}, ${h}, ${d})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${tt}.0, ${_e}.0);
        return sampleTexture(${i}, uv);
      }
    `;if(tt===d&&$==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${tt}.0, ${_e}.0);
        return sampleTexture(${i}, uv);
      }
    `;const et=getFlatOffsetUniformName(i);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${b} + col * ${_} + depth * ${g} +
          depth2 * ${h} + depth3 * ${d} + depth4 + ${et};
      vec2 uv = uvFromFlat(${_e}, ${tt}, index);
      return sampleTexture(${i}, uv);
    }
  `}function getUniformSampler(a){const e=a.name,i=sizeFromShape(a.shapeInfo.logicalShape);return i<2?`return ${e};`:`
    for (int i = 0; i < ${i}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function getPackedSamplerAtOutputCoords(a,e){const i=a.name,s=i.charAt(0).toUpperCase()+i.slice(1),o="get"+s+"AtOutCoords",c=a.shapeInfo.logicalShape.length,d=e.logicalShape.length,h=getBroadcastDims(a.shapeInfo.logicalShape,e.logicalShape),g=getCoordsDataType(d),_=d-c;let b;const $=["x","y","z","w","u","v"];c===0?b="":d<2&&h.length>=1?b="coords = 0;":b=h.map(it=>`coords.${$[it+_]} = 0;`).join(`
`);let j="";d<2&&c>0?j="coords":j=a.shapeInfo.logicalShape.map((it,at)=>`coords.${$[at+_]}`).join(", ");let _e="return outputValue;";const et=sizeFromShape(a.shapeInfo.logicalShape)===1,rt=sizeFromShape(e.logicalShape)===1;if(c===1&&!et&&!rt)_e=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(et&&!rt)d===1?_e=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:_e=`
        return vec4(outputValue.x);
      `;else if(h.length){const it=c-2,at=c-1;h.indexOf(it)>-1&&h.indexOf(at)>-1?_e="return vec4(outputValue.x);":h.indexOf(it)>-1?_e="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":h.indexOf(at)>-1&&(_e="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${g} coords = getOutputCoords();
      ${b}
      vec4 outputValue = get${s}(${j});
      ${_e}
    }
  `}function getSamplerAtOutputCoords(a,e){const i=a.name,s=i.charAt(0).toUpperCase()+i.slice(1),o="get"+s+"AtOutCoords",c=e.texShape,d=a.shapeInfo.texShape,h=a.shapeInfo.logicalShape.length,g=e.logicalShape.length;if(!a.shapeInfo.isUniform&&h===g&&a.shapeInfo.flatOffset==null&&arraysEqual(d,c))return`
      float ${o}() {
        return sampleTexture(${i}, resultUV);
      }
    `;const _=getCoordsDataType(g),b=getBroadcastDims(a.shapeInfo.logicalShape,e.logicalShape),$=g-h;let j;const _e=["x","y","z","w","u","v"];h===0?j="":g<2&&b.length>=1?j="coords = 0;":j=b.map(et=>`coords.${_e[et+$]} = 0;`).join(`
`);let tt="";return g<2&&h>0?tt="coords":tt=a.shapeInfo.logicalShape.map((et,nt)=>`coords.${_e[nt+$]}`).join(", "),`
    float ${o}() {
      ${_} coords = getOutputCoords();
      ${j}
      return get${s}(${tt});
    }
  `}function getCoordsDataType(a){if(a<=1)return"int";if(a===2)return"ivec2";if(a===3)return"ivec3";if(a===4)return"ivec4";if(a===5)return"ivec5";if(a===6)return"ivec6";throw Error(`GPU for rank ${a} is not yet supported`)}function squeezeInputInfo(a,e){const i=JSON.parse(JSON.stringify(a));return i.shapeInfo.logicalShape=e,i}function getSqueezedParams(a,e){return e.map(i=>a[i]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function compileProgram(a,e,i,s){const o=e.userCode,c=i.map((_e,tt)=>{const et={logicalShape:_e.shape,texShape:_e.isUniform?null:_e.texData.texShape,isUniform:_e.isUniform,isPacked:_e.isUniform?!1:_e.texData.isPacked,flatOffset:null};return _e.texData!=null&&_e.texData.slice!=null&&_e.texData.slice.flatOffset>0&&(et.flatOffset=_e.texData.slice.flatOffset),{name:e.variableNames[tt],shapeInfo:et}}),d=c.map(_e=>_e.shapeInfo),h={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},g=makeShader(c,h,o,e.packedInputs),_=a.createProgram(g);let b=null;const $=a.getUniformLocation(_,"NAN",!1);env$1().getNumber("WEBGL_VERSION")===1&&(b=a.getUniformLocation(_,"INFINITY",!1));const j={};for(let _e=0;_e<e.variableNames.length;_e++){const tt=e.variableNames[_e],et=!1;j[tt]=a.getUniformLocation(_,tt,et),j[`offset${tt}`]=a.getUniformLocation(_,`offset${tt}`,et)}return{program:e,source:g,webGLProgram:_,uniformLocations:j,inShapeInfos:d,outShapeInfo:h,infLoc:b,nanLoc:$}}function validateBinaryAndProgram(a,e){if(a.length!==e.length)throw Error(`Binary was compiled with ${a.length} inputs, but was executed with ${e.length} inputs`);a.forEach((i,s)=>{const o=i.logicalShape,c=e[s],d=c.shape;if(!arraysEqual(o,d))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${d} must match`);if(i.isUniform&&c.isUniform)return;const h=i.texShape,g=c.isUniform?null:c.texData.texShape;if(!arraysEqual(h,g))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${h} and ${g} must match`)})}function runProgram(a,e,i,s,o){validateBinaryAndProgram(e.inShapeInfos,i),validateBinaryAndProgram([e.outShapeInfo],[s]);const c=s.texData.texture,d=s.texData.texShape;s.texData.isPacked?a.setOutputPackedMatrixTexture(c,d[0],d[1]):a.setOutputMatrixTexture(c,d[0],d[1]),a.setProgram(e.webGLProgram),env$1().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&a.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&a.gl.uniform1f(e.nanLoc,NaN),i.forEach((h,g)=>{const _=e.program.variableNames[g],b=e.uniformLocations[_],$=e.uniformLocations[`offset${_}`];if(b!=null){if(h.isUniform){if(sizeFromShape(h.shape)<2)a.gl.uniform1f(b,h.uniformValues[0]);else{let j=h.uniformValues;j instanceof Float32Array||(j=new Float32Array(j)),a.gl.uniform1fv(b,j)}return}h.texData.slice!=null&&$!=null&&a.gl.uniform1i($,h.texData.slice.flatOffset),a.setInputMatrixTexture(h.texData.texture,b,g)}}),o!=null&&o(a,e.webGLProgram),a.executeProgram()}function makeShaderKey(a,e,i){let s="";e.concat(i).forEach(d=>{const h=d.texData!=null&&d.texData.slice!=null&&d.texData.slice.flatOffset>0,g=d.isUniform?"uniform":d.texData.texShape;s+=`${d.shape}_${g}_${h}`});const o=a.userCode;let c=a.constructor.name;return c+="_"+s+"_"+o,c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:addImplCPU,bincountImpl:bincountImplCPU,bincountReduceImpl:bincountReduceImplCPU,ceilImpl:ceilImplCPU,concatImpl:concatImplCPU,expImpl:expImplCPU,expm1Impl:expm1ImplCPU,floorImpl:floorImplCPU,gatherV2Impl:gatherV2ImplCPU,greaterImpl:greaterImplCPU,lessImpl:lessImplCPU,linSpaceImpl:linSpaceImplCPU,logImpl:logImplCPU,maxImpl:maxImplCPU,maximumImpl:maximumImplCPU,minimumImpl:minimumImplCPU,multiplyImpl:multiplyImplCPU,negImpl:negImplCPU,prodImpl:prodImplCPU,rangeImpl:rangeImplCPU,rsqrtImpl:rsqrtImplCPU,simpleAbsImpl:simpleAbsImplCPU,sliceImpl:sliceImplCPU,stridedSliceImpl:stridedSliceImplCPU,subImpl:subImplCPU,tileImpl:tileImplCPU,topKImpl:topKImplCPU,transposeImpl:transposeImplCPU,uniqueImpl:uniqueImplCPU}=shared;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getVecChannels(a,e){return["x","y","z","w","u","v"].slice(0,e).map(i=>`${a}.${i}`)}function getChannels(a,e){return e===1?[a]:getVecChannels(a,e)}function getSourceCoords$2(a,e){if(a===1)return"rc";let i="";for(let s=0;s<a;s++)i+=e[s],s<a-1&&(i+=",");return i}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PackProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const i=e.length;if(i===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const s=getChannels("rc",i),o=getCoordsDataType(i),c=getOutOfBoundsCondition(i,e,s),d=getSetup(i,e[e.length-1],e[e.length-2],s),h=getOutput(e,s);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${c}) {
            setOutput(vec4(0));
          } else {
            ${d}

            setOutput(vec4(${h}));
          }
        }
      `}}}function getSourceCoordsArr(a,e){const i=[];for(let s=0;s<=1;s++)for(let o=0;o<=1;o++){let c=`${s===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let d=2;d<a;d++)c=`${e[e.length-1-d]},`+c;i.push(c)}return i}function getOutOfBoundsCondition(a,e,i){if(a===1)return`rc > ${e[0]}`;let s="";for(let o=a-2;o<a;o++)s+=`${i[o]} >= ${e[o]}`,o<a-1&&(s+="||");return s}function getSetup(a,e,i,s){if(a===1)return"";const o=s.slice(-2);return`
    int r = ${o[0]};
    int c = ${o[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${e};
    bool rEdge = rp1 >= ${i};
  `}function getOutput(a,e){const i=a.length,s=getSourceCoordsArr(i,e);return i===1?`getA(rc),
            rc + 1 >= ${a[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${s[0]}),
          cEdge ? 0. : getA(${s[1]}),
          rEdge ? 0. : getA(${s[2]}),
          rEdge || cEdge ? 0. : getA(${s[3]})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ReshapePackedProgram{constructor(e,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let s="";for(let o=0;o<4;o++){let c="thisRC = rc;";o%2===1&&(c+="thisRC.z += 1;"),o>1&&(c+="thisRC.y += 1;"),s+=`
        ${c}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${getReshapedInputCoords(i)}
      ${getFlatIndexFrom3D(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${e[1]};
        int cols = ${e[2]};

        ${s}

        setOutput(result);
      }
    `}}function getReshapedInputCoords(a){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${getLogicalCoordinatesFromFlatIndex(["r","c","d"],a)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TextureManager{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,i,s){const o=getPhysicalFromLogicalTextureType(i,s),c=getKeyFromTextureShape(e,o,s);c in this.freeTextures||(this.freeTextures[c]=[]),c in this.usedTextures||(this.usedTextures[c]=[]);const d=computeBytes(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[c].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=d,this.log();const g=this.freeTextures[c].shift();return this.usedTextures[c].push(g),g}let h;return o===PhysicalTextureType.PACKED_2X2_FLOAT32?h=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===PhysicalTextureType.PACKED_2X2_FLOAT16?h=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===PhysicalTextureType.UNPACKED_FLOAT32?h=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===PhysicalTextureType.UNPACKED_FLOAT16?h=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(h=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[c].push(h),this.numUsedTextures++,this._numBytesAllocated+=d,this.log(),h}releaseTexture(e,i,s,o){if(this.freeTextures==null)return;const c=getPhysicalFromLogicalTextureType(s,o),d=getKeyFromTextureShape(i,c,o);d in this.freeTextures||(this.freeTextures[d]=[]);const h=computeBytes(i,c,this.gpgpu.gl,this.gpgpu.textureConfig,o),g=env$1().get("WEBGL_DELETE_TEXTURE_THRESHOLD");g!==-1&&this._numBytesAllocated>g?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=h):(this.freeTextures[d].push(e),this.numFreeTextures++,this._numBytesFree+=h),this.numUsedTextures--;const _=this.usedTextures[d],b=_.indexOf(e);if(b<0)throw new Error("Cannot release a texture that was never provided by this texture manager");_.splice(b,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const i=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*i)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(i=>{this.gpgpu.deleteMatrixTexture(i)});for(const e in this.usedTextures)this.usedTextures[e].forEach(i=>{this.gpgpu.deleteMatrixTexture(i)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function numBytesForInternalFormat(a,e){const i=a;if(e===i.R32F)return 4;if(e===i.R16F)return 2;if(e===i.RGBA32F)return 16;if(e===a.RGBA)return 16;if(e===i.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}function computeBytes(a,e,i,s,o){const c=internalFormatForPhysicalTexType(e,s);let d;if(o){const[g,_]=getPackedMatrixTextureShapeWidthHeight(a[0],a[1]);d=g*_}else{const[g,_]=getUnpackedMatrixTextureShapeWidthHeight(a[0],a[1]);d=g*_}const h=numBytesForInternalFormat(i,c);return d*h}function internalFormatForPhysicalTexType(a,e){switch(a){case PhysicalTextureType.PACKED_2X2_FLOAT32:return getInternalFormatForPackedMatrixTexture(e);case PhysicalTextureType.PACKED_2X2_FLOAT16:return getInternalFormatForFloat16PackedMatrixTexture(e);case PhysicalTextureType.UNPACKED_FLOAT32:return getInternalFormatForFloat32MatrixTexture(e);case PhysicalTextureType.UNPACKED_FLOAT16:return getInternalFormatForFloat16MatrixTexture(e);case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:return getInternalFormatForUnsignedBytesMatrixTexture(e);default:throw new Error(`Unknown physical texture type ${a}`)}}function getPhysicalTextureForRendering(a){return env$1().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?a?PhysicalTextureType.PACKED_2X2_FLOAT32:PhysicalTextureType.UNPACKED_FLOAT32:a?PhysicalTextureType.PACKED_2X2_FLOAT16:PhysicalTextureType.UNPACKED_FLOAT16}function getPhysicalFromLogicalTextureType(a,e){if(a===TextureUsage.UPLOAD)return PhysicalTextureType.PACKED_2X2_FLOAT32;if(a===TextureUsage.RENDER||a==null)return getPhysicalTextureForRendering(e);if(a===TextureUsage.DOWNLOAD||a===TextureUsage.PIXELS)return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${a}`)}function getKeyFromTextureShape(a,e,i){return`${a[0]}_${a[1]}_${e}_${i}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UnaryOpProgram{constructor(e,i){this.variableNames=["A"],this.outputShape=e,this.userCode=`
      float unaryOperation(float x) {
        ${i}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const CHECK_NAN_SNIPPET$2="if (isnan(x)) return x;",LINEAR$1="return x;",ABS$1="return abs(x);",ELU$2="return (x >= 0.0) ? x : (exp(x) - 1.0);",RELU$2=CHECK_NAN_SNIPPET$2+`
  return (x < 0.0) ? 0.0 : x;
`,RELU6$2=CHECK_NAN_SNIPPET$2+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,CLONE="return x;";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LINEAR="return x;",ELU$1=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,RELU$1=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,RELU6$1=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;class UnaryOpPackedProgram{constructor(e,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${i}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UnpackProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const i=e.length,s=getChannels("rc",i),o=getCoordsDataType(i),c=getSourceCoords$2(i,s),d=s.slice(-2),h=i<=1?"rc":`vec2(${d.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${c});

        setOutput(getChannel(packedInput, ${h}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const whereImpl=whereImpl$2,EPSILON_FLOAT32=1e-7,EPSILON_FLOAT16=1e-4,binaryCaches={};function getBinaryCache(a){return a in binaryCaches||(binaryCaches[a]={}),binaryCaches[a]}const CPU_HANDOFF_SIZE_THRESHOLD=128,BEFORE_PAGING_CONSTANT=600;function numMBBeforeWarning(){return env$1().global.screen==null?1024:env$1().global.screen.height*env$1().global.screen.width*window.devicePixelRatio*BEFORE_PAGING_CONSTANT/1024/1024}class MathBackendWebGL extends KernelBackend{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!env$1().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){const i=getWebGLContext(env$1().getNumber("WEBGL_VERSION"));this.binaryCache=getBinaryCache(env$1().getNumber("WEBGL_VERSION")),this.gpgpu=new GPGPUContext(i),this.canvas=i.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new TextureManager(this.gpgpu),this.numMBBeforeWarning=numMBBeforeWarning(),this.texData=new DataStorage(this,engine())}nextDataId(){return MathBackendWebGL.nextDataId++}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(e,i,s){if((env$1().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||env$1().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:i,dtype:s,values:e,usage:TextureUsage.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const i=this.texData.get(e);i.refCount++}decRef(e){if(this.texData.has(e)){const i=this.texData.get(e);i.refCount--}}move(e,i,s,o,c){if(env$1().getBool("DEBUG")&&this.checkNumericalProblems(i),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:o,values:i,usage:TextureUsage.UPLOAD,refCount:c})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const i=this.texData.get(e),{values:s,dtype:o,complexTensorInfos:c,slice:d,shape:h,isPacked:g}=i;if(d!=null){let j;g?j=new UnaryOpPackedProgram(h,CLONE):j=new UnaryOpProgram(h,CLONE);const _e=this.runWebGLProgram(j,[{dataId:e,shape:h,dtype:o}],o),tt=this.readSync(_e.dataId);return this.disposeIntermediateTensorInfo(_e),tt}if(s!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return s;const _=this.activeTimers!=null;let b;_&&(b=now());let $;if(o==="complex64"){const j=this.readSync(c.real.dataId),_e=this.readSync(c.imag.dataId);$=mergeRealAndImagArrays(j,_e)}else $=this.getValuesFromTexture(e);return _&&(this.downloadWaitMs+=now()-b),this.convertAndCacheOnCPU(e,$)}async read(e){if(this.pendingRead.has(e)){const tt=this.pendingRead.get(e);return new Promise(et=>tt.push(et))}const i=this.texData.get(e),{values:s,shape:o,slice:c,dtype:d,complexTensorInfos:h,isPacked:g}=i;if(c!=null){let tt;g?tt=new UnaryOpPackedProgram(o,CLONE):tt=new UnaryOpProgram(o,CLONE);const et=this.runWebGLProgram(tt,[{dataId:e,shape:o,dtype:d}],d),nt=this.read(et.dataId);return this.disposeIntermediateTensorInfo(et),nt}if(s!=null)return this.convertAndCacheOnCPU(e);if(!env$1().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&env$1().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let _=null,b;if(d!=="complex64"&&env$1().get("WEBGL_BUFFER_SUPPORTED")){b=this.decode(e);const tt=this.texData.get(b.dataId);_=this.gpgpu.createBufferFromTexture(tt.texture,...getDenseTexShape(o))}this.pendingRead.set(e,[]),d!=="complex64"&&await this.gpgpu.createAndWaitForFence();let $;if(d==="complex64"){const tt=await Promise.all([this.read(h.real.dataId),this.read(h.imag.dataId)]),et=tt[0],nt=tt[1];$=mergeRealAndImagArrays(et,nt)}else if(_==null)$=this.getValuesFromTexture(e);else{const tt=sizeFromShape(o);$=this.gpgpu.downloadFloat32MatrixFromBuffer(_,tt)}b!=null&&this.disposeIntermediateTensorInfo(b);const j=this.convertAndCacheOnCPU(e,$),_e=this.pendingRead.get(e);return this.pendingRead.delete(e),_e.forEach(tt=>tt(j)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&engine().removeDataId(e,this),this.pendingDeletes--),j}bufferSync(e){const i=this.readSync(e.dataId);let s=i;if(e.dtype==="string")try{s=i.map(o=>decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return buffer(e.shape,e.dtype,s)}checkNumericalProblems(e){if(e!=null)for(let i=0;i<e.length;i++){const s=e[i];if(!canBeRepresented(s))throw env$1().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:i,dtype:s,isPacked:o}=this.texData.get(e),c=sizeFromShape(i);if(env$1().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const j=this.decode(e),_e=this.texData.get(j.dataId),tt=this.gpgpu.downloadMatrixFromPackedTexture(_e.texture,...getDenseTexShape(i)).subarray(0,c);return this.disposeIntermediateTensorInfo(j),tt}const d=env$1().getBool("WEBGL_PACK")&&o===!0,h=d?getShapeAs3D(i):i,g=d?new EncodeFloatPackedProgram(h):new EncodeFloatProgram(h),_=this.runWebGLProgram(g,[{shape:h,dtype:s,dataId:e}],"float32"),b=this.texData.get(_.dataId),$=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(b.texture,b.texShape[0],b.texShape[1]).subarray(0,c);return this.disposeIntermediateTensorInfo(_),$}timerAvailable(){return env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const i=this.activeTimers,s=[];let o=!1;this.programTimersStack==null?(this.programTimersStack=s,o=!0):this.activeTimers.push(s),this.activeTimers=s,e();const c=flatten$4(this.activeTimers.map(g=>g.query)).filter(g=>g!=null),d=flatten$4(this.activeTimers.map(g=>g.name)).filter(g=>g!=null);this.activeTimers=i,o&&(this.programTimersStack=null);const h={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const g=await Promise.all(c);h.kernelMs=sum$4(g),h.getExtraProfileInfo=()=>g.map((_,b)=>({name:d[b],ms:_})).map(_=>`${_.name}: ${_.ms}`).join(", ")}else h.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,h}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:now(),endMs:null}}endTimer(e){return env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=now(),e)}async getQueryTime(e){if(env$1().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const i=e;return i.endMs-i.startMs}disposeData(e,i=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(i?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!i&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,i),this.disposeData(s.imag.dataId,i)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:i,dtype:s,texShape:o,usage:c,isPacked:d,slice:h}=this.texData.get(e),g=h&&h.origDataId||e,_=this.dataRefCount.get(g);_>1?this.dataRefCount.set(g,_-1):(this.dataRefCount.delete(g),i!=null&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(i,o,c,d)));const b=this.texData.get(e);b.texture=null,b.texShape=null,b.isPacked=!1,b.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}getCPUBackend(){return env$1().getBool("WEBGL_CPU_FORWARD")?(this.cpuBackend==null&&(this.cpuBackend=engine().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(e,i=CPU_HANDOFF_SIZE_THRESHOLD){const s=this.getCPUBackend();return!env$1().getBool("IS_TEST")&&!this.warnedAboutCPUBackend&&s==null&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),s!=null&&e.every(o=>this.texData.get(o.dataId).texture==null&&sizeFromShape(o.shape)<i)}getGPGPUContext(){return this.gpgpu}where(e){warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const i=e.dataSync();return whereImpl(e.shape,i)}packedUnaryOp(e,i,s){const o=new UnaryOpPackedProgram(e.shape,i),c=this.compileAndRun(o,[e],s);return engine().makeTensorFromDataId(c.dataId,c.shape,c.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const o=simpleAbsImplCPU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(env$1().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ABS$1,e.dtype);const i=new UnaryOpProgram(e.shape,ABS$1),s=this.compileAndRun(i,[e]);return engine().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(e,i,s){let o;if(i==="string"&&s!=null&&s.length>0&&isString$1(s[0])){const c=s.map(d=>encodeString(d));o=this.write(c,e,i)}else o=this.write(s,e,i);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:i}}makeOutput(e,i,s){const{dataId:o}=this.makeTensorInfo(e,i,s);return engine().makeTensorFromDataId(o,e,i,this)}unpackTensor(e){const i=new UnpackProgram(e.shape);return this.runWebGLProgram(i,[e],e.dtype)}packTensor(e){const i=new PackProgram(e.shape);return this.runWebGLProgram(i,[e],e.dtype,null,!0)}packedReshape(e,i){const s=[getBatchDim(e.shape),...getRowsCols(e.shape)],o={dtype:e.dtype,shape:s,dataId:e.dataId},c=[getBatchDim(i),...getRowsCols(i)],d=new ReshapePackedProgram(c,s),g=this.runWebGLProgram(d,[o],e.dtype,null,!0);return{dataId:g.dataId,shape:i,dtype:g.dtype}}decode(e){const i=this.texData.get(e),{isPacked:s,shape:o,dtype:c}=i,d=getShapeAs3D(o);let h;s?h=new DecodeMatrixPackedProgram(d):h=new DecodeMatrixProgram(d);const _=this.runWebGLProgram(h,[{shape:d,dtype:c,dataId:e}],c,null,!0);return{dtype:c,shape:o,dataId:_.dataId}}runWebGLProgram(e,i,s,o,c=!1){const d=this.makeTensorInfo(e.outputShape,s),h=this.texData.get(d.dataId);if(e.packedOutput&&(h.isPacked=!0),e.outPackingScheme===PackingScheme.DENSE){const et=getDenseTexShape(e.outputShape);h.texShape=et.map(nt=>nt*2)}if(e.outTexUsage!=null&&(h.usage=e.outTexUsage),sizeFromShape(d.shape)===0)return h.values=getTypedArrayFromDType(d.dtype,0),d;const g=[],_=i.map(et=>{if(et.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let nt=this.texData.get(et.dataId);if(nt.texture==null){if(!e.packedInputs&&sizeFromShape(et.shape)<=env$1().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:et.shape,texData:null,isUniform:!0,uniformValues:nt.values};e.packedInputs&&(nt.isPacked=!0,nt.shape=et.shape)}else if(!!nt.isPacked!=!!e.packedInputs)et=nt.isPacked?this.unpackTensor(et):this.packTensor(et),g.push(et),nt=this.texData.get(et.dataId);else if(nt.isPacked&&!isReshapeFree(nt.shape,et.shape)){const rt=et,it=et.shape;et.shape=nt.shape,et=this.packedReshape(et,it),g.push(et),nt=this.texData.get(et.dataId),rt.shape=it}return this.uploadToGPU(et.dataId),{shape:et.shape,texData:nt,isUniform:!1}});this.uploadToGPU(d.dataId);const b={shape:d.shape,texData:h,isUniform:!1},$=makeShaderKey(e,_,b),j=this.getAndSaveBinary($,()=>compileProgram(this.gpgpu,e,_,b)),_e=this.activeTimers!=null;let tt;if(_e&&(tt=this.startTimer()),runProgram(this.gpgpu,j,_,b,o),g.forEach(et=>this.disposeIntermediateTensorInfo(et)),_e&&(tt=this.endTimer(tt),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(tt)})),!env$1().getBool("WEBGL_LAZILY_UNPACK")&&h.isPacked&&c===!1){const et=this.unpackTensor(d);return this.disposeIntermediateTensorInfo(d),et}return d}compileAndRun(e,i,s,o,c=!1){return s=s||i[0].dtype,this.runWebGLProgram(e,i,s,o,c)}getAndSaveBinary(e,i){return e in this.binaryCache||(this.binaryCache[e]=i()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(env$1().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(i=>{this.gpgpu.deleteProgram(this.binaryCache[i].webGLProgram),delete this.binaryCache[i]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=tidy(()=>{if(!env$1().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=env$1().getBool("DEBUG");env$1().set("DEBUG",!1);const i=this.abs(scalar(1e-8)).dataSync()[0];if(env$1().set("DEBUG",e),i>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?EPSILON_FLOAT32:EPSILON_FLOAT16}uploadToGPU(e){const i=this.texData.get(e),{shape:s,dtype:o,values:c,texture:d,usage:h,isPacked:g}=i;if(d!=null)return;const _=this.activeTimers!=null;let b;_&&(b=now());let $=i.texShape;if($==null&&($=getTextureShapeFromLogicalShape(s,g),i.texShape=$),c!=null){const j=getShapeAs3D(s);let _e,tt=$[1],et=$[0];const nt=c instanceof Uint8Array;g?([tt,et]=getPackedMatrixTextureShapeWidthHeight($[0],$[1]),_e=new EncodeMatrixPackedProgram(j,[et,tt],nt)):_e=new EncodeMatrixProgram(j,[et,tt],nt);const rt=this.makeTensorInfo([et,tt],o);nt?this.texData.get(rt.dataId).usage=TextureUsage.PIXELS:this.texData.get(rt.dataId).usage=TextureUsage.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(rt.dataId),tt,et,c);const at=this.runWebGLProgram(_e,[rt],o,null,!0),st=this.texData.get(at.dataId);i.texture=st.texture,i.texShape=st.texShape,i.isPacked=st.isPacked,i.usage=st.usage,this.disposeIntermediateTensorInfo(rt),this.texData.delete(at.dataId),i.values=null,_&&(this.uploadWaitMs+=now()-b)}else{const j=this.acquireTexture($,h,o,g);i.texture=j}}convertAndCacheOnCPU(e,i){const s=this.texData.get(e),{dtype:o}=s;return this.releaseGPUData(e),i!=null&&(s.values=float32ToTypedArray(i,o)),s.values}acquireTexture(e,i,s,o){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const c=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${c} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,i,o)}computeBytes(e,i){return e[0]*e[1]*bytesPerElement(i)}}MathBackendWebGL.nextDataId=0;function float32ToTypedArray(a,e){if(e==="float32"||e==="complex64")return a;if(e==="int32"||e==="bool"){const i=e==="int32"?new Int32Array(a.length):new Uint8Array(a.length);for(let s=0;s<i.length;++s)i[s]=Math.round(a[s]);return i}else throw new Error(`Unknown dtype ${e}`)}/** @license See the LICENSE file. */const version$4="3.1.0";/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */isBrowser()&&registerBackend("webgl",()=>new MathBackendWebGL,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CHECK_NAN_SNIPPET$1=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class BinaryOpProgram{constructor(e,i,s){this.variableNames=["A","B"],this.outputShape=assertAndGetBroadcastShape(i,s),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CHECK_NAN_SNIPPET=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class BinaryOpPackedProgram{constructor(e,i,s,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=assertAndGetBroadcastShape(i,s);const c=this.outputShape.length;let d="";if(o)if(c===0||sizeFromShape(this.outputShape)===1)d=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(d=`
          ${getCoordsDataType(c)} coords = getOutputCoords();
        `,c===1)d+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const g=getChannels("coords",c);d+=`
            bool nextRowOutOfBounds =
              (${g[c-2]} + 1) >= ${this.outputShape[c-2]};
            bool nextColOutOfBounds =
              (${g[c-1]} + 1) >= ${this.outputShape[c-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${d}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity$1(a){const{inputs:e,backend:i}=a,{x:s}=e;return i.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const identityConfig={kernelName:Identity$1,backendName:"webgl",kernelFunc:identity$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex$2(a){const{inputs:e,backend:i}=a,{real:s,imag:o}=e,c=i.makeTensorInfo(s.shape,"complex64"),d=i.texData.get(c.dataId),h=identity$1({inputs:{x:s},backend:i}),g=identity$1({inputs:{x:o},backend:i});return d.complexTensorInfos={real:h,imag:g},c}const complexConfig={kernelName:Complex$2,backendName:"webgl",kernelFunc:complex$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LEAKYRELU="return (a < 0.) ? b * a : a;",LEAKYRELU_PACKED=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function leakyRelu(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{alpha:c}=s,d=i.makeTensorInfo([],"float32",createScalarValue(c,"float32")),h=env$1().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(LEAKYRELU_PACKED,o.shape,d.shape):new BinaryOpProgram(LEAKYRELU,o.shape,d.shape),g=i.runWebGLProgram(h,[o,d],o.dtype);return i.disposeIntermediateTensorInfo(d),g}const leakyReluConfig={kernelName:LeakyRelu,backendName:"webgl",kernelFunc:leakyRelu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PRELU="return (a < 0.) ? b * a : a;",PRELU_PACKED=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function prelu(a){const{inputs:e,backend:i}=a,{x:s,alpha:o}=e,c=env$1().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(PRELU_PACKED,s.shape,o.shape):new BinaryOpProgram(PRELU,s.shape,o.shape);return i.runWebGLProgram(c,[s,o],s.dtype)}const preluConfig={kernelName:Prelu,backendName:"webgl",kernelFunc:prelu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CHECK_NAN_SNIPPET_UNARY="if (isnan(x)) return x;",CHECK_NAN_SNIPPET_BINARY=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,CHECK_NAN_SNIPPET_BINARY_PACKED=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function unaryKernelFunc({opSnippet:a,packedOpSnippet:e,cpuKernelImpl:i,dtype:s}){return({inputs:o,backend:c})=>{const{x:d}=o,h=c,g=s||d.dtype;if(h.shouldExecuteOnCPU([d])&&i!=null){const $=h.texData.get(d.dataId),j=i($.values,g);return h.makeTensorInfo(d.shape,g,j)}const _=env$1().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let b;return _?b=new UnaryOpPackedProgram(d.shape,e):b=new UnaryOpProgram(d.shape,a),h.runWebGLProgram(b,[d],g)}}function binaryKernelFunc({opSnippet:a,packedOpSnippet:e,checkOutOfBounds:i=!1,supportsComplex:s=!1,cpuKernelImpl:o,dtype:c}){return({inputs:d,backend:h})=>{const{a:g,b:_}=d,b=h;if(s&&g.dtype==="complex64"){const tt=b.texData.get(g.dataId),et=b.texData.get(_.dataId),[nt,rt]=[[tt.complexTensorInfos.real,et.complexTensorInfos.real],[tt.complexTensorInfos.imag,et.complexTensorInfos.imag]].map(at=>{const[st,ot]=at,ct={dataId:st.dataId,dtype:st.dtype,shape:g.shape},lt={dataId:ot.dataId,dtype:ot.dtype,shape:_.shape},dt=new BinaryOpProgram(a,g.shape,_.shape);return b.runWebGLProgram(dt,[ct,lt],upcastType(st.dtype,ot.dtype))}),it=complex$2({inputs:{real:nt,imag:rt},backend:b});return b.disposeIntermediateTensorInfo(nt),b.disposeIntermediateTensorInfo(rt),it}const $=c||upcastType(g.dtype,_.dtype);if(b.shouldExecuteOnCPU([g,_])&&o!=null){const tt=b.texData.get(g.dataId),et=b.texData.get(_.dataId),[nt,rt]=o(g.shape,_.shape,tt.values,et.values,$),it=b.makeTensorInfo(rt,$),at=b.texData.get(it.dataId);return at.values=nt,it}const j=env$1().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let _e;return j?_e=new BinaryOpPackedProgram(e,g.shape,_.shape,i):_e=new BinaryOpProgram(a,g.shape,_.shape),b.runWebGLProgram(_e,[g,_],$)}}function mapActivationToShaderProgram(a,e=!1){if(a==="linear")return e?LINEAR:LINEAR$1;if(a==="relu")return e?RELU$1:RELU$2;if(a==="elu")return e?ELU$1:ELU$2;if(a==="relu6")return e?RELU6$1:RELU6$2;if(a==="prelu")return e?PRELU_PACKED:PRELU;if(a==="leakyrelu")return e?LEAKYRELU_PACKED:LEAKYRELU;throw new Error(`Activation ${a} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MatMulPackedProgram{constructor(e,i,s,o=!1,c=!1,d=!1,h=null,g=!1,_=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const b=o?e[1]:e[2],$=Math.ceil(b/2),j=o?"i * 2, rc.y":"rc.y, i * 2",_e=c?"rc.z, i * 2":"i * 2, rc.z",tt=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],et=c?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let nt="",rt="";h&&(g?nt=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${h}
        }`:_?nt=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${h}
        }`:nt=`vec4 activation(vec4 x) {
          ${h}
        }`,rt="result = activation(result);");const it=d?"result += getBiasAtOutCoords();":"";d&&this.variableNames.push("bias"),g&&this.variableNames.push("preluActivationWeights"),_&&this.variableNames.push("leakyreluAlpha");let at="rc.x",st="rc.x";e[0]<i[0]?at=`int(min(float(rc.x), ${e[0]-1}.))`:i[0]<e[0]&&(st=`int(min(float(rc.x), ${i[0]-1}.))`),this.userCode=`
      ${nt}

      const float sharedDimension = ${$}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${$}; i++) {
          int batchA = ${at};
          int batchB = ${st};
          vec4 a = getMatrixA(batchA, ${j});
          vec4 b = getMatrixB(batchB, ${_e});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${tt[0]} * ${et[0]});
          result += (${tt[1]} * ${et[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${it}

        ${rt}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class BinaryOpComplexProgram{constructor(e,i,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=assertAndGetBroadcastShape(i,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MUL="return a * b;";function multiply$1(a){const{inputs:e,backend:i}=a,{a:s,b:o}=e,c=upcastType(s.dtype,o.dtype);if(s.dtype==="complex64"){const h=i.texData.get(s.dataId),g=i.texData.get(o.dataId),_=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL,s.shape,o.shape),b=new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG,s.shape,o.shape),$=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:s.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:g.complexTensorInfos.real.dataId,dtype:g.complexTensorInfos.real.dtype,shape:o.shape},{dataId:g.complexTensorInfos.imag.dataId,dtype:g.complexTensorInfos.imag.dtype,shape:o.shape}],j=i.runWebGLProgram(_,$,"float32"),_e=i.runWebGLProgram(b,$,"float32"),tt=complex$2({inputs:{real:j,imag:_e},backend:i});return i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(_e),tt}if(i.shouldExecuteOnCPU([s,o])){const h=i.texData.get(s.dataId),g=i.texData.get(o.dataId),[_,b]=multiplyImplCPU(s.shape,o.shape,h.values,g.values,c),$=i.makeTensorInfo(b,c),j=i.texData.get($.dataId);return j.values=_,$}let d;return env$1().getBool("WEBGL_PACK_BINARY_OPERATIONS")?d=new BinaryOpPackedProgram(MUL,s.shape,o.shape):d=new BinaryOpProgram(MUL,s.shape,o.shape),i.runWebGLProgram(d,[s,o],c)}const multiplyConfig={kernelName:Multiply$1,backendName:"webgl",kernelFunc:multiply$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function packedReshape(a,e,i){const s=[getBatchDim(a.shape),...getRowsCols(a.shape)],o={dtype:a.dtype,shape:s,dataId:a.dataId},c=[getBatchDim(e),...getRowsCols(e)],d=new ReshapePackedProgram(c,s),g=i.runWebGLProgram(d,[o],a.dtype,null,!0);return{dataId:g.dataId,shape:e,dtype:g.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{shape:c}=s,d=i,h=sizeFromShape(o.shape),g=inferFromImplicitShape(c,h),_=sizeFromShape(g);assert$1(h===_,()=>`The new shape (${g}) has ${_} elements and the old shape (${o.shape}) has ${h} elements. The new shape and old shape must have the same number of elements.`);const b=d.texData.get(o.dataId);return b.isPacked&&!isReshapeFree(o.shape,g)&&!(b.texture!==null&&isReshapeFree(b.shape,g))?packedReshape(o,g,d):(d.incRef(o.dataId),{dataId:o.dataId,shape:g,dtype:o.dtype})}const reshapeConfig={kernelName:Reshape$1,backendName:"webgl",kernelFunc:reshape$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MeanProgram{constructor(e,i){this.variableNames=["x"];const{windowSize:s,batchSize:o,inSize:c,outSize:d}=e;this.outputShape=[o,d];const h=Math.floor(s/4)*4,g=s%4;let _="sumValue += dot(values, ones);";if(i!=null){const $=1/i;_=`sumValue += dot(values * ${isInt($)?$.toPrecision(2):$}, ones);`}let b="";c%s>0&&(b=`
        if (inIdx < 0 || inIdx >= ${c}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${_}
        }

        int inIdx = inOffset + ${h};
        if (${g===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${_}
        } else if (${g===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${_}
        } else if (${g===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${_}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ReduceProgram{constructor(e,i){this.variableNames=["x"];const{windowSize:s,batchSize:o,inSize:c,outSize:d}=e;this.outputShape=[o,d];let h="0.0",g="";i==="prod"?h="1.0":i==="min"?(h="1.0 / 1e-20",g="min"):i==="max"&&(h="-1.0 / 1e-20",g="max");let _=`${i}(${i}(${i}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;i==="sum"?_="sumValue":i==="prod"?_="prodValue":i==="all"?_="allValue":i==="any"&&(_="anyValue");const b=Math.floor(s/4)*4,$=s%4;let j=`
      if (${i==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${i==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${g}(values, minMaxValue);
      }
    `,_e="vec4";i==="all"?(h="1.0",j=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,_e="bvec4"):i==="any"&&(h="0.0",j=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,_e="bvec4");let tt="";c%s>0&&(tt=`
        if (inIdx < 0 || inIdx >= ${c}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${h};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${tt}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${h});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${b}; i += 4) {
          int inIdx = inOffset + i;
          ${_e} values = ${_e}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${j}
        }

        int inIdx = inOffset + ${b};
        if (${$===1}) {
          ${_e} values = ${_e}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${j}
        } else if (${$===2}) {
          ${_e} values = ${_e}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${j}
        } else if (${$===3}) {
          ${_e} values = ${_e}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${j}
        }
        setOutput(${_});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getReductionStages(a){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const i=e.length?e[e.length-1].outSize:a[1],s=computeOptimalWindowSize(i);e.push({inSize:i,windowSize:s,outSize:Math.ceil(i/s)})}return e}function reduce(a,e,i,s){const o=getReductionStages(a.shape);let c=a;for(let d=0;d<o.length;d++){const{inSize:h,windowSize:g,outSize:_}=o[d];let b,$;i==="mean"?b=d===0?new MeanProgram({windowSize:g,inSize:h,batchSize:a.shape[0],outSize:_},h):new MeanProgram({windowSize:g,inSize:h,batchSize:a.shape[0],outSize:_}):b=new ReduceProgram({windowSize:g,inSize:h,batchSize:a.shape[0],outSize:_},i),$=c,c=s.runWebGLProgram(b,[c],e),$.dataId!==a.dataId&&s.disposeIntermediateTensorInfo($)}return c}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TransposeProgram{constructor(e,i){this.variableNames=["A"];const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[i[d]];this.outputShape=s,this.rank=s.length;const o=getCoordsDataType(this.rank),c=getSwitchedCoords(i);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${c}));
    }
    `}}function getSwitchedCoords(a){const e=a.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const i=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let o=0;o<a.length;o++)s[a[o]]=i[o];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TransposePackedProgram{constructor(e,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let b=0;b<s.length;b++)s[b]=e[i[b]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const o=getCoordsDataType(this.rank),c=getVecChannels("rc",this.rank),d=new Array(this.rank);for(let b=0;b<i.length;b++)d[i[b]]=c[b];const h=`vec2(${d.slice(-2).join()})`,g=`++${c[this.rank-1]} < ${s[this.rank-1]}`,_=`getChannel(getA(${d.join()}), ${h})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${_};
      if(${g}) {
        result[1] = ${_};
      }
      --${c[this.rank-1]};
      if(++${c[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${_};
        if(${g}) {
          result[3] = ${_};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(a,e,i){const s=env$1().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(a.shape,e):new TransposeProgram(a.shape,e);return i.runWebGLProgram(s,[a],a.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sumImpl(a,e,i,s){const o=e,c=a.shape.length,d=parseAxisParam(o,a.shape);let h=d;const g=getAxesPermutation(h,c),_=g!=null;let b=a;_&&(b=transposeImpl(a,g,s),h=getInnerMostAxes(h.length,c)),assertAxesAreInnerMostDims("sum",h,c);const[$,j]=computeOutAndReduceShapes(b.shape,h);let _e=$;i&&(_e=expandShapeToKeepDim($,d));const tt=sizeFromShape(j),nt=sizeFromShape(a.shape)/tt,rt=reshape$1({inputs:{x:b},attrs:{shape:[nt,tt]},backend:s}),it=sumOutType(a.dtype),at=reduce(rt,it,"sum",s),st=reshape$1({inputs:{x:at},attrs:{shape:_e},backend:s});return s.disposeIntermediateTensorInfo(rt),s.disposeIntermediateTensorInfo(at),_&&s.disposeIntermediateTensorInfo(b),st}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s;return sumImpl(o,c,d,i)}const sumConfig={kernelName:Sum,backendName:"webgl",kernelFunc:sum$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{perm:c}=s,d=i,h=o.shape.length,g=new Array(h);for(let b=0;b<g.length;b++)g[b]=o.shape[c[b]];let _;if(d.shouldExecuteOnCPU([o])){const $=d.texData.get(o.dataId).values,j=transposeImplCPU($,o.shape,o.dtype,c,g);_=d.makeTensorInfo(g,o.dtype);const _e=d.texData.get(_.dataId);_e.values=j}else _=transposeImpl(o,c,d);return _}const transposeConfig={kernelName:Transpose,backendName:"webgl",kernelFunc:transpose$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MATMUL_SHARED_DIM_THRESHOLD=1e3;function batchMatMulImpl({a,b:e,transposeA:i,transposeB:s,backend:o,bias:c=null,preluActivationWeights:d=null,leakyreluAlpha:h=0,activation:g=null}){const _=a.shape.length,b=e.shape.length,$=i?a.shape[_-2]:a.shape[_-1],j=s?e.shape[b-1]:e.shape[b-2],_e=i?a.shape[_-1]:a.shape[_-2],tt=s?e.shape[b-2]:e.shape[b-1],et=a.shape.slice(0,-2),nt=e.shape.slice(0,-2),rt=sizeFromShape(et),it=sizeFromShape(nt),at=rt===it||rt===1||it===1;assert$1(_>=2&&b>=2&&at,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${et}) and (${nt}).`);const ot=(rt>it?a.shape.slice(0,-2):e.shape.slice(0,-2)).concat([_e,tt]);assert$1($===j,()=>`Error in matMul: inner shapes (${$}) and (${j}) of Tensors with shapes ${a.shape} and ${e.shape} and transposeA=${i} and transposeB=${s} must match.`);const ct=i?[rt,$,_e]:[rt,_e,$],lt=s?[it,tt,j]:[it,j,tt],dt=reshape$1({inputs:{x:a},backend:o,attrs:{shape:ct}}),xt=reshape$1({inputs:{x:e},backend:o,attrs:{shape:lt}}),ut=[dt,xt],ft=Math.max(rt,it),mt=i?dt.shape[1]:dt.shape[2],yt=c!=null,St=d!=null,Et=g==="leakyrelu",vt=g!=null?mapActivationToShaderProgram(g,!0):null,Nt=yt||St||Et||vt!=null;let wt;if((_e===1||tt===1)&&mt>MATMUL_SHARED_DIM_THRESHOLD&&Nt===!1){let Ct=dt,Mt=xt;i&&(Ct=transpose$1({inputs:{x:dt},backend:o,attrs:{perm:[0,2,1]}}),ut.push(Ct)),s&&(Mt=transpose$1({inputs:{x:xt},backend:o,attrs:{perm:[0,2,1]}}),ut.push(Mt));const Ot=tt!==1,Dt=tt===1;let At=Ct;Ot&&(At=reshape$1({inputs:{x:Ct},backend:o,attrs:{shape:[ft,mt,1]}}),ut.push(At));const kt=tt===1?2:1;let Ft=Mt;Dt&&(Ft=reshape$1({inputs:{x:Mt},backend:o,attrs:{shape:[ft,1,mt]}}),ut.push(Ft));const Bt=multiply$1({inputs:{a:At,b:Ft},backend:o});wt=sum$1({inputs:{x:Bt},backend:o,attrs:{axis:kt,keepDims:!0}}),ut.push(Bt)}else{const Ct=upcastType(a.dtype,e.dtype),Mt=new MatMulPackedProgram(ct,lt,[ft,_e,tt],i,s,yt,vt,St,Et),Ot=[dt,xt];if(c!=null&&Ot.push(c),St&&Ot.push(d),Et){const Dt=o.makeTensorInfo([],"float32",createScalarValue(h,"float32"));Ot.push(Dt),ut.push(Dt)}wt=o.runWebGLProgram(Mt,Ot,Ct)}const $t=reshape$1({inputs:{x:wt},backend:o,attrs:{shape:ot}});ut.push(wt);for(const Ct of ut)o.disposeIntermediateTensorInfo(Ct);return $t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _fusedMatMul(a){const{inputs:e,backend:i,attrs:s}=a,{a:o,b:c,bias:d,preluActivationWeights:h}=e,{transposeA:g,transposeB:_,activation:b,leakyreluAlpha:$}=s;return batchMatMulImpl({a:o,b:c,transposeA:g,transposeB:_,backend:i,bias:d,preluActivationWeights:h,leakyreluAlpha:$,activation:b})}const _fusedMatMulConfig={kernelName:_FusedMatMul,backendName:"webgl",kernelFunc:_fusedMatMul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ABS="return abs(x);";function abs$2(a){const{inputs:e,backend:i}=a,{x:s}=e;if(i.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const c=i.texData.get(s.dataId),d=simpleAbsImplCPU(c.values);return i.makeTensorInfo(s.shape,s.dtype,d)}let o;return env$1().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new UnaryOpPackedProgram(s.shape,ABS):o=new UnaryOpProgram(s.shape,ABS),i.runWebGLProgram(o,[s],s.dtype)}const absConfig={kernelName:Abs,backendName:"webgl",kernelFunc:abs$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ACOS=CHECK_NAN_SNIPPET$2+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,acos$1=unaryKernelFunc({opSnippet:ACOS}),acosConfig={kernelName:Acos,backendName:"webgl",kernelFunc:acos$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ACOSH=CHECK_NAN_SNIPPET$2+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,acosh$1=unaryKernelFunc({opSnippet:ACOSH}),acoshConfig={kernelName:Acosh,backendName:"webgl",kernelFunc:acosh$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ADD="return a + b;",addKernelFunc=binaryKernelFunc({opSnippet:ADD,packedOpSnippet:ADD,supportsComplex:!0,cpuKernelImpl:addImplCPU}),addConfig={kernelName:Add$1,backendName:"webgl",kernelFunc:addKernelFunc};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AddNProgram{constructor(e,i){this.outputShape=[],this.outputShape=e,this.variableNames=i.map((c,d)=>`T${d}`);const s=[];this.variableNames.forEach(c=>{s.push(`float v${c} = get${c}AtOutCoords();`)});const o=this.variableNames.map(c=>`v${c}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AddNPackedProgram{constructor(e,i){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=i.map((c,d)=>`T${d}`);const s=[];this.variableNames.forEach(c=>{s.push(`vec4 v${c} = get${c}AtOutCoords();`)});const o=this.variableNames.map(c=>`v${c}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN(a){const{inputs:e,backend:i}=a,s=e;if(s.length===1)return identity$1({inputs:{x:s[0]},backend:i});if(s.length>env$1().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const g=Math.floor(s.length/2),_=addN({inputs:s.slice(0,g),backend:i}),b=addN({inputs:s.slice(g),backend:i});return addN({inputs:[_,b],backend:i})}const o=s.map(g=>g.dtype).reduce((g,_)=>upcastType(g,_)),c=s.map(g=>g.shape),h=env$1().getBool("WEBGL_PACK")?new AddNPackedProgram(s[0].shape,c):new AddNProgram(s[0].shape,c);return i.runWebGLProgram(h,s,o)}const addNConfig={kernelName:AddN,backendName:"webgl",kernelFunc:addN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function all(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s,h=o.shape.length,g=parseAxisParam(c,o.shape);let _=g;const b=getAxesPermutation(_,h);let $=o;b!=null&&($=transpose$1({inputs:{x:o},backend:i,attrs:{perm:b}}),_=getInnerMostAxes(_.length,h)),assertAxesAreInnerMostDims("all",_,h);const[j,_e]=computeOutAndReduceShapes($.shape,_),tt=sizeFromShape(_e),et=reshape$1({inputs:{x:$},backend:i,attrs:{shape:[-1,tt]}}),nt=reduce(et,et.dtype,"all",i);let rt;if(d){const it=expandShapeToKeepDim(j,g);rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:it}})}else rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:j}});return i.disposeIntermediateTensorInfo(et),i.disposeIntermediateTensorInfo(nt),b!=null&&i.disposeIntermediateTensorInfo($),rt}const allConfig={kernelName:All,backendName:"webgl",kernelFunc:all};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function any(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s,h=o.shape.length,g=parseAxisParam(c,o.shape);let _=g;const b=getAxesPermutation(_,h);let $=o;b!=null&&($=transpose$1({inputs:{x:o},backend:i,attrs:{perm:b}}),_=getInnerMostAxes(_.length,h)),assertAxesAreInnerMostDims("any",_,h);const[j,_e]=computeOutAndReduceShapes($.shape,_),tt=sizeFromShape(_e),et=reshape$1({inputs:{x:$},backend:i,attrs:{shape:[-1,tt]}}),nt=reduce(et,et.dtype,"any",i);let rt;if(d){const it=expandShapeToKeepDim(j,g);rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:it}})}else rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:j}});return i.disposeIntermediateTensorInfo(et),i.disposeIntermediateTensorInfo(nt),b!=null&&i.disposeIntermediateTensorInfo($),rt}const anyConfig={kernelName:Any,backendName:"webgl",kernelFunc:any};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ArgMinMaxProgram{constructor(e,i,s){this.variableNames=["A"];const{windowSize:o,batchSize:c,outSize:d}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[c,d];const h=i==="max"?">":"<",g=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${g};
          float candidate = getA(batch, inIdx);
          if (candidate ${h} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ArgMinMaxPackedProgram{constructor(e,i,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,assert$1(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const c=e[e.length-1],d=Math.ceil(c/i);this.outputShape=e.slice(0,-1),d>1&&this.outputShape.push(d),o||this.variableNames.push("bestIndicesA");const h=this.outputShape,g=h.length,_=getCoordsDataType(g),b=getChannels("coords",g);let $,j;if(d===1){j=g+1;const dt=getCoordsDataType(j);$=`
        ${dt} sourceLocR = ${dt}(${b.join()}, 0);
        ++${b[g-1]};
        ${dt} sourceLocG = ${dt}(${b.join()}, 0);
        ++${b[g-2]};
        ${dt} sourceLocA = ${dt}(${b.join()}, 0);
        --${b[g-1]};
        ${dt} sourceLocB = ${dt}(${b.join()}, 0);
        --${b[g-2]};`}else j=g,$=`
        ${_} sourceLocR = coords;
        ++${b[g-1]};
        ${_} sourceLocG = coords;
        ++${b[g-2]};
        ${_} sourceLocA = coords;
        --${b[g-1]};
        ${_} sourceLocB = coords;
        --${b[g-2]};`;const _e=["x","y","z","w","u","v"].slice(0,j),tt="."+_e[j-1],et=_e.map(dt=>"int "+dt),nt=getChannels("sourceLocR",j-1).concat("inIdx.r"),rt=getChannels("sourceLocG",j-1).concat("inIdx.g"),it=getChannels("sourceLocB",j-1).concat("inIdx.b"),at=getChannels("sourceLocA",j-1).concat("inIdx.a"),st=s==="max"?"greaterThan":"lessThan",ot=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${nt.join()}),
                             getBestIndicesAChannel(${rt.join()}),
                             getBestIndicesAChannel(${it.join()}),
                             getBestIndicesAChannel(${at.join()})));`,ct=`vec4(
            getAChannel(${nt.join()}),
            hasNextCol ? getAChannel(${rt.join()}) : 0.,
            hasNextRow ? getAChannel(${it.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${at.join()}) : 0.)`,lt=o?"":`
      float getBestIndicesAChannel(${et.join()}) {
        return getChannel(getBestIndicesA(${_e.join()}),
                                          vec2(${_e.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${et.join()}) {
        return getChannel(getA(${_e.join()}),
                               vec2(${_e.slice(-2).join()}));
      }
      ${lt}
      void main() {
        ${_} coords = getOutputCoords();
        bool hasNextCol = ${b[g-1]} < ${h[g-1]-1};
        bool hasNextRow = ${b[g-2]} < ${h[g-2]-1};
        ${$}
        ivec4 srcIdx = ivec4(sourceLocR${tt}, sourceLocG${tt},
          sourceLocB${tt}, sourceLocA${tt}) * ${i};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${ct};

        for (int i = 0; i < ${i}; i++) {
          inIdx = srcIdx;
          ${ot}
          vec4 candidate = ${ct};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${st}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argReduce(a,e,i,s=null){let o=e.shape[0],c=e.shape[1];s!=null&&(o=s.shape[0],c=s.shape[1]);const d=computeOptimalWindowSize(c),h={windowSize:d,inSize:c,batchSize:o,outSize:Math.ceil(c/d)},g=new ArgMinMaxProgram(h,i,s==null),_=[e];s!=null&&_.push(s);const b=a.runWebGLProgram(g,_,"int32");if(b.shape[1]===1)return b;const $=argReduce(a,e,i,b);return a.disposeIntermediateTensorInfo(b),$}function argReducePacked(a,e,i,s=null){const o=s!=null?s.shape:e.shape,c=o[o.length-1],d=computeOptimalWindowSize(c),h=new ArgMinMaxPackedProgram(o,d,i,s==null),g=s==null?[e]:[e,s],_=a.runWebGLProgram(h,g,"int32");if(_.shape.length===e.shape.length){const b=argReducePacked(a,e,i,_);return a.disposeIntermediateTensorInfo(_),b}return _}function argMinMaxReduce(a,e,i,s){const o=[i];if(assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),o,e.shape.length),!env$1().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const c=[],[d,h]=computeOutAndReduceShapes(e.shape,o),g=sizeFromShape(h),_=reshape$1({inputs:{x:e},backend:a,attrs:{shape:[-1,g]}});c.push(_);const b=argReduce(a,_,s);c.push(b);const $=reshape$1({inputs:{x:b},backend:a,attrs:{shape:d}});return c.forEach(j=>a.disposeIntermediateTensorInfo(j)),$}return argReducePacked(a,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMax(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c}=s;let d=parseAxisParam(c,o.shape);const h=getAxesPermutation(d,o.shape.length);let g=o;const _=[];h!=null&&(g=transpose$1({inputs:{x:o},backend:i,attrs:{perm:h}}),_.push(g),d=getInnerMostAxes(d.length,g.shape.length)),assertAxesAreInnerMostDims("argMax",[d[0]],g.shape.length);const b=argMinMaxReduce(i,g,d[0],"max");return _.forEach($=>i.disposeIntermediateTensorInfo($)),b}const argMaxConfig={kernelName:ArgMax,backendName:"webgl",kernelFunc:argMax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argMin(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c}=s;let d=parseAxisParam(c,o.shape);const h=getAxesPermutation(d,o.shape.length);let g=o;const _=[];h!=null&&(g=transpose$1({inputs:{x:o},backend:i,attrs:{perm:h}}),_.push(g),d=getInnerMostAxes(d.length,g.shape.length)),assertAxesAreInnerMostDims("argMin",[d[0]],g.shape.length);const b=argMinMaxReduce(i,g,d[0],"min");return _.forEach($=>i.disposeIntermediateTensorInfo($)),b}const argMinConfig={kernelName:ArgMin,backendName:"webgl",kernelFunc:argMin};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ASIN=CHECK_NAN_SNIPPET$2+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,asin$1=unaryKernelFunc({opSnippet:ASIN}),asinConfig={kernelName:Asin,backendName:"webgl",kernelFunc:asin$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ASINH=CHECK_NAN_SNIPPET$2+"return log(x + sqrt(x * x + 1.0));",asinh$1=unaryKernelFunc({opSnippet:ASINH}),asinhConfig={kernelName:Asinh,backendName:"webgl",kernelFunc:asinh$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ATAN=CHECK_NAN_SNIPPET$2+`
  return atan(x);
`,atan$2=unaryKernelFunc({opSnippet:ATAN}),atanConfig={kernelName:Atan,backendName:"webgl",kernelFunc:atan$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ATAN2=CHECK_NAN_SNIPPET_BINARY+`
  return atan(a, b);
`,ATAN2_PACKED=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CHECK_NAN_SNIPPET_BINARY_PACKED+`
  return result;
`,atan2$1=binaryKernelFunc({opSnippet:ATAN2,packedOpSnippet:ATAN2_PACKED}),atan2Config={kernelName:Atan2,backendName:"webgl",kernelFunc:atan2$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ATANH=CHECK_NAN_SNIPPET$2+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,atanh$1=unaryKernelFunc({opSnippet:ATANH}),atanhConfig={kernelName:Atanh,backendName:"webgl",kernelFunc:atanh$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pool2DProgram{constructor(e,i,s,o=!1,c=!1){if(this.variableNames=["x"],i==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const d=e.filterWidth,h=e.strideHeight,g=e.strideWidth,_=e.dilationHeight,b=e.dilationWidth,$=e.effectiveFilterHeight,j=e.effectiveFilterWidth,_e=e.padInfo.top,tt=e.padInfo.left;this.outputShape=e.outShape;const et=i==="avg",nt=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,rt=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let it="0.0";if(et||(it="-1.0 / 1e-20"),s){const dt=">=";this.userCode=`
        const ivec2 strides = ivec2(${h}, ${g});
        const ivec2 pads = ivec2(${_e}, ${tt});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${$};
              wR += ${_}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${j};
                wC += ${b}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${dt} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?c?nt:rt:`wR * ${j} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const at="max";let st=`${i}(${i}(${i}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;i==="avg"&&(st="avgValue / count");const ot=Math.floor(d/4)*4,ct=d%4,lt=`
      if (${et}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${at}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${h}, ${g});
      const ivec2 pads = ivec2(${_e}, ${tt});
      const float initializationValue = ${it};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${it});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${$};
            wR += ${_}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${ot}; wC += 4) {
            int xC = xCCorner + wC * ${b};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${b}, d),
              getValue(batch, xR, xC + 2 * ${b}, d),
              getValue(batch, xR, xC + 3 * ${b}, d)
            );

            ${lt}
          }

          int xC = xCCorner + ${ot};
          if (${ct===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${lt}
          } else if (${ct===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${b}, d),
              initializationValue,
              initializationValue
            );

            ${lt}
          } else if (${ct===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${b}, d),
              getValue(batch, xR, xC + 2 * ${b}, d),
              initializationValue
            );

            ${lt}
          }
        }
        setOutput(${st});
      }
    `}}class Pool3DProgram{constructor(e,i,s,o=!1,c=!1){if(this.variableNames=["x"],i==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const d=e.filterWidth,h=e.strideDepth,g=e.strideHeight,_=e.strideWidth,b=e.dilationDepth,$=e.dilationHeight,j=e.dilationWidth,_e=e.effectiveFilterDepth,tt=e.effectiveFilterHeight,et=e.effectiveFilterWidth,nt=e.padInfo.front,rt=e.padInfo.top,it=e.padInfo.left;this.outputShape=e.outShape;const at=i==="avg";let st="0.0";if(at||(st="-1.0 / 1e-20"),s){const ut=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${h}, ${g}, ${_});
        const ivec3 pads = ivec3(${nt}, ${rt}, ${it});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${_e};
              wD += ${b}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${tt};
                wR += ${$}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${et};
                  wC += ${j}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${ut} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?c?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${tt} * ${et} +
                      wR * ${et} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const ot="max";let ct=`${i}(${i}(${i}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;i==="avg"&&(ct="avgValue / count");const lt=Math.floor(d/4)*4,dt=d%4,xt=`
      if (${at}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${ot}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${h}, ${g}, ${_});
      const ivec3 pads = ivec3(${nt}, ${rt}, ${it});
      const float initializationValue = ${st};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${st});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${_e};
            wD += ${b}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${tt};
            wR += ${$}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${lt}; wC += 4) {
              int xC = xCCorner + wC * ${j};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${j}, ch),
                getValue(batch, xD, xR, xC + 2 * ${j}, ch),
                getValue(batch, xD, xR, xC + 3 * ${j}, ch)
              );

              ${xt}
            }

            int xC = xCCorner + ${lt};
            if (${dt===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${xt}
            } else if (${dt===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${j}, ch),
                initializationValue,
                initializationValue
              );

              ${xt}
            } else if (${dt===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${j}, ch),
                getValue(batch, xD, xR, xC + 2 * ${j}, ch),
                initializationValue
              );

              ${xt}
            }
          }
          setOutput(${ct});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e;assertNotComplex(o,"avgPool");const{filterSize:c,strides:d,pad:h,dimRoundingMode:g}=s,_=1;assert$1(eitherStridesOrDilationsAreOne(d,_),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${d} and dilations '${_}'`);const b=computePool2DInfo(o.shape,c,d,_,h,g);if(b.filterWidth===1&&b.filterHeight===1&&arraysEqual(b.inShape,b.outShape))return identity$1({inputs:{x:o},backend:i});const $=new Pool2DProgram(b,"avg",!1);return i.runWebGLProgram($,[o],"float32")}const avgPoolConfig={kernelName:AvgPool,backendName:"webgl",kernelFunc:avgPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{filterSize:c,strides:d,pad:h,dimRoundingMode:g,dataFormat:_}=s,b=[1,1,1],$=computePool3DInfo(o.shape,c,d,b,h,g,_),j=new Pool3DProgram($,"avg",!1);return i.runWebGLProgram(j,[o],"float32")}const avgPool3DConfig={kernelName:AvgPool3D,backendName:"webgl",kernelFunc:avgPool3D};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AvgPool2DBackpropProgram{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const i=e.filterHeight,s=e.filterWidth,o=e.strideHeight,c=e.strideWidth,d=e.dilationHeight,h=e.dilationWidth,g=e.effectiveFilterHeight,_=e.effectiveFilterWidth,b=g-1-e.padInfo.top,$=_-1-e.padInfo.left,j=1/(i*s);this.userCode=`
      const ivec2 pads = ivec2(${b}, ${$});
      const float avgMultiplier = float(${j});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${g};
            wR += ${d}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${_};
            wC+= ${h}) {
            float dyC = float(dyCCorner + wC) / ${c}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class AvgPool3DBackpropProgram{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const i=e.filterDepth,s=e.filterHeight,o=e.filterWidth,c=e.strideDepth,d=e.strideHeight,h=e.strideWidth,g=e.dilationDepth,_=e.dilationHeight,b=e.dilationWidth,$=e.effectiveFilterDepth,j=e.effectiveFilterHeight,_e=e.effectiveFilterWidth,tt=$-1-e.padInfo.front,et=j-1-e.padInfo.top,nt=_e-1-e.padInfo.left,rt=1/(i*s*o);this.userCode=`
      const ivec3 pads = ivec3(${tt}, ${et}, ${nt});
      const float avgMultiplier = float(${rt});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${$};
            wD += ${g}) {
          float dyD = float(dyDCorner + wD) / ${c}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${j};
              wR += ${_}) {
            float dyR = float(dyRCorner + wR) / ${d}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${_e};
                wC += ${b}) {
              float dyC = float(dyCCorner + wC) / ${h}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPool3DGrad(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c}=e,d=c,{filterSize:h,strides:g,pad:_,dimRoundingMode:b}=s,$=[1,1,1],j=computePool3DInfo(d.shape,h,g,$,_,b),_e=new AvgPool3DBackpropProgram(j);return i.runWebGLProgram(_e,[o],d.dtype)}const avgPoolGrad3DConfig={kernelName:AvgPool3DGrad,backendName:"webgl",kernelFunc:avgPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function avgPoolGrad(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c}=e,d=c;assertNotComplex([o,c],"avgPoolGrad");const{filterSize:h,strides:g,pad:_}=s,b=computePool2DInfo(d.shape,h,g,1,_),$=new AvgPool2DBackpropProgram(b);return i.runWebGLProgram($,[o],d.dtype)}const avgPoolGradConfig={kernelName:AvgPoolGrad,backendName:"webgl",kernelFunc:avgPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchMatMul(a){const{inputs:e,backend:i,attrs:s}=a,{a:o,b:c}=e,{transposeA:d,transposeB:h}=s;return batchMatMulImpl({a:o,b:c,transposeA:d,transposeB:h,backend:i})}const batchMatMulConfig={kernelName:BatchMatMul,backendName:"webgl",kernelFunc:batchMatMul};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BatchNormProgram{constructor(e,i,s,o,c,d){this.outputShape=[],this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(e,i),assertAndGetBroadcastShape(e,s);let h="0.0";o!=null&&(assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),h="getOffsetAtOutCoords()");let g="1.0";c!=null&&(assertAndGetBroadcastShape(e,c),this.variableNames.push("scale"),g="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${h};
        float scale = ${g};
        float inv = scale * inversesqrt(variance + float(${d}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BatchNormPackedProgram{constructor(e,i,s,o,c,d){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],assertAndGetBroadcastShape(e,i),assertAndGetBroadcastShape(e,s);let h="vec4(0.0)";o!=null&&(assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),h="getOffsetAtOutCoords()");let g="vec4(1.0)";c!=null&&(assertAndGetBroadcastShape(e,c),this.variableNames.push("scale"),g="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${h};
        vec4 scale = ${g};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${d}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const batchNorm=({inputs:a,backend:e,attrs:i})=>{const{x:s,mean:o,variance:c,offset:d,scale:h}=a;assert$1(o.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),assert$1(d==null||o.shape.length===d.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),assert$1(h==null||o.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:g}=i;g==null&&(g=.001);const _=[s,o,c];let b=null;d!=null&&(b=d.shape,_.push(d));let $=null;h!=null&&($=h.shape,_.push(h));const j=env$1().getBool("WEBGL_PACK_NORMALIZATION")?new BatchNormPackedProgram(s.shape,o.shape,c.shape,b,$,g):new BatchNormProgram(s.shape,o.shape,c.shape,b,$,g);return e.runWebGLProgram(j,_,_[0].dtype)},batchNormConfig={kernelName:FusedBatchNorm,backendName:"webgl",kernelFunc:batchNorm};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SliceProgram{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const i=getCoordsDataType(this.rank),s=`uniform int start[${this.rank}];`,o=getCoords$1(this.rank);let c;const d=e.map((h,g)=>`sourceLoc.${coords[g]} = start[${g}] + coords.${coords[g]};`);c=`
        ${i} sourceLoc;
        ${i} coords = getOutputCoords();
        ${d.join(`
`)}
      `,this.userCode=`
      ${s}
      void main() {
        ${c}
        setOutput(getSource(${o}));
      }
    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(i,s)=>{this.startLoc==null&&(this.startLoc=i.getUniformLocationNoThrow(s,"start"),this.startLoc==null)||i.gl.uniform1iv(this.startLoc,e)}}}const coords=["x","y","z","w","u","v"];function getCoords$1(a){if(a===1)return"sourceLoc";if(a<=6)return coords.slice(0,a).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${a} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SlicePackedProgram{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const i=getCoordsDataType(this.rank),s=getChannels("coords",this.rank),o=getChannels("sourceLoc",this.rank),c=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,d=`getChannel(getSource(${o.join()}), ${c})`,h=`
      result.x = ${d};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${d};
        --${o[this.rank-1]};
      }
    `,g=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${d};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${d};
        }
      }
    `,_=this.rank<=4?`sourceLoc = coords +
            ${i}(${e.map((b,$)=>`start[${$}]`).join()});`:e.map((b,$)=>`${o[$]} = ${s[$]} + start[${$}];`).join(`
`);this.userCode=`
      uniform int start[${this.rank}];
      void main() {
        ${i} coords = getOutputCoords();
        ${i} sourceLoc;
        ${_}
        vec4 result = vec4(0.);
        ${h}
        ${g}
        setOutput(result);
      }
    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(i,s)=>{this.startLoc==null&&(this.startLoc=i.getUniformLocationNoThrow(s,"start"),this.startLoc==null)||i.gl.uniform1iv(this.startLoc,e)}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function shallowSlice(a,e,i,s){const o=s.texData.get(a.dataId),c=s.makeTensorInfo(i,a.dtype),d=s.texData.get(c.dataId);Object.assign(d,o),d.refCount=1,d.shape=i,d.dtype=a.dtype;let h=computeFlatOffset(e,computeStrides(a.shape));o.slice&&(h+=o.slice.flatOffset),d.slice={flatOffset:h,origDataId:o.slice&&o.slice.origDataId||a.dataId};const g=s.dataRefCount.get(d.slice.origDataId)||1;return s.dataRefCount.set(d.slice.origDataId,g+1),c}function slice(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{begin:c,size:d}=s,[h,g]=parseSliceParams(o,c,d);if(assertParamsValid(o,h,g),sizeFromShape(g)===0)return i.makeTensorInfo(g,o.dtype,[]);if(i.shouldExecuteOnCPU([o])||o.dtype==="string"){const $=i.texData.get(o.dataId),j=sliceImplCPU($.values,h,g,o.shape,o.dtype);return i.makeTensorInfo(g,o.dtype,j)}const{isPacked:_}=i.texData.get(o.dataId),b=isSliceContinous(o.shape,h,g);if(_||!b){const $=env$1().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(g):new SliceProgram(g),j=$.getCustomSetupFunc(h);return i.runWebGLProgram($,[o],o.dtype,j)}return i.uploadToGPU(o.dataId),shallowSlice(o,h,g,i)}const sliceConfig={kernelName:Slice,backendName:"webgl",kernelFunc:slice};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const batchToSpaceND=a=>{const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{blockShape:c,crops:d}=s;assert$1(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const h=c.reduce((it,at)=>it*at),g=getReshaped(o.shape,c,h),_=getPermuted(g.length,c.length),b=getReshapedPermuted(o.shape,c,h),$=getSliceBeginCoords(d,c.length),j=getSliceSize(b,d,c.length),_e=[],tt=reshape$1({inputs:{x:o},backend:i,attrs:{shape:g}}),et=transpose$1({inputs:{x:tt},backend:i,attrs:{perm:_}}),nt=reshape$1({inputs:{x:et},backend:i,attrs:{shape:b}}),rt=slice({inputs:{x:nt},backend:i,attrs:{begin:$,size:j}});return _e.push(tt),_e.push(et),_e.push(nt),_e.forEach(it=>i.disposeIntermediateTensorInfo(it)),rt},batchToSpaceNDConfig={kernelName:BatchToSpaceND,backendName:"webgl",kernelFunc:batchToSpaceND};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincount(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,weights:c}=e,{size:d}=s,h=i.readSync(o.dataId),g=i.readSync(c.dataId),_=bincountImplCPU(h,g,c.dtype,c.shape,d);return i.makeTensorInfo([d],c.dtype,_)}const bincountConfig={kernelName:Bincount,backendName:"webgl",kernelFunc:bincount};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NOT_EQUAL="return float(a != b);",notEqual=binaryKernelFunc({opSnippet:NOT_EQUAL,dtype:"bool"}),notEqualConfig={kernelName:NotEqual,backendName:"webgl",kernelFunc:notEqual};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(a){const{inputs:e,backend:i}=a,{input:s}=e,o=i.texData.get(s.dataId);return identity$1({inputs:{x:o.complexTensorInfos.real},backend:i})}const realConfig={kernelName:Real,backendName:"webgl",kernelFunc:real};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TO_INT="return float(int(x));";function int(a,e){const i=new UnaryOpProgram(a.shape,TO_INT),s=e.runWebGLProgram(i,[a],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{dtype:c}=s;if(c==="complex64"){if(o.dtype==="complex64")return identity$1({inputs:{x:o},backend:i});const d=zeros$4(o.shape),h=cast({inputs:{x:o},backend:i,attrs:{dtype:"float32"}}),g=complex$2({inputs:{real:h,imag:d},backend:i});return d.dispose(),i.disposeIntermediateTensorInfo(h),g}if(o.dtype==="complex64"){const d=real({inputs:{input:o},backend:i}),h=cast({inputs:{x:d},backend:i,attrs:{dtype:c}});return i.disposeIntermediateTensorInfo(d),h}if(!hasEncodingLoss(o.dtype,c)){const d=identity$1({inputs:{x:o},backend:i});return{dataId:d.dataId,shape:d.shape,dtype:c}}if(c==="int32")return int(o,i);if(c==="bool"){const d=i.makeTensorInfo([],"bool",getTypedArrayFromDType("bool",1)),g=notEqual({inputs:{a:o,b:d},backend:i});return i.disposeIntermediateTensorInfo(d),g}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${c}`)}const castConfig={kernelName:Cast,backendName:"webgl",kernelFunc:cast};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CEIL="return ceil(x);",ceil$1=unaryKernelFunc({opSnippet:CEIL,packedOpSnippet:CEIL,cpuKernelImpl:ceilImplCPU}),ceilConfig={kernelName:Ceil,backendName:"webgl",kernelFunc:ceil$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ClipProgram{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}getCustomSetupFunc(e,i){return(s,o)=>{this.minLoc==null&&(this.minLoc=s.getUniformLocationNoThrow(o,"minVal"),this.maxLoc=s.getUniformLocationNoThrow(o,"maxVal")),s.gl.uniform1f(this.minLoc,e),s.gl.uniform1f(this.maxLoc,i)}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ClipPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}getCustomSetupFunc(e,i){return(s,o)=>{this.minLoc==null&&(this.minLoc=s.getUniformLocationNoThrow(o,"minVal"),this.maxLoc=s.getUniformLocationNoThrow(o,"maxVal")),s.gl.uniform1f(this.minLoc,e),s.gl.uniform1f(this.maxLoc,i)}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function clipByValue(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{clipValueMin:c,clipValueMax:d}=s;let h;env$1().getBool("WEBGL_PACK_CLIP")?h=new ClipPackedProgram(o.shape):h=new ClipProgram(o.shape);const g=h.getCustomSetupFunc(c,d);return i.runWebGLProgram(h,[o],o.dtype,g)}const clipByValueConfig={kernelName:ClipByValue,backendName:"webgl",kernelFunc:clipByValue};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ComplexAbsProgram{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeComplexComponentTensorInfo(a,e){return{dataId:e.dataId,dtype:e.dtype,shape:a.shape}}function complexAbs(a){const{inputs:e,backend:i}=a,{x:s}=e,o=i.texData.get(s.dataId),c=new ComplexAbsProgram(s.shape),d=[makeComplexComponentTensorInfo(s,o.complexTensorInfos.real),makeComplexComponentTensorInfo(s,o.complexTensorInfos.imag)];return i.runWebGLProgram(c,d,d[0].dtype)}const complexAbsConfig={kernelName:ComplexAbs,backendName:"webgl",kernelFunc:complexAbs};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ConcatProgram{constructor(e){this.outputShape=[],this.outputShape=computeOutShape$1(e,1),this.variableNames=e.map((d,h)=>`T${h}`);const i=new Array(e.length-1);i[0]=e[0][1];for(let d=1;d<i.length;d++)i[d]=i[d-1]+e[d][1];const s=[`if (yC < ${i[0]}) setOutput(getT0(yR, yC));`];for(let d=1;d<i.length;d++){const h=i[d-1];s.push(`else if (yC < ${i[d]}) setOutput(getT${d}(yR, yC-${h}));`)}const o=i.length,c=i[i.length-1];s.push(`else setOutput(getT${o}(yR, yC-${c}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ConcatPackedProgram{constructor(e,i){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=computeOutShape$1(e,i);const s=this.outputShape,o=s.length,c=getCoordsDataType(o),d=getChannels("coords",o),h=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((et,nt)=>`T${nt}`);const g=new Array(e.length-1);g[0]=e[0][i];for(let et=1;et<g.length;et++)g[et]=g[et-1]+e[et][i];const _=h[i],b=h.slice(-2),$=h.join();let j=`if (${_} < ${g[0]}) {
        return getChannel(
            getT0(${$}), vec2(${b.join()}));
        }`;for(let et=1;et<g.length;et++){const nt=g[et-1];j+=`
        if (${_} < ${g[et]}  && ${_} >= ${g[et-1]}) {
          return getChannel(
            getT${et}(${shiftedChannels(h,_,nt)}),
            vec2(${shiftedChannels(b,_,nt)}));
        }`}const _e=g.length,tt=g[g.length-1];j+=`
        return getChannel(
          getT${_e}(${shiftedChannels(h,_,tt)}),
          vec2(${shiftedChannels(b,_,tt)}));`,this.userCode=`
      float getValue(${h.map(et=>"int "+et)}) {
        ${j}
      }

      void main() {
        ${c} coords = getOutputCoords();
        vec4 result = vec4(getValue(${d}), 0., 0., 0.);

        ${d[o-1]} = ${d[o-1]} + 1;
        if (${d[o-1]} < ${s[o-1]}) {
          result.g = getValue(${d});
        }

        ${d[o-2]} = ${d[o-2]} + 1;
        if (${d[o-2]} < ${s[o-2]}) {
          result.a = getValue(${d});
        }

        ${d[o-1]} = ${d[o-1]} - 1;
        if (${d[o-2]} < ${s[o-2]} &&
            ${d[o-1]} < ${s[o-1]}) {
          result.b = getValue(${d});
        }
        setOutput(result);
      }
    `}}function shiftedChannels(a,e,i){const s=a.indexOf(e);return a.map((c,d)=>d===s?`${c} - ${i}`:c).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(a){const{inputs:e,backend:i}=a,{input:s}=e,o=i.texData.get(s.dataId);return identity$1({inputs:{x:o.complexTensorInfos.imag},backend:i})}const imagConfig={kernelName:Imag,backendName:"webgl",kernelFunc:imag};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(a,e,i){const s=a[0].dtype;if(s==="complex64"){const _=a.map(tt=>real({inputs:{input:tt},backend:i})),b=a.map(tt=>imag({inputs:{input:tt},backend:i})),$=concatImpl(_,e,i),j=concatImpl(b,e,i),_e=complex$2({inputs:{real:$,imag:j},backend:i});return _.forEach(tt=>i.disposeIntermediateTensorInfo(tt)),b.forEach(tt=>i.disposeIntermediateTensorInfo(tt)),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(j),_e}if(s==="string"){const{tensors2D:_,outShape:b}=computeTensors2D(a,e,i),$=_.map(nt=>({vals:i.readSync(nt.dataId),shape:nt.shape})),j=_[0].shape[0]===1,_e=concatImplCPU($,b,s,j),tt=computeOutShape$1(a.map(nt=>nt.shape),e),et=i.makeTensorInfo(tt,s,_e);return _.forEach(nt=>i.disposeIntermediateTensorInfo(nt)),et}if(a.length>env$1().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const _=Math.floor(a.length/2),b=concatImpl(a.slice(0,_),e,i),$=concatImpl(a.slice(_),e,i),j=concatImpl([b,$],e,i);return i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo($),j}if(env$1().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1){const _=new ConcatPackedProgram(a.map(b=>b.shape),e);return i.runWebGLProgram(_,a,s)}const{tensors2D:o,outShape:c}=computeTensors2D(a,e,i),d=new ConcatProgram(o.map(_=>_.shape)),h=i.runWebGLProgram(d,o,s);o.forEach(_=>i.disposeIntermediateTensorInfo(_));const g=reshape$1({inputs:{x:h},attrs:{shape:c},backend:i});return i.disposeIntermediateTensorInfo(h),g}function computeTensors2D(a,e,i){const s=computeOutShape$1(a.map(c=>c.shape),e);return{tensors2D:a.map(c=>reshape$1({inputs:{x:c},attrs:{shape:[-1,sizeFromShape(c.shape.slice(e))]},backend:i})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat$1(a){const{inputs:e,backend:i,attrs:s}=a,{axis:o}=s,c=parseAxisParam(o,e[0].shape)[0],d=computeOutShape$1(e.map(_=>_.shape),c);if(sizeFromShape(d)===0)return i.makeTensorInfo(d,e[0].dtype,[]);const h=e.filter(_=>sizeFromShape(_.shape)>0);if(h.length===1)return identity$1({inputs:{x:h[0]},backend:i});const g=h.map(_=>_.shape);return assertParamsConsistent(g,c),concatImpl(h,c,i)}const concatConfig={kernelName:Concat,backendName:"webgl",kernelFunc:concat$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Conv2DProgram{constructor(e,i=!1,s=null,o=!1,c=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const d=e.padInfo.top,h=e.padInfo.left,g=e.strideHeight,_=e.strideWidth,b=e.dilationHeight,$=e.dilationWidth,j=e.filterHeight,_e=e.filterWidth,tt=Math.floor(e.inChannels/4)*4,et=e.inChannels%4,nt=e.dataFormat==="channelsLast",rt=nt?1:2,it=nt?2:3,at=nt?3:1;let st="",ot="";s&&(o?st=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:c?st=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:st=`
          float activation(float x) {
            ${s}
          }
        `,ot="result = activation(result);");const ct=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${st}

      const ivec2 strides = ivec2(${g}, ${_});
      const ivec2 pads = ivec2(${d}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${at}];

        ivec2 xRCCorner =
            ivec2(coords[${rt}], coords[${it}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${j}; wR++) {
          int xR = xRCorner + wR * ${b};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${_e}; wC++) {
            int xC = xCCorner + wC * ${$};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${tt}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${nt}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${et===1}) {

              if (${nt}) {
                dotProd +=
                    getX(batch, xR, xC, ${tt}) *
                    getW(wR, wC, ${tt}, d2);
              } else {
                dotProd +=
                    getX(batch, ${tt}, xR, xC) *
                    getW(wR, wC, ${tt}, d2);
              }

            } else if (${et===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${tt}, d2),
                getW(wR, wC, ${tt} + 1, d2)
              );

              if (${nt}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${tt}),
                  getX(batch, xR, xC, ${tt} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${tt}, xR, xC),
                  getX(batch, ${tt} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${et===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${tt}, d2),
                getW(wR, wC, ${tt} + 1, d2),
                getW(wR, wC, ${tt} + 2, d2)
              );

              if (${nt}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${tt}),
                  getX(batch, xR, xC, ${tt} + 1),
                  getX(batch, xR, xC, ${tt} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${tt}, xR, xC),
                  getX(batch, ${tt} + 1, xR, xC),
                  getX(batch, ${tt} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${ct}
        ${ot}
        setOutput(result);
      }
    `}}class Conv3DProgram{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left,c=e.strideDepth,d=e.strideHeight,h=e.strideWidth,g=e.dilationDepth,_=e.dilationHeight,b=e.dilationWidth,$=e.filterDepth,j=e.filterHeight,_e=e.filterWidth,tt=Math.floor(e.inChannels/4)*4,et=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${c}, ${d}, ${h});
      const ivec3 pads = ivec3(${i}, ${s}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${$}; wF++) {
          int xF = xFCorner + wF * ${g};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${j}; wR++) {
            int xR = xRCorner + wR * ${_};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_e}; wC++) {
              int xC = xCCorner + wC * ${b};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${tt}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${et===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${tt}) *
                  getW(wF, wR, wC, ${tt}, d2);
              } else if (${et===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${tt}),
                  getX(batch, xF, xR, xC, ${tt} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${tt}, d2),
                  getW(wF, wR, wC, ${tt} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${et===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${tt}),
                  getX(batch, xF, xR, xC, ${tt} + 1),
                  getX(batch, xF, xR, xC, ${tt} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${tt}, d2),
                  getW(wF, wR, wC, ${tt} + 1, d2),
                  getW(wF, wR, wC, ${tt} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Im2ColPackedProgram{constructor(e,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:o,inChannels:c,strideWidth:d,strideHeight:h,padInfo:g,outWidth:_,dilationWidth:b,dilationHeight:$,dataFormat:j}=s,{left:_e,top:tt}=g,et=c*o,nt=getGlslDifferences(),rt=j==="channelsLast",it=rt?0:1,at=rt?1:2;let st="";for(let ot=0;ot<=1;ot++)for(let ct=0;ct<=1;ct++)st+=`
          blockIndex = rc.y + ${ct};
          pos = rc.x + ${ot};

          if(blockIndex < ${e[1]} && pos < ${e[0]}) {
            offsetY = int(blockIndex / (${_})) * ${h} - ${tt};
            d0 = offsetY + ${$} * (pos / ${et});

            if(d0 < ${i[it]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${_}.) * ${d}. - ${_e}.);
              d1 = offsetX + ${b} * (int(mod(float(pos), ${et}.) / ${c}.));

              if(d1 < ${i[at]} && d1 >= 0) {

                ch = int(mod(float(pos), ${c}.));

                if (${rt}) {
                  innerDims = vec2(d1, ch);
                  result[${ot*2+ct}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${ot*2+ct}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${st}

        ${nt.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2dByMatMul({x:a,filter:e,convInfo:i,backend:s,bias:o=null,preluActivationWeights:c=null,leakyreluAlpha:d=0,activation:h=null}){const g=a.shape,_=s.texData.get(a.dataId),b=i.inChannels,$=g[0]*g[1]*g[2],j=i.outChannels,_e=i.dataFormat==="channelsLast",tt=!1,et=!1;let nt;const rt=[],it=($===1||j===1)&&b>MATMUL_SHARED_DIM_THRESHOLD,at=g[2]%2!==0&&!!_.isPacked;if(it||!env$1().getBool("WEBGL_LAZILY_UNPACK")||!env$1().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!at){const st=_e?g[0]*g[1]*g[2]:g[0]*g[2]*g[3],ot=reshape$1({inputs:{x:a},backend:s,attrs:{shape:[1,st,i.inChannels]}}),ct=reshape$1({inputs:{x:e},backend:s,attrs:{shape:[1,i.inChannels,i.outChannels]}}),lt=batchMatMulImpl({a:ot,b:ct,transposeA:tt,transposeB:et,backend:s,bias:o,activation:h,preluActivationWeights:c,leakyreluAlpha:d});nt=reshape$1({inputs:{x:lt},backend:s,attrs:{shape:i.outShape}}),rt.push(ot),rt.push(ct),rt.push(lt)}else{const st=_e?g[0]*g[1]*(g[2]+1):g[0]*g[2]*(g[3]+1),ot={dataId:a.dataId,shape:[1,st,i.inChannels],dtype:a.dtype},ct=_.shape;_.shape=_.shape.slice(),_.shape[_.shape.length-2]++,assert$1(isReshapeFree(_.shape,ot.shape),()=>`packed reshape ${_.shape} to ${ot.shape} isn't free`);const lt=reshape$1({inputs:{x:e},backend:s,attrs:{shape:[1,i.inChannels,i.outChannels]}});rt.push(lt);const dt=batchMatMulImpl({a:ot,b:lt,backend:s,transposeA:tt,transposeB:et,bias:o,activation:h,preluActivationWeights:c,leakyreluAlpha:d}),xt=s.texData.get(dt.dataId);assert$1(xt.isPacked,()=>"batchMatMul result is expected to be packed"),_.shape=ct,xt.shape=i.outShape,nt=identity$1({inputs:{x:dt},backend:s}),nt.shape=i.outShape,rt.push(dt)}for(const st of rt)s.disposeIntermediateTensorInfo(st);return nt}function conv2dWithIm2Row({x:a,filter:e,convInfo:i,backend:s,bias:o=null,preluActivationWeights:c=null,leakyreluAlpha:d=0,activation:h=null}){const{filterWidth:g,filterHeight:_,inChannels:b,outWidth:$,outHeight:j,dataFormat:_e}=i,tt=_e==="channelsLast",et=g*_*b,nt=j*$,rt=[et,nt],it=!0,at=!1,st=[],ot=reshape$1({inputs:{x:a},backend:s,attrs:{shape:a.shape.slice(1)}}),ct=reshape$1({inputs:{x:e},backend:s,attrs:{shape:[1,et,sizeFromShape(e.shape)/et]}});st.push(ot),st.push(ct);const lt=new Im2ColPackedProgram(rt,ot.shape,i),dt=s.runWebGLProgram(lt,[ot],"float32"),xt=reshape$1({inputs:{x:dt},backend:s,attrs:{shape:[1,rt[0],rt[1]]}});st.push(dt),st.push(xt);const ut=o!=null,ft=c!=null,mt=h==="leakyrelu",yt=h?mapActivationToShaderProgram(h,!0):null,St=new MatMulPackedProgram(xt.shape,ct.shape,[1,nt,i.outChannels],it,at,ut,yt,ft,mt),Et=[xt,ct];if(o&&Et.push(o),ft&&Et.push(c),mt){const $t=s.makeTensorInfo([],"float32",createScalarValue(d,"float32"));Et.push($t),st.push($t)}const vt=s.runWebGLProgram(St,Et,"float32"),Nt=tt?[1,j,$,i.outChannels]:[1,i.outChannels,j,$],wt=reshape$1({inputs:{x:vt},backend:s,attrs:{shape:Nt}});st.push(vt);for(const $t of st)s.disposeIntermediateTensorInfo($t);return wt}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2d(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dataFormat:g,dilations:_,dimRoundingMode:b}=s,$=convertConv2DDataFormat(g),j=computeConv2DInfo(o.shape,c.shape,d,_,h,b,!1,$);let _e;if(j.filterHeight===1&&j.filterWidth===1&&j.dilationHeight===1&&j.dilationWidth===1&&j.strideHeight===1&&j.strideWidth===1&&(j.padInfo.type==="SAME"||j.padInfo.type==="VALID"))_e=conv2dByMatMul({x:o,filter:c,convInfo:j,backend:i});else if(env$1().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)_e=conv2dWithIm2Row({x:o,filter:c,convInfo:j,backend:i});else{const et=new Conv2DProgram(j);_e=i.runWebGLProgram(et,[o,c],"float32")}const tt=reshape$1({inputs:{x:_e},backend:i,attrs:{shape:j.outShape}});return i.disposeIntermediateTensorInfo(_e),tt}const conv2DConfig={kernelName:Conv2D$1,backendName:"webgl",kernelFunc:conv2d};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Conv2DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const i=e.strideHeight,s=e.strideWidth,o=e.padInfo.top,c=e.padInfo.left,d=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${i} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${d}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Conv2DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const i=e.filterHeight,s=e.filterWidth,o=e.strideHeight,c=e.strideWidth,d=e.dataFormat==="channelsLast",h=i-1-e.padInfo.top,g=s-1-e.padInfo.left,_=d?1:2,b=d?2:3,$=d?3:1;this.userCode=`
      const ivec2 pads = ivec2(${h}, ${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${$}];

        ivec2 dyCorner = ivec2(coords[${_}], coords[${b}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${i} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${c}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${d}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Conv3DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const i=e.strideDepth,s=e.strideHeight,o=e.strideWidth,c=e.padInfo.front,d=e.padInfo.top,h=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${i} - ${c};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${d};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${h};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Conv3DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const i=e.filterDepth,s=e.filterHeight,o=e.filterWidth,c=e.strideDepth,d=e.strideHeight,h=e.strideWidth,g=i-1-e.padInfo.front,_=s-1-e.padInfo.top,b=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${g}, ${_}, ${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${i}; wF++) {
          float dyF = float(dyFCorner + wF) / ${c}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${i} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${d}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${h}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropFilter(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,dy:c}=e,{strides:d,pad:h,dataFormat:g,dimRoundingMode:_,filterShape:b}=s,$=convertConv2DDataFormat(g),j=computeConv2DInfo(o.shape,b,d,1,h,_,!1,$),_e=new Conv2DDerFilterProgram(j);return i.runWebGLProgram(_e,[o,c],"float32")}const conv2DBackpropFilterConfig={kernelName:Conv2DBackpropFilter,backendName:"webgl",kernelFunc:conv2DBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv2DBackpropInput(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,filter:c}=e,{inputShape:d,strides:h,pad:g,dataFormat:_,dimRoundingMode:b}=s,$=convertConv2DDataFormat(_),j=computeConv2DInfo(d,c.shape,h,1,g,b,!1,$),_e=new Conv2DDerInputProgram(j);return i.runWebGLProgram(_e,[o,c],"float32")}const conv2DBackpropInputConfig={kernelName:Conv2DBackpropInput,backendName:"webgl",kernelFunc:conv2DBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dilations:g}=s,_=computeConv3DInfo(o.shape,c.shape,d,g,h),b=new Conv3DProgram(_);return i.runWebGLProgram(b,[o,c],"float32")}const conv3DConfig={kernelName:Conv3D$1,backendName:"webgl",kernelFunc:conv3D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropFilterV2(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,dy:c}=e,{strides:d,pad:h,filterShape:g}=s,_=computeConv3DInfo(o.shape,g,d,1,h),b=new Conv3DDerFilterProgram(_);return i.runWebGLProgram(b,[o,c],"float32")}const conv3DBackpropFilterV2Config={kernelName:Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:conv3DBackpropFilterV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function conv3DBackpropInput(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,filter:c}=e,{pad:d,strides:h,inputShape:g}=s,_=computeConv3DInfo(g,c.shape,h,1,d),b=new Conv3DDerInputProgram(_);return i.runWebGLProgram(b,[o,c],"float32")}const conv3DBackpropInputConfig={kernelName:Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:conv3DBackpropInput};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const COS=CHECK_NAN_SNIPPET_UNARY+`
  return cos(x);
`,cos$2=unaryKernelFunc({opSnippet:COS}),cosConfig={kernelName:Cos,backendName:"webgl",kernelFunc:cos$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const COSH=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,cosh$1=unaryKernelFunc({opSnippet:COSH}),coshConfig={kernelName:Cosh,backendName:"webgl",kernelFunc:cosh$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CropAndResizeProgram{constructor(e,i,s,o,c){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[d,h,g,_]=e,[b]=i,[$,j]=s;this.outputShape=[b,$,j,_];const _e=o==="bilinear"?1:0,[tt,et]=[`${h-1}.0`,`${g-1}.0`],[nt,rt,it]=$>1?[`${(h-1)/($-1)}`,"(y2-y1) * height_ratio",`y1*${tt} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${tt}`],[at,st,ot]=j>1?[`${(g-1)/(j-1)}`,"(x2-x1) * width_ratio",`x1*${et} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${et}`];this.userCode=`
      const float height_ratio = float(${nt});
      const float width_ratio = float(${at});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${d}) {
          return;
        }

        float height_scale = ${rt};
        float width_scale = ${st};

        float in_y = ${it};
        if( in_y < 0.0 || in_y > ${tt} ) {
          setOutput(float(${c}));
          return;
        }
        float in_x = ${ot};
        if( in_x < 0.0 || in_x > ${et} ) {
          setOutput(float(${c}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${_e} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cropAndResize=a=>{const{inputs:e,backend:i,attrs:s}=a,{image:o,boxes:c,boxInd:d}=e,{cropSize:h,method:g,extrapolationValue:_}=s,b=new CropAndResizeProgram(o.shape,c.shape,h,g,_);return i.runWebGLProgram(b,[o,c,d],"float32")},cropAndResizeConfig={kernelName:CropAndResize,backendName:"webgl",kernelFunc:cropAndResize};class CumSumProgram{constructor(e,i,s){this.variableNames=["x"],this.outputShape=e;const o=e.length,c=i?"0.0":`getX(${getCoords(o,"coords")})`,d=e[e.length-1];let h="",g="";i?(h=s?`end != ${d-1}`:"end != 0",g=s?"end + 1":"end - 1"):(h=s?`end + pow2 < ${d}`:"end >= pow2",g=s?"end + pow2":"end - pow2"),this.userCode=`
      uniform float index;
      void main() {
        ${getCoordsDataType(o)} coords = getOutputCoords();
        int end = ${getFinalCoord(o,"coords")};
        float val = ${c};
        int pow2 = int(pow(2.0, index));
        if (${h}) {
          int idx = ${g};
          ${getFinalCoord(o,"coords")} = idx;
          val += getX(${getCoords(o,"coords")});
        }
        setOutput(val);
      }
    `}getCustomSetupFunc(e){return(i,s)=>{this.index==null&&(this.index=i.getUniformLocation(s,"index")),i.gl.uniform1f(this.index,e)}}}function getCoords(a,e){if(a===1)return`${e}`;if(a===2)return`${e}.x, ${e}.y`;if(a===3)return`${e}.x, ${e}.y, ${e}.z`;if(a===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${a} is not yet supported`)}function getFinalCoord(a,e){if(a===1)return`${e}`;if(a===2)return`${e}.y`;if(a===3)return`${e}.z`;if(a===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${a} is not yet supported`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumsum(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,exclusive:d,reverse:h}=s,g=o.shape.length,_=getAxesPermutation([c],g);let b=o;_!=null&&(b=transpose$1({inputs:{x:o},backend:i,attrs:{perm:_}}));const $=getInnerMostAxes(1,g)[0];if($!==g-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${c}`);const j=b.shape[$];let _e=identity$1({inputs:{x:b},backend:i});for(let tt=0;tt<=Math.ceil(Math.log2(j))-1;tt++){const et=new CumSumProgram(b.shape,!1,h),nt=et.getCustomSetupFunc(tt),rt=_e;_e=i.runWebGLProgram(et,[_e],_e.dtype,nt),i.disposeIntermediateTensorInfo(rt)}if(d){const tt=new CumSumProgram(b.shape,d,h),et=_e;_e=i.runWebGLProgram(tt,[_e],_e.dtype),i.disposeIntermediateTensorInfo(et)}if(_!=null){const tt=getUndoAxesPermutation(_),et=transpose$1({inputs:{x:_e},backend:i,attrs:{perm:tt}});return i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(b),et}return _e}const cumsumConfig={kernelName:Cumsum,backendName:"webgl",kernelFunc:cumsum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function denseBincount(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,weights:c}=e,{size:d,binaryOutput:h}=s;if(o.shape.length===1){const g=i.readSync(o.dataId),_=i.readSync(c.dataId),b=bincountImplCPU(g,_,c.dtype,c.shape,d);return i.makeTensorInfo([d],c.dtype,b)}else if(o.shape.length===2){const g=i.bufferSync(o),_=i.bufferSync(c),b=bincountReduceImplCPU(g,_,d,h);return i.makeTensorInfo(b.shape,c.dtype,b.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}const denseBincountConfig={kernelName:DenseBincount,backendName:"webgl",kernelFunc:denseBincount};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DepthToSpaceProgram{constructor(e,i,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=i,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${i};
      int offset_h = imod(h, ${i});
      int in_w = w / ${i};
      int offset_w = imod(w, ${i});
      int offset_d = (offset_h * ${i} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthToSpace(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{blockSize:c,dataFormat:d}=s;assert$1(c>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${c}`);const h=o.shape[0],g=d==="NHWC"?o.shape[1]:o.shape[2],_=d==="NHWC"?o.shape[2]:o.shape[3],b=d==="NHWC"?o.shape[3]:o.shape[1],$=g*c,j=_*c,_e=b/(c*c),tt=d==="NHWC"?[h,$,j,_e]:[h,_e,$,j],et=new DepthToSpaceProgram(tt,c,d);return i.runWebGLProgram(et,[o],o.dtype)}const depthToSpaceConfig={kernelName:DepthToSpace,backendName:"webgl",kernelFunc:depthToSpace};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DepthwiseConv2DProgram{constructor(e,i=!1,s=null,o=!1,c=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const d=e.inHeight,h=e.inWidth,g=e.padInfo.top,_=e.padInfo.left,b=e.strideHeight,$=e.strideWidth,j=e.dilationHeight,_e=e.dilationWidth,tt=e.filterHeight,et=e.filterWidth,nt=e.outChannels/e.inChannels;let rt="",it="";s&&(o?rt=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:c?rt=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:rt=`
          float activation(float x) {
            ${s}
          }
        `,it="result = activation(result);");const at=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${rt}

      const ivec2 strides = ivec2(${b}, ${$});
      const ivec2 pads = ivec2(${g}, ${_});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${nt};
        int q = d2 - d1 * ${nt};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${tt}; wR++) {
          int xR = xRCorner + wR * ${j};

          if (xR < 0 || xR >= ${d}) {
            continue;
          }

          for (int wC = 0; wC < ${et}; wC++) {
            int xC = xCCorner + wC * ${_e};

            if (xC < 0 || xC >= ${h}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${at}
        ${it}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DepthwiseConvPacked2DProgram{constructor(e,i=!1,s=null,o=!1,c=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const d=e.inHeight,h=e.inWidth,g=e.padInfo.top,_=e.padInfo.left,b=e.strideHeight,$=e.strideWidth,j=e.dilationHeight,_e=e.dilationWidth,tt=e.filterHeight,et=e.filterWidth,nt=et;let rt="int xR; int xC; int xCOffset;";for(let ot=0;ot<tt;ot++)for(let ct=0;ct<et;ct++)rt+=`
          vec4 xTexelR${ot}C${ct*2} = vec4(0.);
          vec4 wR${ot}C${ct} = vec4(0.);
          vec4 xR${ot}C${ct} = vec4(0.);`;for(let ot=0;ot<tt;ot++)for(let ct=0;ct<nt;ct++){const lt=ct*2;if(rt+=`
          xR = xRCorner + ${ot*j};
          xC = xCCorner + ${lt*_e};
        `,$===1){if(lt<et&&(_%2===1?rt+=`
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${d} && xCOffset >= 0 && xCOffset < ${h}) {
                  xTexelR${ot}C${lt} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${h}) {
                    xTexelR${ot}C${lt}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${ot}C${lt} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${d} && xCOffset >= 0 && xCOffset < ${h}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${h}) {
                    previous.zw = vec2(0.);
                  }

                  xR${ot}C${lt} = vec4(previous.zw, xTexelR${ot}C${lt}.xy);
                } else {
                  xR${ot}C${lt} = vec4(0, 0, xTexelR${ot}C${lt}.xy);
                }
              `:rt+=`
                if(xR >= 0 && xR < ${d} && xC >= 0 && xC < ${h}) {
                  xTexelR${ot}C${lt} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${ot}C${lt} = vec4(0.);
                }

                xR${ot}C${lt} = xTexelR${ot}C${lt};
              `,lt+1<et)){const dt=_%2===0?nearestLargerEven(_e):_e;_e%2===0&&_%2===1||_e%2!==0&&_%2!==1?(rt+=`
                  xCOffset = xC + ${_%2} + ${dt};

                  if(xR >= 0 && xR < ${d} &&
                    xCOffset >= 0 && xCOffset < ${h}) {
                    xTexelR${ot}C${lt+2} = getX(batch, xR, xCOffset, d1);
                  }
                `,_e>1&&(rt+=`
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${d} &&
                      xCOffset >= 0 && xCOffset < ${h}) {
                      xTexelR${ot}C${lt} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${ot}C${lt} = vec4(0.);
                    }
                  `),rt+=`
                  xR${ot}C${lt+1} = vec4(
                    xTexelR${ot}C${lt}.zw, xTexelR${ot}C${lt+2}.xy);
                `):rt+=`
                  xCOffset = xC + ${dt};

                  if(xR >= 0 && xR < ${d} &&
                    xCOffset >= 0 && xCOffset < ${h}) {
                    xTexelR${ot}C${lt+2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${ot}C${lt+1} = xTexelR${ot}C${lt+2};
                `}}else lt<et&&(rt+=`
              if(xR >= 0 && xR < ${d}) {
            `,_%2===1?(rt+=`
                xCOffset = xC + 1 - ${$};
                if(xCOffset >= 0 && xCOffset < ${h}) {
                  xTexelR${ot}C${lt} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${ot}C${lt} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${h}) {
                  xTexelR${ot}C${lt+2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${ot}C${lt+2} = vec4(0.);
                }

                xR${ot}C${lt} = vec4(
                  xTexelR${ot}C${lt}.zw, xTexelR${ot}C${lt+2}.zw);
              `,lt+1<et&&(rt+=`
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${$};
                  if(xCOffset >= 0 && xCOffset < ${h}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${ot}C${lt+1} = vec4(xTexelR${ot}C${lt+2}.xy, final.xy);
                `)):(rt+=`
                if(xC >= 0 && xC < ${h}) {
                  xTexelR${ot}C${lt} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${ot}C${lt} = vec4(0.);
                }

                xCOffset = xC + ${$};
                if(xCOffset >= 0 && xCOffset < ${h}) {
                  xTexelR${ot}C${lt+2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${ot}C${lt+2} = vec4(0.);
                }

                xR${ot}C${lt} = vec4(
                  xTexelR${ot}C${lt}.xy, xTexelR${ot}C${lt+2}.xy);
              `,lt+1<et&&(rt+=`
                  xR${ot}C${lt+1} = vec4(
                    xTexelR${ot}C${lt}.zw, xTexelR${ot}C${lt+2}.zw);
                `)),rt+="}");lt<et&&(rt+=`
            vec4 wTexelR${ot}C${lt} = getW(${ot}, ${lt}, d1, q);
            wR${ot}C${lt} = vec4(wTexelR${ot}C${lt}.xz, wTexelR${ot}C${lt}.xz);
          `,lt+1<et&&(rt+=`
              vec4 wTexelR${ot}C${lt+1} = getW(${ot}, ${lt+1}, d1, q);
              wR${ot}C${lt+1} =
                vec4(wTexelR${ot}C${lt+1}.xz, wTexelR${ot}C${lt+1}.xz);`))}for(let ot=0;ot<tt;ot++)for(let ct=0;ct<et;ct++)rt+=`dotProd += xR${ot}C${ct} * wR${ot}C${ct};`;let it="",at="";s&&(o?it=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:c?it=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:it=`vec4 activation(vec4 x) {
          ${s}
        }`,at="result = activation(result);");const st=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${it}

      const ivec2 strides = ivec2(${b}, ${$});
      const ivec2 pads = ivec2(${g}, ${_});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${rt}

        vec4 result = dotProd;
        ${st}
        ${at}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNative(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dilations:g,dimRoundingMode:_}=s;let b=g;b==null&&(b=[1,1]),assert$1(eitherStridesOrDilationsAreOne(d,b),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${b}'`);const $=computeConv2DInfo(o.shape,c.shape,d,b,h,_,!0);let j;return env$1().getBool("WEBGL_PACK_DEPTHWISECONV")&&$.strideWidth<=2&&$.outChannels/$.inChannels===1?j=new DepthwiseConvPacked2DProgram($):j=new DepthwiseConv2DProgram($),i.runWebGLProgram(j,[o,c],"float32")}const depthwiseConv2dNativeConfig={kernelName:DepthwiseConv2dNative,backendName:"webgl",kernelFunc:depthwiseConv2dNative};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DepthwiseConv2DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const i=e.strideHeight,s=e.strideWidth,o=e.padInfo.top,c=e.padInfo.left,d=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${d} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${i} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class DepthwiseConv2DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const i=e.filterHeight,s=e.filterWidth,o=e.strideHeight,c=e.strideWidth,d=i-1-e.padInfo.top,h=s-1-e.padInfo.left,g=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${d}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${i}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${i} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${c}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${g}; dm++) {
              int d2 = d1 * ${g} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropFilter(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,dy:c}=e,{strides:d,dilations:h,pad:g,dimRoundingMode:_,filterShape:b}=s,$=computeConv2DInfo(o.shape,b,d,h,g,_,!0),j=new DepthwiseConv2DDerFilterProgram($);return i.runWebGLProgram(j,[o,c],"float32")}const depthwiseConv2dNativeBackpropFilterConfig={kernelName:DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:depthwiseConv2dNativeBackpropFilter};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function depthwiseConv2dNativeBackpropInput(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,filter:c}=e,{strides:d,dilations:h,pad:g,dimRoundingMode:_,inputShape:b}=s,$=computeConv2DInfo(b,c.shape,d,h,g,_,!0),j=new DepthwiseConv2DDerInputProgram($);return i.runWebGLProgram(j,[o,c],"float32")}const depthwiseConv2dNativeBackpropInputConfig={kernelName:DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:depthwiseConv2dNativeBackpropInput};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DiagProgram{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function diag$1(a){const{inputs:e,backend:i}=a,{x:s}=e,o=[...s.shape,...s.shape],c=sizeFromShape(s.shape),d=reshape$1({inputs:{x:s},backend:i,attrs:{shape:[c]}}),h=new DiagProgram(c),g=i.runWebGLProgram(h,[d],d.dtype),_=reshape$1({inputs:{x:g},backend:i,attrs:{shape:o}});return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(g),_}const diagConfig={kernelName:Diag,backendName:"webgl",kernelFunc:diag$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dilation2DProgram{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:i,inWidth:s,padInfo:o,strideHeight:c,strideWidth:d,filterHeight:h,filterWidth:g,dilationHeight:_,dilationWidth:b}=e,{top:$,left:j}=o;this.userCode=`
      const ivec2 strides = ivec2(${c}, ${d});
      const ivec2 pads = ivec2(${$}, ${j});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${h}; h++) {
          int hIn = hBeg + h * ${_};

          if (hIn >= 0 && hIn < ${i}) {
            for (int w = 0; w < ${g}; w++) {
              int wIn = wBeg + w * ${b};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dilation2D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c}=e,{strides:d,pad:h,dilations:g}=s,_=computeDilation2DInfo(o.shape,c.shape,d,h,"NHWC",g);let b;const $=new Dilation2DProgram(_);b=i.runWebGLProgram($,[o,c],"float32");const j=reshape$1({inputs:{x:b},backend:i,attrs:{shape:_.outShape}});return i.disposeIntermediateTensorInfo(b),j}const dilation2DConfig={kernelName:Dilation2D,backendName:"webgl",kernelFunc:dilation2D};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ELU="return (x >= 0.0) ? x : (exp(x) - 1.0);",ELU_PACKED=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,elu=unaryKernelFunc({opSnippet:ELU,packedOpSnippet:ELU_PACKED}),eluConfig={kernelName:Elu$1,backendName:"webgl",kernelFunc:elu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ELU_DER="return (b >= 1.0) ? a : a * (b + 1.0);",ELU_DER_PACKED=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,eluGrad=a=>{const{inputs:e,backend:i}=a,{dy:s,y:o}=e,c=env$1().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(ELU_DER_PACKED,s.shape,o.shape):new BinaryOpProgram(ELU_DER,s.shape,o.shape);return i.runWebGLProgram(c,[s,o],s.dtype)},eluGradConfig={kernelName:EluGrad,backendName:"webgl",kernelFunc:eluGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PACKED_EQUAL=`
  return vec4(equal(a, b));
`,EQUAL="return float(a == b);",equal$1=binaryKernelFunc({opSnippet:EQUAL,packedOpSnippet:PACKED_EQUAL,dtype:"bool"}),equalConfig={kernelName:Equal,backendName:"webgl",kernelFunc:equal$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ERF=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${ERF_P};
  float a1 = ${ERF_A1};
  float a2 = ${ERF_A2};
  float a3 = ${ERF_A3};
  float a4 = ${ERF_A4};
  float a5 = ${ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,erf=unaryKernelFunc({opSnippet:ERF}),erfConfig={kernelName:Erf,backendName:"webgl",kernelFunc:erf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EXP="return exp(x);",exp$1=unaryKernelFunc({opSnippet:EXP,packedOpSnippet:EXP,cpuKernelImpl:expImplCPU}),expConfig={kernelName:Exp,backendName:"webgl",kernelFunc:exp$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(a){const{inputs:e,attrs:i,backend:s}=a,{dim:o}=i,{input:c}=e,d=c.shape.length,h=c.shape.slice();let g=o;return o<0&&(assert$1(-(d+1)<=o,()=>`Axis must be in the interval [${-(d+1)}, ${d}]`),g=d+o+1),h.splice(g,0,1),reshape$1({inputs:{x:c},backend:s,attrs:{shape:h}})}const expandDimsConfig={kernelName:ExpandDims,backendName:"webgl",kernelFunc:expandDims};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EXPM1="return exp(x) - 1.0;",expm1=unaryKernelFunc({opSnippet:EXPM1,packedOpSnippet:EXPM1,cpuKernelImpl:expm1ImplCPU}),expm1Config={kernelName:Expm1,backendName:"webgl",kernelFunc:expm1};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FFTProgram{constructor(e,i,s){this.variableNames=["real","imag"];const o=i[1];this.outputShape=i;const c=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,d=s?`${o}.0`:"1.0";let h;if(e==="real")h="return real * expR - imag * expI;";else if(e==="imag")h="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${c};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${h}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${d};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftImpl(a,e,i){const s=i.texData.get(a.dataId),o=sizeFromShape(a.shape),c=a.shape[a.shape.length-1],d=o/c,h=reshape$1({inputs:{x:a},backend:i,attrs:{shape:[d,c]}}),g=h.shape,_=new FFTProgram("real",g,e),b=new FFTProgram("imag",g,e),$=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:g},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:g}],j=i.runWebGLProgram(_,$,"float32"),_e=i.runWebGLProgram(b,$,"float32"),tt=complex$2({inputs:{real:j,imag:_e},backend:i});i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(_e);const et=reshape$1({inputs:{x:tt},backend:i,attrs:{shape:a.shape}});return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(tt),et}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fft(a){const{inputs:e,backend:i}=a,{input:s}=e;return fftImpl(s,!1,i)}const fftConfig={kernelName:FFT,backendName:"webgl",kernelFunc:fft};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FillProgram{constructor(e,i){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}getCustomSetupFunc(e){return(i,s)=>{this.valueLoc==null&&(this.valueLoc=i.getUniformLocationNoThrow(s,"value")),i.gl.uniform1f(this.valueLoc,e)}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(a){const{backend:e,attrs:i}=a,{shape:s,value:o}=i;let{dtype:c}=i;if(c=c||inferDtype(o),c==="string"){const d=getArrayFromDType(c,sizeFromShape(s));return d.fill(o),e.makeTensorInfo(s,c,d)}else{const d=new FillProgram(s,o),h=d.getCustomSetupFunc(o);return e.runWebGLProgram(d,[],c,h)}}const fillConfig={kernelName:Fill,backendName:"webgl",kernelFunc:fill};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FlipLeftRightProgram{constructor(e){this.variableNames=["Image"],this.outputShape=[];const i=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${i} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${i}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const flipLeftRightConfig={kernelName:FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:a,backend:e})=>{const{image:i}=a,s=e,o=new FlipLeftRightProgram(i.shape);return s.runWebGLProgram(o,[i],i.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FLOOR="return floor(x);",floor$1=unaryKernelFunc({opSnippet:FLOOR,packedOpSnippet:FLOOR,cpuKernelImpl:floorImplCPU}),floorConfig={kernelName:Floor,backendName:"webgl",kernelFunc:floor$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const INT_DIV=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,INT_DIV_PACKED=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,floorDiv=binaryKernelFunc({opSnippet:INT_DIV,packedOpSnippet:INT_DIV_PACKED,dtype:"int32"}),floorDivConfig={kernelName:FloorDiv,backendName:"webgl",kernelFunc:floorDiv};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FromPixelsProgram{constructor(e){this.variableNames=["A"];const i=getGlslDifferences(),[s,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${s}.0);

        vec4 values = ${i.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FromPixelsPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const i=getGlslDifferences(),[s,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${s}.0);
            vec4 values = ${i.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fromPixelsConfig={kernelName:FromPixels,backendName:"webgl",kernelFunc:fromPixels};let fromPixels2DContext;function fromPixels(a){const{inputs:e,backend:i,attrs:s}=a;let{pixels:o}=e;const{numChannels:c}=s,d=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,h=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,g=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,[_,b]=d?[o.videoWidth,o.videoHeight]:[o.width,o.height],$=[b,_],j=[b,_,c];(h||d||g)&&(fromPixels2DContext==null&&(fromPixels2DContext=document.createElement("canvas").getContext("2d")),fromPixels2DContext.canvas.width=_,fromPixels2DContext.canvas.height=b,fromPixels2DContext.drawImage(o,0,0,_,b),o=fromPixels2DContext.canvas);const _e=i.makeTensorInfo($,"int32");i.texData.get(_e.dataId).usage=TextureUsage.PIXELS,i.gpgpu.uploadPixelDataToTexture(i.getTexture(_e.dataId),o);const tt=env$1().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(j):new FromPixelsProgram(j),et=i.runWebGLProgram(tt,[_e],"int32");return i.disposeData(_e.dataId),et}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedConv2d(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c,bias:d,preluActivationWeights:h}=e,{strides:g,pad:_,dataFormat:b,dilations:$,dimRoundingMode:j,activation:_e,leakyreluAlpha:tt}=s,et=convertConv2DDataFormat(b),nt=computeConv2DInfo(o.shape,c.shape,g,$,_,j,!1,et);let rt;const it=[];if(nt.filterHeight===1&&nt.filterWidth===1&&nt.dilationHeight===1&&nt.dilationWidth===1&&nt.strideHeight===1&&nt.strideWidth===1&&(nt.padInfo.type==="SAME"||nt.padInfo.type==="VALID"))rt=conv2dByMatMul({x:o,filter:c,convInfo:nt,backend:i,bias:d,activation:_e,preluActivationWeights:h,leakyreluAlpha:tt});else if(env$1().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)rt=conv2dWithIm2Row({x:o,filter:c,convInfo:nt,backend:i,bias:d,activation:_e,preluActivationWeights:h,leakyreluAlpha:tt});else{const st=d!=null,ot=h!=null,ct=_e==="leakyrelu",lt=_e?mapActivationToShaderProgram(_e,!1):null,dt=new Conv2DProgram(nt,st,lt,ot,ct),xt=[o,c];if(d&&xt.push(d),h&&xt.push(h),ct){const ut=i.makeTensorInfo([],"float32",createScalarValue(tt,"float32"));xt.push(ut),it.push(ut)}rt=i.runWebGLProgram(dt,xt,"float32")}const at=reshape$1({inputs:{x:rt},backend:i,attrs:{shape:nt.outShape}});return it.push(rt),it.forEach(st=>i.disposeIntermediateTensorInfo(st)),at}const fusedConv2DConfig={kernelName:FusedConv2D,backendName:"webgl",kernelFunc:fusedConv2d};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fusedDepthwiseConv2D(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,filter:c,bias:d,preluActivationWeights:h}=e,{strides:g,pad:_,dilations:b,dimRoundingMode:$,activation:j,leakyreluAlpha:_e}=s,tt=[];let et=b;et==null&&(et=[1,1]),assert$1(eitherStridesOrDilationsAreOne(g,et),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${g} and dilations '${et}'`);const nt=computeConv2DInfo(o.shape,c.shape,g,et,_,$,!0),rt=env$1().getBool("WEBGL_PACK_DEPTHWISECONV")&&nt.strideWidth<=2&&nt.outChannels/nt.inChannels===1,it=j?mapActivationToShaderProgram(j,rt):null,at=[o,c],st=d!=null,ot=h!=null,ct=j==="leakyrelu";if(st&&at.push(d),ot&&at.push(h),ct){const xt=i.makeTensorInfo([],"float32",createScalarValue(_e,"float32"));at.push(xt),tt.push(xt)}let lt;rt?lt=new DepthwiseConvPacked2DProgram(nt,st,it,ot,ct):lt=new DepthwiseConv2DProgram(nt,st,it,ot,ct);const dt=i.runWebGLProgram(lt,at,"float32");return tt.forEach(xt=>i.disposeIntermediateTensorInfo(xt)),dt}const fusedDepthwiseConv2DConfig={kernelName:FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:fusedDepthwiseConv2D};class GatherNDProgram{constructor(e,i,s){this.sliceDim=e,this.strides=i,this.variableNames=["x","indices"],this.outputShape=s;const o=getCoordsDataType(i.length),c=getCoordsDataType(s.length),d=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${c} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${d};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNd(a){const{inputs:e,backend:i}=a,{params:s,indices:o}=e,c=o.shape,d=c[c.length-1],[h,g,_,b]=prepareAndValidate(s,o),$=reshape$1({inputs:{x:o},backend:i,attrs:{shape:[g,d]}}),j=reshape$1({inputs:{x:s},backend:i,attrs:{shape:[sizeFromShape(s.shape)/_,_]}}),_e=new GatherNDProgram(d,b,[g,_]),tt=i.runWebGLProgram(_e,[j,$],j.dtype),et=reshape$1({inputs:{x:tt},backend:i,attrs:{shape:h}});return i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(tt),et}const gatherNdConfig={kernelName:GatherNd,backendName:"webgl",kernelFunc:gatherNd};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GatherProgram{constructor(e,i){this.variableNames=["A","indices"],this.outputShape=i,this.rank=i.length;const s=getCoordsDataType(this.rank),o=getSourceCoords$1(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function getSourceCoords$1(a,e){const i=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let o=0;o<a.length;o++)o===2?s.push("int(getIndices(resRC.x, resRC.z))"):s.push(`${i[o]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,indices:c}=e,{axis:d,batchDims:h}=s,g=parseAxisParam(d,o.shape)[0],_=collectGatherOpShapeInfo(o,c,g,h),b=sizeFromShape(c.shape),$=[],j=reshape$1({inputs:{x:o},backend:i,attrs:{shape:[_.batchSize,_.outerSize,_.dimSize,_.sliceSize]}}),_e=reshape$1({inputs:{x:c},backend:i,attrs:{shape:[_.batchSize,b/_.batchSize]}});$.push(j),$.push(_e);const tt=[_.batchSize,_.outerSize,b/_.batchSize,_.sliceSize];if(i.shouldExecuteOnCPU([o,c])||o.dtype==="string"){const it=i.bufferSync(_e),at=i.bufferSync(j),st=gatherV2ImplCPU(at,it,tt);return $.forEach(ot=>i.disposeIntermediateTensorInfo(ot)),i.makeTensorInfo(_.outputShape,st.dtype,st.values)}const et=new GatherProgram(j.shape,tt),nt=i.runWebGLProgram(et,[j,_e],j.dtype);$.push(nt);const rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:_.outputShape}});return $.forEach(it=>i.disposeIntermediateTensorInfo(it)),rt}const gatherV2Config={kernelName:GatherV2,backendName:"webgl",kernelFunc:gatherV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GREATER="return float(a > b);",GREATER_PACKED=`
  return vec4(greaterThan(a, b));
`,greater=binaryKernelFunc({opSnippet:GREATER,packedOpSnippet:GREATER_PACKED,cpuKernelImpl:greaterImplCPU,dtype:"bool"}),greaterConfig={kernelName:Greater,backendName:"webgl",kernelFunc:greater};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GREATER_EQUAL="return float(a >= b);",GREATER_EQUAL_PACKED=`
  return vec4(greaterThanEqual(a, b));
`,greaterEqual=binaryKernelFunc({opSnippet:GREATER_EQUAL,packedOpSnippet:GREATER_EQUAL_PACKED,dtype:"bool"}),greaterEqualConfig={kernelName:GreaterEqual,backendName:"webgl",kernelFunc:greaterEqual};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ifft(a){const{inputs:e,backend:i}=a,{input:s}=e;return fftImpl(s,!0,i)}const ifftConfig={kernelName:IFFT,backendName:"webgl",kernelFunc:ifft};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IS_FINITE="return float(!isnan(x) && !isinf(x));",isFinite$1=unaryKernelFunc({opSnippet:IS_FINITE,dtype:"bool"}),isFiniteConfig={kernelName:IsFinite,backendName:"webgl",kernelFunc:isFinite$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IS_INF="return float(isinf(x));",isInf=unaryKernelFunc({opSnippet:IS_INF,dtype:"bool"}),isInfConfig={kernelName:IsInf,backendName:"webgl",kernelFunc:isInf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IS_NAN="return float(isnan(x));",isNaN$1=unaryKernelFunc({opSnippet:IS_NAN,dtype:"bool"}),isNaNConfig={kernelName:IsNan,backendName:"webgl",kernelFunc:isNaN$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LESS="return float(a < b);",LESS_PACKED=`
  return vec4(lessThan(a, b));
`,less=binaryKernelFunc({opSnippet:LESS,packedOpSnippet:LESS_PACKED,cpuKernelImpl:lessImplCPU,dtype:"bool"}),lessConfig={kernelName:Less,backendName:"webgl",kernelFunc:less};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LESS_EQUAL="return float(a <= b);",LESS_EQUAL_PACKED=`
  return vec4(lessThanEqual(a, b));
`,lessEqual=binaryKernelFunc({opSnippet:LESS_EQUAL,packedOpSnippet:LESS_EQUAL_PACKED,dtype:"bool"}),lessEqualConfig={kernelName:LessEqual,backendName:"webgl",kernelFunc:lessEqual};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpace(a){const{backend:e,attrs:i}=a,{start:s,stop:o,num:c}=i,d=linSpaceImplCPU(s,o,c);return e.makeTensorInfo([d.length],"float32",d)}const linSpaceConfig={kernelName:LinSpace,backendName:"webgl",kernelFunc:linSpace};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOG=`if (x < 0.0) return NAN;
  return log(x);`,LOG_PACKED=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,log$1=unaryKernelFunc({opSnippet:LOG,packedOpSnippet:LOG_PACKED,cpuKernelImpl:logImplCPU}),logConfig={kernelName:Log,backendName:"webgl",kernelFunc:log$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOG1P="return log(1.0 + x);",log1p=unaryKernelFunc({opSnippet:LOG1P}),log1pConfig={kernelName:Log1p,backendName:"webgl",kernelFunc:log1p};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOGICAL_AND="return float(a >= 1.0 && b >= 1.0);",LOGICAL_AND_PACKED=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,logicalAnd=binaryKernelFunc({opSnippet:LOGICAL_AND,packedOpSnippet:LOGICAL_AND_PACKED,dtype:"bool"}),logicalAndConfig={kernelName:LogicalAnd,backendName:"webgl",kernelFunc:logicalAnd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOGICAL_NOT="return float(!(x >= 1.0));",logicalNot=unaryKernelFunc({opSnippet:LOGICAL_NOT}),logicalNotConfig={kernelName:LogicalNot,backendName:"webgl",kernelFunc:logicalNot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOGICAL_OR="return float(a >= 1.0 || b >= 1.0);",LOGICAL_OR_PACKED=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,logicalOr=binaryKernelFunc({opSnippet:LOGICAL_OR,packedOpSnippet:LOGICAL_OR_PACKED,dtype:"bool"}),logicalOrConfig={kernelName:LogicalOr,backendName:"webgl",kernelFunc:logicalOr};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LRNProgram{constructor(e,i,s,o,c){this.variableNames=["x"],this.outputShape=[];const d=i,h=e[3]-1;this.outputShape=e;let g;const _=`float(${s}) + float(${o}) * sum`;c===.5?g=`inversesqrt(${_})`:c===1?g=`1.0/(${_})`:g=`exp(log(${_}) * float(-${c}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${d}; j <= ${d}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${h}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${g};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LRNPackedProgram{constructor(e,i,s,o,c){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const d=i,h=e[3]-1;this.outputShape=e;let g;const _=`float(${s}) + float(${o}) * sum`;c===.5?g=`inversesqrt(${_})`:c===1?g=`1.0/(${_})`:g=`exp(log(${_}) * float(-${c}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${d};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${d}; j <= ${d}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${h}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${g};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lrn=a=>{const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{depthRadius:c,bias:d,alpha:h,beta:g}=s,_=env$1().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(o.shape,c,d,h,g):new LRNProgram(o.shape,c,d,h,g);return i.runWebGLProgram(_,[o],o.dtype)},LRNConfig={kernelName:LRN,backendName:"webgl",kernelFunc:lrn};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LRNGradProgram{constructor(e,i,s,o,c){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=i,this.bias=s,this.alpha=o,this.beta=c,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${i})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${i} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${c})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${c});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lrnGrad=a=>{const{inputs:e,backend:i,attrs:s}=a,{x:o,y:c,dy:d}=e,{depthRadius:h,bias:g,alpha:_,beta:b}=s,$=new LRNGradProgram(o.shape,h,g,_,b);return i.runWebGLProgram($,[o,c,d],o.dtype)},LRNGradConfig={kernelName:LRNGrad,backendName:"webgl",kernelFunc:lrnGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxImpl(a,e,i,s){const o=sizeFromShape(e),d=sizeFromShape(a.shape)/o,h=reshape$1({inputs:{x:a},attrs:{shape:[d,o]},backend:s}),g=reduce(h,a.dtype,"max",s),_=reshape$1({inputs:{x:g},attrs:{shape:i},backend:s});return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(g),_}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{reductionIndices:c,keepDims:d}=s,h=o.shape.length,g=parseAxisParam(c,o.shape);let _=g;const b=getAxesPermutation(_,h),$=b!=null,j=i.shouldExecuteOnCPU([o]);let _e=o;if($){if(j){const at=i.texData.get(_e.dataId).values,st=new Array(h);for(let lt=0;lt<st.length;lt++)st[lt]=o.shape[b[lt]];const ot=transposeImplCPU(at,o.shape,o.dtype,b,st);_e=i.makeTensorInfo(st,o.dtype);const ct=i.texData.get(_e.dataId);ct.values=ot}else _e=transposeImpl(o,b,i);_=getInnerMostAxes(_.length,h)}assertAxesAreInnerMostDims("max",_,h);const[tt,et]=computeOutAndReduceShapes(_e.shape,_);let nt=tt;d&&(nt=expandShapeToKeepDim(tt,g));let rt;if(j){const at=i.texData.get(_e.dataId).values,st=maxImplCPU(at,sizeFromShape(et),nt,o.dtype);rt=i.makeTensorInfo(nt,o.dtype);const ot=i.texData.get(rt.dataId);ot.values=st}else rt=maxImpl(_e,et,nt,i);return $&&i.disposeIntermediateTensorInfo(_e),rt}const maxConfig={kernelName:Max,backendName:"webgl",kernelFunc:max$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MAXIMUM=CHECK_NAN_SNIPPET$1+`
  return max(a, b);
`,MAXIMUM_PACKED=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CHECK_NAN_SNIPPET+`
  return result;
`,maximum=binaryKernelFunc({opSnippet:MAXIMUM,packedOpSnippet:MAXIMUM_PACKED,cpuKernelImpl:maximumImplCPU}),maximumConfig={kernelName:Maximum$1,backendName:"webgl",kernelFunc:maximum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e;assertNotComplex(o,"maxPool");const{filterSize:c,strides:d,pad:h,dimRoundingMode:g}=s,_=1;assert$1(eitherStridesOrDilationsAreOne(d,_),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${d} and dilations '${_}'`);const b=computePool2DInfo(o.shape,c,d,_,h,g);if(b.filterWidth===1&&b.filterHeight===1&&arraysEqual(b.inShape,b.outShape))return identity$1({inputs:{x:o},backend:i});const $=new Pool2DProgram(b,"max",!1);return i.runWebGLProgram($,[o],o.dtype)}const maxPoolConfig={kernelName:MaxPool,backendName:"webgl",kernelFunc:maxPool};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3d(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{filterSize:c,strides:d,pad:h,dataFormat:g,dimRoundingMode:_}=s,b=[1,1,1],$=computePool3DInfo(o.shape,c,d,b,h,_,g),j=new Pool3DProgram($,"max",!1);return i.runWebGLProgram(j,[o],o.dtype)}const maxPool3DConfig={kernelName:MaxPool3D,backendName:"webgl",kernelFunc:maxPool3d};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MaxPool2DBackpropProgram{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const i=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=c-1-e.padInfo.top,g=d-1-e.padInfo.left,_=c*d-1;this.userCode=`
      const ivec2 pads = ivec2(${h}, ${g});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${d}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${_} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${d} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class MaxPool3DBackpropProgram{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const i=e.strideDepth,s=e.strideHeight,o=e.strideWidth,c=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,g=e.effectiveFilterDepth,_=e.effectiveFilterHeight,b=e.effectiveFilterWidth,$=g-1-e.padInfo.front,j=_-1-e.padInfo.top,_e=b-1-e.padInfo.left,tt=g*_*b-1;this.userCode=`
      const ivec3 pads = ivec3(${$}, ${j}, ${_e});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${g};
           wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${_};
              wR += ${d}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${b};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${tt} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${_} * ${b} +
                  wR * ${b} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPool3DGrad(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c}=e,d=c,{filterSize:h,strides:g,pad:_,dimRoundingMode:b}=s,$=[1,1,1],j=computePool3DInfo(d.shape,h,g,$,_,b),_e=new Pool3DProgram(j,"max",!0),tt=i.runWebGLProgram(_e,[d],d.dtype),et=new MaxPool3DBackpropProgram(j),nt=i.runWebGLProgram(et,[o,tt],d.dtype);return i.disposeIntermediateTensorInfo(tt),nt}const maxPoolGrad3DConfig={kernelName:MaxPool3DGrad,backendName:"webgl",kernelFunc:maxPool3DGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolGrad(a){const{inputs:e,backend:i,attrs:s}=a,{dy:o,input:c,output:d}=e,h=c;assertNotComplex([c,d],"maxPoolGrad");const{filterSize:g,strides:_,pad:b,dimRoundingMode:$}=s,j=computePool2DInfo(h.shape,g,_,1,b,$),_e=!0,tt=new Pool2DProgram(j,"max",_e),et=i.runWebGLProgram(tt,[h],h.dtype),nt=new MaxPool2DBackpropProgram(j),rt=i.runWebGLProgram(nt,[o,et],h.dtype);return i.disposeIntermediateTensorInfo(et),rt}const maxPoolGradConfig={kernelName:MaxPoolGrad,backendName:"webgl",kernelFunc:maxPoolGrad};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxPoolWithArgmaxImpl(a,e,i,s){let o=new Pool2DProgram(i,"max",!1);const c=s.runWebGLProgram(o,[a],"float32");o=new Pool2DProgram(i,"max",!0,!0,e);const d=s.runWebGLProgram(o,[a],"float32");return[c,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const maxPoolWithArgmaxConfig={kernelName:MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:a,attrs:e,backend:i})=>{const{x:s}=a,{filterSize:o,strides:c,pad:d,includeBatchInIndex:h}=e,g=i;assert$1(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const _=[1,1];assert$1(eitherStridesOrDilationsAreOne(c,_),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${c} and dilations '${_}'`);const b=computePool2DInfo(s.shape,o,c,_,d),[$,j]=maxPoolWithArgmaxImpl(s,h,b,g);return[$,j]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function meanImpl(a,e,i,s){const o=sizeFromShape(e),d=sizeFromShape(a.shape)/o,h=reshape$1({inputs:{x:a},attrs:{shape:[d,o]},backend:s}),g=reduce(h,"float32","mean",s),_=reshape$1({inputs:{x:g},attrs:{shape:i},backend:s});return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(g),_}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const meanConfig={kernelName:Mean,backendName:"webgl",kernelFunc:({inputs:a,attrs:e,backend:i})=>{const{x:s}=a,{keepDims:o,axis:c}=e,d=i,h=s.shape.length,g=parseAxisParam(c,s.shape);let _=g;const b=getAxesPermutation(_,h),$=b!=null,j=d.shouldExecuteOnCPU([s]),_e=[];let tt=s;if($){if(j){const st=d.texData.get(tt.dataId).values,ot=new Array(h);for(let dt=0;dt<ot.length;dt++)ot[dt]=s.shape[b[dt]];const ct=transposeImplCPU(st,s.shape,s.dtype,b,ot);tt=d.makeTensorInfo(ot,s.dtype);const lt=d.texData.get(tt.dataId);lt.values=ct}else tt=transposeImpl(s,b,d);_e.push(tt),_=getInnerMostAxes(_.length,h)}assertAxesAreInnerMostDims("sum",_,h);const[et,nt]=computeOutAndReduceShapes(tt.shape,_);let rt=et;o&&(rt=expandShapeToKeepDim(et,g));const it=meanImpl(tt,nt,rt,d);for(const at of _e)d.disposeIntermediateTensorInfo(at);return it}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function min$1(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s,h=o.shape.length,g=parseAxisParam(c,o.shape);let _=g;const b=getAxesPermutation(_,h);let $=o;b!=null&&($=transpose$1({inputs:{x:o},backend:i,attrs:{perm:b}}),_=getInnerMostAxes(_.length,o.shape.length)),assertAxesAreInnerMostDims("min",_,h);const[j,_e]=computeOutAndReduceShapes($.shape,_),tt=sizeFromShape(_e),et=reshape$1({inputs:{x:$},backend:i,attrs:{shape:[-1,tt]}}),nt=reduce(et,et.dtype,"min",i);let rt;if(d){const it=expandShapeToKeepDim(j,g);rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:it}})}else rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:j}});return i.disposeIntermediateTensorInfo(et),i.disposeIntermediateTensorInfo(nt),b!=null&&i.disposeIntermediateTensorInfo($),rt}const minConfig={kernelName:Min,backendName:"webgl",kernelFunc:min$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MINIMUM=CHECK_NAN_SNIPPET$1+`
  return min(a, b);
`,MINIMUM_PACKED=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+CHECK_NAN_SNIPPET+`
  return result;
`,minimum=binaryKernelFunc({opSnippet:MINIMUM,packedOpSnippet:MINIMUM_PACKED,cpuKernelImpl:minimumImplCPU}),minimumConfig={kernelName:Minimum$1,backendName:"webgl",kernelFunc:minimum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MirrorPadProgram{constructor(e,i,s){this.variableNames=["x"],this.outputShape=i.map((b,$)=>b[0]+e[$]+b[1]);const o=e.length,c=getCoordsDataType(o),d=i.map(b=>b[0]).join(","),h=i.map((b,$)=>b[0]+e[$]).join(","),g=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),_=s==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${d};
        int end = ${h};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${_};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${_};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${c} start = ${c}(${d});
      ${c} end = ${c}(${h});

      void main() {
        ${c} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${_};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${_};
          }
        }
        ${c} coords = outC - start;
        setOutput(getX(${g}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MirrorPadPackedProgram{constructor(e,i,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i.map((tt,et)=>tt[0]+e[et]+tt[1]);const o=e.length,c=getCoordsDataType(o),d=i.map(tt=>tt[0]).join(","),h=i.map((tt,et)=>tt[0]+e[et]).join(","),g=getChannels("rc",o),_=getChannels("source",o),b=`${g[o-1]} < ${this.outputShape[o-1]}`,$=o===1?"source":`vec2(${_.slice(-2).join()})`,j=s==="reflect"?0:1;let _e="";if(o===1){const tt=`
        ${c} source = rc;
        if (source < start) {
          source = start * 2 - source - ${j};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${j};
        }
        source -= start;
      `;_e=`
        ${c} rc = outputLoc;
        ${tt}
        result[0] = getChannel(getX(${_.join()}), ${$});
        ${g[o-1]} += 1;
        if(${b}) {
          ${tt}
          result[1] = getChannel(getX(${_.join()}), ${$});
        }
      `}else{const tt=`
        ${c} source = rc;
        ${c} lt = ${c}(lessThan(source, start));
        ${c} gte = ${c}(greaterThanEqual(source, end));
        ${c} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${j}) +
                gte * ((end - 1) * 2 - source + ${j});
        source -= start;
      `;_e=`
        ${c} rc = outputLoc;
        ${tt}
        result[0] = getChannel(getX(${_.join()}), ${$});
        ${g[o-1]} += 1;
        if(${b}) {
          ${tt}
          result[1] = getChannel(getX(${_.join()}), ${$});
        }
        rc = outputLoc;
        ${g[o-2]} += 1;
        if(${g[o-2]} < ${this.outputShape[o-2]}) {
          ${tt}
          result[2] = getChannel(getX(${_.join()}), ${$});
          ${g[o-1]} += 1;
          if(${b}) {
            ${tt}
            result[3] = getChannel(getX(${_.join()}), ${$});
          }
        }
      `}this.userCode=`
      const ${c} start = ${c}(${d});
      const ${c} end = ${c}(${h});

      void main() {
        ${c} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${_e}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mirrorPadKernelFunc=({inputs:a,backend:e,attrs:i})=>{const{x:s}=a,{paddings:o,mode:c}=i,d=env$1().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MirrorPadPackedProgram(s.shape,o,c):new MirrorPadProgram(s.shape,o,c);return e.runWebGLProgram(d,[s],s.dtype)},mirrorPadConfig={kernelName:MirrorPad,backendName:"webgl",kernelFunc:mirrorPadKernelFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MOD=`if (b == 0.0) return NAN;
  return mod(a, b);`,MOD_PACKED=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+CHECK_NAN_SNIPPET+`
  return result;
`,mod$1=binaryKernelFunc({opSnippet:MOD,packedOpSnippet:MOD_PACKED}),modConfig={kernelName:Mod,backendName:"webgl",kernelFunc:mod$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MultinomialProgram{constructor(e,i,s){this.variableNames=["probs"],this.outputShape=[e,s],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${i-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${i-1}));
      }
    `}getCustomSetupFunc(e){return(i,s)=>{this.seedLoc==null&&(this.seedLoc=i.getUniformLocation(s,"seed")),i.gl.uniform1f(this.seedLoc,e)}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DIV=`
if (a == b) {
  return 1.0;
};
return a / b;`,DIV_PACKED=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,realDiv=binaryKernelFunc({opSnippet:DIV,packedOpSnippet:DIV_PACKED,checkOutOfBounds:!0}),realDivConfig={kernelName:RealDiv,backendName:"webgl",kernelFunc:realDiv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SUB="return a - b;",sub$1=binaryKernelFunc({opSnippet:SUB,packedOpSnippet:SUB,supportsComplex:!0,cpuKernelImpl:subImplCPU}),subConfig={kernelName:Sub,backendName:"webgl",kernelFunc:sub$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax(a){const{inputs:e,backend:i,attrs:s}=a,{logits:o}=e,{dim:c}=s,d=parseAxisParam([c],o.shape),h=max$1({inputs:{x:o},backend:i,attrs:{reductionIndices:d,keepDims:!1}}),g=expandShapeToKeepDim(h.shape,d),_=reshape$1({inputs:{x:h},backend:i,attrs:{shape:g}}),b=sub$1({inputs:{a:o,b:_},backend:i}),$=exp$1({inputs:{x:b},backend:i}),j=sum$1({inputs:{x:$},backend:i,attrs:{axis:d,keepDims:!1}}),_e=reshape$1({inputs:{x:j},backend:i,attrs:{shape:g}}),tt=realDiv({inputs:{a:$,b:_e},backend:i});return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(j),i.disposeIntermediateTensorInfo(_e),tt}const softmaxConfig={kernelName:Softmax$2,backendName:"webgl",kernelFunc:softmax};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function multinomial(a){const{inputs:e,backend:i,attrs:s}=a,{logits:o}=e,{numSamples:c,seed:d,normalized:h}=s,g=h?o:softmax({inputs:{logits:o},backend:i,attrs:{dim:o.shape.length-1}}),_=g.shape[0],b=g.shape[1],$=new MultinomialProgram(_,b,c),j=$.getCustomSetupFunc(d),_e=i.runWebGLProgram($,[g],"int32",j);return h||i.disposeIntermediateTensorInfo(g),_e}const multinomialConfig={kernelName:Multinomial,backendName:"webgl",kernelFunc:multinomial};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NEG="return -x;";function neg(a){const{inputs:e,backend:i}=a,{x:s}=e;if(i.shouldExecuteOnCPU([s])){const c=i.texData.get(s.dataId),[d,h]=negImplCPU(c.values,s.shape,s.dtype);return i.makeTensorInfo(h,s.dtype,d)}let o;return env$1().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new UnaryOpPackedProgram(s.shape,NEG):o=new UnaryOpProgram(s.shape,NEG),i.runWebGLProgram(o,[s],s.dtype)}const negConfig={kernelName:Neg,backendName:"webgl",kernelFunc:neg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV3Impl=nonMaxSuppressionV3Impl$2;function nonMaxSuppressionV3(a){warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:i,attrs:s}=a,{boxes:o,scores:c}=e,{maxOutputSize:d,iouThreshold:h,scoreThreshold:g}=s,_=i.readSync(o.dataId),b=i.readSync(c.dataId),{selectedIndices:$}=nonMaxSuppressionV3Impl(_,b,d,h,g);return i.makeTensorInfo([$.length],"int32",new Int32Array($))}const nonMaxSuppressionV3Config={kernelName:NonMaxSuppressionV3,backendName:"webgl",kernelFunc:nonMaxSuppressionV3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV4Impl=nonMaxSuppressionV4Impl$2;function nonMaxSuppressionV4(a){warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:i,attrs:s}=a,{boxes:o,scores:c}=e,{maxOutputSize:d,iouThreshold:h,scoreThreshold:g,padToMaxOutputSize:_}=s,b=i.readSync(o.dataId),$=i.readSync(c.dataId),{selectedIndices:j,validOutputs:_e}=nonMaxSuppressionV4Impl(b,$,d,h,g,_);return[i.makeTensorInfo([j.length],"int32",new Int32Array(j)),i.makeTensorInfo([],"int32",new Int32Array([_e]))]}const nonMaxSuppressionV4Config={kernelName:NonMaxSuppressionV4,backendName:"webgl",kernelFunc:nonMaxSuppressionV4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nonMaxSuppressionV5Impl=nonMaxSuppressionV5Impl$2;function nonMaxSuppressionV5(a){warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:i,attrs:s}=a,{boxes:o,scores:c}=e,{maxOutputSize:d,iouThreshold:h,scoreThreshold:g,softNmsSigma:_}=s,b=i.readSync(o.dataId),$=i.readSync(c.dataId),j=d,_e=h,tt=g,et=_,{selectedIndices:nt,selectedScores:rt}=nonMaxSuppressionV5Impl(b,$,j,_e,tt,et);return[i.makeTensorInfo([nt.length],"int32",new Int32Array(nt)),i.makeTensorInfo([rt.length],"float32",new Float32Array(rt))]}const nonMaxSuppressionV5Config={kernelName:NonMaxSuppressionV5,backendName:"webgl",kernelFunc:nonMaxSuppressionV5};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OneHotProgram{constructor(e,i,s,o){this.variableNames=["indices"],this.outputShape=[e,i],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oneHot=a=>{const{inputs:e,backend:i,attrs:s}=a,{indices:o}=e,{depth:c,onValue:d,offValue:h}=s,g=sizeFromShape(o.shape),_=new OneHotProgram(g,c,d,h),b=reshape$1({inputs:{x:o},backend:i,attrs:{shape:[g]}}),$=i.runWebGLProgram(_,[b],o.dtype);i.disposeIntermediateTensorInfo(b);const j=[...o.shape,c],_e=reshape$1({inputs:{x:$},backend:i,attrs:{shape:j}});return i.disposeIntermediateTensorInfo($),_e},oneHotConfig={kernelName:OneHot,backendName:"webgl",kernelFunc:oneHot};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(a){const{inputs:e,backend:i}=a,{x:s}=e;if(s.dtype==="complex64"){const o=real({inputs:{input:s},backend:i}),c=zerosLike({inputs:{x:o},backend:i}),d=imag({inputs:{input:s},backend:i}),h=zerosLike({inputs:{x:d},backend:i}),g=complex$2({inputs:{real:c,imag:h},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),g}else return fill({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:i})}const zerosLikeConfig={kernelName:ZerosLike,backendName:"webgl",kernelFunc:zerosLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(a){const{inputs:e,backend:i}=a,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const o=real({inputs:{input:s},backend:i}),c=onesLike({inputs:{x:o},backend:i}),d=imag({inputs:{input:s},backend:i}),h=zerosLike({inputs:{x:d},backend:i}),g=complex$2({inputs:{real:c,imag:h},backend:i});return i.disposeIntermediateTensorInfo(o),i.disposeIntermediateTensorInfo(c),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),g}else return fill({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:i})}const onesLikeConfig={kernelName:OnesLike,backendName:"webgl",kernelFunc:onesLike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pack(a){const{inputs:e,backend:i,attrs:s}=a,{axis:o}=s;if(e.length===1)return expandDims({inputs:{input:e[0]},backend:i,attrs:{dim:o}});const c=e[0].shape,d=e[0].dtype;e.forEach(b=>{assertShapesMatch(c,b.shape,"All tensors passed to stack must have matching shapes"),assert$1(d===b.dtype,()=>"All tensors passed to stack must have matching dtypes")});const h=[],g=e.map(b=>{const $=expandDims({inputs:{input:b},backend:i,attrs:{dim:o}});return h.push($),$}),_=concat$1({inputs:g,backend:i,attrs:{axis:o}});return h.forEach(b=>i.disposeIntermediateTensorInfo(b)),_}const packConfig={kernelName:Pack,backendName:"webgl",kernelFunc:pack};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PadProgram{constructor(e,i,s){this.variableNames=["x"],this.outputShape=i.map((_,b)=>_[0]+e[b]+_[1]);const o=e.length,c=getCoordsDataType(o),d=i.map(_=>_[0]).join(","),h=i.map((_,b)=>_[0]+e[b]).join(","),g=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${d};
        int end = ${h};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${s}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${c} start = ${c}(${d});
      ${c} end = ${c}(${h});

      void main() {
        ${c} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${s}));
        } else {
          ${c} coords = outC - start;
          setOutput(getX(${g}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PadPackedProgram{constructor(e,i,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i.map((et,nt)=>et[0]+e[nt]+et[1]);const o=e.length,c=getCoordsDataType(o),d=i.map(et=>et[0]).join(","),h=i.map((et,nt)=>et[0]+e[nt]).join(","),g=getChannels("rc",o),_=getChannels("source",o),b=`${g[o-1]} < ${this.outputShape[o-1]}`,$=o===1?"source":`vec2(${_.slice(-2).join()})`,j=[`${c} rc = outputLoc;`,`${g[o-1]} += 1;
       if(${b}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${g[o-2]} += 1;
       if(${g[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${g[o-1]} += 1;
         if(${b}) {`],_e=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let tt="";for(let et=0,nt=o===1?2:4;et<nt;et++)tt+=`
        ${j[et]}
        if (${_e}) {
          result[${et}] = float(${s});
        } else {
          ${c} source = rc - start;
          result[${et}] = getChannel(getX(${_.join()}), ${$});
        }
      `;tt+=o===1?"} ":"}}",this.userCode=`
      const ${c} start = ${c}(${d});
      const ${c} end = ${c}(${h});

      void main() {
        ${c} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${tt}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const padV2=a=>{const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{paddings:c,constantValue:d}=s,h=env$1().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(o.shape,c,d):new PadProgram(o.shape,c,d);return i.runWebGLProgram(h,[o],o.dtype)},padV2Config={kernelName:PadV2,backendName:"webgl",kernelFunc:padV2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const POW=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,POW_PACKED=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+CHECK_NAN_SNIPPET+`
  return result;
`,pow$2=binaryKernelFunc({opSnippet:POW,packedOpSnippet:POW_PACKED}),powConfig={kernelName:Pow,backendName:"webgl",kernelFunc:pow$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prod(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{axis:c,keepDims:d}=s,h=o.shape.length,g=[],_=parseAxisParam(c,o.shape);let b=_;const $=getAxesPermutation(b,h);let j=o;$!=null&&(j=transpose$1({inputs:{x:o},backend:i,attrs:{perm:$}}),b=getInnerMostAxes(b.length,h),g.push(j)),assertAxesAreInnerMostDims("prod",b,h);let _e;if(i.shouldExecuteOnCPU([j])){const tt=i.texData.get(j.dataId).values,{outVals:et,outShape:nt,outDtype:rt}=prodImplCPU(j.shape,j.dtype,tt,b);_e=i.makeTensorInfo(nt,rt,et)}else{const[tt,et]=computeOutAndReduceShapes(j.shape,b),nt=sizeFromShape(et),rt=reshape$1({inputs:{x:j},backend:i,attrs:{shape:[-1,nt]}}),it=sumOutType(o.dtype),at=reduce(rt,it,"prod",i);_e=reshape$1({inputs:{x:at},backend:i,attrs:{shape:tt}}),g.push(rt),g.push(at)}if(d){g.push(_e);const tt=expandShapeToKeepDim(_e.shape,_);_e=reshape$1({inputs:{x:_e},backend:i,attrs:{shape:tt}})}return g.forEach(tt=>i.disposeIntermediateTensorInfo(tt)),_e}const prodConfig={kernelName:Prod,backendName:"webgl",kernelFunc:prod};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const range$1=a=>{const{backend:e,attrs:i}=a,{start:s,stop:o,step:c,dtype:d}=i,h=rangeImplCPU(s,o,c,d);return e.makeTensorInfo([h.length],d,h)},rangeConfig={kernelName:Range,backendName:"webgl",kernelFunc:range$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RECIPROCAL="return 1.0 / x;",reciprocal=unaryKernelFunc({opSnippet:RECIPROCAL}),reciprocalConfig={kernelName:Reciprocal,backendName:"webgl",kernelFunc:reciprocal};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RELU=CHECK_NAN_SNIPPET$2+`
  return (x < 0.0) ? 0.0 : x;
`,RELU_PACKED=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,relu=unaryKernelFunc({opSnippet:RELU,packedOpSnippet:RELU_PACKED}),reluConfig={kernelName:Relu$1,backendName:"webgl",kernelFunc:relu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RELU6=CHECK_NAN_SNIPPET$2+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,RELU6_PACKED=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,relu6=unaryKernelFunc({opSnippet:RELU6,packedOpSnippet:RELU6_PACKED}),relu6Config={kernelName:Relu6$1,backendName:"webgl",kernelFunc:relu6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ResizeBilinearProgram{constructor(e,i,s,o,c){this.variableNames=["A"],this.outputShape=[];const[d,h,g,_]=e;this.outputShape=[d,i,s,_];const b=[o&&i>1?h-1:h,o&&s>1?g-1:g],$=[o&&i>1?i-1:i,o&&s>1?s-1:s];let j;c?j="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":j="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${b[0]/$[0]},
          ${b[1]/$[1]});
      const vec2 inputShapeRC = vec2(${h}.0, ${g}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${j};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ResizeBilinearPackedProgram{constructor(e,i,s,o,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[d,h,g,_]=e;this.outputShape=[d,i,s,_];const b=[o&&i>1?h-1:h,o&&s>1?g-1:g],$=[o&&i>1?i-1:i,o&&s>1?s-1:s];let j;c?j="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":j="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${b[0]/$[0]},
          ${b[1]/$[1]},
          ${b[1]/$[1]});
      const vec3 inputShapeRC = vec3(${h}.0, ${g}.0,
                                     ${g}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${j};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${_-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinear(a){const{inputs:e,backend:i,attrs:s}=a,{images:o}=e,{alignCorners:c,halfPixelCenters:d,size:h}=s,[g,_]=h,b=env$1().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(o.shape,g,_,c,d):new ResizeBilinearProgram(o.shape,g,_,c,d);return i.runWebGLProgram(b,[o],"float32")}const resizeBilinearConfig={kernelName:ResizeBilinear,backendName:"webgl",kernelFunc:resizeBilinear};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ResizeBilinearBackpropProgram{constructor(e,i,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=i;const[,o,c]=i,[,d,h]=e,g=[s&&d>1?o-1:o,s&&h>1?c-1:c],_=[s&&d>1?d-1:d,s&&h>1?h-1:h],b=g[0]/_[0],$=g[1]/_[1],j=1/b,_e=1/$,tt=Math.ceil(j)*2+2,et=Math.ceil(_e)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${b});
        const float widthScale = float(${$});

        const float invHeightScale = float(${j});
        const float invWidthScale = float(${_e});

        const int winHeight = int(${tt});
        const int winWidth = int(${et});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${d}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${h}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${c-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeBilinearGrad(a){const{inputs:e,backend:i,attrs:s}=a,{images:o,dy:c}=e,{alignCorners:d}=s,h=new ResizeBilinearBackpropProgram(c.shape,o.shape,d);return i.runWebGLProgram(h,[c],c.dtype)}const resizeBilinearGradConfig={kernelName:ResizeBilinearGrad,backendName:"webgl",kernelFunc:resizeBilinearGrad};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ResizeNearestNeighborProgram{constructor(e,i,s,o,c){this.variableNames=["A"],this.outputShape=[];const[d,h,g,_]=e;this.outputShape=[d,i,s,_];const b=[o&&i>1?h-1:h,o&&s>1?g-1:g],$=[o&&i>1?i-1:i,o&&s>1?s-1:s],j=o?"0.5":"0.0";let _e;c?_e="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":_e="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${b[0]/$[0]},
          ${b[1]/$[1]});
      const vec2 inputShapeRC = vec2(${h}.0, ${g}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${_e};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${j})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighbor(a){const{inputs:e,backend:i,attrs:s}=a,{images:o}=e,{alignCorners:c,halfPixelCenters:d,size:h}=s,[g,_]=h,b=new ResizeNearestNeighborProgram(o.shape,g,_,c,d);return i.runWebGLProgram(b,[o],o.dtype)}const resizeNearestNeighborConfig={kernelName:ResizeNearestNeighbor,backendName:"webgl",kernelFunc:resizeNearestNeighbor};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ResizeNearestNeigborBackpropProgram{constructor(e,i,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=i;const[,o,c]=i,[,d,h]=e,g=[s&&d>1?o-1:o,s&&h>1?c-1:c],_=[s&&d>1?d-1:d,s&&h>1?h-1:h],b=g[0]/_[0],$=g[1]/_[1],j=1/b,_e=1/$,tt=Math.ceil(j)*2+2,et=Math.ceil(_e)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${b});
        const float widthScale = float(${$});

        const float invHeightScale = float(${j});
        const float invWidthScale = float(${_e});

        const int winHeight = int(${tt});
        const int winWidth = int(${et});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${d}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${h}) {
              continue;
            }

            float sourceFracRow =
              float(${g[0]}) *
                (float(dyR) / float(${_[0]}));

            float sourceFracCol =
                float(${g[1]}) *
                  (float(dyC) / float(${_[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${c}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function resizeNearestNeighborGrad(a){const{inputs:e,backend:i,attrs:s}=a,{images:o,dy:c}=e,{alignCorners:d}=s,h=new ResizeNearestNeigborBackpropProgram(c.shape,o.shape,d);return i.runWebGLProgram(h,[c],c.dtype)}const resizeNearestNeighborGradConfig={kernelName:ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:resizeNearestNeighborGrad};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ReverseProgram{constructor(e,i){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const o=h=>i.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - coords[${h}] - 1`:`coords[${h}]`,c=e.map((h,g)=>o(g)).join(","),d=getCoordsDataType(s);this.userCode=`
      void main() {
        ${d} coords = getOutputCoords();
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ReversePackedProgram{constructor(e,i){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const o=getChannels("rc",s),c=`${o[s-1]} + 1 < ${this.outputShape[s-1]}`,d=`${o[s-2]} + 1 < ${this.outputShape[s-2]}`,h=getCoordsDataType(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${c}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${h} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${g(o.slice())};
          if(${c}){
            result.g = ${_(o.slice())};
          }
          if(${d}) {
            result.b = ${b(o.slice())};
            if(${c}) {
              result.a = ${$(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function g(tt){return j(tt)}function _(tt){return tt[s-1]="("+tt[s-1]+" + 1)",j(tt)}function b(tt){return tt[s-2]="("+tt[s-2]+" + 1)",j(tt)}function $(tt){return tt[s-1]="("+tt[s-1]+" + 1)",tt[s-2]="("+tt[s-2]+" + 1)",j(tt)}function j(tt){const et=e.map((it,at)=>_e(at,tt)),nt=et.join(","),rt=et.slice(-2).join(",");return`getChannel(getX(${nt}), vec2(${rt}))`}function _e(tt,et){return i.indexOf(tt)!==-1&&e[tt]!==1?`${e[tt]} - ${et[tt]} - 1`:`${et[tt]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reverse(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{dims:c}=s,d=o.shape.length,h=parseAxisParam(c,o.shape);if(d===0)return identity$1({inputs:{x:o},backend:i});const g=env$1().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(o.shape,h):new ReverseProgram(o.shape,h);return i.runWebGLProgram(g,[o],o.dtype)}const reverseConfig={kernelName:Reverse,backendName:"webgl",kernelFunc:reverse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RotateProgram{constructor(e,i,s,o){this.variableNames=["Image"],this.outputShape=[];const c=e[1],d=e[2],h=Math.sin(i).toFixed(3),g=Math.cos(i).toFixed(3);this.outputShape=e;const[_,b]=getImageCenter(o,c,d),$=_.toFixed(3),j=b.toFixed(3);let _e="";typeof s=="number"?_e=`float outputValue = ${s.toFixed(2)};`:_e=`
        vec3 fill = vec3(${s.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${$}) * ${g} - (float(y) - ${j}) * ${h};
          float coordYFloat = (float(x) - ${$}) * ${h} + (float(y) - ${j}) * ${g};
          int coordX = int(round(coordXFloat + ${$}));
          int coordY = int(round(coordYFloat + ${j}));
          ${_e}
          if(coordX >= 0 && coordX < ${d} && coordY >= 0 && coordY < ${c}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rotateWithOffsetConfig={kernelName:RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:a,attrs:e,backend:i})=>{const{image:s}=a,{radians:o,fillValue:c,center:d}=e,h=i,g=new RotateProgram(s.shape,o,c,d);return h.runWebGLProgram(g,[s],s.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ROUND=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,round$1=unaryKernelFunc({opSnippet:ROUND}),roundConfig={kernelName:Round,backendName:"webgl",kernelFunc:round$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RSQRT="return inversesqrt(x);",rsqrt=unaryKernelFunc({opSnippet:RSQRT,cpuKernelImpl:rsqrtImplCPU}),rsqrtConfig={kernelName:Rsqrt,backendName:"webgl",kernelFunc:rsqrt};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ScatterProgram{constructor(e,i,s,o,c,d,h=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=d;const g=getCoordsDataType(c.length),_=getCoordsDataType(d.length);let b="";s===1?b="i":s===2&&(b="i, j");const $=`getIndices(${b})`;let j="";o===1?j="i":o===2&&(j="i, coords[1]");const _e=`getUpdates(${j})`,tt=i>1?"strides[j]":"strides";this.userCode=`
        ${g} strides = ${g}(${c});

        void main() {
          ${_} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${i}; j++) {
              int index = round(${$});
              flattenedIndex += index * ${tt};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${_e};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterNd(a){const{inputs:e,backend:i,attrs:s}=a,{indices:o,updates:c}=e,{shape:d}=s,{sliceRank:h,numUpdates:g,sliceSize:_,strides:b,outputSize:$}=calculateShapes(c,o,d),j=[$/_,_];if($===0)return i.makeTensorInfo(d,o.dtype);const _e=reshape$1({inputs:{x:o},backend:i,attrs:{shape:[g,h]}}),tt=reshape$1({inputs:{x:c},backend:i,attrs:{shape:[g,_]}}),et=i.makeTensorInfo([],"float32",new Float32Array([0])),nt=new ScatterProgram(g,h,_e.shape.length,tt.shape.length,b,j),rt=i.runWebGLProgram(nt,[tt,_e,et],tt.dtype),it=reshape$1({inputs:{x:rt},backend:i,attrs:{shape:d}});return i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(tt),i.disposeIntermediateTensorInfo(rt),i.disposeIntermediateTensorInfo(et),it}const scatterNdConfig={kernelName:ScatterNd,backendName:"webgl",kernelFunc:scatterNd};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SelectProgram{constructor(e,i,s){this.variableNames=["c","a","b"],this.outputShape=i;let o,c;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)c="resRC",o="resRC";else{const h=["resRC.x","resRC.y","resRC.z","resRC.w"],g=[],_=[];for(let b=0;b<i.length;b++)_.push(`${h[b]}`),b<e&&g.push(`${h[b]}`);o=g.join(),c=_.join()}const d=getCoordsDataType(s);this.userCode=`
      void main() {
        ${d} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${c}));
        } else {
          setOutput(getB(${c}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function select(a){const{inputs:e,backend:i}=a,{condition:s,t:o,e:c}=e,d=new SelectProgram(s.shape.length,o.shape,o.shape.length);return i.runWebGLProgram(d,[s,o,c],upcastType(o.dtype,c.dtype))}const selectConfig={kernelName:Select,backendName:"webgl",kernelFunc:select};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SELU=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${SELU_SCALEALPHA};
  float scale = ${SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,selu=unaryKernelFunc({opSnippet:SELU}),seluConfig={kernelName:Selu$1,backendName:"webgl",kernelFunc:selu};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));",sigmoid=unaryKernelFunc({opSnippet:SIGMOID}),sigmoidConfig={kernelName:Sigmoid$1,backendName:"webgl",kernelFunc:sigmoid};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SIGN=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,sign$3=unaryKernelFunc({opSnippet:SIGN}),signConfig={kernelName:Sign,backendName:"webgl",kernelFunc:sign$3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SIN=CHECK_NAN_SNIPPET_UNARY+`
  return sin(x);
`,sin$2=unaryKernelFunc({opSnippet:SIN}),sinConfig={kernelName:Sin,backendName:"webgl",kernelFunc:sin$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SINH=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,sinh$1=unaryKernelFunc({opSnippet:SINH}),sinhConfig={kernelName:Sinh,backendName:"webgl",kernelFunc:sinh$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SOFTPLUS=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,softplus=unaryKernelFunc({opSnippet:SOFTPLUS}),softplusConfig={kernelName:Softplus$1,backendName:"webgl",kernelFunc:softplus};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spaceToBatchND=a=>{const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{blockShape:c,paddings:d}=s;assert$1(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const h=c.reduce((rt,it)=>rt*it),g=[[0,0]];g.push(...d);for(let rt=1+c.length;rt<o.shape.length;++rt)g.push([0,0]);const _=[],b=padV2({inputs:{x:o},backend:i,attrs:{paddings:g,constantValue:0}}),$=getReshaped(b.shape,c,h,!1),j=getPermuted($.length,c.length,!1),_e=getReshapedPermuted(b.shape,c,h,!1),tt=reshape$1({inputs:{x:b},backend:i,attrs:{shape:$}}),et=transpose$1({inputs:{x:tt},backend:i,attrs:{perm:j}}),nt=reshape$1({inputs:{x:et},backend:i,attrs:{shape:_e}});return _.push(b),_.push(tt),_.push(et),_.forEach(rt=>i.disposeIntermediateTensorInfo(rt)),nt},spaceToBatchNDConfig={kernelName:SpaceToBatchND,backendName:"webgl",kernelFunc:spaceToBatchND};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseToDense(a){const{inputs:e,backend:i,attrs:s}=a,{sparseIndices:o,sparseValues:c,defaultValue:d}=e,{outputShape:h}=s,{sliceRank:g,numUpdates:_,strides:b,outputSize:$}=calculateShapes(c,o,h),j=!1,_e=new ScatterProgram(_,g,o.shape.length,c.shape.length,b,[$,1],j),tt=i.runWebGLProgram(_e,[c,o,d],c.dtype),et=reshape$1({inputs:{x:tt},backend:i,attrs:{shape:h}});return i.disposeIntermediateTensorInfo(tt),et}const sparseToDenseConfig={kernelName:SparseToDense,backendName:"webgl",kernelFunc:sparseToDense};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function splitV(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{numOrSizeSplits:c,axis:d}=s,h=parseAxisParam(d,o.shape)[0],g=prepareSplitSize(o,c,h),_=o.shape.length,b=new Array(_).fill(0),$=o.shape.slice();return g.map(j=>{const _e=[...$];_e[h]=j;const tt=slice({inputs:{x:o},backend:i,attrs:{begin:b,size:_e}});return b[h]+=j,tt})}const splitVConfig={kernelName:SplitV,backendName:"webgl",kernelFunc:splitV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SQRT="return sqrt(x);",sqrt$2=unaryKernelFunc({opSnippet:SQRT}),sqrtConfig={kernelName:Sqrt,backendName:"webgl",kernelFunc:sqrt$2};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SQUARE="return x * x;",square=unaryKernelFunc({opSnippet:SQUARE}),squareConfig={kernelName:Square,backendName:"webgl",kernelFunc:square};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SQUARED_DIFFERENCE="return (a - b) * (a - b);",squaredDifference=binaryKernelFunc({opSnippet:SQUARED_DIFFERENCE,packedOpSnippet:SQUARED_DIFFERENCE}),squaredDifferenceConfig={kernelName:SquaredDifference,backendName:"webgl",kernelFunc:squaredDifference};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function step({inputs:a,attrs:e,backend:i}){const{x:s}=a,o=CHECK_NAN_SNIPPET$2+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,c=new UnaryOpProgram(s.shape,o);return i.runWebGLProgram(c,[s],s.dtype)}const stepConfig={kernelName:Step,backendName:"webgl",kernelFunc:step};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class StridedSliceProgram{constructor(e,i,s){this.variableNames=["x"],this.outputShape=s;const o=s.length,c=getCoordsDataType(s.length),d=getCoordsDataType(s.length);let h="";if(o===1)h="coords * strides + begin";else{let g=0;h=s.map((_,b)=>(g++,s.length===1?`coords * strides[${b}] + begin[${b}]`:`coords[${g-1}] * strides[${b}] + begin[${b}]`)).join(",")}this.userCode=`
      ${c} begin = ${c}(${e});
      ${c} strides = ${c}(${i});

      void main() {
        ${d} coords = getOutputCoords();
        setOutput(getX(${h}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSlice(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{begin:c,end:d,strides:h,beginMask:g,endMask:_,ellipsisMask:b,newAxisMask:$,shrinkAxisMask:j}=s,{nonStrided:_e,$begin:tt,$strides:et,size:nt,newShape:rt,outShape:it}=sliceInfo(o.shape,c,d,h,g,_,b,$,j),at=reshape$1({inputs:{x:o},backend:i,attrs:{shape:rt}});let st;if(_e){const ct=slice({inputs:{x:at},backend:i,attrs:{begin:tt,size:nt}});st=reshape$1({inputs:{x:ct},backend:i,attrs:{shape:it}}),i.disposeIntermediateTensorInfo(ct)}else if(it.some(ct=>ct===0))st=i.makeTensorInfo(it,o.dtype,[]);else if(i.shouldExecuteOnCPU([at])){const dt=i.texData.get(at.dataId).values,xt=buffer(at.shape,at.dtype,dt),ut=stridedSliceImplCPU(it,xt,et,tt);st=i.makeTensorInfo(it,at.dtype,ut.values)}else{const lt=new StridedSliceProgram(tt,et,it);st=i.runWebGLProgram(lt,[at],at.dtype)}const ot=reshape$1({inputs:{x:st},backend:i,attrs:{shape:it}});return i.disposeIntermediateTensorInfo(at),i.disposeIntermediateTensorInfo(st),ot}const stridedSliceConfig={kernelName:StridedSlice,backendName:"webgl",kernelFunc:stridedSlice};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TAN="return tan(x);",tan$1=unaryKernelFunc({opSnippet:TAN}),tanConfig={kernelName:Tan,backendName:"webgl",kernelFunc:tan$1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TANH=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,tanh$1=unaryKernelFunc({opSnippet:TANH}),tanhConfig={kernelName:Tanh$1,backendName:"webgl",kernelFunc:tanh$1};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TileProgram{constructor(e,i){this.variableNames=["A"];const s=new Array(e.length);for(let d=0;d<s.length;d++)s[d]=e[d]*i[d];this.outputShape=s,this.rank=s.length;const o=getCoordsDataType(this.rank),c=getSourceCoords(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${c}));
      }
    `}}function getSourceCoords(a){const e=a.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${a[0]})`;const i=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let o=0;o<a.length;o++)s.push(`imod(${i[o]}, ${a[o]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{reps:c}=s;if(o.dtype==="string"){const _=i.readSync(o.dataId).map(j=>decodeString(j)),b=buffer(o.shape,o.dtype,_),$=tileImplCPU(b,c);return i.makeTensorInfo($.shape,$.dtype,$.values)}const d=new TileProgram(o.shape,c);return i.runWebGLProgram(d,[o],o.dtype)}const tileConfig={kernelName:Tile,backendName:"webgl",kernelFunc:tile};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function topK(a){const{inputs:e,backend:i,attrs:s}=a,{x:o}=e,{k:c,sorted:d}=s,h=i.readSync(o.dataId),[g,_]=topKImplCPU(h,o.shape,o.dtype,c,d);return[i.makeTensorInfo(g.shape,g.dtype,g.values),i.makeTensorInfo(_.shape,_.dtype,_.values)]}const topKConfig={kernelName:TopK,backendName:"webgl",kernelFunc:topK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unique(a){const{inputs:e,attrs:i,backend:s}=a,{axis:o}=i,{x:c}=e;assertNotComplex(c,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const d=s.readSync(c.dataId),{outputValues:h,outputShape:g,indices:_}=uniqueImplCPU(d,o,c.shape,c.dtype);return[s.makeTensorInfo(g,c.dtype,h),s.makeTensorInfo([_.length],"int32",_)]}const uniqueConfig={kernelName:Unique,backendName:"webgl",kernelFunc:unique};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unpack(a){const{inputs:e,backend:i,attrs:s}=a,{value:o}=e;let{axis:c}=s;c<0&&(c+=o.shape.length);const d=o,h=d.shape.length,g=o.shape[c],_=new Array(h-1);let b=0;for(let et=0;et<h;et++)et!==c&&(_[b++]=d.shape[et]);const $=[],j=new Array(h).fill(0),_e=d.shape.slice();_e[c]=1;const tt=new Array(g);for(let et=0;et<tt.length;et++){j[c]=et;const nt=slice({inputs:{x:d},backend:i,attrs:{begin:j,size:_e}}),rt=reshape$1({inputs:{x:nt},backend:i,attrs:{shape:_}});tt[et]=rt,$.push(nt)}return $.forEach(et=>i.disposeIntermediateTensorInfo(et)),tt}const unpackConfig={kernelName:Unpack,backendName:"webgl",kernelFunc:unpack};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SegmentOpProgram{constructor(e,i){this.variableNames=["x","segmentIds"];const s=e.windowSize,o=e.batchSize,c=e.inSize,d=e.numSegments,h=d*Math.ceil(c/s);this.outputShape=[o,h];const g="0.0",_="sumValue",b=Math.floor(s/4)*4,$=s%4,j=`
        sumValue += dot(values, segFilter);
    `;let _e="";c%s>0&&(_e=`
        if (inIdx < 0 || inIdx >= ${c}) {
          return initializationValue;
        }
      `);let tt="";c%s>0&&(tt=`
        if (inIdx < 0 || inIdx >= ${c}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${g};

      float getValue(int batch, int inIdx) {
        ${_e}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${tt}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${d})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${d})));

        float sumValue = 0.0;

        for (int i = 0; i < ${b}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${j}
        }

        int inIdx = inOffset + ${b};
        if (${$===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${j}
        } else if (${$===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${j}
        } else if (${$===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${j}
        }
        setOutput(${_});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unsortedSegmentSum(a){const{inputs:e,backend:i,attrs:s}=a,{x:o,segmentIds:c}=e,{numSegments:d}=s,h=o.shape.length,g=[];let _=0;const b=getAxesPermutation([_],h);let $=o;b!=null&&($=transpose$1({inputs:{x:o},backend:i,attrs:{perm:b}}),g.push($),_=getInnerMostAxes(1,h)[0]);const j=computeOutShape($.shape,_,d),_e=sizeFromShape([$.shape[_]]),tt=reshape$1({inputs:{x:$},backend:i,attrs:{shape:[-1,_e]}});g.push(tt);const et=sumOutType(o.dtype),nt=(st,ot,ct,lt,dt)=>{const xt=st.shape[0],ut=st.shape[1],ft=segOpComputeOptimalWindowSize(ut,dt),mt={windowSize:ft,inSize:ut,batchSize:xt,numSegments:dt},yt=new SegmentOpProgram(mt,ot),St=i.compileAndRun(yt,[st,ct],lt);if(g.push(St),St.shape[1]===dt)return St;const Et=range$1({backend:i,attrs:{start:0,stop:dt,step:1,dtype:"float32"}}),vt=tile({inputs:{x:Et},backend:i,attrs:{reps:[ut/ft]}});return g.push(Et),g.push(vt),nt(St,ot,vt,lt,dt)},rt=nt(tt,"unsortedSegmentSum",c,et,d),it=reshape$1({inputs:{x:rt},backend:i,attrs:{shape:j}});let at=it;if(b!=null){g.push(it);const st=getUndoAxesPermutation(b);at=transpose$1({inputs:{x:at},backend:i,attrs:{perm:st}})}return g.forEach(st=>i.disposeIntermediateTensorInfo(st)),at}const unsortedSegmentSumConfig={kernelName:UnsortedSegmentSum,backendName:"webgl",kernelFunc:unsortedSegmentSum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kernelConfigs=[LRNConfig,LRNGradConfig,_fusedMatMulConfig,absConfig,acosConfig,acoshConfig,addConfig,addNConfig,allConfig,anyConfig,argMaxConfig,argMinConfig,asinConfig,asinhConfig,atan2Config,atanConfig,atanhConfig,avgPool3DConfig,avgPoolConfig,avgPoolGrad3DConfig,avgPoolGradConfig,batchMatMulConfig,batchNormConfig,batchToSpaceNDConfig,bincountConfig,castConfig,ceilConfig,clipByValueConfig,complexAbsConfig,complexConfig,concatConfig,conv2DBackpropFilterConfig,conv2DBackpropInputConfig,conv2DConfig,conv3DBackpropFilterV2Config,conv3DBackpropInputConfig,conv3DConfig,cosConfig,coshConfig,cropAndResizeConfig,cumsumConfig,denseBincountConfig,depthToSpaceConfig,depthwiseConv2dNativeBackpropFilterConfig,depthwiseConv2dNativeBackpropInputConfig,depthwiseConv2dNativeConfig,diagConfig,dilation2DConfig,eluConfig,eluGradConfig,equalConfig,erfConfig,expConfig,expandDimsConfig,expm1Config,fftConfig,fillConfig,flipLeftRightConfig,floorConfig,floorDivConfig,fromPixelsConfig,fusedConv2DConfig,fusedDepthwiseConv2DConfig,gatherNdConfig,gatherV2Config,greaterConfig,greaterEqualConfig,identityConfig,ifftConfig,imagConfig,isFiniteConfig,isInfConfig,isNaNConfig,leakyReluConfig,lessConfig,lessEqualConfig,linSpaceConfig,log1pConfig,logConfig,logicalAndConfig,logicalNotConfig,logicalOrConfig,maxConfig,maxPool3DConfig,maxPoolConfig,maxPoolGrad3DConfig,maxPoolGradConfig,maxPoolWithArgmaxConfig,maximumConfig,meanConfig,minConfig,minimumConfig,mirrorPadConfig,modConfig,multinomialConfig,multiplyConfig,negConfig,nonMaxSuppressionV3Config,nonMaxSuppressionV4Config,nonMaxSuppressionV5Config,notEqualConfig,oneHotConfig,onesLikeConfig,packConfig,padV2Config,powConfig,preluConfig,prodConfig,rangeConfig,realConfig,realDivConfig,reciprocalConfig,relu6Config,reluConfig,reshapeConfig,resizeBilinearConfig,resizeBilinearGradConfig,resizeNearestNeighborConfig,resizeNearestNeighborGradConfig,reverseConfig,rotateWithOffsetConfig,roundConfig,rsqrtConfig,scatterNdConfig,selectConfig,seluConfig,sigmoidConfig,signConfig,sinConfig,sinhConfig,sliceConfig,softmaxConfig,softplusConfig,spaceToBatchNDConfig,sparseToDenseConfig,splitVConfig,sqrtConfig,squareConfig,squaredDifferenceConfig,stepConfig,stridedSliceConfig,subConfig,sumConfig,tanConfig,tanhConfig,tileConfig,topKConfig,transposeConfig,uniqueConfig,unpackConfig,unsortedSegmentSumConfig,zerosLikeConfig];for(const a of kernelConfigs)registerKernel(a);/** @license See the LICENSE file. */const version$3="3.1.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const version$2={"tfjs-core":version$9,"tfjs-backend-cpu":version$5,"tfjs-backend-webgl":version$4,"tfjs-data":version$6,"tfjs-layers":version$8,"tfjs-converter":version$7,tfjs:version$3},a1_0x1cfc52=Object.freeze(Object.defineProperty({__proto__:null,Abs,Acos,Acosh,AdadeltaOptimizer,AdagradOptimizer,AdamOptimizer,AdamaxOptimizer,Add:Add$1,AddN,All,Any,ArgMax,ArgMin,Asin,Asinh,Atan,Atan2,Atanh,AvgPool,AvgPool3D,AvgPool3DGrad,AvgPoolGrad,BatchMatMul,BatchToSpaceND,Bincount,BroadcastTo,Callback,CallbackList,Cast,Ceil,ClipByValue,Complex:Complex$2,ComplexAbs,Concat,Conv2D:Conv2D$1,Conv2DBackpropFilter,Conv2DBackpropInput,Conv3D:Conv3D$1,Conv3DBackpropFilterV2,Conv3DBackpropInputV2,Cos,Cosh,CropAndResize,Cumsum,CustomCallback,DataStorage,DenseBincount,DepthToSpace,DepthwiseConv2dNative,DepthwiseConv2dNativeBackpropFilter,DepthwiseConv2dNativeBackpropInput,Diag,Dilation2D,Dilation2DBackpropFilter,Dilation2DBackpropInput,get ENV(){return ENV$2},EarlyStopping,Elu:Elu$1,EluGrad,Environment,Equal,Erf,Exp,ExpandDims,Expm1,FFT,Fill,FlipLeftRight,Floor,FloorDiv,FromPixels,FusedBatchNorm,FusedConv2D,FusedDepthwiseConv2D,GatherNd,GatherV2,GraphModel,Greater,GreaterEqual,History,IFFT,Identity:Identity$1,Imag,InputSpec,IsFinite,IsInf,IsNan,KernelBackend,LRN,LRNGrad,LayerVariable,LayersModel,LeakyRelu,Less,LessEqual,LinSpace,Log,Log1p,LogSoftmax:LogSoftmax$1,LogicalAnd,LogicalNot,LogicalOr,Max,MaxPool,MaxPool3D,MaxPool3DGrad,MaxPoolGrad,MaxPoolWithArgmax,Maximum:Maximum$1,Mean,Min,Minimum:Minimum$1,MirrorPad,Mod,MomentumOptimizer,Multinomial,Multiply:Multiply$1,Neg,NonMaxSuppressionV3,NonMaxSuppressionV4,NonMaxSuppressionV5,NotEqual,OP_SCOPE_SUFFIX,OneHot,OnesLike,Optimizer,Pack,PadV2,Pool,Pow,Prelu,Prod,RMSPropOptimizer,RNN,Range,get Rank(){return Rank},Real,RealDiv,Reciprocal,get Reduction(){return Reduction},Relu:Relu$1,Relu6:Relu6$1,Reshape:Reshape$1,ResizeBilinear,ResizeBilinearGrad,ResizeNearestNeighbor,ResizeNearestNeighborGrad,Reverse,RotateWithOffset,Round,Rsqrt,SGDOptimizer,ScatterNd,Select,Selu:Selu$1,Sequential,Sigmoid:Sigmoid$1,Sign,Sin,Sinh,Slice,Softmax:Softmax$2,Softplus:Softplus$1,SpaceToBatchND,SparseToDense,SplitV,Sqrt,Square,SquaredDifference,Step,StridedSlice,Sub,Sum,SymbolicTensor,Tan,Tanh:Tanh$1,Tensor,TensorBuffer,Tile,TopK,Transpose,Unique,Unpack,UnsortedSegmentSum,Variable,ZerosLike,_FusedMatMul,abs:abs$4,acos:acos$3,acosh:acosh$3,add:add$4,addN:addN$2,all:all$2,any:any$2,argMax:argMax$2,argMin:argMin$2,asin:asin$3,asinh:asinh$3,atan:atan$4,atan2:atan2$3,atanh:atanh$3,avgPool:avgPool$2,avgPool3d:avgPool3d$1,backend,backend_util,basicLSTMCell,batchNorm:batchNorm$2,batchNorm2d,batchNorm3d,batchNorm4d,batchToSpaceND:batchToSpaceND$2,bincount:bincount$2,booleanMaskAsync,broadcastTo,browser:browser$1,buffer,callbacks,cast:cast$3,ceil:ceil$3,clipByValue:clipByValue$1,clone:clone$2,complex:complex$4,concat:concat$3,concat1d,concat2d,concat3d,concat4d,constraints:exports_constraints,conv1d:conv1d$1,conv2d:conv2d$3,conv2dTranspose:conv2dTranspose$1,conv3d:conv3d$1,conv3dTranspose,copyRegisteredKernels,cos:cos$4,cosh:cosh$3,cosineWindow,cumsum:cumsum$2,customGrad,data:index,denseBincount:denseBincount$2,deprecationWarn,depthToSpace:depthToSpace$2,depthwiseConv2d:depthwiseConv2d$3,deregisterOp,device_util,diag:diag$3,dilation2d,disableDeprecationWarnings,dispose,disposeVariables,div:div$2,divNoNan,dot:dot$3,dropout:dropout$2,elu:elu$4,enableDebugMode,enableProdMode,enclosingPowerOfTwo,engine,env:env$1,equal:equal$3,erf:erf$2,exp:exp$3,expandDims:expandDims$3,expm1:expm1$2,eye,fft:fft$2,fill:fill$2,findBackend,findBackendFactory,floor:floor$3,floorDiv:floorDiv$2,fused:fused_ops,gather:gather$1,gatherND,gather_util:gather_nd_util,getBackend,getGradient,getKernel,getKernelsForBackend,grad,grads,greater:greater$3,greaterEqual:greaterEqual$2,ifft:ifft$2,imag:imag$2,image:image$1,inTopKAsync,initializers:exports_initializers,input,io,irfft,isFinite:isFinite$3,isInf:isInf$2,isNaN:isNaN$3,keep,kernel_impls,layers:exports_layers,leakyRelu:leakyRelu$2,less:less$3,lessEqual:lessEqual$2,linalg,linspace,loadGraphModel,loadLayersModel,localResponseNormalization,log:log$4,log1p:log1p$2,logSigmoid,logSoftmax,logSumExp,logicalAnd:logicalAnd$2,logicalNot:logicalNot$2,logicalOr:logicalOr$2,logicalXor,losses,matMul:matMul$1,math,max:max$4,maxPool:maxPool$2,maxPool3d:maxPool3d$1,maxPoolWithArgmax,maximum:maximum$3,mean:mean$1,memory,metrics:exports_metrics,min:min$4,minimum:minimum$3,mirrorPad:mirrorPad$1,mod:mod$3,model,models:exports_models,moments,movingAverage,mul:mul$1,multiRNNCell,multinomial:multinomial$2,neg:neg$2,nextFrame,norm:norm$1,notEqual:notEqual$2,oneHot:oneHot$2,ones:ones$1,onesLike:onesLike$2,op,outerProduct,pad,pad1d,pad2d,pad3d,pad4d,pool:pool$2,pow:pow$4,prelu:prelu$3,print,prod:prod$2,profile,rand,randomGamma,randomNormal:randomNormal$2,randomUniform:randomUniform$1,range:range$4,ready,real:real$2,reciprocal:reciprocal$2,registerBackend,registerCallbackConstructor,registerGradient,registerKernel,registerOp,regularizers:exports_regularizers,relu:relu$2,relu6:relu6$2,removeBackend,reshape:reshape$4,reverse:reverse$2,reverse1d,reverse2d,reverse3d,reverse4d,rfft,round:round$3,rsqrt:rsqrt$2,scalar,scatterND,scatter_util:scatter_nd_util,selu:selu$2,separableConv2d:separableConv2d$1,sequential,serialization,setBackend,setPlatform,setdiff1dAsync,sigmoid:sigmoid$2,sign:sign$5,signal,sin:sin$4,sinh:sinh$3,slice:slice$2,slice1d,slice2d,slice3d,slice4d,slice_util,softmax:softmax$3,softplus:softplus$2,spaceToBatchND:spaceToBatchND$2,sparseToDense:sparseToDense$2,spectral:spectral$1,split:split$1,sqrt:sqrt$4,square:square$2,squaredDifference:squaredDifference$2,squeeze:squeeze$1,stack,step:step$2,stridedSlice:stridedSlice$2,sub:sub$3,sum:sum$3,sumOutType,tan:tan$3,tanh:tanh$3,tensor,tensor1d,tensor2d,tensor3d,tensor4d,tensor5d,tensor6d,tensor_util,test_util,tidy,tile:tile$3,time,topk,train,transpose:transpose$3,truncatedNormal:truncatedNormal$1,unique:unique$3,unregisterGradient,unregisterKernel,unsortedSegmentSum:unsortedSegmentSum$2,unstack,upcastType,util:util$5,valueAndGrad,valueAndGrads,variable,variableGrads,version:version$2,version_converter:version$7,version_core:version$9,version_layers:version$8,where,whereAsync,zeros:zeros$4,zerosLike:zerosLike$2},Symbol.toStringTag,{value:"Module"}));function _extends(){return _extends=Object.assign?Object.assign.bind():function(a){for(var e=1;e<arguments.length;e++){var i=arguments[e];for(var s in i)({}).hasOwnProperty.call(i,s)&&(a[s]=i[s])}return a},_extends.apply(null,arguments)}var DEFAULT_CONFIG={epsilon:1e-12,matrix:"Matrix",number:"number",precision:64,predictable:!1,randomSeed:null};function isNumber(a){return typeof a=="number"}function isBigNumber(a){return!a||typeof a!="object"||typeof a.constructor!="function"?!1:a.isBigNumber===!0&&typeof a.constructor.prototype=="object"&&a.constructor.prototype.isBigNumber===!0||typeof a.constructor.isDecimal=="function"&&a.constructor.isDecimal(a)===!0}function isComplex(a){return a&&typeof a=="object"&&Object.getPrototypeOf(a).isComplex===!0||!1}function isFraction(a){return a&&typeof a=="object"&&Object.getPrototypeOf(a).isFraction===!0||!1}function isUnit(a){return a&&a.constructor.prototype.isUnit===!0||!1}function isString(a){return typeof a=="string"}var isArray=Array.isArray;function isMatrix(a){return a&&a.constructor.prototype.isMatrix===!0||!1}function isCollection(a){return Array.isArray(a)||isMatrix(a)}function isDenseMatrix(a){return a&&a.isDenseMatrix&&a.constructor.prototype.isMatrix===!0||!1}function isSparseMatrix(a){return a&&a.isSparseMatrix&&a.constructor.prototype.isMatrix===!0||!1}function isRange(a){return a&&a.constructor.prototype.isRange===!0||!1}function isIndex(a){return a&&a.constructor.prototype.isIndex===!0||!1}function isBoolean(a){return typeof a=="boolean"}function isResultSet(a){return a&&a.constructor.prototype.isResultSet===!0||!1}function isHelp(a){return a&&a.constructor.prototype.isHelp===!0||!1}function isFunction(a){return typeof a=="function"}function isDate(a){return a instanceof Date}function isRegExp(a){return a instanceof RegExp}function isObject$1(a){return!!(a&&typeof a=="object"&&a.constructor===Object&&!isComplex(a)&&!isFraction(a))}function isNull(a){return a===null}function isUndefined(a){return a===void 0}function isAccessorNode(a){return a&&a.isAccessorNode===!0&&a.constructor.prototype.isNode===!0||!1}function isArrayNode(a){return a&&a.isArrayNode===!0&&a.constructor.prototype.isNode===!0||!1}function isAssignmentNode(a){return a&&a.isAssignmentNode===!0&&a.constructor.prototype.isNode===!0||!1}function isBlockNode(a){return a&&a.isBlockNode===!0&&a.constructor.prototype.isNode===!0||!1}function isConditionalNode(a){return a&&a.isConditionalNode===!0&&a.constructor.prototype.isNode===!0||!1}function isConstantNode(a){return a&&a.isConstantNode===!0&&a.constructor.prototype.isNode===!0||!1}function isFunctionAssignmentNode(a){return a&&a.isFunctionAssignmentNode===!0&&a.constructor.prototype.isNode===!0||!1}function isFunctionNode(a){return a&&a.isFunctionNode===!0&&a.constructor.prototype.isNode===!0||!1}function isIndexNode(a){return a&&a.isIndexNode===!0&&a.constructor.prototype.isNode===!0||!1}function isNode(a){return a&&a.isNode===!0&&a.constructor.prototype.isNode===!0||!1}function isObjectNode(a){return a&&a.isObjectNode===!0&&a.constructor.prototype.isNode===!0||!1}function isOperatorNode(a){return a&&a.isOperatorNode===!0&&a.constructor.prototype.isNode===!0||!1}function isParenthesisNode(a){return a&&a.isParenthesisNode===!0&&a.constructor.prototype.isNode===!0||!1}function isRangeNode(a){return a&&a.isRangeNode===!0&&a.constructor.prototype.isNode===!0||!1}function isSymbolNode(a){return a&&a.isSymbolNode===!0&&a.constructor.prototype.isNode===!0||!1}function isChain(a){return a&&a.constructor.prototype.isChain===!0||!1}function typeOf(a){var e=typeof a;return e==="object"?a===null?"null":Array.isArray(a)?"Array":a instanceof Date?"Date":a instanceof RegExp?"RegExp":isBigNumber(a)?"BigNumber":isComplex(a)?"Complex":isFraction(a)?"Fraction":isMatrix(a)?"Matrix":isUnit(a)?"Unit":isIndex(a)?"Index":isRange(a)?"Range":isResultSet(a)?"ResultSet":isNode(a)?a.type:isChain(a)?"Chain":isHelp(a)?"Help":"Object":e==="function"?"Function":e}function clone$1(a){var e=typeof a;if(e==="number"||e==="string"||e==="boolean"||a===null||a===void 0)return a;if(typeof a.clone=="function")return a.clone();if(Array.isArray(a))return a.map(function(i){return clone$1(i)});if(a instanceof Date)return new Date(a.valueOf());if(isBigNumber(a))return a;if(a instanceof RegExp)throw new TypeError("Cannot clone "+a);return mapObject(a,clone$1)}function mapObject(a,e){var i={};for(var s in a)hasOwnProperty(a,s)&&(i[s]=e(a[s]));return i}function extend(a,e){for(var i in e)hasOwnProperty(e,i)&&(a[i]=e[i]);return a}function deepStrictEqual(a,e){var i,s,o;if(Array.isArray(a)){if(!Array.isArray(e)||a.length!==e.length)return!1;for(s=0,o=a.length;s<o;s++)if(!deepStrictEqual(a[s],e[s]))return!1;return!0}else{if(typeof a=="function")return a===e;if(a instanceof Object){if(Array.isArray(e)||!(e instanceof Object))return!1;for(i in a)if(!(i in e)||!deepStrictEqual(a[i],e[i]))return!1;for(i in e)if(!(i in a))return!1;return!0}else return a===e}}function hasOwnProperty(a,e){return a&&Object.hasOwnProperty.call(a,e)}function pickShallow(a,e){for(var i={},s=0;s<e.length;s++){var o=e[s],c=a[o];c!==void 0&&(i[o]=c)}return i}var MATRIX_OPTIONS=["Matrix","Array"],NUMBER_OPTIONS=["number","BigNumber","Fraction"],config$2=function(e){if(e)throw new Error(`The global config is readonly. 
Please create a mathjs instance if you want to change the default configuration. 
Example:

  import { create, all } from 'mathjs';
  const mathjs = create(all);
  mathjs.config({ number: 'BigNumber' });
`);return Object.freeze(DEFAULT_CONFIG)};_extends(config$2,DEFAULT_CONFIG,{MATRIX_OPTIONS,NUMBER_OPTIONS});var typedFunction$1={exports:{}};(function(a,e){(function(i,s){a.exports=s()})(commonjsGlobal$1,function(){function i(){return!0}function s(){return!1}function o(){}function c(){var d=[{name:"number",test:function(bt){return typeof bt=="number"}},{name:"string",test:function(bt){return typeof bt=="string"}},{name:"boolean",test:function(bt){return typeof bt=="boolean"}},{name:"Function",test:function(bt){return typeof bt=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(bt){return bt instanceof Date}},{name:"RegExp",test:function(bt){return bt instanceof RegExp}},{name:"Object",test:function(bt){return typeof bt=="object"&&bt!==null&&bt.constructor===Object}},{name:"null",test:function(bt){return bt===null}},{name:"undefined",test:function(bt){return bt===void 0}}],h={name:"any",test:i},g=[],_=[],b={types:d,conversions:_,ignore:g};function $(bt){var gt=sn(b.types,function(Lt){return Lt.name===bt});if(gt)return gt;if(bt==="any")return h;var Pt=sn(b.types,function(Lt){return Lt.name.toLowerCase()===bt.toLowerCase()});throw new TypeError('Unknown type "'+bt+'"'+(Pt?'. Did you mean "'+Pt.name+'"?':""))}function j(bt){return bt===h?999:b.types.indexOf(bt)}function _e(bt){var gt=sn(b.types,function(Pt){return Pt.test(bt)});if(gt)return gt.name;throw new TypeError("Value has unknown type. Value: "+bt)}function tt(bt,gt){if(!bt.signatures)throw new TypeError("Function is no typed-function");var Pt;if(typeof gt=="string"){Pt=gt.split(",");for(var Lt=0;Lt<Pt.length;Lt++)Pt[Lt]=Pt[Lt].trim()}else if(Array.isArray(gt))Pt=gt;else throw new TypeError("String array or a comma separated string expected");var Vt=Pt.join(","),jt=bt.signatures[Vt];if(jt)return jt;throw new TypeError("Signature not found (signature: "+(bt.name||"unnamed")+"("+Pt.join(", ")+"))")}function et(bt,gt){var Pt=_e(bt);if(gt===Pt)return bt;for(var Lt=0;Lt<b.conversions.length;Lt++){var Vt=b.conversions[Lt];if(Vt.from===Pt&&Vt.to===gt)return Vt.convert(bt)}throw new Error("Cannot convert from "+Pt+" to "+gt)}function nt(bt){return bt.map(function(gt){var Pt=gt.types.map(xt);return(gt.restParam?"...":"")+Pt.join("|")}).join(",")}function rt(bt,gt){var Pt=bt.indexOf("...")===0,Lt=Pt?bt.length>3?bt.slice(3):"any":bt,Vt=Lt.split("|").map(Ft).filter(Bt).filter(kt),jt=Nt(gt,Vt),cn=Vt.map(function(Zt){var yn=$(Zt);return{name:Zt,typeIndex:j(yn),test:yn.test,conversion:null,conversionIndex:-1}}),en=jt.map(function(Zt){var yn=$(Zt.from);return{name:Zt.from,typeIndex:j(yn),test:yn.test,conversion:Zt,conversionIndex:gt.indexOf(Zt)}});return{types:cn.concat(en),restParam:Pt}}function it(bt,gt,Pt){var Lt=[];return bt.trim()!==""&&(Lt=bt.split(",").map(Ft).map(function(Vt,jt,cn){var en=rt(Vt,Pt);if(en.restParam&&jt!==cn.length-1)throw new SyntaxError('Unexpected rest parameter "'+Vt+'": only allowed for the last parameter');return en})),Lt.some(Wt)?null:{params:Lt,fn:gt}}function at(bt){var gt=Rt(bt);return gt?gt.restParam:!1}function st(bt){return bt.types.some(function(gt){return gt.conversion!=null})}function ot(bt){if(!bt||bt.types.length===0)return i;if(bt.types.length===1)return $(bt.types[0].name).test;if(bt.types.length===2){var gt=$(bt.types[0].name).test,Pt=$(bt.types[1].name).test;return function(jt){return gt(jt)||Pt(jt)}}else{var Lt=bt.types.map(function(Vt){return $(Vt.name).test});return function(jt){for(var cn=0;cn<Lt.length;cn++)if(Lt[cn](jt))return!0;return!1}}}function ct(bt){var gt,Pt,Lt;if(at(bt)){gt=Ut(bt).map(ot);var Vt=gt.length,jt=ot(Rt(bt)),cn=function(en){for(var Zt=Vt;Zt<en.length;Zt++)if(!jt(en[Zt]))return!1;return!0};return function(Zt){for(var yn=0;yn<gt.length;yn++)if(!gt[yn](Zt[yn]))return!1;return cn(Zt)&&Zt.length>=Vt+1}}else return bt.length===0?function(Zt){return Zt.length===0}:bt.length===1?(Pt=ot(bt[0]),function(Zt){return Pt(Zt[0])&&Zt.length===1}):bt.length===2?(Pt=ot(bt[0]),Lt=ot(bt[1]),function(Zt){return Pt(Zt[0])&&Lt(Zt[1])&&Zt.length===2}):(gt=bt.map(ot),function(Zt){for(var yn=0;yn<gt.length;yn++)if(!gt[yn](Zt[yn]))return!1;return Zt.length===gt.length})}function lt(bt,gt){return gt<bt.params.length?bt.params[gt]:at(bt.params)?Rt(bt.params):null}function dt(bt,gt,Pt){var Lt=lt(bt,gt),Vt=Lt?Pt?Lt.types.filter(ut):Lt.types:[];return Vt.map(xt)}function xt(bt){return bt.name}function ut(bt){return bt.conversion===null||bt.conversion===void 0}function ft(bt,gt){var Pt=hn(gn(bt,function(Lt){return dt(Lt,gt,!1)}));return Pt.indexOf("any")!==-1?["any"]:Pt}function mt(bt,gt,Pt){var Lt,Vt,jt=bt||"unnamed",cn=Pt,en;for(en=0;en<gt.length;en++){var Zt=cn.filter(function(Pn){var Rn=ot(lt(Pn,en));return(en<Pn.params.length||at(Pn.params))&&Rn(gt[en])});if(Zt.length===0){if(Vt=ft(cn,en),Vt.length>0){var yn=_e(gt[en]);return Lt=new TypeError("Unexpected type of argument in function "+jt+" (expected: "+Vt.join(" or ")+", actual: "+yn+", index: "+en+")"),Lt.data={category:"wrongType",fn:jt,index:en,actual:yn,expected:Vt},Lt}}else cn=Zt}var pn=cn.map(function(Pn){return at(Pn.params)?1/0:Pn.params.length});if(gt.length<Math.min.apply(null,pn))return Vt=ft(cn,en),Lt=new TypeError("Too few arguments in function "+jt+" (expected: "+Vt.join(" or ")+", index: "+gt.length+")"),Lt.data={category:"tooFewArgs",fn:jt,index:gt.length,expected:Vt},Lt;var wn=Math.max.apply(null,pn);return gt.length>wn?(Lt=new TypeError("Too many arguments in function "+jt+" (expected: "+wn+", actual: "+gt.length+")"),Lt.data={category:"tooManyArgs",fn:jt,index:gt.length,expectedLength:wn},Lt):(Lt=new TypeError('Arguments of type "'+gt.join(", ")+'" do not match any of the defined signatures of function '+jt+"."),Lt.data={category:"mismatch",actual:gt.map(_e)},Lt)}function yt(bt){for(var gt=999,Pt=0;Pt<bt.types.length;Pt++)ut(bt.types[Pt])&&(gt=Math.min(gt,bt.types[Pt].typeIndex));return gt}function St(bt){for(var gt=999,Pt=0;Pt<bt.types.length;Pt++)ut(bt.types[Pt])||(gt=Math.min(gt,bt.types[Pt].conversionIndex));return gt}function Et(bt,gt){var Pt;return Pt=bt.restParam-gt.restParam,Pt!==0||(Pt=st(bt)-st(gt),Pt!==0)||(Pt=yt(bt)-yt(gt),Pt!==0)?Pt:St(bt)-St(gt)}function vt(bt,gt){var Pt=Math.min(bt.params.length,gt.params.length),Lt,Vt;if(Vt=bt.params.some(st)-gt.params.some(st),Vt!==0)return Vt;for(Lt=0;Lt<Pt;Lt++)if(Vt=st(bt.params[Lt])-st(gt.params[Lt]),Vt!==0)return Vt;for(Lt=0;Lt<Pt;Lt++)if(Vt=Et(bt.params[Lt],gt.params[Lt]),Vt!==0)return Vt;return bt.params.length-gt.params.length}function Nt(bt,gt){var Pt={};return bt.forEach(function(Lt){gt.indexOf(Lt.from)===-1&&gt.indexOf(Lt.to)!==-1&&!Pt[Lt.from]&&(Pt[Lt.from]=Lt)}),Object.keys(Pt).map(function(Lt){return Pt[Lt]})}function wt(bt,gt){var Pt=gt;if(bt.some(st)){var Lt=at(bt),Vt=bt.map($t);Pt=function(){for(var Zt=[],yn=Lt?arguments.length-1:arguments.length,pn=0;pn<yn;pn++)Zt[pn]=Vt[pn](arguments[pn]);return Lt&&(Zt[yn]=arguments[yn].map(Vt[yn])),gt.apply(this,Zt)}}var jt=Pt;if(at(bt)){var cn=bt.length-1;jt=function(){return Pt.apply(this,un(arguments,0,cn).concat([un(arguments,cn)]))}}return jt}function $t(bt){var gt,Pt,Lt,Vt,jt=[],cn=[];switch(bt.types.forEach(function(en){en.conversion&&(jt.push($(en.conversion.from).test),cn.push(en.conversion.convert))}),cn.length){case 0:return function(Zt){return Zt};case 1:return gt=jt[0],Lt=cn[0],function(Zt){return gt(Zt)?Lt(Zt):Zt};case 2:return gt=jt[0],Pt=jt[1],Lt=cn[0],Vt=cn[1],function(Zt){return gt(Zt)?Lt(Zt):Pt(Zt)?Vt(Zt):Zt};default:return function(Zt){for(var yn=0;yn<cn.length;yn++)if(jt[yn](Zt))return cn[yn](Zt);return Zt}}}function Ct(bt){var gt={};return bt.forEach(function(Pt){Pt.params.some(st)||Mt(Pt.params,!0).forEach(function(Lt){gt[nt(Lt)]=Pt.fn})}),gt}function Mt(bt,gt){function Pt(Lt,Vt,jt){if(Vt<Lt.length){var cn=Lt[Vt],en=gt?cn.types.filter(ut):cn.types,Zt;if(cn.restParam){var yn=en.filter(ut);Zt=yn.length<en.length?[yn,en]:[en]}else Zt=en.map(function(wn){return[wn]});return gn(Zt,function(wn){return Pt(Lt,Vt+1,jt.concat([wn]))})}else{var pn=jt.map(function(wn,Pn){return{types:wn,restParam:Pn===Lt.length-1&&at(Lt)}});return[pn]}}return Pt(bt,0,[])}function Ot(bt,gt){for(var Pt=Math.max(bt.params.length,gt.params.length),Lt=0;Lt<Pt;Lt++){var Vt=dt(bt,Lt,!0),jt=dt(gt,Lt,!0);if(!mn(Vt,jt))return!1}var cn=bt.params.length,en=gt.params.length,Zt=at(bt.params),yn=at(gt.params);return Zt?yn?cn===en:en>=cn:yn?cn>=en:cn===en}function Dt(bt,gt){if(Object.keys(gt).length===0)throw new SyntaxError("No signatures provided");var Pt=[];Object.keys(gt).map(function(ir){return it(ir,gt[ir],b.conversions)}).filter(Ht).forEach(function(ir){var It=sn(Pt,function(Gt){return Ot(Gt,ir)});if(It)throw new TypeError('Conflicting signatures "'+nt(It.params)+'" and "'+nt(ir.params)+'".');Pt.push(ir)});var Lt=gn(Pt,function(ir){var It=ir?Mt(ir.params,!1):[];return It.map(function(Gt){return{params:Gt,fn:ir.fn}})}).filter(Ht);Lt.sort(vt);var Vt=Lt[0]&&Lt[0].params.length<=2&&!at(Lt[0].params),jt=Lt[1]&&Lt[1].params.length<=2&&!at(Lt[1].params),cn=Lt[2]&&Lt[2].params.length<=2&&!at(Lt[2].params),en=Lt[3]&&Lt[3].params.length<=2&&!at(Lt[3].params),Zt=Lt[4]&&Lt[4].params.length<=2&&!at(Lt[4].params),yn=Lt[5]&&Lt[5].params.length<=2&&!at(Lt[5].params),pn=Vt&&jt&&cn&&en&&Zt&&yn,wn=Lt.map(function(ir){return ct(ir.params)}),Pn=Vt?ot(Lt[0].params[0]):s,Rn=jt?ot(Lt[1].params[0]):s,Sn=cn?ot(Lt[2].params[0]):s,On=en?ot(Lt[3].params[0]):s,Nn=Zt?ot(Lt[4].params[0]):s,rr=yn?ot(Lt[5].params[0]):s,Tt=Vt?ot(Lt[0].params[1]):s,Yt=jt?ot(Lt[1].params[1]):s,Jt=cn?ot(Lt[2].params[1]):s,an=en?ot(Lt[3].params[1]):s,fn=Zt?ot(Lt[4].params[1]):s,Cn=yn?ot(Lt[5].params[1]):s,vn=Lt.map(function(ir){return wt(ir.params,ir.fn)}),or=Vt?vn[0]:o,lr=jt?vn[1]:o,qn=cn?vn[2]:o,ur=en?vn[3]:o,er=Zt?vn[4]:o,mr=yn?vn[5]:o,xr=Vt?Lt[0].params.length:-1,gr=jt?Lt[1].params.length:-1,Tr=cn?Lt[2].params.length:-1,Cr=en?Lt[3].params.length:-1,fr=Zt?Lt[4].params.length:-1,wr=yn?Lt[5].params.length:-1,kr=pn?6:0,Ir=Lt.length,Dr=function(){for(var It=kr;It<Ir;It++)if(wn[It](arguments))return vn[It].apply(this,arguments);return b.onMismatch(bt,arguments,Lt)},Er=function ir(It,Gt){return arguments.length===xr&&Pn(It)&&Tt(Gt)?or.apply(ir,arguments):arguments.length===gr&&Rn(It)&&Yt(Gt)?lr.apply(ir,arguments):arguments.length===Tr&&Sn(It)&&Jt(Gt)?qn.apply(ir,arguments):arguments.length===Cr&&On(It)&&an(Gt)?ur.apply(ir,arguments):arguments.length===fr&&Nn(It)&&fn(Gt)?er.apply(ir,arguments):arguments.length===wr&&rr(It)&&Cn(Gt)?mr.apply(ir,arguments):Dr.apply(ir,arguments)};try{Object.defineProperty(Er,"name",{value:bt})}catch{}return Er.signatures=Ct(Lt),Er}function At(bt,gt,Pt){throw mt(bt,gt,Pt)}function kt(bt){return b.ignore.indexOf(bt)===-1}function Ft(bt){return bt.trim()}function Bt(bt){return!!bt}function Ht(bt){return bt!==null}function Wt(bt){return bt.types.length===0}function Ut(bt){return bt.slice(0,bt.length-1)}function Rt(bt){return bt[bt.length-1]}function un(bt,gt,Pt){return Array.prototype.slice.call(bt,gt,Pt)}function rn(bt,gt){return bt.indexOf(gt)!==-1}function mn(bt,gt){for(var Pt=0;Pt<bt.length;Pt++)if(rn(gt,bt[Pt]))return!0;return!1}function sn(bt,gt){for(var Pt=0;Pt<bt.length;Pt++)if(gt(bt[Pt]))return bt[Pt]}function hn(bt){for(var gt={},Pt=0;Pt<bt.length;Pt++)gt[bt[Pt]]=!0;return Object.keys(gt)}function gn(bt,gt){return Array.prototype.concat.apply([],bt.map(gt))}function Xt(bt){for(var gt="",Pt=0;Pt<bt.length;Pt++){var Lt=bt[Pt];if((typeof Lt.signatures=="object"||typeof Lt.signature=="string")&&Lt.name!==""){if(gt==="")gt=Lt.name;else if(gt!==Lt.name){var Vt=new Error("Function names do not match (expected: "+gt+", actual: "+Lt.name+")");throw Vt.data={actual:Lt.name,expected:gt},Vt}}}return gt}function En(bt){var gt,Pt={};function Lt(en,Zt){if(Pt.hasOwnProperty(en)&&Zt!==Pt[en])throw gt=new Error('Signature "'+en+'" is defined twice'),gt.data={signature:en},gt}for(var Vt=0;Vt<bt.length;Vt++){var jt=bt[Vt];if(typeof jt.signatures=="object")for(var cn in jt.signatures)jt.signatures.hasOwnProperty(cn)&&(Lt(cn,jt.signatures[cn]),Pt[cn]=jt.signatures[cn]);else if(typeof jt.signature=="string")Lt(jt.signature,jt),Pt[jt.signature]=jt;else throw gt=new TypeError("Function is no typed-function (index: "+Vt+")"),gt.data={index:Vt},gt}return Pt}return b=Dt("typed",{"string, Object":Dt,Object:function(bt){var gt=[];for(var Pt in bt)bt.hasOwnProperty(Pt)&&gt.push(bt[Pt]);var Lt=Xt(gt);return Dt(Lt,bt)},"...Function":function(bt){return Dt(Xt(bt),En(bt))},"string, ...Function":function(bt,gt){return Dt(bt,En(gt))}}),b.create=c,b.types=d,b.conversions=_,b.ignore=g,b.onMismatch=At,b.throwMismatchError=At,b.createError=mt,b.convert=et,b.find=tt,b.addType=function(bt,gt){if(!bt||typeof bt.name!="string"||typeof bt.test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");if(gt!==!1){for(var Pt=0;Pt<b.types.length;Pt++)if(b.types[Pt].name==="Object"){b.types.splice(Pt,0,bt);return}}b.types.push(bt)},b.addConversion=function(bt){if(!bt||typeof bt.from!="string"||typeof bt.to!="string"||typeof bt.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");b.conversions.push(bt)},b}return c()})})(typedFunction$1);var typedFunctionExports=typedFunction$1.exports;const typedFunction=getDefaultExportFromCjs$1(typedFunctionExports);function isInteger(a){return typeof a=="boolean"?!0:isFinite(a)?a===Math.round(a):!1}var sign$2=Math.sign||function(a){return a>0?1:a<0?-1:0};function formatNumberToBase(a,e,i){var s={2:"0b",8:"0o",16:"0x"},o=s[e],c="";if(i){if(i<1)throw new Error("size must be in greater than 0");if(!isInteger(i))throw new Error("size must be an integer");if(a>2**(i-1)-1||a<-(2**(i-1)))throw new Error("Value must be in range [-2^".concat(i-1,", 2^").concat(i-1,"-1]"));if(!isInteger(a))throw new Error("Value must be an integer");a<0&&(a=a+2**i),c="i".concat(i)}var d="";return a<0&&(a=-a,d="-"),"".concat(d).concat(o).concat(a.toString(e)).concat(c)}function format$2(a,e){if(typeof e=="function")return e(a);if(a===1/0)return"Infinity";if(a===-1/0)return"-Infinity";if(isNaN(a))return"NaN";var i="auto",s,o;if(e&&(e.notation&&(i=e.notation),isNumber(e)?s=e:isNumber(e.precision)&&(s=e.precision),e.wordSize&&(o=e.wordSize,typeof o!="number")))throw new Error('Option "wordSize" must be a number');switch(i){case"fixed":return toFixed$1(a,s);case"exponential":return toExponential$1(a,s);case"engineering":return toEngineering$1(a,s);case"bin":return formatNumberToBase(a,2,o);case"oct":return formatNumberToBase(a,8,o);case"hex":return formatNumberToBase(a,16,o);case"auto":return toPrecision(a,s,e&&e).replace(/((\.\d*?)(0+))($|e)/,function(){var c=arguments[2],d=arguments[4];return c!=="."?c+d:d});default:throw new Error('Unknown notation "'+i+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function splitNumber(a){var e=String(a).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);if(!e)throw new SyntaxError("Invalid number "+a);var i=e[1],s=e[2],o=parseFloat(e[4]||"0"),c=s.indexOf(".");o+=c!==-1?c-1:s.length-1;var d=s.replace(".","").replace(/^0*/,function(h){return o-=h.length,""}).replace(/0*$/,"").split("").map(function(h){return parseInt(h)});return d.length===0&&(d.push(0),o++),{sign:i,coefficients:d,exponent:o}}function toEngineering$1(a,e){if(isNaN(a)||!isFinite(a))return String(a);var i=splitNumber(a),s=roundDigits(i,e),o=s.exponent,c=s.coefficients,d=o%3===0?o:o<0?o-3-o%3:o-o%3;if(isNumber(e))for(;e>c.length||o-d+1>c.length;)c.push(0);else for(var h=Math.abs(o-d)-(c.length-1),g=0;g<h;g++)c.push(0);for(var _=Math.abs(o-d),b=1;_>0;)b++,_--;var $=c.slice(b).join(""),j=isNumber(e)&&$.length||$.match(/[1-9]/)?"."+$:"",_e=c.slice(0,b).join("")+j+"e"+(o>=0?"+":"")+d.toString();return s.sign+_e}function toFixed$1(a,e){if(isNaN(a)||!isFinite(a))return String(a);var i=splitNumber(a),s=typeof e=="number"?roundDigits(i,i.exponent+1+e):i,o=s.coefficients,c=s.exponent+1,d=c+(e||0);return o.length<d&&(o=o.concat(zeros$1(d-o.length))),c<0&&(o=zeros$1(-c+1).concat(o),c=1),c<o.length&&o.splice(c,0,c===0?"0.":"."),s.sign+o.join("")}function toExponential$1(a,e){if(isNaN(a)||!isFinite(a))return String(a);var i=splitNumber(a),s=e?roundDigits(i,e):i,o=s.coefficients,c=s.exponent;o.length<e&&(o=o.concat(zeros$1(e-o.length)));var d=o.shift();return s.sign+d+(o.length>0?"."+o.join(""):"")+"e"+(c>=0?"+":"")+c}function toPrecision(a,e,i){if(isNaN(a)||!isFinite(a))return String(a);var s=i&&i.lowerExp!==void 0?i.lowerExp:-3,o=i&&i.upperExp!==void 0?i.upperExp:5,c=splitNumber(a),d=e?roundDigits(c,e):c;if(d.exponent<s||d.exponent>=o)return toExponential$1(a,e);var h=d.coefficients,g=d.exponent;h.length<e&&(h=h.concat(zeros$1(e-h.length))),h=h.concat(zeros$1(g-h.length+1+(h.length<e?e-h.length:0))),h=zeros$1(-g).concat(h);var _=g>0?g:0;return _<h.length-1&&h.splice(_+1,0,"."),d.sign+h.join("")}function roundDigits(a,e){for(var i={sign:a.sign,coefficients:a.coefficients,exponent:a.exponent},s=i.coefficients;e<=0;)s.unshift(0),i.exponent++,e++;if(s.length>e){var o=s.splice(e,s.length-e);if(o[0]>=5){var c=e-1;for(s[c]++;s[c]===10;)s.pop(),c===0&&(s.unshift(0),i.exponent++,c++),c--,s[c]++}}return i}function zeros$1(a){for(var e=[],i=0;i<a;i++)e.push(0);return e}function digits(a){return a.toExponential().replace(/e.*$/,"").replace(/^0\.?0*|\./,"").length}var DBL_EPSILON=Number.EPSILON||2220446049250313e-31;function nearlyEqual$1(a,e,i){if(i==null)return a===e;if(a===e)return!0;if(isNaN(a)||isNaN(e))return!1;if(isFinite(a)&&isFinite(e)){var s=Math.abs(a-e);return s<DBL_EPSILON?!0:s<=Math.max(Math.abs(a),Math.abs(e))*i}return!1}function formatBigNumberToBase(a,e,i){var s=a.constructor,o=new s(2),c="";if(i){if(i<1)throw new Error("size must be in greater than 0");if(!isInteger(i))throw new Error("size must be an integer");if(a.greaterThan(o.pow(i-1).sub(1))||a.lessThan(o.pow(i-1).mul(-1)))throw new Error("Value must be in range [-2^".concat(i-1,", 2^").concat(i-1,"-1]"));if(!a.isInteger())throw new Error("Value must be an integer");a.lessThan(0)&&(a=a.add(o.pow(i))),c="i".concat(i)}switch(e){case 2:return"".concat(a.toBinary()).concat(c);case 8:return"".concat(a.toOctal()).concat(c);case 16:return"".concat(a.toHexadecimal()).concat(c);default:throw new Error("Base ".concat(e," not supported "))}}function format$1(a,e){if(typeof e=="function")return e(a);if(!a.isFinite())return a.isNaN()?"NaN":a.gt(0)?"Infinity":"-Infinity";var i="auto",s,o;if(e!==void 0&&(e.notation&&(i=e.notation),typeof e=="number"?s=e:e.precision&&(s=e.precision),e.wordSize&&(o=e.wordSize,typeof o!="number")))throw new Error('Option "wordSize" must be a number');switch(i){case"fixed":return toFixed(a,s);case"exponential":return toExponential(a,s);case"engineering":return toEngineering(a,s);case"bin":return formatBigNumberToBase(a,2,o);case"oct":return formatBigNumberToBase(a,8,o);case"hex":return formatBigNumberToBase(a,16,o);case"auto":{var c=e&&e.lowerExp!==void 0?e.lowerExp:-3,d=e&&e.upperExp!==void 0?e.upperExp:5;if(a.isZero())return"0";var h,g=a.toSignificantDigits(s),_=g.e;return _>=c&&_<d?h=g.toFixed():h=toExponential(a,s),h.replace(/((\.\d*?)(0+))($|e)/,function(){var b=arguments[2],$=arguments[4];return b!=="."?b+$:$})}default:throw new Error('Unknown notation "'+i+'". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.')}}function toEngineering(a,e){var i=a.e,s=i%3===0?i:i<0?i-3-i%3:i-i%3,o=a.mul(Math.pow(10,-s)),c=o.toPrecision(e);return c.indexOf("e")!==-1&&(c=o.toString()),c+"e"+(i>=0?"+":"")+s.toString()}function toExponential(a,e){return e!==void 0?a.toExponential(e-1):a.toExponential()}function toFixed(a,e){return a.toFixed(e)}function format(a,e){if(typeof a=="number")return format$2(a,e);if(isBigNumber(a))return format$1(a,e);if(looksLikeFraction(a))return!e||e.fraction!=="decimal"?a.s*a.n+"/"+a.d:a.toString();if(Array.isArray(a))return formatArray(a,e);if(isString(a))return'"'+a+'"';if(typeof a=="function")return a.syntax?String(a.syntax):"function";if(a&&typeof a=="object"){if(typeof a.format=="function")return a.format(e);if(a&&a.toString(e)!=={}.toString())return a.toString(e);var i=Object.keys(a).map(s=>'"'+s+'": '+format(a[s],e));return"{"+i.join(", ")+"}"}return String(a)}function formatArray(a,e){if(Array.isArray(a)){for(var i="[",s=a.length,o=0;o<s;o++)o!==0&&(i+=", "),i+=formatArray(a[o],e);return i+="]",i}else return format(a,e)}function looksLikeFraction(a){return a&&typeof a=="object"&&typeof a.s=="number"&&typeof a.n=="number"&&typeof a.d=="number"||!1}function DimensionError(a,e,i){if(!(this instanceof DimensionError))throw new SyntaxError("Constructor must be called with the new operator");this.actual=a,this.expected=e,this.relation=i,this.message="Dimension mismatch ("+(Array.isArray(a)?"["+a.join(", ")+"]":a)+" "+(this.relation||"!=")+" "+(Array.isArray(e)?"["+e.join(", ")+"]":e)+")",this.stack=new Error().stack}DimensionError.prototype=new RangeError;DimensionError.prototype.constructor=RangeError;DimensionError.prototype.name="DimensionError";DimensionError.prototype.isDimensionError=!0;function IndexError(a,e,i){if(!(this instanceof IndexError))throw new SyntaxError("Constructor must be called with the new operator");this.index=a,arguments.length<3?(this.min=0,this.max=e):(this.min=e,this.max=i),this.min!==void 0&&this.index<this.min?this.message="Index out of range ("+this.index+" < "+this.min+")":this.max!==void 0&&this.index>=this.max?this.message="Index out of range ("+this.index+" > "+(this.max-1)+")":this.message="Index out of range ("+this.index+")",this.stack=new Error().stack}IndexError.prototype=new RangeError;IndexError.prototype.constructor=RangeError;IndexError.prototype.name="IndexError";IndexError.prototype.isIndexError=!0;function arraySize(a){for(var e=[];Array.isArray(a);)e.push(a.length),a=a[0];return e}function _validate(a,e,i){var s,o=a.length;if(o!==e[i])throw new DimensionError(o,e[i]);if(i<e.length-1){var c=i+1;for(s=0;s<o;s++){var d=a[s];if(!Array.isArray(d))throw new DimensionError(e.length-1,e.length,"<");_validate(a[s],e,c)}}else for(s=0;s<o;s++)if(Array.isArray(a[s]))throw new DimensionError(e.length+1,e.length,">")}function validate(a,e){var i=e.length===0;if(i){if(Array.isArray(a))throw new DimensionError(a.length,0)}else _validate(a,e,0)}function validateIndex(a,e){if(!isNumber(a)||!isInteger(a))throw new TypeError("Index must be an integer (value: "+a+")");if(a<0||typeof e=="number"&&a>=e)throw new IndexError(a,e)}function resize(a,e,i){if(!Array.isArray(a)||!Array.isArray(e))throw new TypeError("Array expected");if(e.length===0)throw new Error("Resizing to scalar is not supported");e.forEach(function(o){if(!isNumber(o)||!isInteger(o)||o<0)throw new TypeError("Invalid size, must contain positive integers (size: "+format(e)+")")});var s=i!==void 0?i:0;return _resize(a,e,0,s),a}function _resize(a,e,i,s){var o,c,d=a.length,h=e[i],g=Math.min(d,h);if(a.length=h,i<e.length-1){var _=i+1;for(o=0;o<g;o++)c=a[o],Array.isArray(c)||(c=[c],a[o]=c),_resize(c,e,_,s);for(o=g;o<h;o++)c=[],a[o]=c,_resize(c,e,_,s)}else{for(o=0;o<g;o++)for(;Array.isArray(a[o]);)a[o]=a[o][0];for(o=g;o<h;o++)a[o]=s}}function reshape(a,e){var i=flatten$1(a),s=i.length;if(!Array.isArray(a)||!Array.isArray(e))throw new TypeError("Array expected");if(e.length===0)throw new DimensionError(0,s,"!=");e=processSizesWildcard(e,s);var o=product(e);if(s!==o)throw new DimensionError(o,s,"!=");try{return _reshape(i,e)}catch(c){throw c instanceof DimensionError?new DimensionError(o,s,"!="):c}}function processSizesWildcard(a,e){var i=product(a),s=a.slice(),o=-1,c=a.indexOf(o),d=a.indexOf(o,c+1)>=0;if(d)throw new Error("More than one wildcard in sizes");var h=c>=0,g=e%i===0;if(h)if(g)s[c]=-e/i;else throw new Error("Could not replace wildcard, since "+e+" is no multiple of "+-i);return s}function product(a){return a.reduce((e,i)=>e*i,1)}function _reshape(a,e){for(var i=a,s,o=e.length-1;o>0;o--){var c=e[o];s=[];for(var d=i.length/c,h=0;h<d;h++)s.push(i.slice(h*c,(h+1)*c));i=s}return i}function squeeze(a,e){for(var i=arraySize(a);Array.isArray(a)&&a.length===1;)a=a[0],i.shift();for(var s=i.length;i[s-1]===1;)s--;return s<i.length&&(a=_squeeze(a,s,0),i.length=s),a}function _squeeze(a,e,i){var s,o;if(i<e){var c=i+1;for(s=0,o=a.length;s<o;s++)a[s]=_squeeze(a[s],e,c)}else for(;Array.isArray(a);)a=a[0];return a}function unsqueeze(a,e,i,s){var o=s||arraySize(a);if(i)for(var c=0;c<i;c++)a=[a],o.unshift(1);for(a=_unsqueeze(a,e,0);o.length<e;)o.push(1);return a}function _unsqueeze(a,e,i){var s,o;if(Array.isArray(a)){var c=i+1;for(s=0,o=a.length;s<o;s++)a[s]=_unsqueeze(a[s],e,c)}else for(var d=i;d<e;d++)a=[a];return a}function flatten$1(a){if(!Array.isArray(a))return a;var e=[];return a.forEach(function i(s){Array.isArray(s)?s.forEach(i):e.push(s)}),e}function getArrayDataType(a,e){for(var i,s=0,o=0;o<a.length;o++){var c=a[o],d=Array.isArray(c);if(o===0&&d&&(s=c.length),d&&c.length!==s)return;var h=d?getArrayDataType(c,e):e(c);if(i===void 0)i=h;else if(i!==h)return"mixed"}return i}function factory$1(a,e,i,s){function o(c){var d=pickShallow(c,e.map(stripOptionalNotation));return assertDependencies(a,e,c),i(d)}return o.isFactory=!0,o.fn=a,o.dependencies=e.slice().sort(),s&&(o.meta=s),o}function assertDependencies(a,e,i){var s=e.filter(c=>!isOptionalDependency(c)).every(c=>i[c]!==void 0);if(!s){var o=e.filter(c=>i[c]===void 0);throw new Error('Cannot create function "'.concat(a,'", ')+"some dependencies are missing: ".concat(o.map(c=>'"'.concat(c,'"')).join(", "),"."))}}function isOptionalDependency(a){return a&&a[0]==="?"}function stripOptionalNotation(a){return a&&a[0]==="?"?a.slice(1):a}function getSafeProperty(a,e){if(isPlainObject(a)&&isSafeProperty(a,e))return a[e];throw typeof a[e]=="function"&&isSafeMethod(a,e)?new Error('Cannot access method "'+e+'" as a property'):new Error('No access to property "'+e+'"')}function setSafeProperty(a,e,i){if(isPlainObject(a)&&isSafeProperty(a,e))return a[e]=i,i;throw new Error('No access to property "'+e+'"')}function hasSafeProperty(a,e){return e in a}function isSafeProperty(a,e){return!a||typeof a!="object"?!1:hasOwnProperty(safeNativeProperties,e)?!0:!(e in Object.prototype||e in Function.prototype)}function isSafeMethod(a,e){return a==null||typeof a[e]!="function"||hasOwnProperty(a,e)&&Object.getPrototypeOf&&e in Object.getPrototypeOf(a)?!1:hasOwnProperty(safeNativeMethods,e)?!0:!(e in Object.prototype||e in Function.prototype)}function isPlainObject(a){return typeof a=="object"&&a&&a.constructor===Object}var safeNativeProperties={length:!0,name:!0},safeNativeMethods={toString:!0,valueOf:!0,toLocaleString:!0};class ObjectWrappingMap{constructor(e){this.wrappedObject=e}keys(){return Object.keys(this.wrappedObject)}get(e){return getSafeProperty(this.wrappedObject,e)}set(e,i){return setSafeProperty(this.wrappedObject,e,i),this}has(e){return hasSafeProperty(this.wrappedObject,e)}}function isMap(a){return a?a instanceof Map||a instanceof ObjectWrappingMap||typeof a.set=="function"&&typeof a.get=="function"&&typeof a.keys=="function"&&typeof a.has=="function":!1}var _createTyped2=function(){return _createTyped2=typedFunction.create,typedFunction},dependencies$17=["?BigNumber","?Complex","?DenseMatrix","?Fraction"],createTyped=factory$1("typed",dependencies$17,function(e){var{BigNumber:i,Complex:s,DenseMatrix:o,Fraction:c}=e,d=_createTyped2();return d.types=[{name:"number",test:isNumber},{name:"Complex",test:isComplex},{name:"BigNumber",test:isBigNumber},{name:"Fraction",test:isFraction},{name:"Unit",test:isUnit},{name:"string",test:isString},{name:"Chain",test:isChain},{name:"Array",test:isArray},{name:"Matrix",test:isMatrix},{name:"DenseMatrix",test:isDenseMatrix},{name:"SparseMatrix",test:isSparseMatrix},{name:"Range",test:isRange},{name:"Index",test:isIndex},{name:"boolean",test:isBoolean},{name:"ResultSet",test:isResultSet},{name:"Help",test:isHelp},{name:"function",test:isFunction},{name:"Date",test:isDate},{name:"RegExp",test:isRegExp},{name:"null",test:isNull},{name:"undefined",test:isUndefined},{name:"AccessorNode",test:isAccessorNode},{name:"ArrayNode",test:isArrayNode},{name:"AssignmentNode",test:isAssignmentNode},{name:"BlockNode",test:isBlockNode},{name:"ConditionalNode",test:isConditionalNode},{name:"ConstantNode",test:isConstantNode},{name:"FunctionNode",test:isFunctionNode},{name:"FunctionAssignmentNode",test:isFunctionAssignmentNode},{name:"IndexNode",test:isIndexNode},{name:"Node",test:isNode},{name:"ObjectNode",test:isObjectNode},{name:"OperatorNode",test:isOperatorNode},{name:"ParenthesisNode",test:isParenthesisNode},{name:"RangeNode",test:isRangeNode},{name:"SymbolNode",test:isSymbolNode},{name:"Map",test:isMap},{name:"Object",test:isObject$1}],d.conversions=[{from:"number",to:"BigNumber",convert:function(g){if(i||throwNoBignumber(g),digits(g)>15)throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: "+g+"). Use function bignumber(x) to convert to BigNumber.");return new i(g)}},{from:"number",to:"Complex",convert:function(g){return s||throwNoComplex(g),new s(g,0)}},{from:"number",to:"string",convert:function(g){return g+""}},{from:"BigNumber",to:"Complex",convert:function(g){return s||throwNoComplex(g),new s(g.toNumber(),0)}},{from:"Fraction",to:"BigNumber",convert:function(g){throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.")}},{from:"Fraction",to:"Complex",convert:function(g){return s||throwNoComplex(g),new s(g.valueOf(),0)}},{from:"number",to:"Fraction",convert:function(g){c||throwNoFraction(g);var _=new c(g);if(_.valueOf()!==g)throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: "+g+"). Use function fraction(x) to convert to Fraction.");return _}},{from:"string",to:"number",convert:function(g){var _=Number(g);if(isNaN(_))throw new Error('Cannot convert "'+g+'" to a number');return _}},{from:"string",to:"BigNumber",convert:function(g){i||throwNoBignumber(g);try{return new i(g)}catch{throw new Error('Cannot convert "'+g+'" to BigNumber')}}},{from:"string",to:"Fraction",convert:function(g){c||throwNoFraction(g);try{return new c(g)}catch{throw new Error('Cannot convert "'+g+'" to Fraction')}}},{from:"string",to:"Complex",convert:function(g){s||throwNoComplex(g);try{return new s(g)}catch{throw new Error('Cannot convert "'+g+'" to Complex')}}},{from:"boolean",to:"number",convert:function(g){return+g}},{from:"boolean",to:"BigNumber",convert:function(g){return i||throwNoBignumber(g),new i(+g)}},{from:"boolean",to:"Fraction",convert:function(g){return c||throwNoFraction(g),new c(+g)}},{from:"boolean",to:"string",convert:function(g){return String(g)}},{from:"Array",to:"Matrix",convert:function(g){return o||throwNoMatrix(),new o(g)}},{from:"Matrix",to:"Array",convert:function(g){return g.valueOf()}}],d});function throwNoBignumber(a){throw new Error("Cannot convert value ".concat(a," into a BigNumber: no class 'BigNumber' provided"))}function throwNoComplex(a){throw new Error("Cannot convert value ".concat(a," into a Complex number: no class 'Complex' provided"))}function throwNoMatrix(){throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided")}function throwNoFraction(a){throw new Error("Cannot convert value ".concat(a," into a Fraction, no class 'Fraction' provided."))}/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */var EXP_LIMIT=9e15,MAX_DIGITS=1e9,NUMERALS="0123456789abcdef",LN10="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",PI="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",DEFAULTS={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-EXP_LIMIT,maxE:EXP_LIMIT,crypto:!1},inexact,quadrant,external=!0,decimalError="[DecimalError] ",invalidArgument=decimalError+"Invalid argument: ",precisionLimitExceeded=decimalError+"Precision limit exceeded",cryptoUnavailable=decimalError+"crypto unavailable",tag="[object Decimal]",mathfloor=Math.floor,mathpow=Math.pow,isBinary=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,isHex=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,isOctal=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,isDecimal=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,BASE=1e7,LOG_BASE=7,MAX_SAFE_INTEGER=9007199254740991,LN10_PRECISION=LN10.length-1,PI_PRECISION=PI.length-1,P$1={toStringTag:tag};P$1.absoluteValue=P$1.abs=function(){var a=new this.constructor(this);return a.s<0&&(a.s=1),finalise(a)};P$1.ceil=function(){return finalise(new this.constructor(this),this.e+1,2)};P$1.clampedTo=P$1.clamp=function(a,e){var i,s=this,o=s.constructor;if(a=new o(a),e=new o(e),!a.s||!e.s)return new o(NaN);if(a.gt(e))throw Error(invalidArgument+e);return i=s.cmp(a),i<0?a:s.cmp(e)>0?e:new o(s)};P$1.comparedTo=P$1.cmp=function(a){var e,i,s,o,c=this,d=c.d,h=(a=new c.constructor(a)).d,g=c.s,_=a.s;if(!d||!h)return!g||!_?NaN:g!==_?g:d===h?0:!d^g<0?1:-1;if(!d[0]||!h[0])return d[0]?g:h[0]?-_:0;if(g!==_)return g;if(c.e!==a.e)return c.e>a.e^g<0?1:-1;for(s=d.length,o=h.length,e=0,i=s<o?s:o;e<i;++e)if(d[e]!==h[e])return d[e]>h[e]^g<0?1:-1;return s===o?0:s>o^g<0?1:-1};P$1.cosine=P$1.cos=function(){var a,e,i=this,s=i.constructor;return i.d?i.d[0]?(a=s.precision,e=s.rounding,s.precision=a+Math.max(i.e,i.sd())+LOG_BASE,s.rounding=1,i=cosine(s,toLessThanHalfPi(s,i)),s.precision=a,s.rounding=e,finalise(quadrant==2||quadrant==3?i.neg():i,a,e,!0)):new s(1):new s(NaN)};P$1.cubeRoot=P$1.cbrt=function(){var a,e,i,s,o,c,d,h,g,_,b=this,$=b.constructor;if(!b.isFinite()||b.isZero())return new $(b);for(external=!1,c=b.s*mathpow(b.s*b,1/3),!c||Math.abs(c)==1/0?(i=digitsToString(b.d),a=b.e,(c=(a-i.length+1)%3)&&(i+=c==1||c==-2?"0":"00"),c=mathpow(i,1/3),a=mathfloor((a+1)/3)-(a%3==(a<0?-1:2)),c==1/0?i="5e"+a:(i=c.toExponential(),i=i.slice(0,i.indexOf("e")+1)+a),s=new $(i),s.s=b.s):s=new $(c.toString()),d=(a=$.precision)+3;;)if(h=s,g=h.times(h).times(h),_=g.plus(b),s=divide$1(_.plus(b).times(h),_.plus(g),d+2,1),digitsToString(h.d).slice(0,d)===(i=digitsToString(s.d)).slice(0,d))if(i=i.slice(d-3,d+1),i=="9999"||!o&&i=="4999"){if(!o&&(finalise(h,a+1,0),h.times(h).times(h).eq(b))){s=h;break}d+=4,o=1}else{(!+i||!+i.slice(1)&&i.charAt(0)=="5")&&(finalise(s,a+1,1),e=!s.times(s).times(s).eq(b));break}return external=!0,finalise(s,a,$.rounding,e)};P$1.decimalPlaces=P$1.dp=function(){var a,e=this.d,i=NaN;if(e){if(a=e.length-1,i=(a-mathfloor(this.e/LOG_BASE))*LOG_BASE,a=e[a],a)for(;a%10==0;a/=10)i--;i<0&&(i=0)}return i};P$1.dividedBy=P$1.div=function(a){return divide$1(this,new this.constructor(a))};P$1.dividedToIntegerBy=P$1.divToInt=function(a){var e=this,i=e.constructor;return finalise(divide$1(e,new i(a),0,1,1),i.precision,i.rounding)};P$1.equals=P$1.eq=function(a){return this.cmp(a)===0};P$1.floor=function(){return finalise(new this.constructor(this),this.e+1,3)};P$1.greaterThan=P$1.gt=function(a){return this.cmp(a)>0};P$1.greaterThanOrEqualTo=P$1.gte=function(a){var e=this.cmp(a);return e==1||e===0};P$1.hyperbolicCosine=P$1.cosh=function(){var a,e,i,s,o,c=this,d=c.constructor,h=new d(1);if(!c.isFinite())return new d(c.s?1/0:NaN);if(c.isZero())return h;i=d.precision,s=d.rounding,d.precision=i+Math.max(c.e,c.sd())+4,d.rounding=1,o=c.d.length,o<32?(a=Math.ceil(o/3),e=(1/tinyPow(4,a)).toString()):(a=16,e="2.3283064365386962890625e-10"),c=taylorSeries(d,1,c.times(e),new d(1),!0);for(var g,_=a,b=new d(8);_--;)g=c.times(c),c=h.minus(g.times(b.minus(g.times(b))));return finalise(c,d.precision=i,d.rounding=s,!0)};P$1.hyperbolicSine=P$1.sinh=function(){var a,e,i,s,o=this,c=o.constructor;if(!o.isFinite()||o.isZero())return new c(o);if(e=c.precision,i=c.rounding,c.precision=e+Math.max(o.e,o.sd())+4,c.rounding=1,s=o.d.length,s<3)o=taylorSeries(c,2,o,o,!0);else{a=1.4*Math.sqrt(s),a=a>16?16:a|0,o=o.times(1/tinyPow(5,a)),o=taylorSeries(c,2,o,o,!0);for(var d,h=new c(5),g=new c(16),_=new c(20);a--;)d=o.times(o),o=o.times(h.plus(d.times(g.times(d).plus(_))))}return c.precision=e,c.rounding=i,finalise(o,e,i,!0)};P$1.hyperbolicTangent=P$1.tanh=function(){var a,e,i=this,s=i.constructor;return i.isFinite()?i.isZero()?new s(i):(a=s.precision,e=s.rounding,s.precision=a+7,s.rounding=1,divide$1(i.sinh(),i.cosh(),s.precision=a,s.rounding=e)):new s(i.s)};P$1.inverseCosine=P$1.acos=function(){var a,e=this,i=e.constructor,s=e.abs().cmp(1),o=i.precision,c=i.rounding;return s!==-1?s===0?e.isNeg()?getPi(i,o,c):new i(0):new i(NaN):e.isZero()?getPi(i,o+4,c).times(.5):(i.precision=o+6,i.rounding=1,e=e.asin(),a=getPi(i,o+4,c).times(.5),i.precision=o,i.rounding=c,a.minus(e))};P$1.inverseHyperbolicCosine=P$1.acosh=function(){var a,e,i=this,s=i.constructor;return i.lte(1)?new s(i.eq(1)?0:NaN):i.isFinite()?(a=s.precision,e=s.rounding,s.precision=a+Math.max(Math.abs(i.e),i.sd())+4,s.rounding=1,external=!1,i=i.times(i).minus(1).sqrt().plus(i),external=!0,s.precision=a,s.rounding=e,i.ln()):new s(i)};P$1.inverseHyperbolicSine=P$1.asinh=function(){var a,e,i=this,s=i.constructor;return!i.isFinite()||i.isZero()?new s(i):(a=s.precision,e=s.rounding,s.precision=a+2*Math.max(Math.abs(i.e),i.sd())+6,s.rounding=1,external=!1,i=i.times(i).plus(1).sqrt().plus(i),external=!0,s.precision=a,s.rounding=e,i.ln())};P$1.inverseHyperbolicTangent=P$1.atanh=function(){var a,e,i,s,o=this,c=o.constructor;return o.isFinite()?o.e>=0?new c(o.abs().eq(1)?o.s/0:o.isZero()?o:NaN):(a=c.precision,e=c.rounding,s=o.sd(),Math.max(s,a)<2*-o.e-1?finalise(new c(o),a,e,!0):(c.precision=i=s-o.e,o=divide$1(o.plus(1),new c(1).minus(o),i+a,1),c.precision=a+4,c.rounding=1,o=o.ln(),c.precision=a,c.rounding=e,o.times(.5))):new c(NaN)};P$1.inverseSine=P$1.asin=function(){var a,e,i,s,o=this,c=o.constructor;return o.isZero()?new c(o):(e=o.abs().cmp(1),i=c.precision,s=c.rounding,e!==-1?e===0?(a=getPi(c,i+4,s).times(.5),a.s=o.s,a):new c(NaN):(c.precision=i+6,c.rounding=1,o=o.div(new c(1).minus(o.times(o)).sqrt().plus(1)).atan(),c.precision=i,c.rounding=s,o.times(2)))};P$1.inverseTangent=P$1.atan=function(){var a,e,i,s,o,c,d,h,g,_=this,b=_.constructor,$=b.precision,j=b.rounding;if(_.isFinite()){if(_.isZero())return new b(_);if(_.abs().eq(1)&&$+4<=PI_PRECISION)return d=getPi(b,$+4,j).times(.25),d.s=_.s,d}else{if(!_.s)return new b(NaN);if($+4<=PI_PRECISION)return d=getPi(b,$+4,j).times(.5),d.s=_.s,d}for(b.precision=h=$+10,b.rounding=1,i=Math.min(28,h/LOG_BASE+2|0),a=i;a;--a)_=_.div(_.times(_).plus(1).sqrt().plus(1));for(external=!1,e=Math.ceil(h/LOG_BASE),s=1,g=_.times(_),d=new b(_),o=_;a!==-1;)if(o=o.times(g),c=d.minus(o.div(s+=2)),o=o.times(g),d=c.plus(o.div(s+=2)),d.d[e]!==void 0)for(a=e;d.d[a]===c.d[a]&&a--;);return i&&(d=d.times(2<<i-1)),external=!0,finalise(d,b.precision=$,b.rounding=j,!0)};P$1.isFinite=function(){return!!this.d};P$1.isInteger=P$1.isInt=function(){return!!this.d&&mathfloor(this.e/LOG_BASE)>this.d.length-2};P$1.isNaN=function(){return!this.s};P$1.isNegative=P$1.isNeg=function(){return this.s<0};P$1.isPositive=P$1.isPos=function(){return this.s>0};P$1.isZero=function(){return!!this.d&&this.d[0]===0};P$1.lessThan=P$1.lt=function(a){return this.cmp(a)<0};P$1.lessThanOrEqualTo=P$1.lte=function(a){return this.cmp(a)<1};P$1.logarithm=P$1.log=function(a){var e,i,s,o,c,d,h,g,_=this,b=_.constructor,$=b.precision,j=b.rounding,_e=5;if(a==null)a=new b(10),e=!0;else{if(a=new b(a),i=a.d,a.s<0||!i||!i[0]||a.eq(1))return new b(NaN);e=a.eq(10)}if(i=_.d,_.s<0||!i||!i[0]||_.eq(1))return new b(i&&!i[0]?-1/0:_.s!=1?NaN:i?0:1/0);if(e)if(i.length>1)c=!0;else{for(o=i[0];o%10===0;)o/=10;c=o!==1}if(external=!1,h=$+_e,d=naturalLogarithm(_,h),s=e?getLn10(b,h+10):naturalLogarithm(a,h),g=divide$1(d,s,h,1),checkRoundingDigits(g.d,o=$,j))do if(h+=10,d=naturalLogarithm(_,h),s=e?getLn10(b,h+10):naturalLogarithm(a,h),g=divide$1(d,s,h,1),!c){+digitsToString(g.d).slice(o+1,o+15)+1==1e14&&(g=finalise(g,$+1,0));break}while(checkRoundingDigits(g.d,o+=10,j));return external=!0,finalise(g,$,j)};P$1.minus=P$1.sub=function(a){var e,i,s,o,c,d,h,g,_,b,$,j,_e=this,tt=_e.constructor;if(a=new tt(a),!_e.d||!a.d)return!_e.s||!a.s?a=new tt(NaN):_e.d?a.s=-a.s:a=new tt(a.d||_e.s!==a.s?_e:NaN),a;if(_e.s!=a.s)return a.s=-a.s,_e.plus(a);if(_=_e.d,j=a.d,h=tt.precision,g=tt.rounding,!_[0]||!j[0]){if(j[0])a.s=-a.s;else if(_[0])a=new tt(_e);else return new tt(g===3?-0:0);return external?finalise(a,h,g):a}if(i=mathfloor(a.e/LOG_BASE),b=mathfloor(_e.e/LOG_BASE),_=_.slice(),c=b-i,c){for($=c<0,$?(e=_,c=-c,d=j.length):(e=j,i=b,d=_.length),s=Math.max(Math.ceil(h/LOG_BASE),d)+2,c>s&&(c=s,e.length=1),e.reverse(),s=c;s--;)e.push(0);e.reverse()}else{for(s=_.length,d=j.length,$=s<d,$&&(d=s),s=0;s<d;s++)if(_[s]!=j[s]){$=_[s]<j[s];break}c=0}for($&&(e=_,_=j,j=e,a.s=-a.s),d=_.length,s=j.length-d;s>0;--s)_[d++]=0;for(s=j.length;s>c;){if(_[--s]<j[s]){for(o=s;o&&_[--o]===0;)_[o]=BASE-1;--_[o],_[s]+=BASE}_[s]-=j[s]}for(;_[--d]===0;)_.pop();for(;_[0]===0;_.shift())--i;return _[0]?(a.d=_,a.e=getBase10Exponent(_,i),external?finalise(a,h,g):a):new tt(g===3?-0:0)};P$1.modulo=P$1.mod=function(a){var e,i=this,s=i.constructor;return a=new s(a),!i.d||!a.s||a.d&&!a.d[0]?new s(NaN):!a.d||i.d&&!i.d[0]?finalise(new s(i),s.precision,s.rounding):(external=!1,s.modulo==9?(e=divide$1(i,a.abs(),0,3,1),e.s*=a.s):e=divide$1(i,a,0,s.modulo,1),e=e.times(a),external=!0,i.minus(e))};P$1.naturalExponential=P$1.exp=function(){return naturalExponential(this)};P$1.naturalLogarithm=P$1.ln=function(){return naturalLogarithm(this)};P$1.negated=P$1.neg=function(){var a=new this.constructor(this);return a.s=-a.s,finalise(a)};P$1.plus=P$1.add=function(a){var e,i,s,o,c,d,h,g,_,b,$=this,j=$.constructor;if(a=new j(a),!$.d||!a.d)return!$.s||!a.s?a=new j(NaN):$.d||(a=new j(a.d||$.s===a.s?$:NaN)),a;if($.s!=a.s)return a.s=-a.s,$.minus(a);if(_=$.d,b=a.d,h=j.precision,g=j.rounding,!_[0]||!b[0])return b[0]||(a=new j($)),external?finalise(a,h,g):a;if(c=mathfloor($.e/LOG_BASE),s=mathfloor(a.e/LOG_BASE),_=_.slice(),o=c-s,o){for(o<0?(i=_,o=-o,d=b.length):(i=b,s=c,d=_.length),c=Math.ceil(h/LOG_BASE),d=c>d?c+1:d+1,o>d&&(o=d,i.length=1),i.reverse();o--;)i.push(0);i.reverse()}for(d=_.length,o=b.length,d-o<0&&(o=d,i=b,b=_,_=i),e=0;o;)e=(_[--o]=_[o]+b[o]+e)/BASE|0,_[o]%=BASE;for(e&&(_.unshift(e),++s),d=_.length;_[--d]==0;)_.pop();return a.d=_,a.e=getBase10Exponent(_,s),external?finalise(a,h,g):a};P$1.precision=P$1.sd=function(a){var e,i=this;if(a!==void 0&&a!==!!a&&a!==1&&a!==0)throw Error(invalidArgument+a);return i.d?(e=getPrecision(i.d),a&&i.e+1>e&&(e=i.e+1)):e=NaN,e};P$1.round=function(){var a=this,e=a.constructor;return finalise(new e(a),a.e+1,e.rounding)};P$1.sine=P$1.sin=function(){var a,e,i=this,s=i.constructor;return i.isFinite()?i.isZero()?new s(i):(a=s.precision,e=s.rounding,s.precision=a+Math.max(i.e,i.sd())+LOG_BASE,s.rounding=1,i=sine(s,toLessThanHalfPi(s,i)),s.precision=a,s.rounding=e,finalise(quadrant>2?i.neg():i,a,e,!0)):new s(NaN)};P$1.squareRoot=P$1.sqrt=function(){var a,e,i,s,o,c,d=this,h=d.d,g=d.e,_=d.s,b=d.constructor;if(_!==1||!h||!h[0])return new b(!_||_<0&&(!h||h[0])?NaN:h?d:1/0);for(external=!1,_=Math.sqrt(+d),_==0||_==1/0?(e=digitsToString(h),(e.length+g)%2==0&&(e+="0"),_=Math.sqrt(e),g=mathfloor((g+1)/2)-(g<0||g%2),_==1/0?e="5e"+g:(e=_.toExponential(),e=e.slice(0,e.indexOf("e")+1)+g),s=new b(e)):s=new b(_.toString()),i=(g=b.precision)+3;;)if(c=s,s=c.plus(divide$1(d,c,i+2,1)).times(.5),digitsToString(c.d).slice(0,i)===(e=digitsToString(s.d)).slice(0,i))if(e=e.slice(i-3,i+1),e=="9999"||!o&&e=="4999"){if(!o&&(finalise(c,g+1,0),c.times(c).eq(d))){s=c;break}i+=4,o=1}else{(!+e||!+e.slice(1)&&e.charAt(0)=="5")&&(finalise(s,g+1,1),a=!s.times(s).eq(d));break}return external=!0,finalise(s,g,b.rounding,a)};P$1.tangent=P$1.tan=function(){var a,e,i=this,s=i.constructor;return i.isFinite()?i.isZero()?new s(i):(a=s.precision,e=s.rounding,s.precision=a+10,s.rounding=1,i=i.sin(),i.s=1,i=divide$1(i,new s(1).minus(i.times(i)).sqrt(),a+10,0),s.precision=a,s.rounding=e,finalise(quadrant==2||quadrant==4?i.neg():i,a,e,!0)):new s(NaN)};P$1.times=P$1.mul=function(a){var e,i,s,o,c,d,h,g,_,b=this,$=b.constructor,j=b.d,_e=(a=new $(a)).d;if(a.s*=b.s,!j||!j[0]||!_e||!_e[0])return new $(!a.s||j&&!j[0]&&!_e||_e&&!_e[0]&&!j?NaN:!j||!_e?a.s/0:a.s*0);for(i=mathfloor(b.e/LOG_BASE)+mathfloor(a.e/LOG_BASE),g=j.length,_=_e.length,g<_&&(c=j,j=_e,_e=c,d=g,g=_,_=d),c=[],d=g+_,s=d;s--;)c.push(0);for(s=_;--s>=0;){for(e=0,o=g+s;o>s;)h=c[o]+_e[s]*j[o-s-1]+e,c[o--]=h%BASE|0,e=h/BASE|0;c[o]=(c[o]+e)%BASE|0}for(;!c[--d];)c.pop();return e?++i:c.shift(),a.d=c,a.e=getBase10Exponent(c,i),external?finalise(a,$.precision,$.rounding):a};P$1.toBinary=function(a,e){return toStringBinary(this,2,a,e)};P$1.toDecimalPlaces=P$1.toDP=function(a,e){var i=this,s=i.constructor;return i=new s(i),a===void 0?i:(checkInt32(a,0,MAX_DIGITS),e===void 0?e=s.rounding:checkInt32(e,0,8),finalise(i,a+i.e+1,e))};P$1.toExponential=function(a,e){var i,s=this,o=s.constructor;return a===void 0?i=finiteToString(s,!0):(checkInt32(a,0,MAX_DIGITS),e===void 0?e=o.rounding:checkInt32(e,0,8),s=finalise(new o(s),a+1,e),i=finiteToString(s,!0,a+1)),s.isNeg()&&!s.isZero()?"-"+i:i};P$1.toFixed=function(a,e){var i,s,o=this,c=o.constructor;return a===void 0?i=finiteToString(o):(checkInt32(a,0,MAX_DIGITS),e===void 0?e=c.rounding:checkInt32(e,0,8),s=finalise(new c(o),a+o.e+1,e),i=finiteToString(s,!1,a+s.e+1)),o.isNeg()&&!o.isZero()?"-"+i:i};P$1.toFraction=function(a){var e,i,s,o,c,d,h,g,_,b,$,j,_e=this,tt=_e.d,et=_e.constructor;if(!tt)return new et(_e);if(_=i=new et(1),s=g=new et(0),e=new et(s),c=e.e=getPrecision(tt)-_e.e-1,d=c%LOG_BASE,e.d[0]=mathpow(10,d<0?LOG_BASE+d:d),a==null)a=c>0?e:_;else{if(h=new et(a),!h.isInt()||h.lt(_))throw Error(invalidArgument+h);a=h.gt(e)?c>0?e:_:h}for(external=!1,h=new et(digitsToString(tt)),b=et.precision,et.precision=c=tt.length*LOG_BASE*2;$=divide$1(h,e,0,1,1),o=i.plus($.times(s)),o.cmp(a)!=1;)i=s,s=o,o=_,_=g.plus($.times(o)),g=o,o=e,e=h.minus($.times(o)),h=o;return o=divide$1(a.minus(i),s,0,1,1),g=g.plus(o.times(_)),i=i.plus(o.times(s)),g.s=_.s=_e.s,j=divide$1(_,s,c,1).minus(_e).abs().cmp(divide$1(g,i,c,1).minus(_e).abs())<1?[_,s]:[g,i],et.precision=b,external=!0,j};P$1.toHexadecimal=P$1.toHex=function(a,e){return toStringBinary(this,16,a,e)};P$1.toNearest=function(a,e){var i=this,s=i.constructor;if(i=new s(i),a==null){if(!i.d)return i;a=new s(1),e=s.rounding}else{if(a=new s(a),e===void 0?e=s.rounding:checkInt32(e,0,8),!i.d)return a.s?i:a;if(!a.d)return a.s&&(a.s=i.s),a}return a.d[0]?(external=!1,i=divide$1(i,a,0,e,1).times(a),external=!0,finalise(i)):(a.s=i.s,i=a),i};P$1.toNumber=function(){return+this};P$1.toOctal=function(a,e){return toStringBinary(this,8,a,e)};P$1.toPower=P$1.pow=function(a){var e,i,s,o,c,d,h=this,g=h.constructor,_=+(a=new g(a));if(!h.d||!a.d||!h.d[0]||!a.d[0])return new g(mathpow(+h,_));if(h=new g(h),h.eq(1))return h;if(s=g.precision,c=g.rounding,a.eq(1))return finalise(h,s,c);if(e=mathfloor(a.e/LOG_BASE),e>=a.d.length-1&&(i=_<0?-_:_)<=MAX_SAFE_INTEGER)return o=intPow(g,h,i,s),a.s<0?new g(1).div(o):finalise(o,s,c);if(d=h.s,d<0){if(e<a.d.length-1)return new g(NaN);if(a.d[e]&1||(d=1),h.e==0&&h.d[0]==1&&h.d.length==1)return h.s=d,h}return i=mathpow(+h,_),e=i==0||!isFinite(i)?mathfloor(_*(Math.log("0."+digitsToString(h.d))/Math.LN10+h.e+1)):new g(i+"").e,e>g.maxE+1||e<g.minE-1?new g(e>0?d/0:0):(external=!1,g.rounding=h.s=1,i=Math.min(12,(e+"").length),o=naturalExponential(a.times(naturalLogarithm(h,s+i)),s),o.d&&(o=finalise(o,s+5,1),checkRoundingDigits(o.d,s,c)&&(e=s+10,o=finalise(naturalExponential(a.times(naturalLogarithm(h,e+i)),e),e+5,1),+digitsToString(o.d).slice(s+1,s+15)+1==1e14&&(o=finalise(o,s+1,0)))),o.s=d,external=!0,g.rounding=c,finalise(o,s,c))};P$1.toPrecision=function(a,e){var i,s=this,o=s.constructor;return a===void 0?i=finiteToString(s,s.e<=o.toExpNeg||s.e>=o.toExpPos):(checkInt32(a,1,MAX_DIGITS),e===void 0?e=o.rounding:checkInt32(e,0,8),s=finalise(new o(s),a,e),i=finiteToString(s,a<=s.e||s.e<=o.toExpNeg,a)),s.isNeg()&&!s.isZero()?"-"+i:i};P$1.toSignificantDigits=P$1.toSD=function(a,e){var i=this,s=i.constructor;return a===void 0?(a=s.precision,e=s.rounding):(checkInt32(a,1,MAX_DIGITS),e===void 0?e=s.rounding:checkInt32(e,0,8)),finalise(new s(i),a,e)};P$1.toString=function(){var a=this,e=a.constructor,i=finiteToString(a,a.e<=e.toExpNeg||a.e>=e.toExpPos);return a.isNeg()&&!a.isZero()?"-"+i:i};P$1.truncated=P$1.trunc=function(){return finalise(new this.constructor(this),this.e+1,1)};P$1.valueOf=P$1.toJSON=function(){var a=this,e=a.constructor,i=finiteToString(a,a.e<=e.toExpNeg||a.e>=e.toExpPos);return a.isNeg()?"-"+i:i};function digitsToString(a){var e,i,s,o=a.length-1,c="",d=a[0];if(o>0){for(c+=d,e=1;e<o;e++)s=a[e]+"",i=LOG_BASE-s.length,i&&(c+=getZeroString(i)),c+=s;d=a[e],s=d+"",i=LOG_BASE-s.length,i&&(c+=getZeroString(i))}else if(d===0)return"0";for(;d%10===0;)d/=10;return c+d}function checkInt32(a,e,i){if(a!==~~a||a<e||a>i)throw Error(invalidArgument+a)}function checkRoundingDigits(a,e,i,s){var o,c,d,h;for(c=a[0];c>=10;c/=10)--e;return--e<0?(e+=LOG_BASE,o=0):(o=Math.ceil((e+1)/LOG_BASE),e%=LOG_BASE),c=mathpow(10,LOG_BASE-e),h=a[o]%c|0,s==null?e<3?(e==0?h=h/100|0:e==1&&(h=h/10|0),d=i<4&&h==99999||i>3&&h==49999||h==5e4||h==0):d=(i<4&&h+1==c||i>3&&h+1==c/2)&&(a[o+1]/c/100|0)==mathpow(10,e-2)-1||(h==c/2||h==0)&&(a[o+1]/c/100|0)==0:e<4?(e==0?h=h/1e3|0:e==1?h=h/100|0:e==2&&(h=h/10|0),d=(s||i<4)&&h==9999||!s&&i>3&&h==4999):d=((s||i<4)&&h+1==c||!s&&i>3&&h+1==c/2)&&(a[o+1]/c/1e3|0)==mathpow(10,e-3)-1,d}function convertBase(a,e,i){for(var s,o=[0],c,d=0,h=a.length;d<h;){for(c=o.length;c--;)o[c]*=e;for(o[0]+=NUMERALS.indexOf(a.charAt(d++)),s=0;s<o.length;s++)o[s]>i-1&&(o[s+1]===void 0&&(o[s+1]=0),o[s+1]+=o[s]/i|0,o[s]%=i)}return o.reverse()}function cosine(a,e){var i,s,o;if(e.isZero())return e;s=e.d.length,s<32?(i=Math.ceil(s/3),o=(1/tinyPow(4,i)).toString()):(i=16,o="2.3283064365386962890625e-10"),a.precision+=i,e=taylorSeries(a,1,e.times(o),new a(1));for(var c=i;c--;){var d=e.times(e);e=d.times(d).minus(d).times(8).plus(1)}return a.precision-=i,e}var divide$1=function(){function a(s,o,c){var d,h=0,g=s.length;for(s=s.slice();g--;)d=s[g]*o+h,s[g]=d%c|0,h=d/c|0;return h&&s.unshift(h),s}function e(s,o,c,d){var h,g;if(c!=d)g=c>d?1:-1;else for(h=g=0;h<c;h++)if(s[h]!=o[h]){g=s[h]>o[h]?1:-1;break}return g}function i(s,o,c,d){for(var h=0;c--;)s[c]-=h,h=s[c]<o[c]?1:0,s[c]=h*d+s[c]-o[c];for(;!s[0]&&s.length>1;)s.shift()}return function(s,o,c,d,h,g){var _,b,$,j,_e,tt,et,nt,rt,it,at,st,ot,ct,lt,dt,xt,ut,ft,mt,yt=s.constructor,St=s.s==o.s?1:-1,Et=s.d,vt=o.d;if(!Et||!Et[0]||!vt||!vt[0])return new yt(!s.s||!o.s||(Et?vt&&Et[0]==vt[0]:!vt)?NaN:Et&&Et[0]==0||!vt?St*0:St/0);for(g?(_e=1,b=s.e-o.e):(g=BASE,_e=LOG_BASE,b=mathfloor(s.e/_e)-mathfloor(o.e/_e)),ft=vt.length,xt=Et.length,rt=new yt(St),it=rt.d=[],$=0;vt[$]==(Et[$]||0);$++);if(vt[$]>(Et[$]||0)&&b--,c==null?(ct=c=yt.precision,d=yt.rounding):h?ct=c+(s.e-o.e)+1:ct=c,ct<0)it.push(1),tt=!0;else{if(ct=ct/_e+2|0,$=0,ft==1){for(j=0,vt=vt[0],ct++;($<xt||j)&&ct--;$++)lt=j*g+(Et[$]||0),it[$]=lt/vt|0,j=lt%vt|0;tt=j||$<xt}else{for(j=g/(vt[0]+1)|0,j>1&&(vt=a(vt,j,g),Et=a(Et,j,g),ft=vt.length,xt=Et.length),dt=ft,at=Et.slice(0,ft),st=at.length;st<ft;)at[st++]=0;mt=vt.slice(),mt.unshift(0),ut=vt[0],vt[1]>=g/2&&++ut;do j=0,_=e(vt,at,ft,st),_<0?(ot=at[0],ft!=st&&(ot=ot*g+(at[1]||0)),j=ot/ut|0,j>1?(j>=g&&(j=g-1),et=a(vt,j,g),nt=et.length,st=at.length,_=e(et,at,nt,st),_==1&&(j--,i(et,ft<nt?mt:vt,nt,g))):(j==0&&(_=j=1),et=vt.slice()),nt=et.length,nt<st&&et.unshift(0),i(at,et,st,g),_==-1&&(st=at.length,_=e(vt,at,ft,st),_<1&&(j++,i(at,ft<st?mt:vt,st,g))),st=at.length):_===0&&(j++,at=[0]),it[$++]=j,_&&at[0]?at[st++]=Et[dt]||0:(at=[Et[dt]],st=1);while((dt++<xt||at[0]!==void 0)&&ct--);tt=at[0]!==void 0}it[0]||it.shift()}if(_e==1)rt.e=b,inexact=tt;else{for($=1,j=it[0];j>=10;j/=10)$++;rt.e=$+b*_e-1,finalise(rt,h?c+rt.e+1:c,d,tt)}return rt}}();function finalise(a,e,i,s){var o,c,d,h,g,_,b,$,j,_e=a.constructor;e:if(e!=null){if($=a.d,!$)return a;for(o=1,h=$[0];h>=10;h/=10)o++;if(c=e-o,c<0)c+=LOG_BASE,d=e,b=$[j=0],g=b/mathpow(10,o-d-1)%10|0;else if(j=Math.ceil((c+1)/LOG_BASE),h=$.length,j>=h)if(s){for(;h++<=j;)$.push(0);b=g=0,o=1,c%=LOG_BASE,d=c-LOG_BASE+1}else break e;else{for(b=h=$[j],o=1;h>=10;h/=10)o++;c%=LOG_BASE,d=c-LOG_BASE+o,g=d<0?0:b/mathpow(10,o-d-1)%10|0}if(s=s||e<0||$[j+1]!==void 0||(d<0?b:b%mathpow(10,o-d-1)),_=i<4?(g||s)&&(i==0||i==(a.s<0?3:2)):g>5||g==5&&(i==4||s||i==6&&(c>0?d>0?b/mathpow(10,o-d):0:$[j-1])%10&1||i==(a.s<0?8:7)),e<1||!$[0])return $.length=0,_?(e-=a.e+1,$[0]=mathpow(10,(LOG_BASE-e%LOG_BASE)%LOG_BASE),a.e=-e||0):$[0]=a.e=0,a;if(c==0?($.length=j,h=1,j--):($.length=j+1,h=mathpow(10,LOG_BASE-c),$[j]=d>0?(b/mathpow(10,o-d)%mathpow(10,d)|0)*h:0),_)for(;;)if(j==0){for(c=1,d=$[0];d>=10;d/=10)c++;for(d=$[0]+=h,h=1;d>=10;d/=10)h++;c!=h&&(a.e++,$[0]==BASE&&($[0]=1));break}else{if($[j]+=h,$[j]!=BASE)break;$[j--]=0,h=1}for(c=$.length;$[--c]===0;)$.pop()}return external&&(a.e>_e.maxE?(a.d=null,a.e=NaN):a.e<_e.minE&&(a.e=0,a.d=[0])),a}function finiteToString(a,e,i){if(!a.isFinite())return nonFiniteToString(a);var s,o=a.e,c=digitsToString(a.d),d=c.length;return e?(i&&(s=i-d)>0?c=c.charAt(0)+"."+c.slice(1)+getZeroString(s):d>1&&(c=c.charAt(0)+"."+c.slice(1)),c=c+(a.e<0?"e":"e+")+a.e):o<0?(c="0."+getZeroString(-o-1)+c,i&&(s=i-d)>0&&(c+=getZeroString(s))):o>=d?(c+=getZeroString(o+1-d),i&&(s=i-o-1)>0&&(c=c+"."+getZeroString(s))):((s=o+1)<d&&(c=c.slice(0,s)+"."+c.slice(s)),i&&(s=i-d)>0&&(o+1===d&&(c+="."),c+=getZeroString(s))),c}function getBase10Exponent(a,e){var i=a[0];for(e*=LOG_BASE;i>=10;i/=10)e++;return e}function getLn10(a,e,i){if(e>LN10_PRECISION)throw external=!0,i&&(a.precision=i),Error(precisionLimitExceeded);return finalise(new a(LN10),e,1,!0)}function getPi(a,e,i){if(e>PI_PRECISION)throw Error(precisionLimitExceeded);return finalise(new a(PI),e,i,!0)}function getPrecision(a){var e=a.length-1,i=e*LOG_BASE+1;if(e=a[e],e){for(;e%10==0;e/=10)i--;for(e=a[0];e>=10;e/=10)i++}return i}function getZeroString(a){for(var e="";a--;)e+="0";return e}function intPow(a,e,i,s){var o,c=new a(1),d=Math.ceil(s/LOG_BASE+4);for(external=!1;;){if(i%2&&(c=c.times(e),truncate(c.d,d)&&(o=!0)),i=mathfloor(i/2),i===0){i=c.d.length-1,o&&c.d[i]===0&&++c.d[i];break}e=e.times(e),truncate(e.d,d)}return external=!0,c}function isOdd(a){return a.d[a.d.length-1]&1}function maxOrMin(a,e,i){for(var s,o=new a(e[0]),c=0;++c<e.length;)if(s=new a(e[c]),s.s)o[i](s)&&(o=s);else{o=s;break}return o}function naturalExponential(a,e){var i,s,o,c,d,h,g,_=0,b=0,$=0,j=a.constructor,_e=j.rounding,tt=j.precision;if(!a.d||!a.d[0]||a.e>17)return new j(a.d?a.d[0]?a.s<0?0:1/0:1:a.s?a.s<0?0:a:NaN);for(e==null?(external=!1,g=tt):g=e,h=new j(.03125);a.e>-2;)a=a.times(h),$+=5;for(s=Math.log(mathpow(2,$))/Math.LN10*2+5|0,g+=s,i=c=d=new j(1),j.precision=g;;){if(c=finalise(c.times(a),g,1),i=i.times(++b),h=d.plus(divide$1(c,i,g,1)),digitsToString(h.d).slice(0,g)===digitsToString(d.d).slice(0,g)){for(o=$;o--;)d=finalise(d.times(d),g,1);if(e==null)if(_<3&&checkRoundingDigits(d.d,g-s,_e,_))j.precision=g+=10,i=c=h=new j(1),b=0,_++;else return finalise(d,j.precision=tt,_e,external=!0);else return j.precision=tt,d}d=h}}function naturalLogarithm(a,e){var i,s,o,c,d,h,g,_,b,$,j,_e=1,tt=10,et=a,nt=et.d,rt=et.constructor,it=rt.rounding,at=rt.precision;if(et.s<0||!nt||!nt[0]||!et.e&&nt[0]==1&&nt.length==1)return new rt(nt&&!nt[0]?-1/0:et.s!=1?NaN:nt?0:et);if(e==null?(external=!1,b=at):b=e,rt.precision=b+=tt,i=digitsToString(nt),s=i.charAt(0),Math.abs(c=et.e)<15e14){for(;s<7&&s!=1||s==1&&i.charAt(1)>3;)et=et.times(a),i=digitsToString(et.d),s=i.charAt(0),_e++;c=et.e,s>1?(et=new rt("0."+i),c++):et=new rt(s+"."+i.slice(1))}else return _=getLn10(rt,b+2,at).times(c+""),et=naturalLogarithm(new rt(s+"."+i.slice(1)),b-tt).plus(_),rt.precision=at,e==null?finalise(et,at,it,external=!0):et;for($=et,g=d=et=divide$1(et.minus(1),et.plus(1),b,1),j=finalise(et.times(et),b,1),o=3;;){if(d=finalise(d.times(j),b,1),_=g.plus(divide$1(d,new rt(o),b,1)),digitsToString(_.d).slice(0,b)===digitsToString(g.d).slice(0,b))if(g=g.times(2),c!==0&&(g=g.plus(getLn10(rt,b+2,at).times(c+""))),g=divide$1(g,new rt(_e),b,1),e==null)if(checkRoundingDigits(g.d,b-tt,it,h))rt.precision=b+=tt,_=d=et=divide$1($.minus(1),$.plus(1),b,1),j=finalise(et.times(et),b,1),o=h=1;else return finalise(g,rt.precision=at,it,external=!0);else return rt.precision=at,g;g=_,o+=2}}function nonFiniteToString(a){return String(a.s*a.s/0)}function parseDecimal(a,e){var i,s,o;for((i=e.indexOf("."))>-1&&(e=e.replace(".","")),(s=e.search(/e/i))>0?(i<0&&(i=s),i+=+e.slice(s+1),e=e.substring(0,s)):i<0&&(i=e.length),s=0;e.charCodeAt(s)===48;s++);for(o=e.length;e.charCodeAt(o-1)===48;--o);if(e=e.slice(s,o),e){if(o-=s,a.e=i=i-s-1,a.d=[],s=(i+1)%LOG_BASE,i<0&&(s+=LOG_BASE),s<o){for(s&&a.d.push(+e.slice(0,s)),o-=LOG_BASE;s<o;)a.d.push(+e.slice(s,s+=LOG_BASE));e=e.slice(s),s=LOG_BASE-e.length}else s-=o;for(;s--;)e+="0";a.d.push(+e),external&&(a.e>a.constructor.maxE?(a.d=null,a.e=NaN):a.e<a.constructor.minE&&(a.e=0,a.d=[0]))}else a.e=0,a.d=[0];return a}function parseOther(a,e){var i,s,o,c,d,h,g,_,b;if(e.indexOf("_")>-1){if(e=e.replace(/(\d)_(?=\d)/g,"$1"),isDecimal.test(e))return parseDecimal(a,e)}else if(e==="Infinity"||e==="NaN")return+e||(a.s=NaN),a.e=NaN,a.d=null,a;if(isHex.test(e))i=16,e=e.toLowerCase();else if(isBinary.test(e))i=2;else if(isOctal.test(e))i=8;else throw Error(invalidArgument+e);for(c=e.search(/p/i),c>0?(g=+e.slice(c+1),e=e.substring(2,c)):e=e.slice(2),c=e.indexOf("."),d=c>=0,s=a.constructor,d&&(e=e.replace(".",""),h=e.length,c=h-c,o=intPow(s,new s(i),c,c*2)),_=convertBase(e,i,BASE),b=_.length-1,c=b;_[c]===0;--c)_.pop();return c<0?new s(a.s*0):(a.e=getBase10Exponent(_,b),a.d=_,external=!1,d&&(a=divide$1(a,o,h*4)),g&&(a=a.times(Math.abs(g)<54?mathpow(2,g):Decimal.pow(2,g))),external=!0,a)}function sine(a,e){var i,s=e.d.length;if(s<3)return e.isZero()?e:taylorSeries(a,2,e,e);i=1.4*Math.sqrt(s),i=i>16?16:i|0,e=e.times(1/tinyPow(5,i)),e=taylorSeries(a,2,e,e);for(var o,c=new a(5),d=new a(16),h=new a(20);i--;)o=e.times(e),e=e.times(c.plus(o.times(d.times(o).minus(h))));return e}function taylorSeries(a,e,i,s,o){var c,d,h,g,_=a.precision,b=Math.ceil(_/LOG_BASE);for(external=!1,g=i.times(i),h=new a(s);;){if(d=divide$1(h.times(g),new a(e++*e++),_,1),h=o?s.plus(d):s.minus(d),s=divide$1(d.times(g),new a(e++*e++),_,1),d=h.plus(s),d.d[b]!==void 0){for(c=b;d.d[c]===h.d[c]&&c--;);if(c==-1)break}c=h,h=s,s=d,d=c}return external=!0,d.d.length=b+1,d}function tinyPow(a,e){for(var i=a;--e;)i*=a;return i}function toLessThanHalfPi(a,e){var i,s=e.s<0,o=getPi(a,a.precision,1),c=o.times(.5);if(e=e.abs(),e.lte(c))return quadrant=s?4:1,e;if(i=e.divToInt(o),i.isZero())quadrant=s?3:2;else{if(e=e.minus(i.times(o)),e.lte(c))return quadrant=isOdd(i)?s?2:3:s?4:1,e;quadrant=isOdd(i)?s?1:4:s?3:2}return e.minus(o).abs()}function toStringBinary(a,e,i,s){var o,c,d,h,g,_,b,$,j,_e=a.constructor,tt=i!==void 0;if(tt?(checkInt32(i,1,MAX_DIGITS),s===void 0?s=_e.rounding:checkInt32(s,0,8)):(i=_e.precision,s=_e.rounding),!a.isFinite())b=nonFiniteToString(a);else{for(b=finiteToString(a),d=b.indexOf("."),tt?(o=2,e==16?i=i*4-3:e==8&&(i=i*3-2)):o=e,d>=0&&(b=b.replace(".",""),j=new _e(1),j.e=b.length-d,j.d=convertBase(finiteToString(j),10,o),j.e=j.d.length),$=convertBase(b,10,o),c=g=$.length;$[--g]==0;)$.pop();if(!$[0])b=tt?"0p+0":"0";else{if(d<0?c--:(a=new _e(a),a.d=$,a.e=c,a=divide$1(a,j,i,s,0,o),$=a.d,c=a.e,_=inexact),d=$[i],h=o/2,_=_||$[i+1]!==void 0,_=s<4?(d!==void 0||_)&&(s===0||s===(a.s<0?3:2)):d>h||d===h&&(s===4||_||s===6&&$[i-1]&1||s===(a.s<0?8:7)),$.length=i,_)for(;++$[--i]>o-1;)$[i]=0,i||(++c,$.unshift(1));for(g=$.length;!$[g-1];--g);for(d=0,b="";d<g;d++)b+=NUMERALS.charAt($[d]);if(tt){if(g>1)if(e==16||e==8){for(d=e==16?4:3,--g;g%d;g++)b+="0";for($=convertBase(b,o,e),g=$.length;!$[g-1];--g);for(d=1,b="1.";d<g;d++)b+=NUMERALS.charAt($[d])}else b=b.charAt(0)+"."+b.slice(1);b=b+(c<0?"p":"p+")+c}else if(c<0){for(;++c;)b="0"+b;b="0."+b}else if(++c>g)for(c-=g;c--;)b+="0";else c<g&&(b=b.slice(0,c)+"."+b.slice(c))}b=(e==16?"0x":e==2?"0b":e==8?"0o":"")+b}return a.s<0?"-"+b:b}function truncate(a,e){if(a.length>e)return a.length=e,!0}function abs$1(a){return new this(a).abs()}function acos(a){return new this(a).acos()}function acosh(a){return new this(a).acosh()}function add$1(a,e){return new this(a).plus(e)}function asin(a){return new this(a).asin()}function asinh(a){return new this(a).asinh()}function atan$1(a){return new this(a).atan()}function atanh(a){return new this(a).atanh()}function atan2(a,e){a=new this(a),e=new this(e);var i,s=this.precision,o=this.rounding,c=s+4;return!a.s||!e.s?i=new this(NaN):!a.d&&!e.d?(i=getPi(this,c,1).times(e.s>0?.25:.75),i.s=a.s):!e.d||a.isZero()?(i=e.s<0?getPi(this,s,o):new this(0),i.s=a.s):!a.d||e.isZero()?(i=getPi(this,c,1).times(.5),i.s=a.s):e.s<0?(this.precision=c,this.rounding=1,i=this.atan(divide$1(a,e,c,1)),e=getPi(this,c,1),this.precision=s,this.rounding=o,i=a.s<0?i.minus(e):i.plus(e)):i=this.atan(divide$1(a,e,c,1)),i}function cbrt(a){return new this(a).cbrt()}function ceil(a){return finalise(a=new this(a),a.e+1,2)}function clamp(a,e,i){return new this(a).clamp(e,i)}function config$1(a){if(!a||typeof a!="object")throw Error(decimalError+"Object expected");var e,i,s,o=a.defaults===!0,c=["precision",1,MAX_DIGITS,"rounding",0,8,"toExpNeg",-EXP_LIMIT,0,"toExpPos",0,EXP_LIMIT,"maxE",0,EXP_LIMIT,"minE",-EXP_LIMIT,0,"modulo",0,9];for(e=0;e<c.length;e+=3)if(i=c[e],o&&(this[i]=DEFAULTS[i]),(s=a[i])!==void 0)if(mathfloor(s)===s&&s>=c[e+1]&&s<=c[e+2])this[i]=s;else throw Error(invalidArgument+i+": "+s);if(i="crypto",o&&(this[i]=DEFAULTS[i]),(s=a[i])!==void 0)if(s===!0||s===!1||s===0||s===1)if(s)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[i]=!0;else throw Error(cryptoUnavailable);else this[i]=!1;else throw Error(invalidArgument+i+": "+s);return this}function cos$1(a){return new this(a).cos()}function cosh(a){return new this(a).cosh()}function clone(a){var e,i,s;function o(c){var d,h,g,_=this;if(!(_ instanceof o))return new o(c);if(_.constructor=o,isDecimalInstance(c)){_.s=c.s,external?!c.d||c.e>o.maxE?(_.e=NaN,_.d=null):c.e<o.minE?(_.e=0,_.d=[0]):(_.e=c.e,_.d=c.d.slice()):(_.e=c.e,_.d=c.d?c.d.slice():c.d);return}if(g=typeof c,g==="number"){if(c===0){_.s=1/c<0?-1:1,_.e=0,_.d=[0];return}if(c<0?(c=-c,_.s=-1):_.s=1,c===~~c&&c<1e7){for(d=0,h=c;h>=10;h/=10)d++;external?d>o.maxE?(_.e=NaN,_.d=null):d<o.minE?(_.e=0,_.d=[0]):(_.e=d,_.d=[c]):(_.e=d,_.d=[c]);return}else if(c*0!==0){c||(_.s=NaN),_.e=NaN,_.d=null;return}return parseDecimal(_,c.toString())}else if(g!=="string")throw Error(invalidArgument+c);return(h=c.charCodeAt(0))===45?(c=c.slice(1),_.s=-1):(h===43&&(c=c.slice(1)),_.s=1),isDecimal.test(c)?parseDecimal(_,c):parseOther(_,c)}if(o.prototype=P$1,o.ROUND_UP=0,o.ROUND_DOWN=1,o.ROUND_CEIL=2,o.ROUND_FLOOR=3,o.ROUND_HALF_UP=4,o.ROUND_HALF_DOWN=5,o.ROUND_HALF_EVEN=6,o.ROUND_HALF_CEIL=7,o.ROUND_HALF_FLOOR=8,o.EUCLID=9,o.config=o.set=config$1,o.clone=clone,o.isDecimal=isDecimalInstance,o.abs=abs$1,o.acos=acos,o.acosh=acosh,o.add=add$1,o.asin=asin,o.asinh=asinh,o.atan=atan$1,o.atanh=atanh,o.atan2=atan2,o.cbrt=cbrt,o.ceil=ceil,o.clamp=clamp,o.cos=cos$1,o.cosh=cosh,o.div=div,o.exp=exp,o.floor=floor,o.hypot=hypot,o.ln=ln,o.log=log,o.log10=log10,o.log2=log2,o.max=max,o.min=min,o.mod=mod,o.mul=mul,o.pow=pow$1,o.random=random,o.round=round,o.sign=sign$1,o.sin=sin$1,o.sinh=sinh,o.sqrt=sqrt$1,o.sub=sub,o.sum=sum,o.tan=tan,o.tanh=tanh,o.trunc=trunc,a===void 0&&(a={}),a&&a.defaults!==!0)for(s=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],e=0;e<s.length;)a.hasOwnProperty(i=s[e++])||(a[i]=this[i]);return o.config(a),o}function div(a,e){return new this(a).div(e)}function exp(a){return new this(a).exp()}function floor(a){return finalise(a=new this(a),a.e+1,3)}function hypot(){var a,e,i=new this(0);for(external=!1,a=0;a<arguments.length;)if(e=new this(arguments[a++]),e.d)i.d&&(i=i.plus(e.times(e)));else{if(e.s)return external=!0,new this(1/0);i=e}return external=!0,i.sqrt()}function isDecimalInstance(a){return a instanceof Decimal||a&&a.toStringTag===tag||!1}function ln(a){return new this(a).ln()}function log(a,e){return new this(a).log(e)}function log2(a){return new this(a).log(2)}function log10(a){return new this(a).log(10)}function max(){return maxOrMin(this,arguments,"lt")}function min(){return maxOrMin(this,arguments,"gt")}function mod(a,e){return new this(a).mod(e)}function mul(a,e){return new this(a).mul(e)}function pow$1(a,e){return new this(a).pow(e)}function random(a){var e,i,s,o,c=0,d=new this(1),h=[];if(a===void 0?a=this.precision:checkInt32(a,1,MAX_DIGITS),s=Math.ceil(a/LOG_BASE),this.crypto)if(crypto.getRandomValues)for(e=crypto.getRandomValues(new Uint32Array(s));c<s;)o=e[c],o>=429e7?e[c]=crypto.getRandomValues(new Uint32Array(1))[0]:h[c++]=o%1e7;else if(crypto.randomBytes){for(e=crypto.randomBytes(s*=4);c<s;)o=e[c]+(e[c+1]<<8)+(e[c+2]<<16)+((e[c+3]&127)<<24),o>=214e7?crypto.randomBytes(4).copy(e,c):(h.push(o%1e7),c+=4);c=s/4}else throw Error(cryptoUnavailable);else for(;c<s;)h[c++]=Math.random()*1e7|0;for(s=h[--c],a%=LOG_BASE,s&&a&&(o=mathpow(10,LOG_BASE-a),h[c]=(s/o|0)*o);h[c]===0;c--)h.pop();if(c<0)i=0,h=[0];else{for(i=-1;h[0]===0;i-=LOG_BASE)h.shift();for(s=1,o=h[0];o>=10;o/=10)s++;s<LOG_BASE&&(i-=LOG_BASE-s)}return d.e=i,d.d=h,d}function round(a){return finalise(a=new this(a),a.e+1,this.rounding)}function sign$1(a){return a=new this(a),a.d?a.d[0]?a.s:0*a.s:a.s||NaN}function sin$1(a){return new this(a).sin()}function sinh(a){return new this(a).sinh()}function sqrt$1(a){return new this(a).sqrt()}function sub(a,e){return new this(a).sub(e)}function sum(){var a=0,e=arguments,i=new this(e[a]);for(external=!1;i.s&&++a<e.length;)i=i.plus(e[a]);return external=!0,finalise(i,this.precision,this.rounding)}function tan(a){return new this(a).tan()}function tanh(a){return new this(a).tanh()}function trunc(a){return finalise(a=new this(a),a.e+1,1)}P$1[Symbol.for("nodejs.util.inspect.custom")]=P$1.toString;P$1[Symbol.toStringTag]="Decimal";var Decimal=P$1.constructor=clone(DEFAULTS);LN10=new Decimal(LN10);PI=new Decimal(PI);var name$16="BigNumber",dependencies$16=["?on","config"],createBigNumberClass=factory$1(name$16,dependencies$16,a=>{var{on:e,config:i}=a,s=Decimal.clone({precision:i.precision,modulo:Decimal.EUCLID});return s.prototype=Object.create(s.prototype),s.prototype.type="BigNumber",s.prototype.isBigNumber=!0,s.prototype.toJSON=function(){return{mathjs:"BigNumber",value:this.toString()}},s.fromJSON=function(o){return new s(o.value)},e&&e("config",function(o,c){o.precision!==c.precision&&s.config({precision:o.precision})}),s},{isClass:!0}),complex$1={exports:{}};/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/(function(a,e){(function(i){var s=Math.cosh||function($){return Math.abs($)<1e-9?1-$:(Math.exp($)+Math.exp(-$))*.5},o=Math.sinh||function($){return Math.abs($)<1e-9?$:(Math.exp($)-Math.exp(-$))*.5},c=function($){var j=Math.PI/4;if(-j>$||$>j)return Math.cos($)-1;var _e=$*$;return _e*(_e*(_e*(_e*(_e*(_e*(_e*(_e/20922789888e3-1/87178291200)+1/479001600)-1/3628800)+1/40320)-1/720)+1/24)-1/2)},d=function($,j){var _e=Math.abs($),tt=Math.abs(j);return _e<3e3&&tt<3e3?Math.sqrt(_e*_e+tt*tt):(_e<tt?(_e=tt,tt=$/j):tt=j/$,_e*Math.sqrt(1+tt*tt))},h=function(){throw SyntaxError("Invalid Param")};function g($,j){var _e=Math.abs($),tt=Math.abs(j);return $===0?Math.log(tt):j===0?Math.log(_e):_e<3e3&&tt<3e3?Math.log($*$+j*j)*.5:($=$/2,j=j/2,.5*Math.log($*$+j*j)+Math.LN2)}var _=function($,j){var _e={re:0,im:0};if($==null)_e.re=_e.im=0;else if(j!==void 0)_e.re=$,_e.im=j;else switch(typeof $){case"object":if("im"in $&&"re"in $)_e.re=$.re,_e.im=$.im;else if("abs"in $&&"arg"in $){if(!Number.isFinite($.abs)&&Number.isFinite($.arg))return b.INFINITY;_e.re=$.abs*Math.cos($.arg),_e.im=$.abs*Math.sin($.arg)}else if("r"in $&&"phi"in $){if(!Number.isFinite($.r)&&Number.isFinite($.phi))return b.INFINITY;_e.re=$.r*Math.cos($.phi),_e.im=$.r*Math.sin($.phi)}else $.length===2?(_e.re=$[0],_e.im=$[1]):h();break;case"string":_e.im=_e.re=0;var tt=$.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g),et=1,nt=0;tt===null&&h();for(var rt=0;rt<tt.length;rt++){var it=tt[rt];it===" "||it==="	"||it===`
`||(it==="+"?et++:it==="-"?nt++:it==="i"||it==="I"?(et+nt===0&&h(),tt[rt+1]!==" "&&!isNaN(tt[rt+1])?(_e.im+=parseFloat((nt%2?"-":"")+tt[rt+1]),rt++):_e.im+=parseFloat((nt%2?"-":"")+"1"),et=nt=0):((et+nt===0||isNaN(it))&&h(),tt[rt+1]==="i"||tt[rt+1]==="I"?(_e.im+=parseFloat((nt%2?"-":"")+it),rt++):_e.re+=parseFloat((nt%2?"-":"")+it),et=nt=0))}et+nt>0&&h();break;case"number":_e.im=0,_e.re=$;break;default:h()}return isNaN(_e.re)||isNaN(_e.im),_e};function b($,j){if(!(this instanceof b))return new b($,j);var _e=_($,j);this.re=_e.re,this.im=_e.im}b.prototype={re:0,im:0,sign:function(){var $=this.abs();return new b(this.re/$,this.im/$)},add:function($,j){var _e=new b($,j);return this.isInfinite()&&_e.isInfinite()?b.NAN:this.isInfinite()||_e.isInfinite()?b.INFINITY:new b(this.re+_e.re,this.im+_e.im)},sub:function($,j){var _e=new b($,j);return this.isInfinite()&&_e.isInfinite()?b.NAN:this.isInfinite()||_e.isInfinite()?b.INFINITY:new b(this.re-_e.re,this.im-_e.im)},mul:function($,j){var _e=new b($,j);return this.isInfinite()&&_e.isZero()||this.isZero()&&_e.isInfinite()?b.NAN:this.isInfinite()||_e.isInfinite()?b.INFINITY:_e.im===0&&this.im===0?new b(this.re*_e.re,0):new b(this.re*_e.re-this.im*_e.im,this.re*_e.im+this.im*_e.re)},div:function($,j){var _e=new b($,j);if(this.isZero()&&_e.isZero()||this.isInfinite()&&_e.isInfinite())return b.NAN;if(this.isInfinite()||_e.isZero())return b.INFINITY;if(this.isZero()||_e.isInfinite())return b.ZERO;$=this.re,j=this.im;var tt=_e.re,et=_e.im,nt,rt;return et===0?new b($/tt,j/tt):Math.abs(tt)<Math.abs(et)?(rt=tt/et,nt=tt*rt+et,new b(($*rt+j)/nt,(j*rt-$)/nt)):(rt=et/tt,nt=et*rt+tt,new b(($+j*rt)/nt,(j-$*rt)/nt))},pow:function($,j){var _e=new b($,j);if($=this.re,j=this.im,_e.isZero())return b.ONE;if(_e.im===0){if(j===0&&$>0)return new b(Math.pow($,_e.re),0);if($===0)switch((_e.re%4+4)%4){case 0:return new b(Math.pow(j,_e.re),0);case 1:return new b(0,Math.pow(j,_e.re));case 2:return new b(-Math.pow(j,_e.re),0);case 3:return new b(0,-Math.pow(j,_e.re))}}if($===0&&j===0&&_e.re>0&&_e.im>=0)return b.ZERO;var tt=Math.atan2(j,$),et=g($,j);return $=Math.exp(_e.re*et-_e.im*tt),j=_e.im*et+_e.re*tt,new b($*Math.cos(j),$*Math.sin(j))},sqrt:function(){var $=this.re,j=this.im,_e=this.abs(),tt,et;if($>=0){if(j===0)return new b(Math.sqrt($),0);tt=.5*Math.sqrt(2*(_e+$))}else tt=Math.abs(j)/Math.sqrt(2*(_e-$));return $<=0?et=.5*Math.sqrt(2*(_e-$)):et=Math.abs(j)/Math.sqrt(2*(_e+$)),new b(tt,j<0?-et:et)},exp:function(){var $=Math.exp(this.re);return this.im,new b($*Math.cos(this.im),$*Math.sin(this.im))},expm1:function(){var $=this.re,j=this.im;return new b(Math.expm1($)*Math.cos(j)+c(j),Math.exp($)*Math.sin(j))},log:function(){var $=this.re,j=this.im;return new b(g($,j),Math.atan2(j,$))},abs:function(){return d(this.re,this.im)},arg:function(){return Math.atan2(this.im,this.re)},sin:function(){var $=this.re,j=this.im;return new b(Math.sin($)*s(j),Math.cos($)*o(j))},cos:function(){var $=this.re,j=this.im;return new b(Math.cos($)*s(j),-Math.sin($)*o(j))},tan:function(){var $=2*this.re,j=2*this.im,_e=Math.cos($)+s(j);return new b(Math.sin($)/_e,o(j)/_e)},cot:function(){var $=2*this.re,j=2*this.im,_e=Math.cos($)-s(j);return new b(-Math.sin($)/_e,o(j)/_e)},sec:function(){var $=this.re,j=this.im,_e=.5*s(2*j)+.5*Math.cos(2*$);return new b(Math.cos($)*s(j)/_e,Math.sin($)*o(j)/_e)},csc:function(){var $=this.re,j=this.im,_e=.5*s(2*j)-.5*Math.cos(2*$);return new b(Math.sin($)*s(j)/_e,-Math.cos($)*o(j)/_e)},asin:function(){var $=this.re,j=this.im,_e=new b(j*j-$*$+1,-2*$*j).sqrt(),tt=new b(_e.re-j,_e.im+$).log();return new b(tt.im,-tt.re)},acos:function(){var $=this.re,j=this.im,_e=new b(j*j-$*$+1,-2*$*j).sqrt(),tt=new b(_e.re-j,_e.im+$).log();return new b(Math.PI/2-tt.im,tt.re)},atan:function(){var $=this.re,j=this.im;if($===0){if(j===1)return new b(0,1/0);if(j===-1)return new b(0,-1/0)}var _e=$*$+(1-j)*(1-j),tt=new b((1-j*j-$*$)/_e,-2*$/_e).log();return new b(-.5*tt.im,.5*tt.re)},acot:function(){var $=this.re,j=this.im;if(j===0)return new b(Math.atan2(1,$),0);var _e=$*$+j*j;return _e!==0?new b($/_e,-j/_e).atan():new b($!==0?$/0:0,j!==0?-j/0:0).atan()},asec:function(){var $=this.re,j=this.im;if($===0&&j===0)return new b(0,1/0);var _e=$*$+j*j;return _e!==0?new b($/_e,-j/_e).acos():new b($!==0?$/0:0,j!==0?-j/0:0).acos()},acsc:function(){var $=this.re,j=this.im;if($===0&&j===0)return new b(Math.PI/2,1/0);var _e=$*$+j*j;return _e!==0?new b($/_e,-j/_e).asin():new b($!==0?$/0:0,j!==0?-j/0:0).asin()},sinh:function(){var $=this.re,j=this.im;return new b(o($)*Math.cos(j),s($)*Math.sin(j))},cosh:function(){var $=this.re,j=this.im;return new b(s($)*Math.cos(j),o($)*Math.sin(j))},tanh:function(){var $=2*this.re,j=2*this.im,_e=s($)+Math.cos(j);return new b(o($)/_e,Math.sin(j)/_e)},coth:function(){var $=2*this.re,j=2*this.im,_e=s($)-Math.cos(j);return new b(o($)/_e,-Math.sin(j)/_e)},csch:function(){var $=this.re,j=this.im,_e=Math.cos(2*j)-s(2*$);return new b(-2*o($)*Math.cos(j)/_e,2*s($)*Math.sin(j)/_e)},sech:function(){var $=this.re,j=this.im,_e=Math.cos(2*j)+s(2*$);return new b(2*s($)*Math.cos(j)/_e,-2*o($)*Math.sin(j)/_e)},asinh:function(){var $=this.im;this.im=-this.re,this.re=$;var j=this.asin();return this.re=-this.im,this.im=$,$=j.re,j.re=-j.im,j.im=$,j},acosh:function(){var $=this.acos();if($.im<=0){var j=$.re;$.re=-$.im,$.im=j}else{var j=$.im;$.im=-$.re,$.re=j}return $},atanh:function(){var $=this.re,j=this.im,_e=$>1&&j===0,tt=1-$,et=1+$,nt=tt*tt+j*j,rt=nt!==0?new b((et*tt-j*j)/nt,(j*tt+et*j)/nt):new b($!==-1?$/0:0,j!==0?j/0:0),it=rt.re;return rt.re=g(rt.re,rt.im)/2,rt.im=Math.atan2(rt.im,it)/2,_e&&(rt.im=-rt.im),rt},acoth:function(){var $=this.re,j=this.im;if($===0&&j===0)return new b(0,Math.PI/2);var _e=$*$+j*j;return _e!==0?new b($/_e,-j/_e).atanh():new b($!==0?$/0:0,j!==0?-j/0:0).atanh()},acsch:function(){var $=this.re,j=this.im;if(j===0)return new b($!==0?Math.log($+Math.sqrt($*$+1)):1/0,0);var _e=$*$+j*j;return _e!==0?new b($/_e,-j/_e).asinh():new b($!==0?$/0:0,j!==0?-j/0:0).asinh()},asech:function(){var $=this.re,j=this.im;if(this.isZero())return b.INFINITY;var _e=$*$+j*j;return _e!==0?new b($/_e,-j/_e).acosh():new b($!==0?$/0:0,j!==0?-j/0:0).acosh()},inverse:function(){if(this.isZero())return b.INFINITY;if(this.isInfinite())return b.ZERO;var $=this.re,j=this.im,_e=$*$+j*j;return new b($/_e,-j/_e)},conjugate:function(){return new b(this.re,-this.im)},neg:function(){return new b(-this.re,-this.im)},ceil:function($){return $=Math.pow(10,$||0),new b(Math.ceil(this.re*$)/$,Math.ceil(this.im*$)/$)},floor:function($){return $=Math.pow(10,$||0),new b(Math.floor(this.re*$)/$,Math.floor(this.im*$)/$)},round:function($){return $=Math.pow(10,$||0),new b(Math.round(this.re*$)/$,Math.round(this.im*$)/$)},equals:function($,j){var _e=new b($,j);return Math.abs(_e.re-this.re)<=b.EPSILON&&Math.abs(_e.im-this.im)<=b.EPSILON},clone:function(){return new b(this.re,this.im)},toString:function(){var $=this.re,j=this.im,_e="";return this.isNaN()?"NaN":this.isInfinite()?"Infinity":(Math.abs($)<b.EPSILON&&($=0),Math.abs(j)<b.EPSILON&&(j=0),j===0?_e+$:($!==0?(_e+=$,_e+=" ",j<0?(j=-j,_e+="-"):_e+="+",_e+=" "):j<0&&(j=-j,_e+="-"),j!==1&&(_e+=j),_e+"i"))},toVector:function(){return[this.re,this.im]},valueOf:function(){return this.im===0?this.re:null},isNaN:function(){return isNaN(this.re)||isNaN(this.im)},isZero:function(){return this.im===0&&this.re===0},isFinite:function(){return isFinite(this.re)&&isFinite(this.im)},isInfinite:function(){return!(this.isNaN()||this.isFinite())}},b.ZERO=new b(0,0),b.ONE=new b(1,0),b.I=new b(0,1),b.PI=new b(Math.PI,0),b.E=new b(Math.E,0),b.INFINITY=new b(1/0,1/0),b.NAN=new b(NaN,NaN),b.EPSILON=1e-15,Object.defineProperty(b,"__esModule",{value:!0}),b.default=b,b.Complex=b,a.exports=b})()})(complex$1);var complexExports=complex$1.exports;const Complex$1=getDefaultExportFromCjs$1(complexExports);var name$15="Complex",dependencies$15=[],createComplexClass=factory$1(name$15,dependencies$15,()=>(Complex$1.prototype.type="Complex",Complex$1.prototype.isComplex=!0,Complex$1.prototype.toJSON=function(){return{mathjs:"Complex",re:this.re,im:this.im}},Complex$1.prototype.toPolar=function(){return{r:this.abs(),phi:this.arg()}},Complex$1.prototype.format=function(a){var e="",i=this.im,s=this.re,o=format$2(this.re,a),c=format$2(this.im,a),d=isNumber(a)?a:a?a.precision:null;if(d!==null){var h=Math.pow(10,-d);Math.abs(s/i)<h&&(s=0),Math.abs(i/s)<h&&(i=0)}return i===0?e=o:s===0?i===1?e="i":i===-1?e="-i":e=c+"i":i<0?i===-1?e=o+" - i":e=o+" - "+c.substring(1)+"i":i===1?e=o+" + i":e=o+" + "+c+"i",e},Complex$1.fromPolar=function(a){switch(arguments.length){case 1:{var e=arguments[0];if(typeof e=="object")return Complex$1(e);throw new TypeError("Input has to be an object with r and phi keys.")}case 2:{var i=arguments[0],s=arguments[1];if(isNumber(i)){if(isUnit(s)&&s.hasBase("ANGLE")&&(s=s.toNumber("rad")),isNumber(s))return new Complex$1({r:i,phi:s});throw new TypeError("Phi is not a number nor an angle unit.")}else throw new TypeError("Radius r is not a number.")}default:throw new SyntaxError("Wrong number of arguments in function fromPolar")}},Complex$1.prototype.valueOf=Complex$1.prototype.toString,Complex$1.fromJSON=function(a){return new Complex$1(a)},Complex$1.compare=function(a,e){return a.re>e.re?1:a.re<e.re?-1:a.im>e.im?1:a.im<e.im?-1:0},Complex$1),{isClass:!0});/**
 * @license Fraction.js v4.3.7 31/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/var MAX_CYCLE_LEN=2e3,P={s:1,n:0,d:1};function assign(a,e){if(isNaN(a=parseInt(a,10)))throw InvalidParameter();return a*e}function newFraction(a,e){if(e===0)throw DivisionByZero();var i=Object.create(Fraction$1.prototype);i.s=a<0?-1:1,a=a<0?-a:a;var s=gcd(a,e);return i.n=a/s,i.d=e/s,i}function factorize(a){for(var e={},i=a,s=2,o=4;o<=i;){for(;i%s===0;)i/=s,e[s]=(e[s]||0)+1;o+=1+2*s++}return i!==a?i>1&&(e[i]=(e[i]||0)+1):e[a]=(e[a]||0)+1,e}var parse=function(a,e){var i=0,s=1,o=1,c=0,d=0,h=0,g=1,_=1,b=0,$=1,j=1,_e=1,tt=1e7,et;if(a!=null)if(e!==void 0){if(i=a,s=e,o=i*s,i%1!==0||s%1!==0)throw NonIntegerParameter()}else switch(typeof a){case"object":{if("d"in a&&"n"in a)i=a.n,s=a.d,"s"in a&&(i*=a.s);else if(0 in a)i=a[0],1 in a&&(s=a[1]);else throw InvalidParameter();o=i*s;break}case"number":{if(a<0&&(o=a,a=-a),a%1===0)i=a;else if(a>0){for(a>=1&&(_=Math.pow(10,Math.floor(1+Math.log(a)/Math.LN10)),a/=_);$<=tt&&_e<=tt;)if(et=(b+j)/($+_e),a===et){$+_e<=tt?(i=b+j,s=$+_e):_e>$?(i=j,s=_e):(i=b,s=$);break}else a>et?(b+=j,$+=_e):(j+=b,_e+=$),$>tt?(i=j,s=_e):(i=b,s=$);i*=_}else(isNaN(a)||isNaN(e))&&(s=i=NaN);break}case"string":{if($=a.match(/\d+|./g),$===null)throw InvalidParameter();if($[b]==="-"?(o=-1,b++):$[b]==="+"&&b++,$.length===b+1?d=assign($[b++],o):$[b+1]==="."||$[b]==="."?($[b]!=="."&&(c=assign($[b++],o)),b++,(b+1===$.length||$[b+1]==="("&&$[b+3]===")"||$[b+1]==="'"&&$[b+3]==="'")&&(d=assign($[b],o),g=Math.pow(10,$[b].length),b++),($[b]==="("&&$[b+2]===")"||$[b]==="'"&&$[b+2]==="'")&&(h=assign($[b+1],o),_=Math.pow(10,$[b+1].length)-1,b+=3)):$[b+1]==="/"||$[b+1]===":"?(d=assign($[b],o),g=assign($[b+2],1),b+=3):$[b+3]==="/"&&$[b+1]===" "&&(c=assign($[b],o),d=assign($[b+2],o),g=assign($[b+4],1),b+=5),$.length<=b){s=g*_,o=i=h+s*c+_*d;break}}default:throw InvalidParameter()}if(s===0)throw DivisionByZero();P.s=o<0?-1:1,P.n=Math.abs(i),P.d=Math.abs(s)};function modpow(a,e,i){for(var s=1;e>0;a=a*a%i,e>>=1)e&1&&(s=s*a%i);return s}function cycleLen(a,e){for(;e%2===0;e/=2);for(;e%5===0;e/=5);if(e===1)return 0;for(var i=10%e,s=1;i!==1;s++)if(i=i*10%e,s>MAX_CYCLE_LEN)return 0;return s}function cycleStart(a,e,i){for(var s=1,o=modpow(10,i,e),c=0;c<300;c++){if(s===o)return c;s=s*10%e,o=o*10%e}return 0}function gcd(a,e){if(!a)return e;if(!e)return a;for(;;){if(a%=e,!a)return e;if(e%=a,!e)return a}}function Fraction$1(a,e){if(parse(a,e),this instanceof Fraction$1)a=gcd(P.d,P.n),this.s=P.s,this.n=P.n/a,this.d=P.d/a;else return newFraction(P.s*P.n,P.d)}var DivisionByZero=function(){return new Error("Division by Zero")},InvalidParameter=function(){return new Error("Invalid argument")},NonIntegerParameter=function(){return new Error("Parameters must be integer")};Fraction$1.prototype={s:1,n:0,d:1,abs:function(){return newFraction(this.n,this.d)},neg:function(){return newFraction(-this.s*this.n,this.d)},add:function(a,e){return parse(a,e),newFraction(this.s*this.n*P.d+P.s*this.d*P.n,this.d*P.d)},sub:function(a,e){return parse(a,e),newFraction(this.s*this.n*P.d-P.s*this.d*P.n,this.d*P.d)},mul:function(a,e){return parse(a,e),newFraction(this.s*P.s*this.n*P.n,this.d*P.d)},div:function(a,e){return parse(a,e),newFraction(this.s*P.s*this.n*P.d,this.d*P.n)},clone:function(){return newFraction(this.s*this.n,this.d)},mod:function(a,e){if(isNaN(this.n)||isNaN(this.d))return new Fraction$1(NaN);if(a===void 0)return newFraction(this.s*this.n%this.d,1);if(parse(a,e),P.n===0&&this.d===0)throw DivisionByZero();return newFraction(this.s*(P.d*this.n)%(P.n*this.d),P.d*this.d)},gcd:function(a,e){return parse(a,e),newFraction(gcd(P.n,this.n)*gcd(P.d,this.d),P.d*this.d)},lcm:function(a,e){return parse(a,e),P.n===0&&this.n===0?newFraction(0,1):newFraction(P.n*this.n,gcd(P.n,this.n)*gcd(P.d,this.d))},ceil:function(a){return a=Math.pow(10,a||0),isNaN(this.n)||isNaN(this.d)?new Fraction$1(NaN):newFraction(Math.ceil(a*this.s*this.n/this.d),a)},floor:function(a){return a=Math.pow(10,a||0),isNaN(this.n)||isNaN(this.d)?new Fraction$1(NaN):newFraction(Math.floor(a*this.s*this.n/this.d),a)},round:function(a){return a=Math.pow(10,a||0),isNaN(this.n)||isNaN(this.d)?new Fraction$1(NaN):newFraction(Math.round(a*this.s*this.n/this.d),a)},roundTo:function(a,e){return parse(a,e),newFraction(this.s*Math.round(this.n*P.d/(this.d*P.n))*P.n,P.d)},inverse:function(){return newFraction(this.s*this.d,this.n)},pow:function(a,e){if(parse(a,e),P.d===1)return P.s<0?newFraction(Math.pow(this.s*this.d,P.n),Math.pow(this.n,P.n)):newFraction(Math.pow(this.s*this.n,P.n),Math.pow(this.d,P.n));if(this.s<0)return null;var i=factorize(this.n),s=factorize(this.d),o=1,c=1;for(var d in i)if(d!=="1"){if(d==="0"){o=0;break}if(i[d]*=P.n,i[d]%P.d===0)i[d]/=P.d;else return null;o*=Math.pow(d,i[d])}for(var d in s)if(d!=="1"){if(s[d]*=P.n,s[d]%P.d===0)s[d]/=P.d;else return null;c*=Math.pow(d,s[d])}return P.s<0?newFraction(c,o):newFraction(o,c)},equals:function(a,e){return parse(a,e),this.s*this.n*P.d===P.s*P.n*this.d},compare:function(a,e){parse(a,e);var i=this.s*this.n*P.d-P.s*P.n*this.d;return(0<i)-(i<0)},simplify:function(a){if(isNaN(this.n)||isNaN(this.d))return this;a=a||.001;for(var e=this.abs(),i=e.toContinued(),s=1;s<i.length;s++){for(var o=newFraction(i[s-1],1),c=s-2;c>=0;c--)o=o.inverse().add(i[c]);if(Math.abs(o.sub(e).valueOf())<a)return o.mul(this.s)}return this},divisible:function(a,e){return parse(a,e),!(!(P.n*this.d)||this.n*P.d%(P.n*this.d))},valueOf:function(){return this.s*this.n/this.d},toFraction:function(a){var e,i="",s=this.n,o=this.d;return this.s<0&&(i+="-"),o===1?i+=s:(a&&(e=Math.floor(s/o))>0&&(i+=e,i+=" ",s%=o),i+=s,i+="/",i+=o),i},toLatex:function(a){var e,i="",s=this.n,o=this.d;return this.s<0&&(i+="-"),o===1?i+=s:(a&&(e=Math.floor(s/o))>0&&(i+=e,s%=o),i+="\\frac{",i+=s,i+="}{",i+=o,i+="}"),i},toContinued:function(){var a,e=this.n,i=this.d,s=[];if(isNaN(e)||isNaN(i))return s;do s.push(Math.floor(e/i)),a=e%i,e=i,i=a;while(e!==1);return s},toString:function(a){var e=this.n,i=this.d;if(isNaN(e)||isNaN(i))return"NaN";a=a||15;var s=cycleLen(e,i),o=cycleStart(e,i,s),c=this.s<0?"-":"";if(c+=e/i|0,e%=i,e*=10,e&&(c+="."),s){for(var d=o;d--;)c+=e/i|0,e%=i,e*=10;c+="(";for(var d=s;d--;)c+=e/i|0,e%=i,e*=10;c+=")"}else for(var d=a;e&&d--;)c+=e/i|0,e%=i,e*=10;return c}};var name$14="Fraction",dependencies$14=[],createFractionClass=factory$1(name$14,dependencies$14,()=>(Fraction$1.prototype.type="Fraction",Fraction$1.prototype.isFraction=!0,Fraction$1.prototype.toJSON=function(){return{mathjs:"Fraction",n:this.s*this.n,d:this.d}},Fraction$1.fromJSON=function(a){return new Fraction$1(a)},Fraction$1),{isClass:!0}),name$13="Matrix",dependencies$13=[],createMatrixClass=factory$1(name$13,dependencies$13,()=>{function a(){if(!(this instanceof a))throw new SyntaxError("Constructor must be called with the new operator")}return a.prototype.type="Matrix",a.prototype.isMatrix=!0,a.prototype.storage=function(){throw new Error("Cannot invoke storage on a Matrix interface")},a.prototype.datatype=function(){throw new Error("Cannot invoke datatype on a Matrix interface")},a.prototype.create=function(e,i){throw new Error("Cannot invoke create on a Matrix interface")},a.prototype.subset=function(e,i,s){throw new Error("Cannot invoke subset on a Matrix interface")},a.prototype.get=function(e){throw new Error("Cannot invoke get on a Matrix interface")},a.prototype.set=function(e,i,s){throw new Error("Cannot invoke set on a Matrix interface")},a.prototype.resize=function(e,i){throw new Error("Cannot invoke resize on a Matrix interface")},a.prototype.reshape=function(e,i){throw new Error("Cannot invoke reshape on a Matrix interface")},a.prototype.clone=function(){throw new Error("Cannot invoke clone on a Matrix interface")},a.prototype.size=function(){throw new Error("Cannot invoke size on a Matrix interface")},a.prototype.map=function(e,i){throw new Error("Cannot invoke map on a Matrix interface")},a.prototype.forEach=function(e){throw new Error("Cannot invoke forEach on a Matrix interface")},a.prototype[Symbol.iterator]=function(){throw new Error("Cannot iterate a Matrix interface")},a.prototype.toArray=function(){throw new Error("Cannot invoke toArray on a Matrix interface")},a.prototype.valueOf=function(){throw new Error("Cannot invoke valueOf on a Matrix interface")},a.prototype.format=function(e){throw new Error("Cannot invoke format on a Matrix interface")},a.prototype.toString=function(){throw new Error("Cannot invoke toString on a Matrix interface")},a},{isClass:!0}),name$12="DenseMatrix",dependencies$12=["Matrix"],createDenseMatrixClass=factory$1(name$12,dependencies$12,a=>{var{Matrix:e}=a;function i(b,$){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator");if($&&!isString($))throw new Error("Invalid datatype: "+$);if(isMatrix(b))b.type==="DenseMatrix"?(this._data=clone$1(b._data),this._size=clone$1(b._size),this._datatype=$||b._datatype):(this._data=b.toArray(),this._size=b.size(),this._datatype=$||b._datatype);else if(b&&isArray(b.data)&&isArray(b.size))this._data=b.data,this._size=b.size,validate(this._data,this._size),this._datatype=$||b.datatype;else if(isArray(b))this._data=_(b),this._size=arraySize(this._data),validate(this._data,this._size),this._datatype=$;else{if(b)throw new TypeError("Unsupported type of data ("+typeOf(b)+")");this._data=[],this._size=[0],this._datatype=$}}i.prototype=new e,i.prototype.createDenseMatrix=function(b,$){return new i(b,$)},i.prototype.type="DenseMatrix",i.prototype.isDenseMatrix=!0,i.prototype.getDataType=function(){return getArrayDataType(this._data,typeOf)},i.prototype.storage=function(){return"dense"},i.prototype.datatype=function(){return this._datatype},i.prototype.create=function(b,$){return new i(b,$)},i.prototype.subset=function(b,$,j){switch(arguments.length){case 1:return s(this,b);case 2:case 3:return c(this,b,$,j);default:throw new SyntaxError("Wrong number of arguments")}},i.prototype.get=function(b){if(!isArray(b))throw new TypeError("Array expected");if(b.length!==this._size.length)throw new DimensionError(b.length,this._size.length);for(var $=0;$<b.length;$++)validateIndex(b[$],this._size[$]);for(var j=this._data,_e=0,tt=b.length;_e<tt;_e++){var et=b[_e];validateIndex(et,j.length),j=j[et]}return j},i.prototype.set=function(b,$,j){if(!isArray(b))throw new TypeError("Array expected");if(b.length<this._size.length)throw new DimensionError(b.length,this._size.length,"<");var _e,tt,et,nt=b.map(function(it){return it+1});g(this,nt,j);var rt=this._data;for(_e=0,tt=b.length-1;_e<tt;_e++)et=b[_e],validateIndex(et,rt.length),rt=rt[et];return et=b[b.length-1],validateIndex(et,rt.length),rt[et]=$,this};function s(b,$){if(!isIndex($))throw new TypeError("Invalid index");var j=$.isScalar();if(j)return b.get($.min());var _e=$.size();if(_e.length!==b._size.length)throw new DimensionError(_e.length,b._size.length);for(var tt=$.min(),et=$.max(),nt=0,rt=b._size.length;nt<rt;nt++)validateIndex(tt[nt],b._size[nt]),validateIndex(et[nt],b._size[nt]);return new i(o(b._data,$,_e.length,0),b._datatype)}function o(b,$,j,_e){var tt=_e===j-1,et=$.dimension(_e);return tt?et.map(function(nt){return validateIndex(nt,b.length),b[nt]}).valueOf():et.map(function(nt){validateIndex(nt,b.length);var rt=b[nt];return o(rt,$,j,_e+1)}).valueOf()}function c(b,$,j,_e){if(!$||$.isIndex!==!0)throw new TypeError("Invalid index");var tt=$.size(),et=$.isScalar(),nt;if(isMatrix(j)?(nt=j.size(),j=j.valueOf()):nt=arraySize(j),et){if(nt.length!==0)throw new TypeError("Scalar expected");b.set($.min(),j,_e)}else{if(tt.length<b._size.length)throw new DimensionError(tt.length,b._size.length,"<");if(nt.length<tt.length){for(var rt=0,it=0;tt[rt]===1&&nt[rt]===1;)rt++;for(;tt[rt]===1;)it++,rt++;j=unsqueeze(j,tt.length,it,nt)}if(!deepStrictEqual(tt,nt))throw new DimensionError(tt,nt,">");var at=$.max().map(function(ct){return ct+1});g(b,at,_e);var st=tt.length,ot=0;d(b._data,$,j,st,ot)}return b}function d(b,$,j,_e,tt){var et=tt===_e-1,nt=$.dimension(tt);et?nt.forEach(function(rt,it){validateIndex(rt),b[rt]=j[it[0]]}):nt.forEach(function(rt,it){validateIndex(rt),d(b[rt],$,j[it[0]],_e,tt+1)})}i.prototype.resize=function(b,$,j){if(!isCollection(b))throw new TypeError("Array or Matrix expected");var _e=b.valueOf().map(et=>Array.isArray(et)&&et.length===1?et[0]:et),tt=j?this.clone():this;return h(tt,_e,$)};function h(b,$,j){if($.length===0){for(var _e=b._data;isArray(_e);)_e=_e[0];return _e}return b._size=$.slice(0),b._data=resize(b._data,b._size,j),b}i.prototype.reshape=function(b,$){var j=$?this.clone():this;j._data=reshape(j._data,b);var _e=j._size.reduce((tt,et)=>tt*et);return j._size=processSizesWildcard(b,_e),j};function g(b,$,j){for(var _e=b._size.slice(0),tt=!1;_e.length<$.length;)_e.push(0),tt=!0;for(var et=0,nt=$.length;et<nt;et++)$[et]>_e[et]&&(_e[et]=$[et],tt=!0);tt&&h(b,_e,j)}i.prototype.clone=function(){var b=new i({data:clone$1(this._data),size:clone$1(this._size),datatype:this._datatype});return b},i.prototype.size=function(){return this._size.slice(0)},i.prototype.map=function(b){var $=this,j=function et(nt,rt){return isArray(nt)?nt.map(function(it,at){return et(it,rt.concat(at))}):b(nt,rt,$)},_e=j(this._data,[]),tt=this._datatype!==void 0?getArrayDataType(_e,typeOf):void 0;return new i(_e,tt)},i.prototype.forEach=function(b){var $=this,j=function _e(tt,et){isArray(tt)?tt.forEach(function(nt,rt){_e(nt,et.concat(rt))}):b(tt,et,$)};j(this._data,[])},i.prototype[Symbol.iterator]=function*(){var b=function*$(j,_e){if(isArray(j))for(var tt=0;tt<j.length;tt++)yield*$(j[tt],_e.concat(tt));else yield{value:j,index:_e}};yield*b(this._data,[])},i.prototype.rows=function(){var b=[],$=this.size();if($.length!==2)throw new TypeError("Rows can only be returned for a 2D matrix.");var j=this._data;for(var _e of j)b.push(new i([_e],this._datatype));return b},i.prototype.columns=function(){var b=this,$=[],j=this.size();if(j.length!==2)throw new TypeError("Rows can only be returned for a 2D matrix.");for(var _e=this._data,tt=function(rt){var it=_e.map(at=>[at[rt]]);$.push(new i(it,b._datatype))},et=0;et<j[1];et++)tt(et);return $},i.prototype.toArray=function(){return clone$1(this._data)},i.prototype.valueOf=function(){return this._data},i.prototype.format=function(b){return format(this._data,b)},i.prototype.toString=function(){return format(this._data)},i.prototype.toJSON=function(){return{mathjs:"DenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},i.prototype.diagonal=function(b){if(b){if(isBigNumber(b)&&(b=b.toNumber()),!isNumber(b)||!isInteger(b))throw new TypeError("The parameter k must be an integer number")}else b=0;for(var $=b>0?b:0,j=b<0?-b:0,_e=this._size[0],tt=this._size[1],et=Math.min(_e-j,tt-$),nt=[],rt=0;rt<et;rt++)nt[rt]=this._data[rt+j][rt+$];return new i({data:nt,size:[et],datatype:this._datatype})},i.diagonal=function(b,$,j,_e){if(!isArray(b))throw new TypeError("Array expected, size parameter");if(b.length!==2)throw new Error("Only two dimensions matrix are supported");if(b=b.map(function(lt){if(isBigNumber(lt)&&(lt=lt.toNumber()),!isNumber(lt)||!isInteger(lt)||lt<1)throw new Error("Size values must be positive integers");return lt}),j){if(isBigNumber(j)&&(j=j.toNumber()),!isNumber(j)||!isInteger(j))throw new TypeError("The parameter k must be an integer number")}else j=0;var tt=j>0?j:0,et=j<0?-j:0,nt=b[0],rt=b[1],it=Math.min(nt-et,rt-tt),at;if(isArray($)){if($.length!==it)throw new Error("Invalid value array length");at=function(dt){return $[dt]}}else if(isMatrix($)){var st=$.size();if(st.length!==1||st[0]!==it)throw new Error("Invalid matrix length");at=function(dt){return $.get([dt])}}else at=function(){return $};_e||(_e=isBigNumber(at(0))?at(0).mul(0):0);var ot=[];if(b.length>0){ot=resize(ot,b,_e);for(var ct=0;ct<it;ct++)ot[ct+et][ct+tt]=at(ct)}return new i({data:ot,size:[nt,rt]})},i.fromJSON=function(b){return new i(b)},i.prototype.swapRows=function(b,$){if(!isNumber(b)||!isInteger(b)||!isNumber($)||!isInteger($))throw new Error("Row index must be positive integers");if(this._size.length!==2)throw new Error("Only two dimensional matrix is supported");return validateIndex(b,this._size[0]),validateIndex($,this._size[0]),i._swapRows(b,$,this._data),this},i._swapRows=function(b,$,j){var _e=j[b];j[b]=j[$],j[$]=_e};function _(b){for(var $=0,j=b.length;$<j;$++){var _e=b[$];isArray(_e)?b[$]=_(_e):_e&&_e.isMatrix===!0&&(b[$]=_(_e.valueOf()))}return b}return i},{isClass:!0});function deepMap(a,e,i){return a&&typeof a.map=="function"?a.map(function(s){return deepMap(s,e)}):e(a)}var n1$1="number",n2="number, number";function absNumber(a){return Math.abs(a)}absNumber.signature=n1$1;function addNumber(a,e){return a+e}addNumber.signature=n2;function multiplyNumber(a,e){return a*e}multiplyNumber.signature=n2;function unaryMinusNumber(a){return-a}unaryMinusNumber.signature=n1$1;function signNumber(a){return sign$2(a)}signNumber.signature=n1$1;function powNumber(a,e){return a*a<1&&e===1/0||a*a>1&&e===-1/0?0:Math.pow(a,e)}powNumber.signature=n2;var n1="number";function isZeroNumber(a){return a===0}isZeroNumber.signature=n1;var name$11="isZero",dependencies$11=["typed"],createIsZero=factory$1(name$11,dependencies$11,a=>{var{typed:e}=a;return e(name$11,{number:isZeroNumber,BigNumber:function(s){return s.isZero()},Complex:function(s){return s.re===0&&s.im===0},Fraction:function(s){return s.d===1&&s.n===0},Unit:function(s){return this(s.value)},"Array | Matrix":function(s){return deepMap(s,this)}})});function nearlyEqual(a,e,i){if(i==null)return a.eq(e);if(a.eq(e))return!0;if(a.isNaN()||e.isNaN())return!1;if(a.isFinite()&&e.isFinite()){var s=a.minus(e).abs();if(s.isZero())return!0;var o=a.constructor.max(a.abs(),e.abs());return s.lte(o.times(i))}return!1}function complexEquals(a,e,i){return nearlyEqual$1(a.re,e.re,i)&&nearlyEqual$1(a.im,e.im,i)}var name$10="equalScalar",dependencies$10=["typed","config"],createEqualScalar=factory$1(name$10,dependencies$10,a=>{var{typed:e,config:i}=a;return e(name$10,{"boolean, boolean":function(o,c){return o===c},"number, number":function(o,c){return nearlyEqual$1(o,c,i.epsilon)},"BigNumber, BigNumber":function(o,c){return o.eq(c)||nearlyEqual(o,c,i.epsilon)},"Fraction, Fraction":function(o,c){return o.equals(c)},"Complex, Complex":function(o,c){return complexEquals(o,c,i.epsilon)},"Unit, Unit":function(o,c){if(!o.equalBase(c))throw new Error("Cannot compare units with different base");return this(o.value,c.value)}})});factory$1(name$10,["typed","config"],a=>{var{typed:e,config:i}=a;return e(name$10,{"number, number":function(o,c){return nearlyEqual$1(o,c,i.epsilon)}})});var name$$="SparseMatrix",dependencies$$=["typed","equalScalar","Matrix"],createSparseMatrixClass=factory$1(name$$,dependencies$$,a=>{var{typed:e,equalScalar:i,Matrix:s}=a;function o(et,nt){if(!(this instanceof o))throw new SyntaxError("Constructor must be called with the new operator");if(nt&&!isString(nt))throw new Error("Invalid datatype: "+nt);if(isMatrix(et))c(this,et,nt);else if(et&&isArray(et.index)&&isArray(et.ptr)&&isArray(et.size))this._values=et.values,this._index=et.index,this._ptr=et.ptr,this._size=et.size,this._datatype=nt||et.datatype;else if(isArray(et))d(this,et,nt);else{if(et)throw new TypeError("Unsupported type of data ("+typeOf(et)+")");this._values=[],this._index=[],this._ptr=[0],this._size=[0,0],this._datatype=nt}}function c(et,nt,rt){nt.type==="SparseMatrix"?(et._values=nt._values?clone$1(nt._values):void 0,et._index=clone$1(nt._index),et._ptr=clone$1(nt._ptr),et._size=clone$1(nt._size),et._datatype=rt||nt._datatype):d(et,nt.valueOf(),rt||nt._datatype)}function d(et,nt,rt){et._values=[],et._index=[],et._ptr=[],et._datatype=rt;var it=nt.length,at=0,st=i,ot=0;if(isString(rt)&&(st=e.find(i,[rt,rt])||i,ot=e.convert(0,rt)),it>0){var ct=0;do{et._ptr.push(et._index.length);for(var lt=0;lt<it;lt++){var dt=nt[lt];if(isArray(dt)){if(ct===0&&at<dt.length&&(at=dt.length),ct<dt.length){var xt=dt[ct];st(xt,ot)||(et._values.push(xt),et._index.push(lt))}}else ct===0&&at<1&&(at=1),st(dt,ot)||(et._values.push(dt),et._index.push(lt))}ct++}while(ct<at)}et._ptr.push(et._index.length),et._size=[it,at]}o.prototype=new s,o.prototype.createSparseMatrix=function(et,nt){return new o(et,nt)},o.prototype.type="SparseMatrix",o.prototype.isSparseMatrix=!0,o.prototype.getDataType=function(){return getArrayDataType(this._values,typeOf)},o.prototype.storage=function(){return"sparse"},o.prototype.datatype=function(){return this._datatype},o.prototype.create=function(et,nt){return new o(et,nt)},o.prototype.density=function(){var et=this._size[0],nt=this._size[1];return et!==0&&nt!==0?this._index.length/(et*nt):0},o.prototype.subset=function(et,nt,rt){if(!this._values)throw new Error("Cannot invoke subset on a Pattern only matrix");switch(arguments.length){case 1:return h(this,et);case 2:case 3:return g(this,et,nt,rt);default:throw new SyntaxError("Wrong number of arguments")}};function h(et,nt){if(!isIndex(nt))throw new TypeError("Invalid index");var rt=nt.isScalar();if(rt)return et.get(nt.min());var it=nt.size();if(it.length!==et._size.length)throw new DimensionError(it.length,et._size.length);var at,st,ot,ct,lt=nt.min(),dt=nt.max();for(at=0,st=et._size.length;at<st;at++)validateIndex(lt[at],et._size[at]),validateIndex(dt[at],et._size[at]);var xt=et._values,ut=et._index,ft=et._ptr,mt=nt.dimension(0),yt=nt.dimension(1),St=[],Et=[];mt.forEach(function($t,Ct){Et[$t]=Ct[0],St[$t]=!0});var vt=xt?[]:void 0,Nt=[],wt=[];return yt.forEach(function($t){for(wt.push(Nt.length),ot=ft[$t],ct=ft[$t+1];ot<ct;ot++)at=ut[ot],St[at]===!0&&(Nt.push(Et[at]),vt&&vt.push(xt[ot]))}),wt.push(Nt.length),new o({values:vt,index:Nt,ptr:wt,size:it,datatype:et._datatype})}function g(et,nt,rt,it){if(!nt||nt.isIndex!==!0)throw new TypeError("Invalid index");var at=nt.size(),st=nt.isScalar(),ot;if(isMatrix(rt)?(ot=rt.size(),rt=rt.toArray()):ot=arraySize(rt),st){if(ot.length!==0)throw new TypeError("Scalar expected");et.set(nt.min(),rt,it)}else{if(at.length!==1&&at.length!==2)throw new DimensionError(at.length,et._size.length,"<");if(ot.length<at.length){for(var ct=0,lt=0;at[ct]===1&&ot[ct]===1;)ct++;for(;at[ct]===1;)lt++,ct++;rt=unsqueeze(rt,at.length,lt,ot)}if(!deepStrictEqual(at,ot))throw new DimensionError(at,ot,">");if(at.length===1){var dt=nt.dimension(0);dt.forEach(function(ft,mt){validateIndex(ft),et.set([ft,0],rt[mt[0]],it)})}else{var xt=nt.dimension(0),ut=nt.dimension(1);xt.forEach(function(ft,mt){validateIndex(ft),ut.forEach(function(yt,St){validateIndex(yt),et.set([ft,yt],rt[mt[0]][St[0]],it)})})}}return et}o.prototype.get=function(et){if(!isArray(et))throw new TypeError("Array expected");if(et.length!==this._size.length)throw new DimensionError(et.length,this._size.length);if(!this._values)throw new Error("Cannot invoke get on a Pattern only matrix");var nt=et[0],rt=et[1];validateIndex(nt,this._size[0]),validateIndex(rt,this._size[1]);var it=_(nt,this._ptr[rt],this._ptr[rt+1],this._index);return it<this._ptr[rt+1]&&this._index[it]===nt?this._values[it]:0},o.prototype.set=function(et,nt,rt){if(!isArray(et))throw new TypeError("Array expected");if(et.length!==this._size.length)throw new DimensionError(et.length,this._size.length);if(!this._values)throw new Error("Cannot invoke set on a Pattern only matrix");var it=et[0],at=et[1],st=this._size[0],ot=this._size[1],ct=i,lt=0;isString(this._datatype)&&(ct=e.find(i,[this._datatype,this._datatype])||i,lt=e.convert(0,this._datatype)),(it>st-1||at>ot-1)&&(j(this,Math.max(it+1,st),Math.max(at+1,ot),rt),st=this._size[0],ot=this._size[1]),validateIndex(it,st),validateIndex(at,ot);var dt=_(it,this._ptr[at],this._ptr[at+1],this._index);return dt<this._ptr[at+1]&&this._index[dt]===it?ct(nt,lt)?b(dt,at,this._values,this._index,this._ptr):this._values[dt]=nt:$(dt,it,at,nt,this._values,this._index,this._ptr),this};function _(et,nt,rt,it){if(rt-nt===0)return rt;for(var at=nt;at<rt;at++)if(it[at]===et)return at;return nt}function b(et,nt,rt,it,at){rt.splice(et,1),it.splice(et,1);for(var st=nt+1;st<at.length;st++)at[st]--}function $(et,nt,rt,it,at,st,ot){at.splice(et,0,it),st.splice(et,0,nt);for(var ct=rt+1;ct<ot.length;ct++)ot[ct]++}o.prototype.resize=function(et,nt,rt){if(!isCollection(et))throw new TypeError("Array or Matrix expected");var it=et.valueOf().map(st=>Array.isArray(st)&&st.length===1?st[0]:st);if(it.length!==2)throw new Error("Only two dimensions matrix are supported");it.forEach(function(st){if(!isNumber(st)||!isInteger(st)||st<0)throw new TypeError("Invalid size, must contain positive integers (size: "+format(it)+")")});var at=rt?this.clone():this;return j(at,it[0],it[1],nt)};function j(et,nt,rt,it){var at=it||0,st=i,ot=0;isString(et._datatype)&&(st=e.find(i,[et._datatype,et._datatype])||i,ot=e.convert(0,et._datatype),at=e.convert(at,et._datatype));var ct=!st(at,ot),lt=et._size[0],dt=et._size[1],xt,ut,ft;if(rt>dt){for(ut=dt;ut<rt;ut++)if(et._ptr[ut]=et._values.length,ct)for(xt=0;xt<lt;xt++)et._values.push(at),et._index.push(xt);et._ptr[rt]=et._values.length}else rt<dt&&(et._ptr.splice(rt+1,dt-rt),et._values.splice(et._ptr[rt],et._values.length),et._index.splice(et._ptr[rt],et._index.length));if(dt=rt,nt>lt){if(ct){var mt=0;for(ut=0;ut<dt;ut++){et._ptr[ut]=et._ptr[ut]+mt,ft=et._ptr[ut+1]+mt;var yt=0;for(xt=lt;xt<nt;xt++,yt++)et._values.splice(ft+yt,0,at),et._index.splice(ft+yt,0,xt),mt++}et._ptr[dt]=et._values.length}}else if(nt<lt){var St=0;for(ut=0;ut<dt;ut++){et._ptr[ut]=et._ptr[ut]-St;var Et=et._ptr[ut],vt=et._ptr[ut+1]-St;for(ft=Et;ft<vt;ft++)xt=et._index[ft],xt>nt-1&&(et._values.splice(ft,1),et._index.splice(ft,1),St++)}et._ptr[ut]=et._values.length}return et._size[0]=nt,et._size[1]=rt,et}o.prototype.reshape=function(et,nt){if(!isArray(et))throw new TypeError("Array expected");if(et.length!==2)throw new Error("Sparse matrices can only be reshaped in two dimensions");et.forEach(function($t){if(!isNumber($t)||!isInteger($t)||$t<=-2||$t===0)throw new TypeError("Invalid size, must contain positive integers or -1 (size: "+format(et)+")")});var rt=this._size[0]*this._size[1];et=processSizesWildcard(et,rt);var it=et[0]*et[1];if(rt!==it)throw new Error("Reshaping sparse matrix will result in the wrong number of elements");var at=nt?this.clone():this;if(this._size[0]===et[0]&&this._size[1]===et[1])return at;for(var st=[],ot=0;ot<at._ptr.length;ot++)for(var ct=0;ct<at._ptr[ot+1]-at._ptr[ot];ct++)st.push(ot);for(var lt=at._values.slice(),dt=at._index.slice(),xt=0;xt<at._index.length;xt++){var ut=dt[xt],ft=st[xt],mt=ut*at._size[1]+ft;st[xt]=mt%et[1],dt[xt]=Math.floor(mt/et[1])}at._values.length=0,at._index.length=0,at._ptr.length=et[1]+1,at._size=et.slice();for(var yt=0;yt<at._ptr.length;yt++)at._ptr[yt]=0;for(var St=0;St<lt.length;St++){var Et=dt[St],vt=st[St],Nt=lt[St],wt=_(Et,at._ptr[vt],at._ptr[vt+1],at._index);$(wt,Et,vt,Nt,at._values,at._index,at._ptr)}return at},o.prototype.clone=function(){var et=new o({values:this._values?clone$1(this._values):void 0,index:clone$1(this._index),ptr:clone$1(this._ptr),size:clone$1(this._size),datatype:this._datatype});return et},o.prototype.size=function(){return this._size.slice(0)},o.prototype.map=function(et,nt){if(!this._values)throw new Error("Cannot invoke map on a Pattern only matrix");var rt=this,it=this._size[0],at=this._size[1],st=function(ct,lt,dt){return et(ct,[lt,dt],rt)};return _e(this,0,it-1,0,at-1,st,nt)};function _e(et,nt,rt,it,at,st,ot){var ct=[],lt=[],dt=[],xt=i,ut=0;isString(et._datatype)&&(xt=e.find(i,[et._datatype,et._datatype])||i,ut=e.convert(0,et._datatype));for(var ft=function(Dt,At,kt){Dt=st(Dt,At,kt),xt(Dt,ut)||(ct.push(Dt),lt.push(At))},mt=it;mt<=at;mt++){dt.push(ct.length);var yt=et._ptr[mt],St=et._ptr[mt+1];if(ot)for(var Et=yt;Et<St;Et++){var vt=et._index[Et];vt>=nt&&vt<=rt&&ft(et._values[Et],vt-nt,mt-it)}else{for(var Nt={},wt=yt;wt<St;wt++){var $t=et._index[wt];Nt[$t]=et._values[wt]}for(var Ct=nt;Ct<=rt;Ct++){var Mt=Ct in Nt?Nt[Ct]:0;ft(Mt,Ct-nt,mt-it)}}}return dt.push(ct.length),new o({values:ct,index:lt,ptr:dt,size:[rt-nt+1,at-it+1]})}o.prototype.forEach=function(et,nt){if(!this._values)throw new Error("Cannot invoke forEach on a Pattern only matrix");for(var rt=this,it=this._size[0],at=this._size[1],st=0;st<at;st++){var ot=this._ptr[st],ct=this._ptr[st+1];if(nt)for(var lt=ot;lt<ct;lt++){var dt=this._index[lt];et(this._values[lt],[dt,st],rt)}else{for(var xt={},ut=ot;ut<ct;ut++){var ft=this._index[ut];xt[ft]=this._values[ut]}for(var mt=0;mt<it;mt++){var yt=mt in xt?xt[mt]:0;et(yt,[mt,st],rt)}}}},o.prototype[Symbol.iterator]=function*(){if(!this._values)throw new Error("Cannot iterate a Pattern only matrix");for(var et=this._size[1],nt=0;nt<et;nt++)for(var rt=this._ptr[nt],it=this._ptr[nt+1],at=rt;at<it;at++){var st=this._index[at];yield{value:this._values[at],index:[st,nt]}}},o.prototype.toArray=function(){return tt(this._values,this._index,this._ptr,this._size,!0)},o.prototype.valueOf=function(){return tt(this._values,this._index,this._ptr,this._size,!1)};function tt(et,nt,rt,it,at){var st=it[0],ot=it[1],ct=[],lt,dt;for(lt=0;lt<st;lt++)for(ct[lt]=[],dt=0;dt<ot;dt++)ct[lt][dt]=0;for(dt=0;dt<ot;dt++)for(var xt=rt[dt],ut=rt[dt+1],ft=xt;ft<ut;ft++)lt=nt[ft],ct[lt][dt]=et?at?clone$1(et[ft]):et[ft]:1;return ct}return o.prototype.format=function(et){for(var nt=this._size[0],rt=this._size[1],it=this.density(),at="Sparse Matrix ["+format(nt,et)+" x "+format(rt,et)+"] density: "+format(it,et)+`
`,st=0;st<rt;st++)for(var ot=this._ptr[st],ct=this._ptr[st+1],lt=ot;lt<ct;lt++){var dt=this._index[lt];at+=`
    (`+format(dt,et)+", "+format(st,et)+") ==> "+(this._values?format(this._values[lt],et):"X")}return at},o.prototype.toString=function(){return format(this.toArray())},o.prototype.toJSON=function(){return{mathjs:"SparseMatrix",values:this._values,index:this._index,ptr:this._ptr,size:this._size,datatype:this._datatype}},o.prototype.diagonal=function(et){if(et){if(isBigNumber(et)&&(et=et.toNumber()),!isNumber(et)||!isInteger(et))throw new TypeError("The parameter k must be an integer number")}else et=0;var nt=et>0?et:0,rt=et<0?-et:0,it=this._size[0],at=this._size[1],st=Math.min(it-rt,at-nt),ot=[],ct=[],lt=[];lt[0]=0;for(var dt=nt;dt<at&&ot.length<st;dt++)for(var xt=this._ptr[dt],ut=this._ptr[dt+1],ft=xt;ft<ut;ft++){var mt=this._index[ft];if(mt===dt-nt+rt){ot.push(this._values[ft]),ct[ot.length-1]=mt-rt;break}}return lt.push(ot.length),new o({values:ot,index:ct,ptr:lt,size:[st,1]})},o.fromJSON=function(et){return new o(et)},o.diagonal=function(et,nt,rt,it,at){if(!isArray(et))throw new TypeError("Array expected, size parameter");if(et.length!==2)throw new Error("Only two dimensions matrix are supported");if(et=et.map(function($t){if(isBigNumber($t)&&($t=$t.toNumber()),!isNumber($t)||!isInteger($t)||$t<1)throw new Error("Size values must be positive integers");return $t}),rt){if(isBigNumber(rt)&&(rt=rt.toNumber()),!isNumber(rt)||!isInteger(rt))throw new TypeError("The parameter k must be an integer number")}else rt=0;var st=i,ot=0;isString(at)&&(st=e.find(i,[at,at])||i,ot=e.convert(0,at));var ct=rt>0?rt:0,lt=rt<0?-rt:0,dt=et[0],xt=et[1],ut=Math.min(dt-lt,xt-ct),ft;if(isArray(nt)){if(nt.length!==ut)throw new Error("Invalid value array length");ft=function(Ct){return nt[Ct]}}else if(isMatrix(nt)){var mt=nt.size();if(mt.length!==1||mt[0]!==ut)throw new Error("Invalid matrix length");ft=function(Ct){return nt.get([Ct])}}else ft=function(){return nt};for(var yt=[],St=[],Et=[],vt=0;vt<xt;vt++){Et.push(yt.length);var Nt=vt-ct;if(Nt>=0&&Nt<ut){var wt=ft(Nt);st(wt,ot)||(St.push(Nt+lt),yt.push(wt))}}return Et.push(yt.length),new o({values:yt,index:St,ptr:Et,size:[dt,xt]})},o.prototype.swapRows=function(et,nt){if(!isNumber(et)||!isInteger(et)||!isNumber(nt)||!isInteger(nt))throw new Error("Row index must be positive integers");if(this._size.length!==2)throw new Error("Only two dimensional matrix is supported");return validateIndex(et,this._size[0]),validateIndex(nt,this._size[0]),o._swapRows(et,nt,this._size[1],this._values,this._index,this._ptr),this},o._forEachRow=function(et,nt,rt,it,at){for(var st=it[et],ot=it[et+1],ct=st;ct<ot;ct++)at(rt[ct],nt[ct])},o._swapRows=function(et,nt,rt,it,at,st){for(var ot=0;ot<rt;ot++){var ct=st[ot],lt=st[ot+1],dt=_(et,ct,lt,at),xt=_(nt,ct,lt,at);if(dt<lt&&xt<lt&&at[dt]===et&&at[xt]===nt){if(it){var ut=it[dt];it[dt]=it[xt],it[xt]=ut}continue}if(dt<lt&&at[dt]===et&&(xt>=lt||at[xt]!==nt)){var ft=it?it[dt]:void 0;at.splice(xt,0,nt),it&&it.splice(xt,0,ft),at.splice(xt<=dt?dt+1:dt,1),it&&it.splice(xt<=dt?dt+1:dt,1);continue}if(xt<lt&&at[xt]===nt&&(dt>=lt||at[dt]!==et)){var mt=it?it[xt]:void 0;at.splice(dt,0,et),it&&it.splice(dt,0,mt),at.splice(dt<=xt?xt+1:xt,1),it&&it.splice(dt<=xt?xt+1:xt,1)}}},o},{isClass:!0}),name$_="number",dependencies$_=["typed"];function getNonDecimalNumberParts(a){var e=a.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);if(e){var i={"0b":2,"0o":8,"0x":16}[e[1]],s=e[2],o=e[3];return{input:a,radix:i,integerPart:s,fractionalPart:o}}else return null}function makeNumberFromNonDecimalParts(a){for(var e=parseInt(a.integerPart,a.radix),i=0,s=0;s<a.fractionalPart.length;s++){var o=parseInt(a.fractionalPart[s],a.radix);i+=o/Math.pow(a.radix,s+1)}var c=e+i;if(isNaN(c))throw new SyntaxError('String "'+a.input+'" is no valid number');return c}var createNumber=factory$1(name$_,dependencies$_,a=>{var{typed:e}=a,i=e("number",{"":function(){return 0},number:function(o){return o},string:function(o){if(o==="NaN")return NaN;var c=getNonDecimalNumberParts(o);if(c)return makeNumberFromNonDecimalParts(c);var d=0,h=o.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);h&&(d=Number(h[2]),o=h[1]);var g=Number(o);if(isNaN(g))throw new SyntaxError('String "'+o+'" is no valid number');if(h){if(g>2**d-1)throw new SyntaxError('String "'.concat(o,'" is out of range'));g>=2**(d-1)&&(g=g-2**d)}return g},BigNumber:function(o){return o.toNumber()},Fraction:function(o){return o.valueOf()},Unit:function(o){throw new Error("Second argument with valueless unit expected")},null:function(o){return 0},"Unit, string | Unit":function(o,c){return o.toNumber(c)},"Array | Matrix":function(o){return deepMap(o,this)}});return i.fromJSON=function(s){return parseFloat(s.value)},i}),name$Z="bignumber",dependencies$Z=["typed","BigNumber"],createBignumber=factory$1(name$Z,dependencies$Z,a=>{var{typed:e,BigNumber:i}=a;return e("bignumber",{"":function(){return new i(0)},number:function(o){return new i(o+"")},string:function(o){var c=o.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);if(c){var d=c[2],h=i(c[1]),g=new i(2).pow(Number(d));if(h.gt(g.sub(1)))throw new SyntaxError('String "'.concat(o,'" is out of range'));var _=new i(2).pow(Number(d)-1);return h.gte(_)?h.sub(g):h}return new i(o)},BigNumber:function(o){return o},Fraction:function(o){return new i(o.n).div(o.d).times(o.s)},null:function(o){return new i(0)},"Array | Matrix":function(o){return deepMap(o,this)}})}),name$Y="complex",dependencies$Y=["typed","Complex"],createComplex=factory$1(name$Y,dependencies$Y,a=>{var{typed:e,Complex:i}=a;return e("complex",{"":function(){return i.ZERO},number:function(o){return new i(o,0)},"number, number":function(o,c){return new i(o,c)},"BigNumber, BigNumber":function(o,c){return new i(o.toNumber(),c.toNumber())},Fraction:function(o){return new i(o.valueOf(),0)},Complex:function(o){return o.clone()},string:function(o){return i(o)},null:function(o){return i(0)},Object:function(o){if("re"in o&&"im"in o)return new i(o.re,o.im);if("r"in o&&"phi"in o||"abs"in o&&"arg"in o)return new i(o);throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)")},"Array | Matrix":function(o){return deepMap(o,this)}})}),name$X="fraction",dependencies$X=["typed","Fraction"],createFraction=factory$1(name$X,dependencies$X,a=>{var{typed:e,Fraction:i}=a;return e("fraction",{number:function(o){if(!isFinite(o)||isNaN(o))throw new Error(o+" cannot be represented as a fraction");return new i(o)},string:function(o){return new i(o)},"number, number":function(o,c){return new i(o,c)},null:function(o){return new i(0)},BigNumber:function(o){return new i(o.toString())},Fraction:function(o){return o},Object:function(o){return new i(o)},"Array | Matrix":function(o){return deepMap(o,this)}})}),name$W="matrix",dependencies$W=["typed","Matrix","DenseMatrix","SparseMatrix"],createMatrix=factory$1(name$W,dependencies$W,a=>{var{typed:e,Matrix:i,DenseMatrix:s,SparseMatrix:o}=a;return e(name$W,{"":function(){return c([])},string:function(h){return c([],h)},"string, string":function(h,g){return c([],h,g)},Array:function(h){return c(h)},Matrix:function(h){return c(h,h.storage())},"Array | Matrix, string":c,"Array | Matrix, string, string":c});function c(d,h,g){if(h==="dense"||h==="default"||h===void 0)return new s(d,g);if(h==="sparse")return new o(d,g);throw new TypeError("Unknown matrix type "+JSON.stringify(h)+".")}}),name$V="matrixFromColumns",dependencies$V=["typed","matrix","flatten","size"],createMatrixFromColumns=factory$1(name$V,dependencies$V,a=>{var{typed:e,matrix:i,flatten:s,size:o}=a;return e(name$V,{"...Array":function(g){return c(g)},"...Matrix":function(g){return i(c(g.map(_=>_.toArray())))}});function c(h){if(h.length===0)throw new TypeError("At least one column is needed to construct a matrix.");for(var g=d(h[0]),_=[],b=0;b<g;b++)_[b]=[];for(var $ of h){var j=d($);if(j!==g)throw new TypeError("The vectors had different length: "+(g|0)+" ≠ "+(j|0));for(var _e=s($),tt=0;tt<g;tt++)_[tt].push(_e[tt])}return _}function d(h){var g=o(h);if(g.length===1)return g[0];if(g.length===2){if(g[0]===1)return g[1];if(g[1]===1)return g[0];throw new TypeError("At least one of the arguments is not a vector.")}else throw new TypeError("Only one- or two-dimensional vectors are supported.")}}),name$U="unaryMinus",dependencies$U=["typed"],createUnaryMinus=factory$1(name$U,dependencies$U,a=>{var{typed:e}=a;return e(name$U,{number:unaryMinusNumber,Complex:function(s){return s.neg()},BigNumber:function(s){return s.neg()},Fraction:function(s){return s.neg()},Unit:function(s){var o=s.clone();return o.value=this(s.value),o},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$T="abs",dependencies$T=["typed"],createAbs=factory$1(name$T,dependencies$T,a=>{var{typed:e}=a;return e(name$T,{number:absNumber,Complex:function(s){return s.abs()},BigNumber:function(s){return s.abs()},Fraction:function(s){return s.abs()},"Array | Matrix":function(s){return deepMap(s,this)},Unit:function(s){return s.abs()}})}),name$S="addScalar",dependencies$S=["typed"],createAddScalar=factory$1(name$S,dependencies$S,a=>{var{typed:e}=a;return e(name$S,{"number, number":addNumber,"Complex, Complex":function(s,o){return s.add(o)},"BigNumber, BigNumber":function(s,o){return s.plus(o)},"Fraction, Fraction":function(s,o){return s.add(o)},"Unit, Unit":function(s,o){if(s.value===null||s.value===void 0)throw new Error("Parameter x contains a unit with undefined value");if(o.value===null||o.value===void 0)throw new Error("Parameter y contains a unit with undefined value");if(!s.equalBase(o))throw new Error("Units do not match");var c=s.clone();return c.value=this(c.value,o.value),c.fixPrefix=!1,c}})}),name$R="algorithm11",dependencies$R=["typed","equalScalar"],createAlgorithm11=factory$1(name$R,dependencies$R,a=>{var{typed:e,equalScalar:i}=a;return function(o,c,d,h){var g=o._values,_=o._index,b=o._ptr,$=o._size,j=o._datatype;if(!g)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var _e=$[0],tt=$[1],et,nt=i,rt=0,it=d;typeof j=="string"&&(et=j,nt=e.find(i,[et,et]),rt=e.convert(0,et),c=e.convert(c,et),it=e.find(d,[et,et]));for(var at=[],st=[],ot=[],ct=0;ct<tt;ct++){ot[ct]=st.length;for(var lt=b[ct],dt=b[ct+1],xt=lt;xt<dt;xt++){var ut=_[xt],ft=h?it(c,g[xt]):it(g[xt],c);nt(ft,rt)||(st.push(ut),at.push(ft))}}return ot[tt]=st.length,o.createSparseMatrix({values:at,index:st,ptr:ot,size:[_e,tt],datatype:et})}}),name$Q="algorithm14",dependencies$Q=["typed"],createAlgorithm14=factory$1(name$Q,dependencies$Q,a=>{var{typed:e}=a;return function(o,c,d,h){var g=o._data,_=o._size,b=o._datatype,$,j=d;typeof b=="string"&&($=b,c=e.convert(c,$),j=e.find(d,[$,$]));var _e=_.length>0?i(j,0,_,_[0],g,c,h):[];return o.createDenseMatrix({data:_e,size:clone$1(_),datatype:$})};function i(s,o,c,d,h,g,_){var b=[];if(o===c.length-1)for(var $=0;$<d;$++)b[$]=_?s(g,h[$]):s(h[$],g);else for(var j=0;j<d;j++)b[j]=i(s,o+1,c,c[o+1],h[j],g,_);return b}}),name$P="algorithm01",dependencies$P=["typed"],createAlgorithm01=factory$1(name$P,dependencies$P,a=>{var{typed:e}=a;return function(s,o,c,d){var h=s._data,g=s._size,_=s._datatype,b=o._values,$=o._index,j=o._ptr,_e=o._size,tt=o._datatype;if(g.length!==_e.length)throw new DimensionError(g.length,_e.length);if(g[0]!==_e[0]||g[1]!==_e[1])throw new RangeError("Dimension mismatch. Matrix A ("+g+") must match Matrix B ("+_e+")");if(!b)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var et=g[0],nt=g[1],rt=typeof _=="string"&&_===tt?_:void 0,it=rt?e.find(c,[rt,rt]):c,at,st,ot=[];for(at=0;at<et;at++)ot[at]=[];var ct=[],lt=[];for(st=0;st<nt;st++){for(var dt=st+1,xt=j[st],ut=j[st+1],ft=xt;ft<ut;ft++)at=$[ft],ct[at]=d?it(b[ft],h[at][st]):it(h[at][st],b[ft]),lt[at]=dt;for(at=0;at<et;at++)lt[at]===dt?ot[at][st]=ct[at]:ot[at][st]=h[at][st]}return s.createDenseMatrix({data:ot,size:[et,nt],datatype:rt})}}),name$O="algorithm04",dependencies$O=["typed","equalScalar"],createAlgorithm04=factory$1(name$O,dependencies$O,a=>{var{typed:e,equalScalar:i}=a;return function(o,c,d){var h=o._values,g=o._index,_=o._ptr,b=o._size,$=o._datatype,j=c._values,_e=c._index,tt=c._ptr,et=c._size,nt=c._datatype;if(b.length!==et.length)throw new DimensionError(b.length,et.length);if(b[0]!==et[0]||b[1]!==et[1])throw new RangeError("Dimension mismatch. Matrix A ("+b+") must match Matrix B ("+et+")");var rt=b[0],it=b[1],at,st=i,ot=0,ct=d;typeof $=="string"&&$===nt&&(at=$,st=e.find(i,[at,at]),ot=e.convert(0,at),ct=e.find(d,[at,at]));var lt=h&&j?[]:void 0,dt=[],xt=[],ut=h&&j?[]:void 0,ft=h&&j?[]:void 0,mt=[],yt=[],St,Et,vt,Nt,wt;for(Et=0;Et<it;Et++){xt[Et]=dt.length;var $t=Et+1;for(Nt=_[Et],wt=_[Et+1],vt=Nt;vt<wt;vt++)St=g[vt],dt.push(St),mt[St]=$t,ut&&(ut[St]=h[vt]);for(Nt=tt[Et],wt=tt[Et+1],vt=Nt;vt<wt;vt++)if(St=_e[vt],mt[St]===$t){if(ut){var Ct=ct(ut[St],j[vt]);st(Ct,ot)?mt[St]=null:ut[St]=Ct}}else dt.push(St),yt[St]=$t,ft&&(ft[St]=j[vt]);if(ut&&ft)for(vt=xt[Et];vt<dt.length;)St=dt[vt],mt[St]===$t?(lt[vt]=ut[St],vt++):yt[St]===$t?(lt[vt]=ft[St],vt++):dt.splice(vt,1)}return xt[it]=dt.length,o.createSparseMatrix({values:lt,index:dt,ptr:xt,size:[rt,it],datatype:at})}}),name$N="algorithm10",dependencies$N=["typed","DenseMatrix"],createAlgorithm10=factory$1(name$N,dependencies$N,a=>{var{typed:e,DenseMatrix:i}=a;return function(o,c,d,h){var g=o._values,_=o._index,b=o._ptr,$=o._size,j=o._datatype;if(!g)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var _e=$[0],tt=$[1],et,nt=d;typeof j=="string"&&(et=j,c=e.convert(c,et),nt=e.find(d,[et,et]));for(var rt=[],it=[],at=[],st=0;st<tt;st++){for(var ot=st+1,ct=b[st],lt=b[st+1],dt=ct;dt<lt;dt++){var xt=_[dt];it[xt]=g[dt],at[xt]=ot}for(var ut=0;ut<_e;ut++)st===0&&(rt[ut]=[]),at[ut]===ot?rt[ut][st]=h?nt(c,it[ut]):nt(it[ut],c):rt[ut][st]=c}return new i({data:rt,size:[_e,tt],datatype:et})}}),name$M="algorithm13",dependencies$M=["typed"],createAlgorithm13=factory$1(name$M,dependencies$M,a=>{var{typed:e}=a;return function(o,c,d){var h=o._data,g=o._size,_=o._datatype,b=c._data,$=c._size,j=c._datatype,_e=[];if(g.length!==$.length)throw new DimensionError(g.length,$.length);for(var tt=0;tt<g.length;tt++){if(g[tt]!==$[tt])throw new RangeError("Dimension mismatch. Matrix A ("+g+") must match Matrix B ("+$+")");_e[tt]=g[tt]}var et,nt=d;typeof _=="string"&&_===j&&(et=_,nt=e.find(d,[et,et]));var rt=_e.length>0?i(nt,0,_e,_e[0],h,b):[];return o.createDenseMatrix({data:rt,size:_e,datatype:et})};function i(s,o,c,d,h,g){var _=[];if(o===c.length-1)for(var b=0;b<d;b++)_[b]=s(h[b],g[b]);else for(var $=0;$<d;$++)_[$]=i(s,o+1,c,c[o+1],h[$],g[$]);return _}}),name$L="algorithm03",dependencies$L=["typed"],createAlgorithm03=factory$1(name$L,dependencies$L,a=>{var{typed:e}=a;return function(s,o,c,d){var h=s._data,g=s._size,_=s._datatype,b=o._values,$=o._index,j=o._ptr,_e=o._size,tt=o._datatype;if(g.length!==_e.length)throw new DimensionError(g.length,_e.length);if(g[0]!==_e[0]||g[1]!==_e[1])throw new RangeError("Dimension mismatch. Matrix A ("+g+") must match Matrix B ("+_e+")");if(!b)throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");var et=g[0],nt=g[1],rt,it=0,at=c;typeof _=="string"&&_===tt&&(rt=_,it=e.convert(0,rt),at=e.find(c,[rt,rt]));for(var st=[],ot=0;ot<et;ot++)st[ot]=[];for(var ct=[],lt=[],dt=0;dt<nt;dt++){for(var xt=dt+1,ut=j[dt],ft=j[dt+1],mt=ut;mt<ft;mt++){var yt=$[mt];ct[yt]=d?at(b[mt],h[yt][dt]):at(h[yt][dt],b[mt]),lt[yt]=xt}for(var St=0;St<et;St++)lt[St]===xt?st[St][dt]=ct[St]:st[St][dt]=d?at(it,h[St][dt]):at(h[St][dt],it)}return s.createDenseMatrix({data:st,size:[et,nt],datatype:rt})}}),name$K="algorithm05",dependencies$K=["typed","equalScalar"],createAlgorithm05=factory$1(name$K,dependencies$K,a=>{var{typed:e,equalScalar:i}=a;return function(o,c,d){var h=o._values,g=o._index,_=o._ptr,b=o._size,$=o._datatype,j=c._values,_e=c._index,tt=c._ptr,et=c._size,nt=c._datatype;if(b.length!==et.length)throw new DimensionError(b.length,et.length);if(b[0]!==et[0]||b[1]!==et[1])throw new RangeError("Dimension mismatch. Matrix A ("+b+") must match Matrix B ("+et+")");var rt=b[0],it=b[1],at,st=i,ot=0,ct=d;typeof $=="string"&&$===nt&&(at=$,st=e.find(i,[at,at]),ot=e.convert(0,at),ct=e.find(d,[at,at]));var lt=h&&j?[]:void 0,dt=[],xt=[],ut=lt?[]:void 0,ft=lt?[]:void 0,mt=[],yt=[],St,Et,vt,Nt;for(Et=0;Et<it;Et++){xt[Et]=dt.length;var wt=Et+1;for(vt=_[Et],Nt=_[Et+1];vt<Nt;vt++)St=g[vt],dt.push(St),mt[St]=wt,ut&&(ut[St]=h[vt]);for(vt=tt[Et],Nt=tt[Et+1];vt<Nt;vt++)St=_e[vt],mt[St]!==wt&&dt.push(St),yt[St]=wt,ft&&(ft[St]=j[vt]);if(lt)for(vt=xt[Et];vt<dt.length;){St=dt[vt];var $t=mt[St],Ct=yt[St];if($t===wt||Ct===wt){var Mt=$t===wt?ut[St]:ot,Ot=Ct===wt?ft[St]:ot,Dt=ct(Mt,Ot);st(Dt,ot)?dt.splice(vt,1):(lt.push(Dt),vt++)}}}return xt[it]=dt.length,o.createSparseMatrix({values:lt,index:dt,ptr:xt,size:[rt,it],datatype:at})}}),name$J="algorithm12",dependencies$J=["typed","DenseMatrix"],createAlgorithm12=factory$1(name$J,dependencies$J,a=>{var{typed:e,DenseMatrix:i}=a;return function(o,c,d,h){var g=o._values,_=o._index,b=o._ptr,$=o._size,j=o._datatype;if(!g)throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");var _e=$[0],tt=$[1],et,nt=d;typeof j=="string"&&(et=j,c=e.convert(c,et),nt=e.find(d,[et,et]));for(var rt=[],it=[],at=[],st=0;st<tt;st++){for(var ot=st+1,ct=b[st],lt=b[st+1],dt=ct;dt<lt;dt++){var xt=_[dt];it[xt]=g[dt],at[xt]=ot}for(var ut=0;ut<_e;ut++)st===0&&(rt[ut]=[]),at[ut]===ot?rt[ut][st]=h?nt(c,it[ut]):nt(it[ut],c):rt[ut][st]=h?nt(c,0):nt(0,c)}return new i({data:rt,size:[_e,tt],datatype:et})}}),name$I="multiplyScalar",dependencies$I=["typed"],createMultiplyScalar=factory$1(name$I,dependencies$I,a=>{var{typed:e}=a;return e("multiplyScalar",{"number, number":multiplyNumber,"Complex, Complex":function(s,o){return s.mul(o)},"BigNumber, BigNumber":function(s,o){return s.times(o)},"Fraction, Fraction":function(s,o){return s.mul(o)},"number | Fraction | BigNumber | Complex, Unit":function(s,o){var c=o.clone();return c.value=c.value===null?c._normalize(s):this(c.value,s),c},"Unit, number | Fraction | BigNumber | Complex":function(s,o){var c=s.clone();return c.value=c.value===null?c._normalize(o):this(c.value,o),c},"Unit, Unit":function(s,o){return s.multiply(o)}})}),name$H="multiply",dependencies$H=["typed","matrix","addScalar","multiplyScalar","equalScalar","dot"],createMultiply=factory$1(name$H,dependencies$H,a=>{var{typed:e,matrix:i,addScalar:s,multiplyScalar:o,equalScalar:c,dot:d}=a,h=createAlgorithm11({typed:e,equalScalar:c}),g=createAlgorithm14({typed:e});function _(ot,ct){switch(ot.length){case 1:switch(ct.length){case 1:if(ot[0]!==ct[0])throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");break;case 2:if(ot[0]!==ct[0])throw new RangeError("Dimension mismatch in multiplication. Vector length ("+ot[0]+") must match Matrix rows ("+ct[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+ct.length+" dimensions)")}break;case 2:switch(ct.length){case 1:if(ot[1]!==ct[0])throw new RangeError("Dimension mismatch in multiplication. Matrix columns ("+ot[1]+") must match Vector length ("+ct[0]+")");break;case 2:if(ot[1]!==ct[0])throw new RangeError("Dimension mismatch in multiplication. Matrix A columns ("+ot[1]+") must match Matrix B rows ("+ct[0]+")");break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has "+ct.length+" dimensions)")}break;default:throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has "+ot.length+" dimensions)")}}function b(ot,ct,lt){if(lt===0)throw new Error("Cannot multiply two empty vectors");return d(ot,ct)}function $(ot,ct){if(ct.storage()!=="dense")throw new Error("Support for SparseMatrix not implemented");return j(ot,ct)}function j(ot,ct){var lt=ot._data,dt=ot._size,xt=ot._datatype,ut=ct._data,ft=ct._size,mt=ct._datatype,yt=dt[0],St=ft[1],Et,vt=s,Nt=o;xt&&mt&&xt===mt&&typeof xt=="string"&&(Et=xt,vt=e.find(s,[Et,Et]),Nt=e.find(o,[Et,Et]));for(var wt=[],$t=0;$t<St;$t++){for(var Ct=Nt(lt[0],ut[0][$t]),Mt=1;Mt<yt;Mt++)Ct=vt(Ct,Nt(lt[Mt],ut[Mt][$t]));wt[$t]=Ct}return ot.createDenseMatrix({data:wt,size:[St],datatype:Et})}var _e=e("_multiplyMatrixVector",{"DenseMatrix, any":et,"SparseMatrix, any":it}),tt=e("_multiplyMatrixMatrix",{"DenseMatrix, DenseMatrix":nt,"DenseMatrix, SparseMatrix":rt,"SparseMatrix, DenseMatrix":at,"SparseMatrix, SparseMatrix":st});function et(ot,ct){var lt=ot._data,dt=ot._size,xt=ot._datatype,ut=ct._data,ft=ct._datatype,mt=dt[0],yt=dt[1],St,Et=s,vt=o;xt&&ft&&xt===ft&&typeof xt=="string"&&(St=xt,Et=e.find(s,[St,St]),vt=e.find(o,[St,St]));for(var Nt=[],wt=0;wt<mt;wt++){for(var $t=lt[wt],Ct=vt($t[0],ut[0]),Mt=1;Mt<yt;Mt++)Ct=Et(Ct,vt($t[Mt],ut[Mt]));Nt[wt]=Ct}return ot.createDenseMatrix({data:Nt,size:[mt],datatype:St})}function nt(ot,ct){var lt=ot._data,dt=ot._size,xt=ot._datatype,ut=ct._data,ft=ct._size,mt=ct._datatype,yt=dt[0],St=dt[1],Et=ft[1],vt,Nt=s,wt=o;xt&&mt&&xt===mt&&typeof xt=="string"&&(vt=xt,Nt=e.find(s,[vt,vt]),wt=e.find(o,[vt,vt]));for(var $t=[],Ct=0;Ct<yt;Ct++){var Mt=lt[Ct];$t[Ct]=[];for(var Ot=0;Ot<Et;Ot++){for(var Dt=wt(Mt[0],ut[0][Ot]),At=1;At<St;At++)Dt=Nt(Dt,wt(Mt[At],ut[At][Ot]));$t[Ct][Ot]=Dt}}return ot.createDenseMatrix({data:$t,size:[yt,Et],datatype:vt})}function rt(ot,ct){var lt=ot._data,dt=ot._size,xt=ot._datatype,ut=ct._values,ft=ct._index,mt=ct._ptr,yt=ct._size,St=ct._datatype;if(!ut)throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");var Et=dt[0],vt=yt[1],Nt,wt=s,$t=o,Ct=c,Mt=0;xt&&St&&xt===St&&typeof xt=="string"&&(Nt=xt,wt=e.find(s,[Nt,Nt]),$t=e.find(o,[Nt,Nt]),Ct=e.find(c,[Nt,Nt]),Mt=e.convert(0,Nt));for(var Ot=[],Dt=[],At=[],kt=ct.createSparseMatrix({values:Ot,index:Dt,ptr:At,size:[Et,vt],datatype:Nt}),Ft=0;Ft<vt;Ft++){At[Ft]=Dt.length;var Bt=mt[Ft],Ht=mt[Ft+1];if(Ht>Bt)for(var Wt=0,Ut=0;Ut<Et;Ut++){for(var Rt=Ut+1,un=void 0,rn=Bt;rn<Ht;rn++){var mn=ft[rn];Wt!==Rt?(un=$t(lt[Ut][mn],ut[rn]),Wt=Rt):un=wt(un,$t(lt[Ut][mn],ut[rn]))}Wt===Rt&&!Ct(un,Mt)&&(Dt.push(Ut),Ot.push(un))}}return At[vt]=Dt.length,kt}function it(ot,ct){var lt=ot._values,dt=ot._index,xt=ot._ptr,ut=ot._datatype;if(!lt)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var ft=ct._data,mt=ct._datatype,yt=ot._size[0],St=ct._size[0],Et=[],vt=[],Nt=[],wt,$t=s,Ct=o,Mt=c,Ot=0;ut&&mt&&ut===mt&&typeof ut=="string"&&(wt=ut,$t=e.find(s,[wt,wt]),Ct=e.find(o,[wt,wt]),Mt=e.find(c,[wt,wt]),Ot=e.convert(0,wt));var Dt=[],At=[];Nt[0]=0;for(var kt=0;kt<St;kt++){var Ft=ft[kt];if(!Mt(Ft,Ot))for(var Bt=xt[kt],Ht=xt[kt+1],Wt=Bt;Wt<Ht;Wt++){var Ut=dt[Wt];At[Ut]?Dt[Ut]=$t(Dt[Ut],Ct(Ft,lt[Wt])):(At[Ut]=!0,vt.push(Ut),Dt[Ut]=Ct(Ft,lt[Wt]))}}for(var Rt=vt.length,un=0;un<Rt;un++){var rn=vt[un];Et[un]=Dt[rn]}return Nt[1]=vt.length,ot.createSparseMatrix({values:Et,index:vt,ptr:Nt,size:[yt,1],datatype:wt})}function at(ot,ct){var lt=ot._values,dt=ot._index,xt=ot._ptr,ut=ot._datatype;if(!lt)throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");var ft=ct._data,mt=ct._datatype,yt=ot._size[0],St=ct._size[0],Et=ct._size[1],vt,Nt=s,wt=o,$t=c,Ct=0;ut&&mt&&ut===mt&&typeof ut=="string"&&(vt=ut,Nt=e.find(s,[vt,vt]),wt=e.find(o,[vt,vt]),$t=e.find(c,[vt,vt]),Ct=e.convert(0,vt));for(var Mt=[],Ot=[],Dt=[],At=ot.createSparseMatrix({values:Mt,index:Ot,ptr:Dt,size:[yt,Et],datatype:vt}),kt=[],Ft=[],Bt=0;Bt<Et;Bt++){Dt[Bt]=Ot.length;for(var Ht=Bt+1,Wt=0;Wt<St;Wt++){var Ut=ft[Wt][Bt];if(!$t(Ut,Ct))for(var Rt=xt[Wt],un=xt[Wt+1],rn=Rt;rn<un;rn++){var mn=dt[rn];Ft[mn]!==Ht?(Ft[mn]=Ht,Ot.push(mn),kt[mn]=wt(Ut,lt[rn])):kt[mn]=Nt(kt[mn],wt(Ut,lt[rn]))}}for(var sn=Dt[Bt],hn=Ot.length,gn=sn;gn<hn;gn++){var Xt=Ot[gn];Mt[gn]=kt[Xt]}}return Dt[Et]=Ot.length,At}function st(ot,ct){var lt=ot._values,dt=ot._index,xt=ot._ptr,ut=ot._datatype,ft=ct._values,mt=ct._index,yt=ct._ptr,St=ct._datatype,Et=ot._size[0],vt=ct._size[1],Nt=lt&&ft,wt,$t=s,Ct=o;ut&&St&&ut===St&&typeof ut=="string"&&(wt=ut,$t=e.find(s,[wt,wt]),Ct=e.find(o,[wt,wt]));for(var Mt=Nt?[]:void 0,Ot=[],Dt=[],At=ot.createSparseMatrix({values:Mt,index:Ot,ptr:Dt,size:[Et,vt],datatype:wt}),kt=Nt?[]:void 0,Ft=[],Bt,Ht,Wt,Ut,Rt,un,rn,mn,sn=0;sn<vt;sn++){Dt[sn]=Ot.length;var hn=sn+1;for(Rt=yt[sn],un=yt[sn+1],Ut=Rt;Ut<un;Ut++)if(mn=mt[Ut],Nt)for(Ht=xt[mn],Wt=xt[mn+1],Bt=Ht;Bt<Wt;Bt++)rn=dt[Bt],Ft[rn]!==hn?(Ft[rn]=hn,Ot.push(rn),kt[rn]=Ct(ft[Ut],lt[Bt])):kt[rn]=$t(kt[rn],Ct(ft[Ut],lt[Bt]));else for(Ht=xt[mn],Wt=xt[mn+1],Bt=Ht;Bt<Wt;Bt++)rn=dt[Bt],Ft[rn]!==hn&&(Ft[rn]=hn,Ot.push(rn));if(Nt)for(var gn=Dt[sn],Xt=Ot.length,En=gn;En<Xt;En++){var bt=Ot[En];Mt[En]=kt[bt]}}return Dt[vt]=Ot.length,At}return e(name$H,extend({"Array, Array":function(ct,lt){_(arraySize(ct),arraySize(lt));var dt=this(i(ct),i(lt));return isMatrix(dt)?dt.valueOf():dt},"Matrix, Matrix":function(ct,lt){var dt=ct.size(),xt=lt.size();return _(dt,xt),dt.length===1?xt.length===1?b(ct,lt,dt[0]):$(ct,lt):xt.length===1?_e(ct,lt):tt(ct,lt)},"Matrix, Array":function(ct,lt){return this(ct,i(lt))},"Array, Matrix":function(ct,lt){return this(i(ct,lt.storage()),lt)},"SparseMatrix, any":function(ct,lt){return h(ct,lt,o,!1)},"DenseMatrix, any":function(ct,lt){return g(ct,lt,o,!1)},"any, SparseMatrix":function(ct,lt){return h(lt,ct,o,!0)},"any, DenseMatrix":function(ct,lt){return g(lt,ct,o,!0)},"Array, any":function(ct,lt){return g(i(ct),lt,o,!1).valueOf()},"any, Array":function(ct,lt){return g(i(lt),ct,o,!0).valueOf()},"any, any":o,"any, any, ...any":function(ct,lt,dt){for(var xt=this(ct,lt),ut=0;ut<dt.length;ut++)xt=this(xt,dt[ut]);return xt}},o.signatures))}),name$G="sign",dependencies$G=["typed","BigNumber","Fraction","complex"],createSign=factory$1(name$G,dependencies$G,a=>{var{typed:e,BigNumber:i,complex:s,Fraction:o}=a;return e(name$G,{number:signNumber,Complex:function(d){return d.im===0?s(signNumber(d.re)):d.sign()},BigNumber:function(d){return new i(d.cmp(0))},Fraction:function(d){return new o(d.s,1)},"Array | Matrix":function(d){return deepMap(d,this)},Unit:function(d){return this(d.value)}})}),name$F="sqrt",dependencies$F=["config","typed","Complex"],createSqrt=factory$1(name$F,dependencies$F,a=>{var{config:e,typed:i,Complex:s}=a;return i("sqrt",{number:o,Complex:function(d){return d.sqrt()},BigNumber:function(d){return!d.isNegative()||e.predictable?d.sqrt():o(d.toNumber())},"Array | Matrix":function(d){return deepMap(d,this)},Unit:function(d){return d.pow(.5)}});function o(c){return isNaN(c)?NaN:c>=0||e.predictable?Math.sqrt(c):new s(c,0).sqrt()}}),name$E="subtract",dependencies$E=["typed","matrix","equalScalar","addScalar","unaryMinus","DenseMatrix"],createSubtract=factory$1(name$E,dependencies$E,a=>{var{typed:e,matrix:i,equalScalar:s,addScalar:o,unaryMinus:c,DenseMatrix:d}=a,h=createAlgorithm01({typed:e}),g=createAlgorithm03({typed:e}),_=createAlgorithm05({typed:e,equalScalar:s}),b=createAlgorithm10({typed:e,DenseMatrix:d}),$=createAlgorithm13({typed:e}),j=createAlgorithm14({typed:e});return e(name$E,{"number, number":function(tt,et){return tt-et},"Complex, Complex":function(tt,et){return tt.sub(et)},"BigNumber, BigNumber":function(tt,et){return tt.minus(et)},"Fraction, Fraction":function(tt,et){return tt.sub(et)},"Unit, Unit":function(tt,et){if(tt.value===null)throw new Error("Parameter x contains a unit with undefined value");if(et.value===null)throw new Error("Parameter y contains a unit with undefined value");if(!tt.equalBase(et))throw new Error("Units do not match");var nt=tt.clone();return nt.value=this(nt.value,et.value),nt.fixPrefix=!1,nt},"SparseMatrix, SparseMatrix":function(tt,et){return checkEqualDimensions(tt,et),_(tt,et,this)},"SparseMatrix, DenseMatrix":function(tt,et){return checkEqualDimensions(tt,et),g(et,tt,this,!0)},"DenseMatrix, SparseMatrix":function(tt,et){return checkEqualDimensions(tt,et),h(tt,et,this,!1)},"DenseMatrix, DenseMatrix":function(tt,et){return checkEqualDimensions(tt,et),$(tt,et,this)},"Array, Array":function(tt,et){return this(i(tt),i(et)).valueOf()},"Array, Matrix":function(tt,et){return this(i(tt),et)},"Matrix, Array":function(tt,et){return this(tt,i(et))},"SparseMatrix, any":function(tt,et){return b(tt,c(et),o)},"DenseMatrix, any":function(tt,et){return j(tt,et,this)},"any, SparseMatrix":function(tt,et){return b(et,tt,this,!0)},"any, DenseMatrix":function(tt,et){return j(et,tt,this,!0)},"Array, any":function(tt,et){return j(i(tt),et,this,!1).valueOf()},"any, Array":function(tt,et){return j(i(et),tt,this,!0).valueOf()}})});function checkEqualDimensions(a,e){var i=a.size(),s=e.size();if(i.length!==s.length)throw new DimensionError(i.length,s.length)}var name$D="algorithm07",dependencies$D=["typed","DenseMatrix"],createAlgorithm07=factory$1(name$D,dependencies$D,a=>{var{typed:e,DenseMatrix:i}=a;return function(c,d,h){var g=c._size,_=c._datatype,b=d._size,$=d._datatype;if(g.length!==b.length)throw new DimensionError(g.length,b.length);if(g[0]!==b[0]||g[1]!==b[1])throw new RangeError("Dimension mismatch. Matrix A ("+g+") must match Matrix B ("+b+")");var j=g[0],_e=g[1],tt,et=0,nt=h;typeof _=="string"&&_===$&&(tt=_,et=e.convert(0,tt),nt=e.find(h,[tt,tt]));var rt,it,at=[];for(rt=0;rt<j;rt++)at[rt]=[];var st=[],ot=[],ct=[],lt=[];for(it=0;it<_e;it++){var dt=it+1;for(s(c,it,ct,st,dt),s(d,it,lt,ot,dt),rt=0;rt<j;rt++){var xt=ct[rt]===dt?st[rt]:et,ut=lt[rt]===dt?ot[rt]:et;at[rt][it]=nt(xt,ut)}}return new i({data:at,size:[j,_e],datatype:tt})};function s(o,c,d,h,g){for(var _=o._values,b=o._index,$=o._ptr,j=$[c],_e=$[c+1];j<_e;j++){var tt=b[j];d[tt]=g,h[tt]=_[j]}}}),name$C="conj",dependencies$C=["typed"],createConj=factory$1(name$C,dependencies$C,a=>{var{typed:e}=a;return e(name$C,{number:function(s){return s},BigNumber:function(s){return s},Complex:function(s){return s.conjugate()},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$B="im",dependencies$B=["typed"],createIm=factory$1(name$B,dependencies$B,a=>{var{typed:e}=a;return e(name$B,{number:function(s){return 0},BigNumber:function(s){return s.mul(0)},Fraction:function(s){return s.mul(0)},Complex:function(s){return s.im},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$A="re",dependencies$A=["typed"],createRe=factory$1(name$A,dependencies$A,a=>{var{typed:e}=a;return e(name$A,{number:function(s){return s},BigNumber:function(s){return s},Fraction:function(s){return s},Complex:function(s){return s.re},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$z="column",dependencies$z=["typed","Index","matrix","range"],createColumn=factory$1(name$z,dependencies$z,a=>{var{typed:e,Index:i,matrix:s,range:o}=a;return e(name$z,{"Matrix, number":c,"Array, number":function(h,g){return c(s(clone$1(h)),g).valueOf()}});function c(d,h){if(d.size().length!==2)throw new Error("Only two dimensional matrix is supported");validateIndex(h,d.size()[1]);var g=o(0,d.size()[0]),_=new i(g,h);return d.subset(_)}}),name$y="cross",dependencies$y=["typed","matrix","subtract","multiply"],createCross=factory$1(name$y,dependencies$y,a=>{var{typed:e,matrix:i,subtract:s,multiply:o}=a;return e(name$y,{"Matrix, Matrix":function(h,g){return i(c(h.toArray(),g.toArray()))},"Matrix, Array":function(h,g){return i(c(h.toArray(),g))},"Array, Matrix":function(h,g){return i(c(h,g.toArray()))},"Array, Array":c});function c(d,h){var g=Math.max(arraySize(d).length,arraySize(h).length);d=squeeze(d),h=squeeze(h);var _=arraySize(d),b=arraySize(h);if(_.length!==1||b.length!==1||_[0]!==3||b[0]!==3)throw new RangeError("Vectors with length 3 expected (Size A = ["+_.join(", ")+"], B = ["+b.join(", ")+"])");var $=[s(o(d[1],h[2]),o(d[2],h[1])),s(o(d[2],h[0]),o(d[0],h[2])),s(o(d[0],h[1]),o(d[1],h[0]))];return g>1?[$]:$}}),name$x="diag",dependencies$x=["typed","matrix","DenseMatrix","SparseMatrix"],createDiag=factory$1(name$x,dependencies$x,a=>{var{typed:e,matrix:i,DenseMatrix:s,SparseMatrix:o}=a;return e(name$x,{Array:function(_){return c(_,0,arraySize(_),null)},"Array, number":function(_,b){return c(_,b,arraySize(_),null)},"Array, BigNumber":function(_,b){return c(_,b.toNumber(),arraySize(_),null)},"Array, string":function(_,b){return c(_,0,arraySize(_),b)},"Array, number, string":function(_,b,$){return c(_,b,arraySize(_),$)},"Array, BigNumber, string":function(_,b,$){return c(_,b.toNumber(),arraySize(_),$)},Matrix:function(_){return c(_,0,_.size(),_.storage())},"Matrix, number":function(_,b){return c(_,b,_.size(),_.storage())},"Matrix, BigNumber":function(_,b){return c(_,b.toNumber(),_.size(),_.storage())},"Matrix, string":function(_,b){return c(_,0,_.size(),b)},"Matrix, number, string":function(_,b,$){return c(_,b,_.size(),$)},"Matrix, BigNumber, string":function(_,b,$){return c(_,b.toNumber(),_.size(),$)}});function c(g,_,b,$){if(!isInteger(_))throw new TypeError("Second parameter in function diag must be an integer");var j=_>0?_:0,_e=_<0?-_:0;switch(b.length){case 1:return d(g,_,$,b[0],_e,j);case 2:return h(g,_,$,b,_e,j)}throw new RangeError("Matrix for function diag must be 2 dimensional")}function d(g,_,b,$,j,_e){var tt=[$+j,$+_e];if(b&&b!=="sparse"&&b!=="dense")throw new TypeError("Unknown matrix type ".concat(b,'"'));var et=b==="sparse"?o.diagonal(tt,g,_):s.diagonal(tt,g,_);return b!==null?et:et.valueOf()}function h(g,_,b,$,j,_e){if(isMatrix(g)){var tt=g.diagonal(_);return b!==null?b!==tt.storage()?i(tt,b):tt:tt.valueOf()}for(var et=Math.min($[0]-j,$[1]-_e),nt=[],rt=0;rt<et;rt++)nt[rt]=g[rt+j][rt+_e];return b!==null?i(nt):nt}}),name$w="flatten",dependencies$w=["typed","matrix"],createFlatten=factory$1(name$w,dependencies$w,a=>{var{typed:e,matrix:i}=a;return e(name$w,{Array:function(o){return flatten$1(clone$1(o))},Matrix:function(o){var c=flatten$1(clone$1(o.toArray()));return i(c)}})}),name$v="identity",dependencies$v=["typed","config","matrix","BigNumber","DenseMatrix","SparseMatrix"],createIdentity=factory$1(name$v,dependencies$v,a=>{var{typed:e,config:i,matrix:s,BigNumber:o,DenseMatrix:c,SparseMatrix:d}=a;return e(name$v,{"":function(){return i.matrix==="Matrix"?s([]):[]},string:function(b){return s(b)},"number | BigNumber":function(b){return g(b,b,i.matrix==="Matrix"?"dense":void 0)},"number | BigNumber, string":function(b,$){return g(b,b,$)},"number | BigNumber, number | BigNumber":function(b,$){return g(b,$,i.matrix==="Matrix"?"dense":void 0)},"number | BigNumber, number | BigNumber, string":function(b,$,j){return g(b,$,j)},Array:function(b){return h(b)},"Array, string":function(b,$){return h(b,$)},Matrix:function(b){return h(b.valueOf(),b.storage())},"Matrix, string":function(b,$){return h(b.valueOf(),$)}});function h(_,b){switch(_.length){case 0:return b?s(b):[];case 1:return g(_[0],_[0],b);case 2:return g(_[0],_[1],b);default:throw new Error("Vector containing two values expected")}}function g(_,b,$){var j=isBigNumber(_)||isBigNumber(b)?o:null;if(isBigNumber(_)&&(_=_.toNumber()),isBigNumber(b)&&(b=b.toNumber()),!isInteger(_)||_<1)throw new Error("Parameters in function identity must be positive integers");if(!isInteger(b)||b<1)throw new Error("Parameters in function identity must be positive integers");var _e=j?new o(1):1,tt=j?new j(0):0,et=[_,b];if($){if($==="sparse")return d.diagonal(et,_e,0,tt);if($==="dense")return c.diagonal(et,_e,0,tt);throw new TypeError('Unknown matrix type "'.concat($,'"'))}for(var nt=resize([],et,tt),rt=_<b?_:b,it=0;it<rt;it++)nt[it][it]=_e;return nt}});function noBignumber(){throw new Error('No "bignumber" implementation available')}function noFraction(){throw new Error('No "fraction" implementation available')}function noMatrix(){throw new Error('No "matrix" implementation available')}var name$u="range",dependencies$u=["typed","config","?matrix","?bignumber","smaller","smallerEq","larger","largerEq"],createRange=factory$1(name$u,dependencies$u,a=>{var{typed:e,config:i,matrix:s,bignumber:o,smaller:c,smallerEq:d,larger:h,largerEq:g}=a;return e(name$u,{string:b,"string, boolean":b,"number, number":function(rt,it){return _($(rt,it,1))},"number, number, number":function(rt,it,at){return _($(rt,it,at))},"number, number, boolean":function(rt,it,at){return _(at?j(rt,it,1):$(rt,it,1))},"number, number, number, boolean":function(rt,it,at,st){return _(st?j(rt,it,at):$(rt,it,at))},"BigNumber, BigNumber":function(rt,it){var at=rt.constructor;return _(_e(rt,it,new at(1)))},"BigNumber, BigNumber, BigNumber":function(rt,it,at){return _(_e(rt,it,at))},"BigNumber, BigNumber, boolean":function(rt,it,at){var st=rt.constructor;return _(at?tt(rt,it,new st(1)):_e(rt,it,new st(1)))},"BigNumber, BigNumber, BigNumber, boolean":function(rt,it,at,st){return _(st?tt(rt,it,at):_e(rt,it,at))}});function _(nt){return i.matrix==="Matrix"?s?s(nt):noMatrix():nt}function b(nt,rt){var it=et(nt);if(!it)throw new SyntaxError('String "'+nt+'" is no valid range');var at;return i.number==="BigNumber"?(o===void 0&&noBignumber(),at=rt?tt:_e,_(at(o(it.start),o(it.end),o(it.step)))):(at=rt?j:$,_(at(it.start,it.end,it.step)))}function $(nt,rt,it){var at=[],st=nt;if(it>0)for(;c(st,rt);)at.push(st),st+=it;else if(it<0)for(;h(st,rt);)at.push(st),st+=it;return at}function j(nt,rt,it){var at=[],st=nt;if(it>0)for(;d(st,rt);)at.push(st),st+=it;else if(it<0)for(;g(st,rt);)at.push(st),st+=it;return at}function _e(nt,rt,it){var at=o(0),st=[],ot=nt;if(it.gt(at))for(;c(ot,rt);)st.push(ot),ot=ot.plus(it);else if(it.lt(at))for(;h(ot,rt);)st.push(ot),ot=ot.plus(it);return st}function tt(nt,rt,it){var at=o(0),st=[],ot=nt;if(it.gt(at))for(;d(ot,rt);)st.push(ot),ot=ot.plus(it);else if(it.lt(at))for(;g(ot,rt);)st.push(ot),ot=ot.plus(it);return st}function et(nt){var rt=nt.split(":"),it=rt.map(function(st){return Number(st)}),at=it.some(function(st){return isNaN(st)});if(at)return null;switch(it.length){case 2:return{start:it[0],end:it[1],step:1};case 3:return{start:it[0],end:it[2],step:it[1]};default:return null}}}),name$t="size",dependencies$t=["typed","config","?matrix"],createSize=factory$1(name$t,dependencies$t,a=>{var{typed:e,config:i,matrix:s}=a;return e(name$t,{Matrix:function(c){return c.create(c.size())},Array:arraySize,string:function(c){return i.matrix==="Array"?[c.length]:s([c.length])},"number | Complex | BigNumber | Unit | boolean | null":function(c){return i.matrix==="Array"?[]:s?s([]):noMatrix()}})}),name$s="transpose",dependencies$s=["typed","matrix"],createTranspose=factory$1(name$s,dependencies$s,a=>{var{typed:e,matrix:i}=a;return e("transpose",{Array:function(d){return this(i(d)).valueOf()},Matrix:function(d){var h=d.size(),g;switch(h.length){case 1:g=d.clone();break;case 2:{var _=h[0],b=h[1];if(b===0)throw new RangeError("Cannot transpose a 2D matrix with no columns (size: "+format(h)+")");switch(d.storage()){case"dense":g=s(d,_,b);break;case"sparse":g=o(d,_,b);break}}break;default:throw new RangeError("Matrix must be a vector or two dimensional (size: "+format(this._size)+")")}return g},any:function(d){return clone$1(d)}});function s(c,d,h){for(var g=c._data,_=[],b,$=0;$<h;$++){b=_[$]=[];for(var j=0;j<d;j++)b[j]=clone$1(g[j][$])}return c.createDenseMatrix({data:_,size:[h,d],datatype:c._datatype})}function o(c,d,h){for(var g=c._values,_=c._index,b=c._ptr,$=g?[]:void 0,j=[],_e=[],tt=[],et=0;et<d;et++)tt[et]=0;var nt,rt,it;for(nt=0,rt=_.length;nt<rt;nt++)tt[_[nt]]++;for(var at=0,st=0;st<d;st++)_e.push(at),at+=tt[st],tt[st]=_e[st];for(_e.push(at),it=0;it<h;it++)for(var ot=b[it],ct=b[it+1],lt=ot;lt<ct;lt++){var dt=tt[_[lt]]++;j[dt]=it,g&&($[dt]=clone$1(g[lt]))}return c.createSparseMatrix({values:$,index:j,ptr:_e,size:[h,d],datatype:c._datatype})}}),name$r="ctranspose",dependencies$r=["typed","transpose","conj"],createCtranspose=factory$1(name$r,dependencies$r,a=>{var{typed:e,transpose:i,conj:s}=a;return e(name$r,{any:function(c){return s(i(c))}})}),name$q="zeros",dependencies$q=["typed","config","matrix","BigNumber"],createZeros=factory$1(name$q,dependencies$q,a=>{var{typed:e,config:i,matrix:s,BigNumber:o}=a;return e(name$q,{"":function(){return i.matrix==="Array"?c([]):c([],"default")},"...number | BigNumber | string":function(_){var b=_[_.length-1];if(typeof b=="string"){var $=_.pop();return c(_,$)}else return i.matrix==="Array"?c(_):c(_,"default")},Array:c,Matrix:function(_){var b=_.storage();return c(_.valueOf(),b)},"Array | Matrix, string":function(_,b){return c(_.valueOf(),b)}});function c(g,_){var b=d(g),$=b?new o(0):0;if(h(g),_){var j=s(_);return g.length>0?j.resize(g,$):j}else{var _e=[];return g.length>0?resize(_e,g,$):_e}}function d(g){var _=!1;return g.forEach(function(b,$,j){isBigNumber(b)&&(_=!0,j[$]=b.toNumber())}),_}function h(g){g.forEach(function(_){if(typeof _!="number"||!isInteger(_)||_<0)throw new Error("Parameters in function zeros must be positive integers")})}}),name$p="numeric",dependencies$p=["number","?bignumber","?fraction"],createNumeric=factory$1(name$p,dependencies$p,a=>{var{number:e,bignumber:i,fraction:s}=a,o={string:!0,number:!0,BigNumber:!0,Fraction:!0},c={number:d=>e(d),BigNumber:i?d=>i(d):noBignumber,Fraction:s?d=>s(d):noFraction};return function(h,g){var _=typeOf(h);if(!(_ in o))throw new TypeError("Cannot convert "+h+' of type "'+_+'"; valid input types are '+Object.keys(o).join(", "));if(!(g in c))throw new TypeError("Cannot convert "+h+' to type "'+g+'"; valid output types are '+Object.keys(c).join(", "));return g===_?h:c[g](h)}}),name$o="divideScalar",dependencies$o=["typed","numeric"],createDivideScalar=factory$1(name$o,dependencies$o,a=>{var{typed:e,numeric:i}=a;return e(name$o,{"number, number":function(o,c){return o/c},"Complex, Complex":function(o,c){return o.div(c)},"BigNumber, BigNumber":function(o,c){return o.div(c)},"Fraction, Fraction":function(o,c){return o.div(c)},"Unit, number | Fraction | BigNumber":function(o,c){var d=o.clone(),h=i(1,typeOf(c));return d.value=this(d.value===null?d._normalize(h):d.value,c),d},"number | Fraction | BigNumber, Unit":function(o,c){var d=c.clone();d=d.pow(-1);var h=i(1,typeOf(o));return d.value=this(o,c.value===null?c._normalize(h):c.value),d},"Unit, Unit":function(o,c){return o.divide(c)}})}),name$n="pow",dependencies$n=["typed","config","identity","multiply","matrix","fraction","number","Complex"],createPow=factory$1(name$n,dependencies$n,a=>{var{typed:e,config:i,identity:s,multiply:o,matrix:c,number:d,fraction:h,Complex:g}=a;return e(name$n,{"number, number":_,"Complex, Complex":function(_e,tt){return _e.pow(tt)},"BigNumber, BigNumber":function(_e,tt){return tt.isInteger()||_e>=0||i.predictable?_e.pow(tt):new g(_e.toNumber(),0).pow(tt.toNumber(),0)},"Fraction, Fraction":function(_e,tt){var et=_e.pow(tt);if(et!=null)return et;if(i.predictable)throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");return _(_e.valueOf(),tt.valueOf())},"Array, number":b,"Array, BigNumber":function(_e,tt){return b(_e,tt.toNumber())},"Matrix, number":$,"Matrix, BigNumber":function(_e,tt){return $(_e,tt.toNumber())},"Unit, number | BigNumber":function(_e,tt){return _e.pow(tt)}});function _(j,_e){if(i.predictable&&!isInteger(_e)&&j<0)try{var tt=h(_e),et=d(tt);if((_e===et||Math.abs((_e-et)/_e)<1e-14)&&tt.d%2===1)return(tt.n%2===0?1:-1)*Math.pow(-j,_e)}catch{}return i.predictable&&(j<-1&&_e===1/0||j>-1&&j<0&&_e===-1/0)?NaN:isInteger(_e)||j>=0||i.predictable?powNumber(j,_e):j*j<1&&_e===1/0||j*j>1&&_e===-1/0?0:new g(j,0).pow(_e,0)}function b(j,_e){if(!isInteger(_e)||_e<0)throw new TypeError("For A^b, b must be a positive integer (value is "+_e+")");var tt=arraySize(j);if(tt.length!==2)throw new Error("For A^b, A must be 2 dimensional (A has "+tt.length+" dimensions)");if(tt[0]!==tt[1])throw new Error("For A^b, A must be square (size is "+tt[0]+"x"+tt[1]+")");for(var et=s(tt[0]).valueOf(),nt=j;_e>=1;)(_e&1)===1&&(et=o(nt,et)),_e>>=1,nt=o(nt,nt);return et}function $(j,_e){return c(b(j.valueOf(),_e))}});function createSolveValidation(a){var{DenseMatrix:e}=a;return function(s,o,c){var d=s.size();if(d.length!==2)throw new RangeError("Matrix must be two dimensional (size: "+format(d)+")");var h=d[0],g=d[1];if(h!==g)throw new RangeError("Matrix must be square (size: "+format(d)+")");var _=[];if(isMatrix(o)){var b=o.size(),$=o._data;if(b.length===1){if(b[0]!==h)throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var j=0;j<h;j++)_[j]=[$[j]];return new e({data:_,size:[h,1],datatype:o._datatype})}if(b.length===2){if(b[0]!==h||b[1]!==1)throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");if(isDenseMatrix(o)){if(c){_=[];for(var _e=0;_e<h;_e++)_[_e]=[$[_e][0]];return new e({data:_,size:[h,1],datatype:o._datatype})}return o}if(isSparseMatrix(o)){for(var tt=0;tt<h;tt++)_[tt]=[0];for(var et=o._values,nt=o._index,rt=o._ptr,it=rt[1],at=rt[0];at<it;at++){var st=nt[at];_[st][0]=et[at]}return new e({data:_,size:[h,1],datatype:o._datatype})}}throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}if(isArray(o)){var ot=arraySize(o);if(ot.length===1){if(ot[0]!==h)throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var ct=0;ct<h;ct++)_[ct]=[o[ct]];return new e({data:_,size:[h,1]})}if(ot.length===2){if(ot[0]!==h||ot[1]!==1)throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");for(var lt=0;lt<h;lt++)_[lt]=[o[lt][0]];return new e({data:_,size:[h,1]})}throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.")}}}var name$m="usolve",dependencies$m=["typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix"],createUsolve=factory$1(name$m,dependencies$m,a=>{var{typed:e,matrix:i,divideScalar:s,multiplyScalar:o,subtract:c,equalScalar:d,DenseMatrix:h}=a,g=createSolveValidation({DenseMatrix:h});return e(name$m,{"SparseMatrix, Array | Matrix":function(j,_e){return b(j,_e)},"DenseMatrix, Array | Matrix":function(j,_e){return _(j,_e)},"Array, Array | Matrix":function(j,_e){var tt=i(j),et=_(tt,_e);return et.valueOf()}});function _($,j){j=g($,j,!0);for(var _e=j._data,tt=$._size[0],et=$._size[1],nt=[],rt=$._data,it=et-1;it>=0;it--){var at=_e[it][0]||0,st=void 0;if(d(at,0))st=0;else{var ot=rt[it][it];if(d(ot,0))throw new Error("Linear system cannot be solved since matrix is singular");st=s(at,ot);for(var ct=it-1;ct>=0;ct--)_e[ct]=[c(_e[ct][0]||0,o(st,rt[ct][it]))]}nt[it]=[st]}return new h({data:nt,size:[tt,1]})}function b($,j){j=g($,j,!0);for(var _e=j._data,tt=$._size[0],et=$._size[1],nt=$._values,rt=$._index,it=$._ptr,at=[],st=et-1;st>=0;st--){var ot=_e[st][0]||0;if(d(ot,0))at[st]=[0];else{for(var ct=0,lt=[],dt=[],xt=it[st],ut=it[st+1],ft=ut-1;ft>=xt;ft--){var mt=rt[ft];mt===st?ct=nt[ft]:mt<st&&(lt.push(nt[ft]),dt.push(mt))}if(d(ct,0))throw new Error("Linear system cannot be solved since matrix is singular");for(var yt=s(ot,ct),St=0,Et=dt.length;St<Et;St++){var vt=dt[St];_e[vt]=[c(_e[vt][0],o(yt,lt[St]))]}at[st]=[yt]}}return new h({data:at,size:[tt,1]})}}),name$l="usolveAll",dependencies$l=["typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix"],createUsolveAll=factory$1(name$l,dependencies$l,a=>{var{typed:e,matrix:i,divideScalar:s,multiplyScalar:o,subtract:c,equalScalar:d,DenseMatrix:h}=a,g=createSolveValidation({DenseMatrix:h});return e(name$l,{"SparseMatrix, Array | Matrix":function(j,_e){return b(j,_e)},"DenseMatrix, Array | Matrix":function(j,_e){return _(j,_e)},"Array, Array | Matrix":function(j,_e){var tt=i(j),et=_(tt,_e);return et.map(nt=>nt.valueOf())}});function _($,j){for(var _e=[g($,j,!0)._data.map(dt=>dt[0])],tt=$._data,et=$._size[0],nt=$._size[1],rt=nt-1;rt>=0;rt--)for(var it=_e.length,at=0;at<it;at++){var st=_e[at];if(d(tt[rt][rt],0))if(d(st[rt],0)){if(at===0){var ct=[...st];ct[rt]=1;for(var lt=rt-1;lt>=0;lt--)ct[lt]=c(ct[lt],tt[lt][rt]);_e.push(ct)}}else{if(at===0)return[];_e.splice(at,1),at-=1,it-=1}else{st[rt]=s(st[rt],tt[rt][rt]);for(var ot=rt-1;ot>=0;ot--)st[ot]=c(st[ot],o(st[rt],tt[ot][rt]))}}return _e.map(dt=>new h({data:dt.map(xt=>[xt]),size:[et,1]}))}function b($,j){for(var _e=[g($,j,!0)._data.map(Mt=>Mt[0])],tt=$._size[0],et=$._size[1],nt=$._values,rt=$._index,it=$._ptr,at=et-1;at>=0;at--)for(var st=_e.length,ot=0;ot<st;ot++){for(var ct=_e[ot],lt=[],dt=[],xt=it[at],ut=it[at+1],ft=0,mt=ut-1;mt>=xt;mt--){var yt=rt[mt];yt===at?ft=nt[mt]:yt<at&&(lt.push(nt[mt]),dt.push(yt))}if(d(ft,0))if(d(ct[at],0)){if(ot===0){var Nt=[...ct];Nt[at]=1;for(var wt=0,$t=dt.length;wt<$t;wt++){var Ct=dt[wt];Nt[Ct]=c(Nt[Ct],lt[wt])}_e.push(Nt)}}else{if(ot===0)return[];_e.splice(ot,1),ot-=1,st-=1}else{ct[at]=s(ct[at],ft);for(var St=0,Et=dt.length;St<Et;St++){var vt=dt[St];ct[vt]=c(ct[vt],o(ct[at],lt[St]))}}}return _e.map(Mt=>new h({data:Mt.map(Ot=>[Ot]),size:[tt,1]}))}}),name$k="equal",dependencies$k=["typed","matrix","equalScalar","DenseMatrix"],createEqual=factory$1(name$k,dependencies$k,a=>{var{typed:e,matrix:i,equalScalar:s,DenseMatrix:o}=a,c=createAlgorithm03({typed:e}),d=createAlgorithm07({typed:e,DenseMatrix:o}),h=createAlgorithm12({typed:e,DenseMatrix:o}),g=createAlgorithm13({typed:e}),_=createAlgorithm14({typed:e});return e(name$k,{"any, any":function($,j){return $===null?j===null:j===null?$===null:$===void 0?j===void 0:j===void 0?$===void 0:s($,j)},"SparseMatrix, SparseMatrix":function($,j){return d($,j,s)},"SparseMatrix, DenseMatrix":function($,j){return c(j,$,s,!0)},"DenseMatrix, SparseMatrix":function($,j){return c($,j,s,!1)},"DenseMatrix, DenseMatrix":function($,j){return g($,j,s)},"Array, Array":function($,j){return this(i($),i(j)).valueOf()},"Array, Matrix":function($,j){return this(i($),j)},"Matrix, Array":function($,j){return this($,i(j))},"SparseMatrix, any":function($,j){return h($,j,s,!1)},"DenseMatrix, any":function($,j){return _($,j,s,!1)},"any, SparseMatrix":function($,j){return h(j,$,s,!0)},"any, DenseMatrix":function($,j){return _(j,$,s,!0)},"Array, any":function($,j){return _(i($),j,s,!1).valueOf()},"any, Array":function($,j){return _(i(j),$,s,!0).valueOf()}})});factory$1(name$k,["typed","equalScalar"],a=>{var{typed:e,equalScalar:i}=a;return e(name$k,{"any, any":function(o,c){return o===null?c===null:c===null?o===null:o===void 0?c===void 0:c===void 0?o===void 0:i(o,c)}})});var name$j="smaller",dependencies$j=["typed","config","matrix","DenseMatrix"],createSmaller=factory$1(name$j,dependencies$j,a=>{var{typed:e,config:i,matrix:s,DenseMatrix:o}=a,c=createAlgorithm03({typed:e}),d=createAlgorithm07({typed:e,DenseMatrix:o}),h=createAlgorithm12({typed:e,DenseMatrix:o}),g=createAlgorithm13({typed:e}),_=createAlgorithm14({typed:e});return e(name$j,{"boolean, boolean":function($,j){return $<j},"number, number":function($,j){return $<j&&!nearlyEqual$1($,j,i.epsilon)},"BigNumber, BigNumber":function($,j){return $.lt(j)&&!nearlyEqual($,j,i.epsilon)},"Fraction, Fraction":function($,j){return $.compare(j)===-1},"Complex, Complex":function($,j){throw new TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function($,j){if(!$.equalBase(j))throw new Error("Cannot compare units with different base");return this($.value,j.value)},"SparseMatrix, SparseMatrix":function($,j){return d($,j,this)},"SparseMatrix, DenseMatrix":function($,j){return c(j,$,this,!0)},"DenseMatrix, SparseMatrix":function($,j){return c($,j,this,!1)},"DenseMatrix, DenseMatrix":function($,j){return g($,j,this)},"Array, Array":function($,j){return this(s($),s(j)).valueOf()},"Array, Matrix":function($,j){return this(s($),j)},"Matrix, Array":function($,j){return this($,s(j))},"SparseMatrix, any":function($,j){return h($,j,this,!1)},"DenseMatrix, any":function($,j){return _($,j,this,!1)},"any, SparseMatrix":function($,j){return h(j,$,this,!0)},"any, DenseMatrix":function($,j){return _(j,$,this,!0)},"Array, any":function($,j){return _(s($),j,this,!1).valueOf()},"any, Array":function($,j){return _(s(j),$,this,!0).valueOf()}})}),name$i="smallerEq",dependencies$i=["typed","config","matrix","DenseMatrix"],createSmallerEq=factory$1(name$i,dependencies$i,a=>{var{typed:e,config:i,matrix:s,DenseMatrix:o}=a,c=createAlgorithm03({typed:e}),d=createAlgorithm07({typed:e,DenseMatrix:o}),h=createAlgorithm12({typed:e,DenseMatrix:o}),g=createAlgorithm13({typed:e}),_=createAlgorithm14({typed:e});return e(name$i,{"boolean, boolean":function($,j){return $<=j},"number, number":function($,j){return $<=j||nearlyEqual$1($,j,i.epsilon)},"BigNumber, BigNumber":function($,j){return $.lte(j)||nearlyEqual($,j,i.epsilon)},"Fraction, Fraction":function($,j){return $.compare(j)!==1},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function($,j){if(!$.equalBase(j))throw new Error("Cannot compare units with different base");return this($.value,j.value)},"SparseMatrix, SparseMatrix":function($,j){return d($,j,this)},"SparseMatrix, DenseMatrix":function($,j){return c(j,$,this,!0)},"DenseMatrix, SparseMatrix":function($,j){return c($,j,this,!1)},"DenseMatrix, DenseMatrix":function($,j){return g($,j,this)},"Array, Array":function($,j){return this(s($),s(j)).valueOf()},"Array, Matrix":function($,j){return this(s($),j)},"Matrix, Array":function($,j){return this($,s(j))},"SparseMatrix, any":function($,j){return h($,j,this,!1)},"DenseMatrix, any":function($,j){return _($,j,this,!1)},"any, SparseMatrix":function($,j){return h(j,$,this,!0)},"any, DenseMatrix":function($,j){return _(j,$,this,!0)},"Array, any":function($,j){return _(s($),j,this,!1).valueOf()},"any, Array":function($,j){return _(s(j),$,this,!0).valueOf()}})}),name$h="larger",dependencies$h=["typed","config","matrix","DenseMatrix"],createLarger=factory$1(name$h,dependencies$h,a=>{var{typed:e,config:i,matrix:s,DenseMatrix:o}=a,c=createAlgorithm03({typed:e}),d=createAlgorithm07({typed:e,DenseMatrix:o}),h=createAlgorithm12({typed:e,DenseMatrix:o}),g=createAlgorithm13({typed:e}),_=createAlgorithm14({typed:e});return e(name$h,{"boolean, boolean":function($,j){return $>j},"number, number":function($,j){return $>j&&!nearlyEqual$1($,j,i.epsilon)},"BigNumber, BigNumber":function($,j){return $.gt(j)&&!nearlyEqual($,j,i.epsilon)},"Fraction, Fraction":function($,j){return $.compare(j)===1},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function($,j){if(!$.equalBase(j))throw new Error("Cannot compare units with different base");return this($.value,j.value)},"SparseMatrix, SparseMatrix":function($,j){return d($,j,this)},"SparseMatrix, DenseMatrix":function($,j){return c(j,$,this,!0)},"DenseMatrix, SparseMatrix":function($,j){return c($,j,this,!1)},"DenseMatrix, DenseMatrix":function($,j){return g($,j,this)},"Array, Array":function($,j){return this(s($),s(j)).valueOf()},"Array, Matrix":function($,j){return this(s($),j)},"Matrix, Array":function($,j){return this($,s(j))},"SparseMatrix, any":function($,j){return h($,j,this,!1)},"DenseMatrix, any":function($,j){return _($,j,this,!1)},"any, SparseMatrix":function($,j){return h(j,$,this,!0)},"any, DenseMatrix":function($,j){return _(j,$,this,!0)},"Array, any":function($,j){return _(s($),j,this,!1).valueOf()},"any, Array":function($,j){return _(s(j),$,this,!0).valueOf()}})}),name$g="largerEq",dependencies$g=["typed","config","matrix","DenseMatrix"],createLargerEq=factory$1(name$g,dependencies$g,a=>{var{typed:e,config:i,matrix:s,DenseMatrix:o}=a,c=createAlgorithm03({typed:e}),d=createAlgorithm07({typed:e,DenseMatrix:o}),h=createAlgorithm12({typed:e,DenseMatrix:o}),g=createAlgorithm13({typed:e}),_=createAlgorithm14({typed:e});return e(name$g,{"boolean, boolean":function($,j){return $>=j},"number, number":function($,j){return $>=j||nearlyEqual$1($,j,i.epsilon)},"BigNumber, BigNumber":function($,j){return $.gte(j)||nearlyEqual($,j,i.epsilon)},"Fraction, Fraction":function($,j){return $.compare(j)!==-1},"Complex, Complex":function(){throw new TypeError("No ordering relation is defined for complex numbers")},"Unit, Unit":function($,j){if(!$.equalBase(j))throw new Error("Cannot compare units with different base");return this($.value,j.value)},"SparseMatrix, SparseMatrix":function($,j){return d($,j,this)},"SparseMatrix, DenseMatrix":function($,j){return c(j,$,this,!0)},"DenseMatrix, SparseMatrix":function($,j){return c($,j,this,!1)},"DenseMatrix, DenseMatrix":function($,j){return g($,j,this)},"Array, Array":function($,j){return this(s($),s(j)).valueOf()},"Array, Matrix":function($,j){return this(s($),j)},"Matrix, Array":function($,j){return this($,s(j))},"SparseMatrix, any":function($,j){return h($,j,this,!1)},"DenseMatrix, any":function($,j){return _($,j,this,!1)},"any, SparseMatrix":function($,j){return h(j,$,this,!0)},"any, DenseMatrix":function($,j){return _(j,$,this,!0)},"Array, any":function($,j){return _(s($),j,this,!1).valueOf()},"any, Array":function($,j){return _(s(j),$,this,!0).valueOf()}})}),name$f="ImmutableDenseMatrix",dependencies$f=["smaller","DenseMatrix"],createImmutableDenseMatrixClass=factory$1(name$f,dependencies$f,a=>{var{smaller:e,DenseMatrix:i}=a;function s(o,c){if(!(this instanceof s))throw new SyntaxError("Constructor must be called with the new operator");if(c&&!isString(c))throw new Error("Invalid datatype: "+c);if(isMatrix(o)||isArray(o)){var d=new i(o,c);this._data=d._data,this._size=d._size,this._datatype=d._datatype,this._min=null,this._max=null}else if(o&&isArray(o.data)&&isArray(o.size))this._data=o.data,this._size=o.size,this._datatype=o.datatype,this._min=typeof o.min<"u"?o.min:null,this._max=typeof o.max<"u"?o.max:null;else{if(o)throw new TypeError("Unsupported type of data ("+typeOf(o)+")");this._data=[],this._size=[0],this._datatype=c,this._min=null,this._max=null}}return s.prototype=new i,s.prototype.type="ImmutableDenseMatrix",s.prototype.isImmutableDenseMatrix=!0,s.prototype.subset=function(o){switch(arguments.length){case 1:{var c=i.prototype.subset.call(this,o);return isMatrix(c)?new s({data:c._data,size:c._size,datatype:c._datatype}):c}case 2:case 3:throw new Error("Cannot invoke set subset on an Immutable Matrix instance");default:throw new SyntaxError("Wrong number of arguments")}},s.prototype.set=function(){throw new Error("Cannot invoke set on an Immutable Matrix instance")},s.prototype.resize=function(){throw new Error("Cannot invoke resize on an Immutable Matrix instance")},s.prototype.reshape=function(){throw new Error("Cannot invoke reshape on an Immutable Matrix instance")},s.prototype.clone=function(){return new s({data:clone$1(this._data),size:clone$1(this._size),datatype:this._datatype})},s.prototype.toJSON=function(){return{mathjs:"ImmutableDenseMatrix",data:this._data,size:this._size,datatype:this._datatype}},s.fromJSON=function(o){return new s(o)},s.prototype.swapRows=function(){throw new Error("Cannot invoke swapRows on an Immutable Matrix instance")},s.prototype.min=function(){if(this._min===null){var o=null;this.forEach(function(c){(o===null||e(c,o))&&(o=c)}),this._min=o!==null?o:void 0}return this._min},s.prototype.max=function(){if(this._max===null){var o=null;this.forEach(function(c){(o===null||e(o,c))&&(o=c)}),this._max=o!==null?o:void 0}return this._max},s},{isClass:!0}),name$e="Index",dependencies$e=["ImmutableDenseMatrix"],createIndexClass=factory$1(name$e,dependencies$e,a=>{var{ImmutableDenseMatrix:e}=a;function i(o){if(!(this instanceof i))throw new SyntaxError("Constructor must be called with the new operator");this._dimensions=[],this._isScalar=!0;for(var c=0,d=arguments.length;c<d;c++){var h=arguments[c];if(isRange(h))this._dimensions.push(h),this._isScalar=!1;else if(Array.isArray(h)||isMatrix(h)){var g=s(h.valueOf());this._dimensions.push(g);var _=g.size();(_.length!==1||_[0]!==1)&&(this._isScalar=!1)}else if(typeof h=="number")this._dimensions.push(s([h]));else if(typeof h=="string")this._dimensions.push(h);else throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range")}}i.prototype.type="Index",i.prototype.isIndex=!0;function s(o){for(var c=0,d=o.length;c<d;c++)if(typeof o[c]!="number"||!isInteger(o[c]))throw new TypeError("Index parameters must be positive integer numbers");return new e(o)}return i.prototype.clone=function(){var o=new i;return o._dimensions=clone$1(this._dimensions),o._isScalar=this._isScalar,o},i.create=function(o){var c=new i;return i.apply(c,o),c},i.prototype.size=function(){for(var o=[],c=0,d=this._dimensions.length;c<d;c++){var h=this._dimensions[c];o[c]=typeof h=="string"?1:h.size()[0]}return o},i.prototype.max=function(){for(var o=[],c=0,d=this._dimensions.length;c<d;c++){var h=this._dimensions[c];o[c]=typeof h=="string"?h:h.max()}return o},i.prototype.min=function(){for(var o=[],c=0,d=this._dimensions.length;c<d;c++){var h=this._dimensions[c];o[c]=typeof h=="string"?h:h.min()}return o},i.prototype.forEach=function(o){for(var c=0,d=this._dimensions.length;c<d;c++)o(this._dimensions[c],c,this)},i.prototype.dimension=function(o){return this._dimensions[o]||null},i.prototype.isObjectProperty=function(){return this._dimensions.length===1&&typeof this._dimensions[0]=="string"},i.prototype.getObjectProperty=function(){return this.isObjectProperty()?this._dimensions[0]:null},i.prototype.isScalar=function(){return this._isScalar},i.prototype.toArray=function(){for(var o=[],c=0,d=this._dimensions.length;c<d;c++){var h=this._dimensions[c];o.push(typeof h=="string"?h:h.toArray())}return o},i.prototype.valueOf=i.prototype.toArray,i.prototype.toString=function(){for(var o=[],c=0,d=this._dimensions.length;c<d;c++){var h=this._dimensions[c];typeof h=="string"?o.push(JSON.stringify(h)):o.push(h.toString())}return"["+o.join(", ")+"]"},i.prototype.toJSON=function(){return{mathjs:"Index",dimensions:this._dimensions}},i.fromJSON=function(o){return i.create(o.dimensions)},i},{isClass:!0}),name$d="FibonacciHeap",dependencies$d=["smaller","larger"],createFibonacciHeapClass=factory$1(name$d,dependencies$d,a=>{var{smaller:e,larger:i}=a,s=1/Math.log((1+Math.sqrt(5))/2);function o(){if(!(this instanceof o))throw new SyntaxError("Constructor must be called with the new operator");this._minimum=null,this._size=0}o.prototype.type="FibonacciHeap",o.prototype.isFibonacciHeap=!0,o.prototype.insert=function(b,$){var j={key:b,value:$,degree:0};if(this._minimum){var _e=this._minimum;j.left=_e,j.right=_e.right,_e.right=j,j.right.left=j,e(b,_e.key)&&(this._minimum=j)}else j.left=j,j.right=j,this._minimum=j;return this._size++,j},o.prototype.size=function(){return this._size},o.prototype.clear=function(){this._minimum=null,this._size=0},o.prototype.isEmpty=function(){return this._size===0},o.prototype.extractMinimum=function(){var b=this._minimum;if(b===null)return b;for(var $=this._minimum,j=b.degree,_e=b.child;j>0;){var tt=_e.right;_e.left.right=_e.right,_e.right.left=_e.left,_e.left=$,_e.right=$.right,$.right=_e,_e.right.left=_e,_e.parent=null,_e=tt,j--}return b.left.right=b.right,b.right.left=b.left,b===b.right?$=null:($=b.right,$=_($,this._size)),this._size--,this._minimum=$,b},o.prototype.remove=function(b){this._minimum=c(this._minimum,b,-1),this.extractMinimum()};function c(b,$,j){$.key=j;var _e=$.parent;return _e&&e($.key,_e.key)&&(d(b,$,_e),h(b,_e)),e($.key,b.key)&&(b=$),b}function d(b,$,j){$.left.right=$.right,$.right.left=$.left,j.degree--,j.child===$&&(j.child=$.right),j.degree===0&&(j.child=null),$.left=b,$.right=b.right,b.right=$,$.right.left=$,$.parent=null,$.mark=!1}function h(b,$){var j=$.parent;j&&($.mark?(d(b,$,j),h(j)):$.mark=!0)}var g=function($,j){$.left.right=$.right,$.right.left=$.left,$.parent=j,j.child?($.left=j.child,$.right=j.child.right,j.child.right=$,$.right.left=$):(j.child=$,$.right=$,$.left=$),j.degree++,$.mark=!1};function _(b,$){var j=Math.floor(Math.log($)*s)+1,_e=new Array(j),tt=0,et=b;if(et)for(tt++,et=et.right;et!==b;)tt++,et=et.right;for(var nt;tt>0;){for(var rt=et.degree,it=et.right;nt=_e[rt],!!nt;){if(i(et.key,nt.key)){var at=nt;nt=et,et=at}g(nt,et),_e[rt]=null,rt++}_e[rt]=et,et=it,tt--}b=null;for(var st=0;st<j;st++)nt=_e[st],nt&&(b?(nt.left.right=nt.right,nt.right.left=nt.left,nt.left=b,nt.right=b.right,b.right=nt,nt.right.left=nt,e(nt.key,b.key)&&(b=nt)):b=nt);return b}return o},{isClass:!0}),name$c="Spa",dependencies$c=["addScalar","equalScalar","FibonacciHeap"],createSpaClass=factory$1(name$c,dependencies$c,a=>{var{addScalar:e,equalScalar:i,FibonacciHeap:s}=a;function o(){if(!(this instanceof o))throw new SyntaxError("Constructor must be called with the new operator");this._values=[],this._heap=new s}return o.prototype.type="Spa",o.prototype.isSpa=!0,o.prototype.set=function(c,d){if(this._values[c])this._values[c].value=d;else{var h=this._heap.insert(c,d);this._values[c]=h}},o.prototype.get=function(c){var d=this._values[c];return d?d.value:0},o.prototype.accumulate=function(c,d){var h=this._values[c];h?h.value=e(h.value,d):(h=this._heap.insert(c,d),this._values[c]=h)},o.prototype.forEach=function(c,d,h){var g=this._heap,_=this._values,b=[],$=g.extractMinimum();for($&&b.push($);$&&$.key<=d;)$.key>=c&&(i($.value,0)||h($.key,$.value,this)),$=g.extractMinimum(),$&&b.push($);for(var j=0;j<b.length;j++){var _e=b[j];$=g.insert(_e.key,_e.value),_[$.key]=$}},o.prototype.swap=function(c,d){var h=this._values[c],g=this._values[d];if(!h&&g)h=this._heap.insert(c,g.value),this._heap.remove(g),this._values[c]=h,this._values[d]=void 0;else if(h&&!g)g=this._heap.insert(d,h.value),this._heap.remove(h),this._values[d]=g,this._values[c]=void 0;else if(h&&g){var _=h.value;h.value=g.value,g.value=_}},o},{isClass:!0}),name$b="atan",dependencies$b=["typed"],createAtan=factory$1(name$b,dependencies$b,a=>{var{typed:e}=a;return e("atan",{number:function(s){return Math.atan(s)},Complex:function(s){return s.atan()},BigNumber:function(s){return s.atan()},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$a="cos",dependencies$a=["typed"],createCos=factory$1(name$a,dependencies$a,a=>{var{typed:e}=a;return e(name$a,{number:Math.cos,Complex:function(s){return s.cos()},BigNumber:function(s){return s.cos()},Unit:function(s){if(!s.hasBase(s.constructor.BASE_UNITS.ANGLE))throw new TypeError("Unit in function cos is no angle");return this(s.value)},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$9="sin",dependencies$9=["typed"],createSin=factory$1(name$9,dependencies$9,a=>{var{typed:e}=a;return e(name$9,{number:Math.sin,Complex:function(s){return s.sin()},BigNumber:function(s){return s.sin()},Unit:function(s){if(!s.hasBase(s.constructor.BASE_UNITS.ANGLE))throw new TypeError("Unit in function sin is no angle");return this(s.value)},"Array | Matrix":function(s){return deepMap(s,this)}})}),name$8="add",dependencies$8=["typed","matrix","addScalar","equalScalar","DenseMatrix","SparseMatrix"],createAdd=factory$1(name$8,dependencies$8,a=>{var{typed:e,matrix:i,addScalar:s,equalScalar:o,DenseMatrix:c,SparseMatrix:d}=a,h=createAlgorithm01({typed:e}),g=createAlgorithm04({typed:e,equalScalar:o}),_=createAlgorithm10({typed:e,DenseMatrix:c}),b=createAlgorithm13({typed:e}),$=createAlgorithm14({typed:e});return e(name$8,extend({"DenseMatrix, DenseMatrix":function(_e,tt){return b(_e,tt,s)},"DenseMatrix, SparseMatrix":function(_e,tt){return h(_e,tt,s,!1)},"SparseMatrix, DenseMatrix":function(_e,tt){return h(tt,_e,s,!0)},"SparseMatrix, SparseMatrix":function(_e,tt){return g(_e,tt,s)},"Array, Array":function(_e,tt){return this(i(_e),i(tt)).valueOf()},"Array, Matrix":function(_e,tt){return this(i(_e),tt)},"Matrix, Array":function(_e,tt){return this(_e,i(tt))},"DenseMatrix, any":function(_e,tt){return $(_e,tt,s,!1)},"SparseMatrix, any":function(_e,tt){return _(_e,tt,s,!1)},"any, DenseMatrix":function(_e,tt){return $(tt,_e,s,!0)},"any, SparseMatrix":function(_e,tt){return _(tt,_e,s,!0)},"Array, any":function(_e,tt){return $(i(_e),tt,s,!1).valueOf()},"any, Array":function(_e,tt){return $(i(tt),_e,s,!0).valueOf()},"any, any":s,"any, any, ...any":function(_e,tt,et){for(var nt=this(_e,tt),rt=0;rt<et.length;rt++)nt=this(nt,et[rt]);return nt}},s.signatures))}),name$7="norm",dependencies$7=["typed","abs","add","pow","conj","sqrt","multiply","equalScalar","larger","smaller","matrix","ctranspose","eigs"],createNorm=factory$1(name$7,dependencies$7,a=>{var{typed:e,abs:i,add:s,pow:o,conj:c,sqrt:d,multiply:h,equalScalar:g,larger:_,smaller:b,matrix:$,ctranspose:j,eigs:_e}=a;return e(name$7,{number:Math.abs,Complex:function(dt){return dt.abs()},BigNumber:function(dt){return dt.abs()},boolean:function(dt){return Math.abs(dt)},Array:function(dt){return ct($(dt),2)},Matrix:function(dt){return ct(dt,2)},"number | Complex | BigNumber | boolean, number | BigNumber | string":function(dt){return this(dt)},"Array, number | BigNumber | string":function(dt,xt){return ct($(dt),xt)},"Matrix, number | BigNumber | string":function(dt,xt){return ct(dt,xt)}});function tt(lt){var dt=0;return lt.forEach(function(xt){var ut=i(xt);_(ut,dt)&&(dt=ut)},!0),dt}function et(lt){var dt;return lt.forEach(function(xt){var ut=i(xt);(!dt||b(ut,dt))&&(dt=ut)},!0),dt||0}function nt(lt,dt){if(dt===Number.POSITIVE_INFINITY||dt==="inf")return tt(lt);if(dt===Number.NEGATIVE_INFINITY||dt==="-inf")return et(lt);if(dt==="fro")return ct(lt,2);if(typeof dt=="number"&&!isNaN(dt)){if(!g(dt,0)){var xt=0;return lt.forEach(function(ut){xt=s(o(i(ut),dt),xt)},!0),o(xt,1/dt)}return Number.POSITIVE_INFINITY}throw new Error("Unsupported parameter value")}function rt(lt){var dt=0;return lt.forEach(function(xt,ut){dt=s(dt,h(xt,c(xt)))}),i(d(dt))}function it(lt){var dt=[],xt=0;return lt.forEach(function(ut,ft){var mt=ft[1],yt=s(dt[mt]||0,i(ut));_(yt,xt)&&(xt=yt),dt[mt]=yt},!0),xt}function at(lt){var dt=lt.size();if(dt[0]!==dt[1])throw new RangeError("Invalid matrix dimensions");var xt=j(lt),ut=h(xt,lt),ft=_e(ut).values.toArray(),mt=ft[ft.length-1];return i(d(mt))}function st(lt){var dt=[],xt=0;return lt.forEach(function(ut,ft){var mt=ft[0],yt=s(dt[mt]||0,i(ut));_(yt,xt)&&(xt=yt),dt[mt]=yt},!0),xt}function ot(lt,dt){if(dt===1)return it(lt);if(dt===Number.POSITIVE_INFINITY||dt==="inf")return st(lt);if(dt==="fro")return rt(lt);if(dt===2)return at(lt);throw new Error("Unsupported parameter value "+dt)}function ct(lt,dt){var xt=lt.size();if(xt.length===1)return nt(lt,dt);if(xt.length===2){if(xt[0]&&xt[1])return ot(lt,dt);throw new RangeError("Invalid matrix dimensions")}}}),name$6="dot",dependencies$6=["typed","addScalar","multiplyScalar","conj","size"],createDot=factory$1(name$6,dependencies$6,a=>{var{typed:e,addScalar:i,multiplyScalar:s,conj:o,size:c}=a;return e(name$6,{"Array | DenseMatrix, Array | DenseMatrix":h,"SparseMatrix, SparseMatrix":g});function d(b,$){var j=_(b),_e=_($),tt,et;if(j.length===1)tt=j[0];else if(j.length===2&&j[1]===1)tt=j[0];else throw new RangeError("Expected a column vector, instead got a matrix of size ("+j.join(", ")+")");if(_e.length===1)et=_e[0];else if(_e.length===2&&_e[1]===1)et=_e[0];else throw new RangeError("Expected a column vector, instead got a matrix of size ("+_e.join(", ")+")");if(tt!==et)throw new RangeError("Vectors must have equal length ("+tt+" != "+et+")");if(tt===0)throw new RangeError("Cannot calculate the dot product of empty vectors");return tt}function h(b,$){var j=d(b,$),_e=isMatrix(b)?b._data:b,tt=isMatrix(b)?b._datatype:void 0,et=isMatrix($)?$._data:$,nt=isMatrix($)?$._datatype:void 0,rt=_(b).length===2,it=_($).length===2,at=i,st=s;if(tt&&nt&&tt===nt&&typeof tt=="string"){var ot=tt;at=e.find(i,[ot,ot]),st=e.find(s,[ot,ot])}if(!rt&&!it){for(var ct=st(o(_e[0]),et[0]),lt=1;lt<j;lt++)ct=at(ct,st(o(_e[lt]),et[lt]));return ct}if(!rt&&it){for(var dt=st(o(_e[0]),et[0][0]),xt=1;xt<j;xt++)dt=at(dt,st(o(_e[xt]),et[xt][0]));return dt}if(rt&&!it){for(var ut=st(o(_e[0][0]),et[0]),ft=1;ft<j;ft++)ut=at(ut,st(o(_e[ft][0]),et[ft]));return ut}if(rt&&it){for(var mt=st(o(_e[0][0]),et[0][0]),yt=1;yt<j;yt++)mt=at(mt,st(o(_e[yt][0]),et[yt][0]));return mt}}function g(b,$){d(b,$);for(var j=b._index,_e=b._values,tt=$._index,et=$._values,nt=0,rt=i,it=s,at=0,st=0;at<j.length&&st<tt.length;){var ot=j[at],ct=tt[st];if(ot<ct){at++;continue}if(ot>ct){st++;continue}ot===ct&&(nt=rt(nt,it(_e[at],et[st])),at++,st++)}return nt}function _(b){return isMatrix(b)?b.size():c(b)}}),name$5="lup",dependencies$5=["typed","matrix","abs","addScalar","divideScalar","multiplyScalar","subtract","larger","equalScalar","unaryMinus","DenseMatrix","SparseMatrix","Spa"],createLup=factory$1(name$5,dependencies$5,a=>{var{typed:e,matrix:i,abs:s,addScalar:o,divideScalar:c,multiplyScalar:d,subtract:h,larger:g,equalScalar:_,unaryMinus:b,DenseMatrix:$,SparseMatrix:j,Spa:_e}=a;return e(name$5,{DenseMatrix:function(rt){return tt(rt)},SparseMatrix:function(rt){return et(rt)},Array:function(rt){var it=i(rt),at=tt(it);return{L:at.L.valueOf(),U:at.U.valueOf(),p:at.p}}});function tt(nt){var rt=nt._size[0],it=nt._size[1],at=Math.min(rt,it),st=clone$1(nt._data),ot=[],ct=[rt,at],lt=[],dt=[at,it],xt,ut,ft,mt=[];for(xt=0;xt<rt;xt++)mt[xt]=xt;for(ut=0;ut<it;ut++){if(ut>0)for(xt=0;xt<rt;xt++){var yt=Math.min(xt,ut),St=0;for(ft=0;ft<yt;ft++)St=o(St,d(st[xt][ft],st[ft][ut]));st[xt][ut]=h(st[xt][ut],St)}var Et=ut,vt=0,Nt=0;for(xt=ut;xt<rt;xt++){var wt=st[xt][ut],$t=s(wt);g($t,vt)&&(Et=xt,vt=$t,Nt=wt)}if(ut!==Et&&(mt[ut]=[mt[Et],mt[Et]=mt[ut]][0],$._swapRows(ut,Et,st)),ut<rt)for(xt=ut+1;xt<rt;xt++){var Ct=st[xt][ut];_(Ct,0)||(st[xt][ut]=c(st[xt][ut],Nt))}}for(ut=0;ut<it;ut++)for(xt=0;xt<rt;xt++){if(ut===0&&(xt<it&&(lt[xt]=[]),ot[xt]=[]),xt<ut){xt<it&&(lt[xt][ut]=st[xt][ut]),ut<rt&&(ot[xt][ut]=0);continue}if(xt===ut){xt<it&&(lt[xt][ut]=st[xt][ut]),ut<rt&&(ot[xt][ut]=1);continue}xt<it&&(lt[xt][ut]=0),ut<rt&&(ot[xt][ut]=st[xt][ut])}var Mt=new $({data:ot,size:ct}),Ot=new $({data:lt,size:dt}),Dt=[];for(xt=0,at=mt.length;xt<at;xt++)Dt[mt[xt]]=xt;return{L:Mt,U:Ot,p:Dt,toString:function(){return"L: "+this.L.toString()+`
U: `+this.U.toString()+`
P: `+this.p}}}function et(nt){var rt=nt._size[0],it=nt._size[1],at=Math.min(rt,it),st=nt._values,ot=nt._index,ct=nt._ptr,lt=[],dt=[],xt=[],ut=[rt,at],ft=[],mt=[],yt=[],St=[at,it],Et,vt,Nt,wt=[],$t=[];for(Et=0;Et<rt;Et++)wt[Et]=Et,$t[Et]=Et;var Ct=function(Dt,At){var kt=$t[Dt],Ft=$t[At];wt[kt]=At,wt[Ft]=Dt,$t[Dt]=Ft,$t[At]=kt},Mt=function(){var Dt=new _e;vt<rt&&(xt.push(lt.length),lt.push(1),dt.push(vt)),yt.push(ft.length);var At=ct[vt],kt=ct[vt+1];for(Nt=At;Nt<kt;Nt++)Et=ot[Nt],Dt.set(wt[Et],st[Nt]);vt>0&&Dt.forEach(0,vt-1,function(Wt,Ut){j._forEachRow(Wt,lt,dt,xt,function(Rt,un){Rt>Wt&&Dt.accumulate(Rt,b(d(un,Ut)))})});var Ft=vt,Bt=Dt.get(vt),Ht=s(Bt);Dt.forEach(vt+1,rt-1,function(Wt,Ut){var Rt=s(Ut);g(Rt,Ht)&&(Ft=Wt,Ht=Rt,Bt=Ut)}),vt!==Ft&&(j._swapRows(vt,Ft,ut[1],lt,dt,xt),j._swapRows(vt,Ft,St[1],ft,mt,yt),Dt.swap(vt,Ft),Ct(vt,Ft)),Dt.forEach(0,rt-1,function(Wt,Ut){Wt<=vt?(ft.push(Ut),mt.push(Wt)):(Ut=c(Ut,Bt),_(Ut,0)||(lt.push(Ut),dt.push(Wt)))})};for(vt=0;vt<it;vt++)Mt();return yt.push(ft.length),xt.push(lt.length),{L:new j({values:lt,index:dt,ptr:xt,size:ut}),U:new j({values:ft,index:mt,ptr:yt,size:St}),p:wt,toString:function(){return"L: "+this.L.toString()+`
U: `+this.U.toString()+`
P: `+this.p}}}}),name$4="qr",dependencies$4=["typed","matrix","zeros","identity","isZero","equal","sign","sqrt","conj","unaryMinus","addScalar","divideScalar","multiplyScalar","subtract","complex"],createQr=factory$1(name$4,dependencies$4,a=>{var{typed:e,matrix:i,zeros:s,identity:o,isZero:c,equal:d,sign:h,sqrt:g,conj:_,unaryMinus:b,addScalar:$,divideScalar:j,multiplyScalar:_e,subtract:tt,complex:et}=a;return _extends(e(name$4,{DenseMatrix:function(st){return rt(st)},SparseMatrix:function(st){return it()},Array:function(st){var ot=i(st),ct=rt(ot);return{Q:ct.Q.valueOf(),R:ct.R.valueOf()}}}),{_denseQRimpl:nt});function nt(at){var st=at._size[0],ot=at._size[1],ct=o([st],"dense"),lt=ct._data,dt=at.clone(),xt=dt._data,ut,ft,mt,yt=s([st],"");for(mt=0;mt<Math.min(ot,st);++mt){var St=xt[mt][mt],Et=b(d(St,0)?1:h(St)),vt=_(Et),Nt=0;for(ut=mt;ut<st;ut++)Nt=$(Nt,_e(xt[ut][mt],_(xt[ut][mt])));var wt=_e(Et,g(Nt));if(!c(wt)){var $t=tt(St,wt);for(yt[mt]=1,ut=mt+1;ut<st;ut++)yt[ut]=j(xt[ut][mt],$t);var Ct=b(_(j($t,wt))),Mt=void 0;for(ft=mt;ft<ot;ft++){for(Mt=0,ut=mt;ut<st;ut++)Mt=$(Mt,_e(_(yt[ut]),xt[ut][ft]));for(Mt=_e(Mt,Ct),ut=mt;ut<st;ut++)xt[ut][ft]=_e(tt(xt[ut][ft],_e(yt[ut],Mt)),vt)}for(ut=0;ut<st;ut++){for(Mt=0,ft=mt;ft<st;ft++)Mt=$(Mt,_e(lt[ut][ft],yt[ft]));for(Mt=_e(Mt,Ct),ft=mt;ft<st;++ft)lt[ut][ft]=j(tt(lt[ut][ft],_e(Mt,_(yt[ft]))),vt)}}}return{Q:ct,R:dt,toString:function(){return"Q: "+this.Q.toString()+`
R: `+this.R.toString()}}}function rt(at){var st=nt(at),ot=st.R._data;if(at._data.length>0)for(var ct=ot[0][0].type==="Complex"?et(0):0,lt=0;lt<ot.length;++lt)for(var dt=0;dt<lt&&dt<(ot[0]||[]).length;++dt)ot[lt][dt]=ct;return st}function it(at){throw new Error("qr not implemented for sparse matrices yet")}}),name$3="det",dependencies$3=["typed","matrix","subtract","multiply","unaryMinus","lup"],createDet=factory$1(name$3,dependencies$3,a=>{var{typed:e,matrix:i,subtract:s,multiply:o,unaryMinus:c,lup:d}=a;return e(name$3,{any:function(_){return clone$1(_)},"Array | Matrix":function(_){var b;switch(isMatrix(_)?b=_.size():Array.isArray(_)?(_=i(_),b=_.size()):b=[],b.length){case 0:return clone$1(_);case 1:if(b[0]===1)return clone$1(_.valueOf()[0]);throw new RangeError("Matrix must be square (size: "+format(b)+")");case 2:{var $=b[0],j=b[1];if($===j)return h(_.clone().valueOf(),$);throw new RangeError("Matrix must be square (size: "+format(b)+")")}default:throw new RangeError("Matrix must be two dimensional (size: "+format(b)+")")}}});function h(g,_,b){if(_===1)return clone$1(g[0][0]);if(_===2)return s(o(g[0][0],g[1][1]),o(g[1][0],g[0][1]));for(var $=d(g),j=$.U[0][0],_e=1;_e<_;_e++)j=o(j,$.U[_e][_e]);for(var tt=0,et=0,nt=[];;){for(;nt[et];)et++;if(et>=_)break;for(var rt=et,it=0;!nt[$.p[rt]];)nt[$.p[rt]]=!0,rt=$.p[rt],it++;it%2===0&&tt++}return tt%2===0?j:c(j)}}),name$2="inv",dependencies$2=["typed","matrix","divideScalar","addScalar","multiply","unaryMinus","det","identity","abs"],createInv=factory$1(name$2,dependencies$2,a=>{var{typed:e,matrix:i,divideScalar:s,addScalar:o,multiply:c,unaryMinus:d,det:h,identity:g,abs:_}=a;return e(name$2,{"Array | Matrix":function(j){var _e=isMatrix(j)?j.size():arraySize(j);switch(_e.length){case 1:if(_e[0]===1)return isMatrix(j)?i([s(1,j.valueOf()[0])]):[s(1,j[0])];throw new RangeError("Matrix must be square (size: "+format(_e)+")");case 2:{var tt=_e[0],et=_e[1];if(tt===et)return isMatrix(j)?i(b(j.valueOf(),tt,et),j.storage()):b(j,tt,et);throw new RangeError("Matrix must be square (size: "+format(_e)+")")}default:throw new RangeError("Matrix must be two dimensional (size: "+format(_e)+")")}},any:function(j){return s(1,j)}});function b($,j,_e){var tt,et,nt,rt,it;if(j===1){if(rt=$[0][0],rt===0)throw Error("Cannot calculate inverse, determinant is zero");return[[s(1,rt)]]}else if(j===2){var at=h($);if(at===0)throw Error("Cannot calculate inverse, determinant is zero");return[[s($[1][1],at),s(d($[0][1]),at)],[s(d($[1][0]),at),s($[0][0],at)]]}else{var st=$.concat();for(tt=0;tt<j;tt++)st[tt]=st[tt].concat();for(var ot=g(j).valueOf(),ct=0;ct<_e;ct++){var lt=_(st[ct][ct]),dt=ct;for(tt=ct+1;tt<j;)_(st[tt][ct])>lt&&(lt=_(st[tt][ct]),dt=tt),tt++;if(lt===0)throw Error("Cannot calculate inverse, determinant is zero");tt=dt,tt!==ct&&(it=st[ct],st[ct]=st[tt],st[tt]=it,it=ot[ct],ot[ct]=ot[tt],ot[tt]=it);var xt=st[ct],ut=ot[ct];for(tt=0;tt<j;tt++){var ft=st[tt],mt=ot[tt];if(tt!==ct){if(ft[ct]!==0){for(nt=s(d(ft[ct]),xt[ct]),et=ct;et<_e;et++)ft[et]=o(ft[et],c(nt,xt[et]));for(et=0;et<_e;et++)mt[et]=o(mt[et],c(nt,ut[et]))}}else{for(nt=xt[ct],et=ct;et<_e;et++)ft[et]=s(ft[et],nt);for(et=0;et<_e;et++)mt[et]=s(mt[et],nt)}}}return ot}}});function createComplexEigs(a){var{addScalar:e,subtract:i,flatten:s,multiply:o,multiplyScalar:c,divideScalar:d,sqrt:h,abs:g,bignumber:_,diag:b,inv:$,qr:j,usolve:_e,usolveAll:tt,equal:et,complex:nt,larger:rt,smaller:it,matrixFromColumns:at,dot:st}=a;function ot(Ct,Mt,Ot,Dt,At){At===void 0&&(At=!0);var kt=ct(Ct,Mt,Ot,Dt,At);lt(Ct,Mt,Ot,Dt,At,kt);var{values:Ft,C:Bt}=dt(Ct,Mt,Ot,Dt,At);Bt=o($(kt),Bt);var Ht;return At&&(Ht=xt(Ct,Mt,Bt,Ft,Ot,Dt),Ht=at(...Ht)),{values:Ft,vectors:Ht}}function ct(Ct,Mt,Ot,Dt,At){var kt=Dt==="BigNumber",Ft=Dt==="Complex",Bt=kt?_(0):Ft?nt(0):0,Ht=kt?_(1):Ft?nt(1):1,Wt=kt?_(10):2,Ut=c(Wt,Wt),Rt;At&&(Rt=Array(Mt).fill(Ht));for(var un=!1;!un;){un=!0;for(var rn=0;rn<Mt;rn++){for(var mn=Bt,sn=Bt,hn=0;hn<Mt;hn++)if(rn!==hn){var gn=g(Ct[rn][hn]);mn=e(mn,gn),sn=e(sn,gn)}if(!et(mn,0)&&!et(sn,0)){for(var Xt=Ht,En=mn,bt=d(sn,Wt),gt=c(sn,Wt);it(En,bt);)En=c(En,Ut),Xt=c(Xt,Wt);for(;rt(En,gt);)En=d(En,Ut),Xt=d(Xt,Wt);var Pt=it(d(e(En,sn),Xt),c(e(mn,sn),.95));if(Pt){un=!1;for(var Lt=d(1,Xt),Vt=0;Vt<Mt;Vt++)rn!==Vt&&(Ct[rn][Vt]=c(Ct[rn][Vt],Xt),Ct[Vt][rn]=c(Ct[Vt][rn],Lt));At&&(Rt[rn]=c(Rt[rn],Xt))}}}}return b(Rt)}function lt(Ct,Mt,Ot,Dt,At,kt){var Ft=Dt==="BigNumber",Bt=Dt==="Complex",Ht=Ft?_(0):Bt?nt(0):0;Ft&&(Ot=_(Ot));for(var Wt=0;Wt<Mt-2;Wt++){for(var Ut=0,Rt=Ht,un=Wt+1;un<Mt;un++){var rn=Ct[un][Wt];it(g(Rt),g(rn))&&(Rt=rn,Ut=un)}if(!it(g(Rt),Ot)){if(Ut!==Wt+1){var mn=Ct[Ut];Ct[Ut]=Ct[Wt+1],Ct[Wt+1]=mn;for(var sn=0;sn<Mt;sn++){var hn=Ct[sn][Ut];Ct[sn][Ut]=Ct[sn][Wt+1],Ct[sn][Wt+1]=hn}if(At){var gn=kt[Ut];kt[Ut]=kt[Wt+1],kt[Wt+1]=gn}}for(var Xt=Wt+2;Xt<Mt;Xt++){var En=d(Ct[Xt][Wt],Rt);if(En!==0){for(var bt=0;bt<Mt;bt++)Ct[Xt][bt]=i(Ct[Xt][bt],c(En,Ct[Wt+1][bt]));for(var gt=0;gt<Mt;gt++)Ct[gt][Wt+1]=e(Ct[gt][Wt+1],c(En,Ct[gt][Xt]));if(At)for(var Pt=0;Pt<Mt;Pt++)kt[Xt][Pt]=i(kt[Xt][Pt],c(En,kt[Wt+1][Pt]))}}}}return kt}function dt(Ct,Mt,Ot,Dt,At){var kt=Dt==="BigNumber",Ft=Dt==="Complex",Bt=kt?_(1):Ft?nt(1):1;kt&&(Ot=_(Ot));for(var Ht=clone$1(Ct),Wt=[],Ut=Mt,Rt=[],un=At?b(Array(Mt).fill(Bt)):void 0,rn=At?b(Array(Ut).fill(Bt)):void 0,mn=0;mn<=100;){mn+=1;for(var sn=0,hn=0;hn<Ut;hn++)Ht[hn][hn]=i(Ht[hn][hn],sn);var{Q:gn,R:Xt}=j(Ht);Ht=o(Xt,gn);for(var En=0;En<Ut;En++)Ht[En][En]=e(Ht[En][En],sn);if(At&&(rn=o(rn,gn)),Ut===1||it(g(Ht[Ut-1][Ut-2]),Ot)){mn=0,Wt.push(Ht[Ut-1][Ut-1]),At&&(Rt.unshift([[1]]),mt(rn,Mt),un=o(un,rn),Ut>1&&(rn=b(Array(Ut-1).fill(Bt)))),Ut-=1,Ht.pop();for(var bt=0;bt<Ut;bt++)Ht[bt].pop()}else if(Ut===2||it(g(Ht[Ut-2][Ut-3]),Ot)){mn=0;var gt=ut(Ht[Ut-2][Ut-2],Ht[Ut-2][Ut-1],Ht[Ut-1][Ut-2],Ht[Ut-1][Ut-1]);Wt.push(...gt),At&&(Rt.unshift(ft(Ht[Ut-2][Ut-2],Ht[Ut-2][Ut-1],Ht[Ut-1][Ut-2],Ht[Ut-1][Ut-1],gt[0],gt[1],Ot,Dt)),mt(rn,Mt),un=o(un,rn),Ut>2&&(rn=b(Array(Ut-2).fill(Bt)))),Ut-=2,Ht.pop(),Ht.pop();for(var Pt=0;Pt<Ut;Pt++)Ht[Pt].pop(),Ht[Pt].pop()}if(Ut===0)break}if(Wt.sort((jt,cn)=>+i(g(jt),g(cn))),mn>100){var Lt=Error("The eigenvalues failed to converge. Only found these eigenvalues: "+Wt.join(", "));throw Lt.values=Wt,Lt.vectors=[],Lt}var Vt=At?o(un,yt(Rt,Mt)):void 0;return{values:Wt,C:Vt}}function xt(Ct,Mt,Ot,Dt,At,kt){var Ft=$(Ot),Bt=o(Ft,Ct,Ot),Ht=kt==="BigNumber",Wt=kt==="Complex",Ut=Ht?_(0):Wt?nt(0):0,Rt=Ht?_(1):Wt?nt(1):1,un=[],rn=[];for(var mn of Dt){var sn=St(un,mn,et);sn===-1?(un.push(mn),rn.push(1)):rn[sn]+=1}for(var hn=[],gn=un.length,Xt=Array(Mt).fill(Ut),En=b(Array(Mt).fill(Rt)),bt=[],gt=0;gt<gn;gt++){var Pt=un[gt],Lt=i(Bt,o(Pt,En)),Vt=tt(Lt,Xt);for(Vt=Vt.map(en=>o(Ot,en)),Vt.shift();Vt.length<rn[gt];){var jt=Et(Lt,Mt,Vt,At,kt);if(jt==null){bt.push(Pt);break}Vt.push(jt)}hn.push(...Vt.map(en=>s(en)))}if(bt.length!==0){var cn=new Error("Failed to find eigenvectors for the following eigenvalues: "+bt.join(", "));throw cn.values=Dt,cn.vectors=hn,cn}return hn}function ut(Ct,Mt,Ot,Dt){var At=e(Ct,Dt),kt=i(c(Ct,Dt),c(Mt,Ot)),Ft=c(At,.5),Bt=c(h(i(c(At,At),c(4,kt))),.5);return[e(Ft,Bt),i(Ft,Bt)]}function ft(Ct,Mt,Ot,Dt,At,kt,Ft,Bt){var Ht=Bt==="BigNumber",Wt=Bt==="Complex",Ut=Ht?_(0):Wt?nt(0):0,Rt=Ht?_(1):Wt?nt(1):1;if(it(g(Ot),Ft))return[[Rt,Ut],[Ut,Rt]];if(rt(g(i(At,kt)),Ft))return[[i(At,Dt),i(kt,Dt)],[Ot,Ot]];var un=i(Ct,At),rn=i(Mt,At),mn=i(Ot,At),sn=i(Dt,At);return it(g(rn),Ft)?[[un,Rt],[mn,Ut]]:[[rn,Ut],[sn,Rt]]}function mt(Ct,Mt){for(var Ot=0;Ot<Ct.length;Ot++)Ct[Ot].push(...Array(Mt-Ct[Ot].length).fill(0));for(var Dt=Ct.length;Dt<Mt;Dt++)Ct.push(Array(Mt).fill(0)),Ct[Dt][Dt]=1;return Ct}function yt(Ct,Mt){for(var Ot=[],Dt=0;Dt<Mt;Dt++)Ot[Dt]=Array(Mt).fill(0);var At=0;for(var kt of Ct){for(var Ft=kt.length,Bt=0;Bt<Ft;Bt++)for(var Ht=0;Ht<Ft;Ht++)Ot[At+Bt][At+Ht]=kt[Bt][Ht];At+=Ft}return Ot}function St(Ct,Mt,Ot){for(var Dt=0;Dt<Ct.length;Dt++)if(Ot(Ct[Dt],Mt))return Dt;return-1}function Et(Ct,Mt,Ot,Dt,At){for(var kt=At==="BigNumber"?_(1e3):1e3,Ft,Bt=0;Ft=vt(Mt,Ot,At),Ft=_e(Ct,Ft),!rt(wt(Ft),kt);)if(++Bt>=5)return null;for(Bt=0;;){var Ht=_e(Ct,Ft);if(it(wt(Nt(Ft,[Ht])),Dt))break;if(++Bt>=10)return null;Ft=$t(Ht)}return Ft}function vt(Ct,Mt,Ot){var Dt=Ot==="BigNumber",At=Ot==="Complex",kt=Array(Ct).fill(0).map(Ft=>2*Math.random()-1);return Dt&&(kt=kt.map(Ft=>_(Ft))),At&&(kt=kt.map(Ft=>nt(Ft))),kt=Nt(kt,Mt),$t(kt,Ot)}function Nt(Ct,Mt){for(var Ot of Mt)Ct=i(Ct,o(d(st(Ot,Ct),st(Ot,Ot)),Ot));return Ct}function wt(Ct){return g(h(st(Ct,Ct)))}function $t(Ct,Mt){var Ot=Mt==="BigNumber",Dt=Mt==="Complex",At=Ot?_(1):Dt?nt(1):1;return o(d(At,wt(Ct)),Ct)}return ot}function createRealSymmetric(a){var{config:e,addScalar:i,subtract:s,abs:o,atan:c,cos:d,sin:h,multiplyScalar:g,inv:_,bignumber:b,multiply:$,add:j}=a;function _e(ut,ft){var mt=arguments.length>2&&arguments[2]!==void 0?arguments[2]:e.epsilon,yt=arguments.length>3?arguments[3]:void 0;if(yt==="number")return tt(ut,mt);if(yt==="BigNumber")return et(ut,mt);throw TypeError("Unsupported data type: "+yt)}function tt(ut,ft){for(var mt=ut.length,yt=Math.abs(ft/mt),St,Et=new Array(mt),vt=0;vt<mt;vt++)Et[vt]=xt(mt,0),Et[vt][vt]=1;for(var Nt=ct(ut);Math.abs(Nt[1])>=Math.abs(yt);){var wt=Nt[0][0],$t=Nt[0][1];St=nt(ut[wt][wt],ut[$t][$t],ut[wt][$t]),ut=ot(ut,St,wt,$t),Et=it(Et,St,wt,$t),Nt=ct(ut)}for(var Ct=xt(mt,0),Mt=0;Mt<mt;Mt++)Ct[Mt]=ut[Mt][Mt];return dt(clone$1(Ct),clone$1(Et))}function et(ut,ft){for(var mt=ut.length,yt=o(ft/mt),St,Et=new Array(mt),vt=0;vt<mt;vt++)Et[vt]=xt(mt,0),Et[vt][vt]=1;for(var Nt=lt(ut);o(Nt[1])>=o(yt);){var wt=Nt[0][0],$t=Nt[0][1];St=rt(ut[wt][wt],ut[$t][$t],ut[wt][$t]),ut=st(ut,St,wt,$t),Et=at(Et,St,wt,$t),Nt=lt(ut)}for(var Ct=xt(mt,0),Mt=0;Mt<mt;Mt++)Ct[Mt]=ut[Mt][Mt];return dt(clone$1(Ct),clone$1(Et))}function nt(ut,ft,mt){var yt=ft-ut;return Math.abs(yt)<=e.epsilon?Math.PI/4:.5*Math.atan(2*mt/(ft-ut))}function rt(ut,ft,mt){var yt=s(ft,ut);return o(yt)<=e.epsilon?b(-1).acos().div(4):g(.5,c($(2,mt,_(yt))))}function it(ut,ft,mt,yt){for(var St=ut.length,Et=Math.cos(ft),vt=Math.sin(ft),Nt=xt(St,0),wt=xt(St,0),$t=0;$t<St;$t++)Nt[$t]=Et*ut[$t][mt]-vt*ut[$t][yt],wt[$t]=vt*ut[$t][mt]+Et*ut[$t][yt];for(var Ct=0;Ct<St;Ct++)ut[Ct][mt]=Nt[Ct],ut[Ct][yt]=wt[Ct];return ut}function at(ut,ft,mt,yt){for(var St=ut.length,Et=d(ft),vt=h(ft),Nt=xt(St,b(0)),wt=xt(St,b(0)),$t=0;$t<St;$t++)Nt[$t]=s(g(Et,ut[$t][mt]),g(vt,ut[$t][yt])),wt[$t]=i(g(vt,ut[$t][mt]),g(Et,ut[$t][yt]));for(var Ct=0;Ct<St;Ct++)ut[Ct][mt]=Nt[Ct],ut[Ct][yt]=wt[Ct];return ut}function st(ut,ft,mt,yt){for(var St=ut.length,Et=b(d(ft)),vt=b(h(ft)),Nt=g(Et,Et),wt=g(vt,vt),$t=xt(St,b(0)),Ct=xt(St,b(0)),Mt=$(b(2),Et,vt,ut[mt][yt]),Ot=i(s(g(Nt,ut[mt][mt]),Mt),g(wt,ut[yt][yt])),Dt=j(g(wt,ut[mt][mt]),Mt,g(Nt,ut[yt][yt])),At=0;At<St;At++)$t[At]=s(g(Et,ut[mt][At]),g(vt,ut[yt][At])),Ct[At]=i(g(vt,ut[mt][At]),g(Et,ut[yt][At]));ut[mt][mt]=Ot,ut[yt][yt]=Dt,ut[mt][yt]=b(0),ut[yt][mt]=b(0);for(var kt=0;kt<St;kt++)kt!==mt&&kt!==yt&&(ut[mt][kt]=$t[kt],ut[kt][mt]=$t[kt],ut[yt][kt]=Ct[kt],ut[kt][yt]=Ct[kt]);return ut}function ot(ut,ft,mt,yt){for(var St=ut.length,Et=Math.cos(ft),vt=Math.sin(ft),Nt=Et*Et,wt=vt*vt,$t=xt(St,0),Ct=xt(St,0),Mt=Nt*ut[mt][mt]-2*Et*vt*ut[mt][yt]+wt*ut[yt][yt],Ot=wt*ut[mt][mt]+2*Et*vt*ut[mt][yt]+Nt*ut[yt][yt],Dt=0;Dt<St;Dt++)$t[Dt]=Et*ut[mt][Dt]-vt*ut[yt][Dt],Ct[Dt]=vt*ut[mt][Dt]+Et*ut[yt][Dt];ut[mt][mt]=Mt,ut[yt][yt]=Ot,ut[mt][yt]=0,ut[yt][mt]=0;for(var At=0;At<St;At++)At!==mt&&At!==yt&&(ut[mt][At]=$t[At],ut[At][mt]=$t[At],ut[yt][At]=Ct[At],ut[At][yt]=Ct[At]);return ut}function ct(ut){for(var ft=ut.length,mt=0,yt=[0,1],St=0;St<ft;St++)for(var Et=St+1;Et<ft;Et++)Math.abs(mt)<Math.abs(ut[St][Et])&&(mt=Math.abs(ut[St][Et]),yt=[St,Et]);return[yt,mt]}function lt(ut){for(var ft=ut.length,mt=0,yt=[0,1],St=0;St<ft;St++)for(var Et=St+1;Et<ft;Et++)o(mt)<o(ut[St][Et])&&(mt=o(ut[St][Et]),yt=[St,Et]);return[yt,mt]}function dt(ut,ft){for(var mt=ut.length,yt=Array(mt),St=Array(mt),Et=0;Et<mt;Et++)St[Et]=Array(mt);for(var vt=0;vt<mt;vt++){for(var Nt=0,wt=ut[0],$t=0;$t<ut.length;$t++)o(ut[$t])<o(wt)&&(Nt=$t,wt=ut[Nt]);yt[vt]=ut.splice(Nt,1)[0];for(var Ct=0;Ct<mt;Ct++)St[Ct][vt]=ft[Ct][Nt],ft[Ct].splice(Nt,1)}return{values:yt,vectors:St}}function xt(ut,ft){for(var mt=new Array(ut),yt=0;yt<ut;yt++)mt[yt]=ft;return mt}return _e}var name$1="eigs",dependencies$1=["config","typed","matrix","addScalar","equal","subtract","abs","atan","cos","sin","multiplyScalar","divideScalar","inv","bignumber","multiply","add","larger","column","flatten","number","complex","sqrt","diag","qr","usolve","usolveAll","im","re","smaller","matrixFromColumns","dot"],createEigs=factory$1(name$1,dependencies$1,a=>{var{config:e,typed:i,matrix:s,addScalar:o,subtract:c,equal:d,abs:h,atan:g,cos:_,sin:b,multiplyScalar:$,divideScalar:j,inv:_e,bignumber:tt,multiply:et,add:nt,larger:rt,column:it,flatten:at,number:st,complex:ot,sqrt:ct,diag:lt,qr:dt,usolve:xt,usolveAll:ut,im:ft,re:mt,smaller:yt,matrixFromColumns:St,dot:Et}=a,vt=createRealSymmetric({config:e,addScalar:o,subtract:c,column:it,flatten:at,equal:d,abs:h,atan:g,cos:_,sin:b,multiplyScalar:$,inv:_e,bignumber:tt,complex:ot,multiply:et,add:nt}),Nt=createComplexEigs({config:e,addScalar:o,subtract:c,multiply:et,multiplyScalar:$,flatten:at,divideScalar:j,sqrt:ct,abs:h,bignumber:tt,diag:lt,qr:dt,inv:_e,usolve:xt,usolveAll:ut,equal:d,complex:ot,larger:rt,smaller:yt,matrixFromColumns:St,dot:Et});return i("eigs",{Array:function(At){var kt=s(At);return wt(kt)},"Array, number|BigNumber":function(At,kt){var Ft=s(At);return wt(Ft,kt)},Matrix:function(At){var{values:kt,vectors:Ft}=wt(At);return{values:s(kt),vectors:s(Ft)}},"Matrix, number|BigNumber":function(At,kt){var{values:Ft,vectors:Bt}=wt(At,kt);return{values:s(Ft),vectors:s(Bt)}}});function wt(Dt,At){At===void 0&&(At=e.epsilon);var kt=Dt.size();if(kt.length!==2||kt[0]!==kt[1])throw new RangeError("Matrix must be square (size: "+format(kt)+")");var Ft=Dt.toArray(),Bt=kt[0];if(Ct(Ft,Bt,At)&&(Mt(Ft,Bt),$t(Ft,Bt,At))){var Ht=Ot(Dt,Ft,Bt);return vt(Ft,Bt,At,Ht)}var Wt=Ot(Dt,Ft,Bt);return Nt(Ft,Bt,At,Wt)}function $t(Dt,At,kt){for(var Ft=0;Ft<At;Ft++)for(var Bt=Ft;Bt<At;Bt++)if(rt(tt(h(c(Dt[Ft][Bt],Dt[Bt][Ft]))),kt))return!1;return!0}function Ct(Dt,At,kt){for(var Ft=0;Ft<At;Ft++)for(var Bt=0;Bt<At;Bt++)if(rt(tt(h(ft(Dt[Ft][Bt]))),kt))return!1;return!0}function Mt(Dt,At){for(var kt=0;kt<At;kt++)for(var Ft=0;Ft<At;Ft++)Dt[kt][Ft]=mt(Dt[kt][Ft])}function Ot(Dt,At,kt){var Ft=Dt.datatype();if(Ft==="number"||Ft==="BigNumber"||Ft==="Complex")return Ft;for(var Bt=!1,Ht=!1,Wt=!1,Ut=0;Ut<kt;Ut++)for(var Rt=0;Rt<kt;Rt++){var un=At[Ut][Rt];if(isNumber(un)||isFraction(un))Bt=!0;else if(isBigNumber(un))Ht=!0;else if(isComplex(un))Wt=!0;else throw TypeError("Unsupported type in Matrix: "+typeOf(un))}if(Ht&&Wt&&console.warn("Complex BigNumbers not supported, this operation will lose precission."),Wt){for(var rn=0;rn<kt;rn++)for(var mn=0;mn<kt;mn++)At[rn][mn]=ot(At[rn][mn]);return"Complex"}if(Ht){for(var sn=0;sn<kt;sn++)for(var hn=0;hn<kt;hn++)At[sn][hn]=tt(At[sn][hn]);return"BigNumber"}if(Bt){for(var gn=0;gn<kt;gn++)for(var Xt=0;Xt<kt;Xt++)At[gn][Xt]=st(At[gn][Xt]);return"number"}else throw TypeError("Matrix contains unsupported types only.")}}),name="divide",dependencies=["typed","matrix","multiply","equalScalar","divideScalar","inv"],createDivide=factory$1(name,dependencies,a=>{var{typed:e,matrix:i,multiply:s,equalScalar:o,divideScalar:c,inv:d}=a,h=createAlgorithm11({typed:e,equalScalar:o}),g=createAlgorithm14({typed:e});return e("divide",extend({"Array | Matrix, Array | Matrix":function(b,$){return s(b,d($))},"DenseMatrix, any":function(b,$){return g(b,$,c,!1)},"SparseMatrix, any":function(b,$){return h(b,$,c,!1)},"Array, any":function(b,$){return g(i(b),$,c,!1).valueOf()},"any, Array | Matrix":function(b,$){return s(b,d($))}},c.signatures))}),BigNumber=createBigNumberClass({config:config$2}),Complex=createComplexClass({}),Fraction=createFractionClass({}),Matrix=createMatrixClass({}),DenseMatrix=createDenseMatrixClass({Matrix}),typed=createTyped({BigNumber,Complex,DenseMatrix,Fraction}),abs=createAbs({typed}),addScalar=createAddScalar({typed}),atan=createAtan({typed}),bignumber=createBignumber({BigNumber,typed}),complex=createComplex({Complex,typed}),conj=createConj({typed}),equalScalar=createEqualScalar({config:config$2,typed}),im=createIm({typed}),isZero=createIsZero({typed}),multiplyScalar=createMultiplyScalar({typed}),number=createNumber({typed}),re=createRe({typed}),sign=createSign({BigNumber,Fraction,complex,typed}),sin=createSin({typed}),SparseMatrix=createSparseMatrixClass({Matrix,equalScalar,typed}),cos=createCos({typed}),sqrt=createSqrt({Complex,config:config$2,typed}),unaryMinus=createUnaryMinus({typed}),fraction=createFraction({Fraction,typed}),matrix=createMatrix({DenseMatrix,Matrix,SparseMatrix,typed}),numeric=createNumeric({bignumber,fraction,number}),size=createSize({matrix,config:config$2,typed}),smaller=createSmaller({DenseMatrix,config:config$2,matrix,typed}),subtract=createSubtract({DenseMatrix,addScalar,equalScalar,matrix,typed,unaryMinus}),transpose=createTranspose({matrix,typed}),zeros=createZeros({BigNumber,config:config$2,matrix,typed}),ctranspose=createCtranspose({conj,transpose,typed}),diag=createDiag({DenseMatrix,SparseMatrix,matrix,typed}),divideScalar=createDivideScalar({numeric,typed}),equal=createEqual({DenseMatrix,equalScalar,matrix,typed}),flatten=createFlatten({matrix,typed}),ImmutableDenseMatrix=createImmutableDenseMatrixClass({DenseMatrix,smaller}),Index=createIndexClass({ImmutableDenseMatrix}),largerEq=createLargerEq({DenseMatrix,config:config$2,matrix,typed}),matrixFromColumns=createMatrixFromColumns({flatten,matrix,size,typed}),smallerEq=createSmallerEq({DenseMatrix,config:config$2,matrix,typed}),usolve=createUsolve({DenseMatrix,divideScalar,equalScalar,matrix,multiplyScalar,subtract,typed}),add=createAdd({DenseMatrix,SparseMatrix,addScalar,equalScalar,matrix,typed}),dot=createDot({addScalar,conj,multiplyScalar,size,typed}),identity=createIdentity({BigNumber,DenseMatrix,SparseMatrix,config:config$2,matrix,typed}),larger=createLarger({DenseMatrix,config:config$2,matrix,typed}),multiply=createMultiply({addScalar,dot,equalScalar,matrix,multiplyScalar,typed}),pow=createPow({Complex,config:config$2,fraction,identity,matrix,multiply,number,typed}),qr=createQr({addScalar,complex,conj,divideScalar,equal,identity,isZero,matrix,multiplyScalar,sign,sqrt,subtract,typed,unaryMinus,zeros}),range=createRange({bignumber,matrix,config:config$2,larger,largerEq,smaller,smallerEq,typed}),usolveAll=createUsolveAll({DenseMatrix,divideScalar,equalScalar,matrix,multiplyScalar,subtract,typed}),column=createColumn({Index,matrix,range,typed}),cross=createCross({matrix,multiply,subtract,typed}),FibonacciHeap=createFibonacciHeapClass({larger,smaller}),Spa=createSpaClass({FibonacciHeap,addScalar,equalScalar}),lup=createLup({DenseMatrix,Spa,SparseMatrix,abs,addScalar,divideScalar,equalScalar,larger,matrix,multiplyScalar,subtract,typed,unaryMinus}),det=createDet({lup,matrix,multiply,subtract,typed,unaryMinus}),inv=createInv({abs,addScalar,det,divideScalar,identity,matrix,multiply,typed,unaryMinus}),divide=createDivide({divideScalar,equalScalar,inv,matrix,multiply,typed}),eigs=createEigs({abs,add,addScalar,atan,bignumber,column,complex,config:config$2,cos,diag,divideScalar,dot,equal,flatten,im,inv,larger,matrix,matrixFromColumns,multiply,multiplyScalar,number,qr,re,sin,smaller,sqrt,subtract,typed,usolve,usolveAll}),norm=createNorm({abs,add,conj,ctranspose,eigs,equalScalar,larger,matrix,multiply,pow,smaller,sqrt,typed}),NEWTON_ITERATIONS=4,NEWTON_MIN_SLOPE=.001,SUBDIVISION_PRECISION=1e-7,SUBDIVISION_MAX_ITERATIONS=10,kSplineTableSize=11,kSampleStepSize=1/(kSplineTableSize-1),float32ArraySupported=typeof Float32Array=="function";function A(a,e){return 1-3*e+3*a}function B(a,e){return 3*e-6*a}function C(a){return 3*a}function calcBezier(a,e,i){return((A(e,i)*a+B(e,i))*a+C(e))*a}function getSlope(a,e,i){return 3*A(e,i)*a*a+2*B(e,i)*a+C(e)}function binarySubdivide(a,e,i,s,o){var c,d,h=0;do d=e+(i-e)/2,c=calcBezier(d,s,o)-a,c>0?i=d:e=d;while(Math.abs(c)>SUBDIVISION_PRECISION&&++h<SUBDIVISION_MAX_ITERATIONS);return d}function newtonRaphsonIterate(a,e,i,s){for(var o=0;o<NEWTON_ITERATIONS;++o){var c=getSlope(e,i,s);if(c===0)return e;var d=calcBezier(e,i,s)-a;e-=d/c}return e}function LinearEasing(a){return a}var src=function(e,i,s,o){if(!(0<=e&&e<=1&&0<=s&&s<=1))throw new Error("bezier x values must be in [0, 1] range");if(e===i&&s===o)return LinearEasing;for(var c=float32ArraySupported?new Float32Array(kSplineTableSize):new Array(kSplineTableSize),d=0;d<kSplineTableSize;++d)c[d]=calcBezier(d*kSampleStepSize,e,s);function h(g){for(var _=0,b=1,$=kSplineTableSize-1;b!==$&&c[b]<=g;++b)_+=kSampleStepSize;--b;var j=(g-c[b])/(c[b+1]-c[b]),_e=_+j*kSampleStepSize,tt=getSlope(_e,e,s);return tt>=NEWTON_MIN_SLOPE?newtonRaphsonIterate(g,_e,e,s):tt===0?_e:binarySubdivide(g,_,_+kSampleStepSize,e,s)}return function(_){return _===0?0:_===1?1:calcBezier(h(_),i,o)}};const a1_0x2514d1=getDefaultExportFromCjs$1(src);var face_mesh={};(function(){var a;function e(ht){var pt=0;return function(){return pt<ht.length?{done:!1,value:ht[pt++]}:{done:!0}}}var i=typeof Object.defineProperties=="function"?Object.defineProperty:function(ht,pt,_t){return ht==Array.prototype||ht==Object.prototype||(ht[pt]=_t.value),ht};function s(ht){ht=[typeof globalThis=="object"&&globalThis,ht,typeof window=="object"&&window,typeof self=="object"&&self,typeof commonjsGlobal$1=="object"&&commonjsGlobal$1];for(var pt=0;pt<ht.length;++pt){var _t=ht[pt];if(_t&&_t.Math==Math)return _t}throw Error("Cannot find global object")}var o=s(this);function c(ht,pt){if(pt)e:{var _t=o;ht=ht.split(".");for(var zt=0;zt<ht.length-1;zt++){var Kt=ht[zt];if(!(Kt in _t))break e;_t=_t[Kt]}ht=ht[ht.length-1],zt=_t[ht],pt=pt(zt),pt!=zt&&pt!=null&&i(_t,ht,{configurable:!0,writable:!0,value:pt})}}c("Symbol",function(ht){function pt(xn){if(this instanceof pt)throw new TypeError("Symbol is not a constructor");return new _t(zt+(xn||"")+"_"+Kt++,xn)}function _t(xn,Qt){this.g=xn,i(this,"description",{configurable:!0,writable:!0,value:Qt})}if(ht)return ht;_t.prototype.toString=function(){return this.g};var zt="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",Kt=0;return pt}),c("Symbol.iterator",function(ht){if(ht)return ht;ht=Symbol("Symbol.iterator");for(var pt="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),_t=0;_t<pt.length;_t++){var zt=o[pt[_t]];typeof zt=="function"&&typeof zt.prototype[ht]!="function"&&i(zt.prototype,ht,{configurable:!0,writable:!0,value:function(){return d(e(this))}})}return ht});function d(ht){return ht={next:ht},ht[Symbol.iterator]=function(){return this},ht}function h(ht){var pt=typeof Symbol<"u"&&Symbol.iterator&&ht[Symbol.iterator];return pt?pt.call(ht):{next:e(ht)}}function g(ht){if(!(ht instanceof Array)){ht=h(ht);for(var pt,_t=[];!(pt=ht.next()).done;)_t.push(pt.value);ht=_t}return ht}var _=typeof Object.create=="function"?Object.create:function(ht){function pt(){}return pt.prototype=ht,new pt},b;if(typeof Object.setPrototypeOf=="function")b=Object.setPrototypeOf;else{var $;e:{var j={a:!0},_e={};try{_e.__proto__=j,$=_e.a;break e}catch{}$=!1}b=$?function(ht,pt){if(ht.__proto__=pt,ht.__proto__!==pt)throw new TypeError(ht+" is not extensible");return ht}:null}var tt=b;function et(ht,pt){if(ht.prototype=_(pt.prototype),ht.prototype.constructor=ht,tt)tt(ht,pt);else for(var _t in pt)if(_t!="prototype")if(Object.defineProperties){var zt=Object.getOwnPropertyDescriptor(pt,_t);zt&&Object.defineProperty(ht,_t,zt)}else ht[_t]=pt[_t];ht.ea=pt.prototype}function nt(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function rt(ht){if(ht.l)throw new TypeError("Generator is already running");ht.l=!0}nt.prototype.o=function(ht){this.h=ht};function it(ht,pt){ht.j={U:pt,V:!0},ht.g=ht.m||ht.s}nt.prototype.return=function(ht){this.j={return:ht},this.g=this.s};function at(ht,pt,_t){return ht.g=_t,{value:pt}}function st(ht){this.g=new nt,this.h=ht}function ot(ht,pt){rt(ht.g);var _t=ht.g.i;return _t?ct(ht,"return"in _t?_t.return:function(zt){return{value:zt,done:!0}},pt,ht.g.return):(ht.g.return(pt),lt(ht))}function ct(ht,pt,_t,zt){try{var Kt=pt.call(ht.g.i,_t);if(!(Kt instanceof Object))throw new TypeError("Iterator result "+Kt+" is not an object");if(!Kt.done)return ht.g.l=!1,Kt;var xn=Kt.value}catch(Qt){return ht.g.i=null,it(ht.g,Qt),lt(ht)}return ht.g.i=null,zt.call(ht.g,xn),lt(ht)}function lt(ht){for(;ht.g.g;)try{var pt=ht.h(ht.g);if(pt)return ht.g.l=!1,{value:pt.value,done:!1}}catch(_t){ht.g.h=void 0,it(ht.g,_t)}if(ht.g.l=!1,ht.g.j){if(pt=ht.g.j,ht.g.j=null,pt.V)throw pt.U;return{value:pt.return,done:!0}}return{value:void 0,done:!0}}function dt(ht){this.next=function(pt){return rt(ht.g),ht.g.i?pt=ct(ht,ht.g.i.next,pt,ht.g.o):(ht.g.o(pt),pt=lt(ht)),pt},this.throw=function(pt){return rt(ht.g),ht.g.i?pt=ct(ht,ht.g.i.throw,pt,ht.g.o):(it(ht.g,pt),pt=lt(ht)),pt},this.return=function(pt){return ot(ht,pt)},this[Symbol.iterator]=function(){return this}}function xt(ht,pt){return pt=new dt(new st(pt)),tt&&ht.prototype&&tt(pt,ht.prototype),pt}function ut(ht,pt){ht instanceof String&&(ht+="");var _t=0,zt=!1,Kt={next:function(){if(!zt&&_t<ht.length){var xn=_t++;return{value:pt(xn,ht[xn]),done:!1}}return zt=!0,{done:!0,value:void 0}}};return Kt[Symbol.iterator]=function(){return Kt},Kt}var ft=typeof Object.assign=="function"?Object.assign:function(ht,pt){for(var _t=1;_t<arguments.length;_t++){var zt=arguments[_t];if(zt)for(var Kt in zt)Object.prototype.hasOwnProperty.call(zt,Kt)&&(ht[Kt]=zt[Kt])}return ht};c("Object.assign",function(ht){return ht||ft}),c("Promise",function(ht){function pt(Qt){this.h=0,this.i=void 0,this.g=[],this.o=!1;var dn=this.j();try{Qt(dn.resolve,dn.reject)}catch(_n){dn.reject(_n)}}function _t(){this.g=null}function zt(Qt){return Qt instanceof pt?Qt:new pt(function(dn){dn(Qt)})}if(ht)return ht;_t.prototype.h=function(Qt){if(this.g==null){this.g=[];var dn=this;this.i(function(){dn.l()})}this.g.push(Qt)};var Kt=o.setTimeout;_t.prototype.i=function(Qt){Kt(Qt,0)},_t.prototype.l=function(){for(;this.g&&this.g.length;){var Qt=this.g;this.g=[];for(var dn=0;dn<Qt.length;++dn){var _n=Qt[dn];Qt[dn]=null;try{_n()}catch(An){this.j(An)}}}this.g=null},_t.prototype.j=function(Qt){this.i(function(){throw Qt})},pt.prototype.j=function(){function Qt(An){return function(zn){_n||(_n=!0,An.call(dn,zn))}}var dn=this,_n=!1;return{resolve:Qt(this.C),reject:Qt(this.l)}},pt.prototype.C=function(Qt){if(Qt===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(Qt instanceof pt)this.F(Qt);else{e:switch(typeof Qt){case"object":var dn=Qt!=null;break e;case"function":dn=!0;break e;default:dn=!1}dn?this.u(Qt):this.m(Qt)}},pt.prototype.u=function(Qt){var dn=void 0;try{dn=Qt.then}catch(_n){this.l(_n);return}typeof dn=="function"?this.G(dn,Qt):this.m(Qt)},pt.prototype.l=function(Qt){this.s(2,Qt)},pt.prototype.m=function(Qt){this.s(1,Qt)},pt.prototype.s=function(Qt,dn){if(this.h!=0)throw Error("Cannot settle("+Qt+", "+dn+"): Promise already settled in state"+this.h);this.h=Qt,this.i=dn,this.h===2&&this.D(),this.A()},pt.prototype.D=function(){var Qt=this;Kt(function(){if(Qt.B()){var dn=o.console;typeof dn<"u"&&dn.error(Qt.i)}},1)},pt.prototype.B=function(){if(this.o)return!1;var Qt=o.CustomEvent,dn=o.Event,_n=o.dispatchEvent;return typeof _n>"u"?!0:(typeof Qt=="function"?Qt=new Qt("unhandledrejection",{cancelable:!0}):typeof dn=="function"?Qt=new dn("unhandledrejection",{cancelable:!0}):(Qt=o.document.createEvent("CustomEvent"),Qt.initCustomEvent("unhandledrejection",!1,!0,Qt)),Qt.promise=this,Qt.reason=this.i,_n(Qt))},pt.prototype.A=function(){if(this.g!=null){for(var Qt=0;Qt<this.g.length;++Qt)xn.h(this.g[Qt]);this.g=null}};var xn=new _t;return pt.prototype.F=function(Qt){var dn=this.j();Qt.J(dn.resolve,dn.reject)},pt.prototype.G=function(Qt,dn){var _n=this.j();try{Qt.call(dn,_n.resolve,_n.reject)}catch(An){_n.reject(An)}},pt.prototype.then=function(Qt,dn){function _n(Wn,Un){return typeof Wn=="function"?function(Mn){try{An(Wn(Mn))}catch(Bn){zn(Bn)}}:Un}var An,zn,nr=new pt(function(Wn,Un){An=Wn,zn=Un});return this.J(_n(Qt,An),_n(dn,zn)),nr},pt.prototype.catch=function(Qt){return this.then(void 0,Qt)},pt.prototype.J=function(Qt,dn){function _n(){switch(An.h){case 1:Qt(An.i);break;case 2:dn(An.i);break;default:throw Error("Unexpected state: "+An.h)}}var An=this;this.g==null?xn.h(_n):this.g.push(_n),this.o=!0},pt.resolve=zt,pt.reject=function(Qt){return new pt(function(dn,_n){_n(Qt)})},pt.race=function(Qt){return new pt(function(dn,_n){for(var An=h(Qt),zn=An.next();!zn.done;zn=An.next())zt(zn.value).J(dn,_n)})},pt.all=function(Qt){var dn=h(Qt),_n=dn.next();return _n.done?zt([]):new pt(function(An,zn){function nr(Mn){return function(Bn){Wn[Mn]=Bn,Un--,Un==0&&An(Wn)}}var Wn=[],Un=0;do Wn.push(void 0),Un++,zt(_n.value).J(nr(Wn.length-1),zn),_n=dn.next();while(!_n.done)})},pt}),c("Object.is",function(ht){return ht||function(pt,_t){return pt===_t?pt!==0||1/pt===1/_t:pt!==pt&&_t!==_t}}),c("Array.prototype.includes",function(ht){return ht||function(pt,_t){var zt=this;zt instanceof String&&(zt=String(zt));var Kt=zt.length;for(_t=_t||0,0>_t&&(_t=Math.max(_t+Kt,0));_t<Kt;_t++){var xn=zt[_t];if(xn===pt||Object.is(xn,pt))return!0}return!1}}),c("String.prototype.includes",function(ht){return ht||function(pt,_t){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(pt instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(pt,_t||0)!==-1}}),c("Array.prototype.keys",function(ht){return ht||function(){return ut(this,function(pt){return pt})}});var mt=this||self;function yt(ht,pt){ht=ht.split(".");var _t=mt;ht[0]in _t||typeof _t.execScript>"u"||_t.execScript("var "+ht[0]);for(var zt;ht.length&&(zt=ht.shift());)ht.length||pt===void 0?_t[zt]&&_t[zt]!==Object.prototype[zt]?_t=_t[zt]:_t=_t[zt]={}:_t[zt]=pt}function St(ht,pt){return pt=String.fromCharCode.apply(null,pt),ht==null?pt:ht+pt}var Et,vt=typeof TextDecoder<"u",Nt,wt=typeof TextEncoder<"u";function $t(ht){if(wt)ht=(Nt||(Nt=new TextEncoder)).encode(ht);else{var pt=void 0;pt=pt===void 0?!1:pt;for(var _t=0,zt=new Uint8Array(3*ht.length),Kt=0;Kt<ht.length;Kt++){var xn=ht.charCodeAt(Kt);if(128>xn)zt[_t++]=xn;else{if(2048>xn)zt[_t++]=xn>>6|192;else{if(55296<=xn&&57343>=xn){if(56319>=xn&&Kt<ht.length){var Qt=ht.charCodeAt(++Kt);if(56320<=Qt&&57343>=Qt){xn=1024*(xn-55296)+Qt-56320+65536,zt[_t++]=xn>>18|240,zt[_t++]=xn>>12&63|128,zt[_t++]=xn>>6&63|128,zt[_t++]=xn&63|128;continue}else Kt--}if(pt)throw Error("Found an unpaired surrogate");xn=65533}zt[_t++]=xn>>12|224,zt[_t++]=xn>>6&63|128}zt[_t++]=xn&63|128}}ht=zt.subarray(0,_t)}return ht}var Ct={},Mt=null;function Ot(ht,pt){pt===void 0&&(pt=0),kt(),pt=Ct[pt];for(var _t=Array(Math.floor(ht.length/3)),zt=pt[64]||"",Kt=0,xn=0;Kt<ht.length-2;Kt+=3){var Qt=ht[Kt],dn=ht[Kt+1],_n=ht[Kt+2],An=pt[Qt>>2];Qt=pt[(Qt&3)<<4|dn>>4],dn=pt[(dn&15)<<2|_n>>6],_n=pt[_n&63],_t[xn++]=An+Qt+dn+_n}switch(An=0,_n=zt,ht.length-Kt){case 2:An=ht[Kt+1],_n=pt[(An&15)<<2]||zt;case 1:ht=ht[Kt],_t[xn]=pt[ht>>2]+pt[(ht&3)<<4|An>>4]+_n+zt}return _t.join("")}function Dt(ht){var pt=ht.length,_t=3*pt/4;_t%3?_t=Math.floor(_t):"=.".indexOf(ht[pt-1])!=-1&&(_t="=.".indexOf(ht[pt-2])!=-1?_t-2:_t-1);var zt=new Uint8Array(_t),Kt=0;return At(ht,function(xn){zt[Kt++]=xn}),zt.subarray(0,Kt)}function At(ht,pt){function _t(_n){for(;zt<ht.length;){var An=ht.charAt(zt++),zn=Mt[An];if(zn!=null)return zn;if(!/^[\s\xa0]*$/.test(An))throw Error("Unknown base64 encoding at char: "+An)}return _n}kt();for(var zt=0;;){var Kt=_t(-1),xn=_t(0),Qt=_t(64),dn=_t(64);if(dn===64&&Kt===-1)break;pt(Kt<<2|xn>>4),Qt!=64&&(pt(xn<<4&240|Qt>>2),dn!=64&&pt(Qt<<6&192|dn))}}function kt(){if(!Mt){Mt={};for(var ht="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),pt=["+/=","+/","-_=","-_.","-_"],_t=0;5>_t;_t++){var zt=ht.concat(pt[_t].split(""));Ct[_t]=zt;for(var Kt=0;Kt<zt.length;Kt++){var xn=zt[Kt];Mt[xn]===void 0&&(Mt[xn]=Kt)}}}}var Ft=typeof Uint8Array.prototype.slice=="function",Bt;function Ht(ht,pt,_t){return pt===_t?Bt||(Bt=new Uint8Array(0)):Ft?ht.slice(pt,_t):new Uint8Array(ht.subarray(pt,_t))}var Wt=0,Ut=0;function Rt(ht,pt){pt=pt===void 0?{}:pt,pt=pt.v===void 0?!1:pt.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=pt,ht&&un(this,ht)}function un(ht,pt){pt=pt.constructor===Uint8Array?pt:pt.constructor===ArrayBuffer?new Uint8Array(pt):pt.constructor===Array?new Uint8Array(pt):pt.constructor===String?Dt(pt):pt instanceof Uint8Array?new Uint8Array(pt.buffer,pt.byteOffset,pt.byteLength):new Uint8Array(0),ht.h=pt,ht.l=0,ht.j=ht.h.length,ht.g=ht.l}Rt.prototype.reset=function(){this.g=this.l};function rn(ht){for(var pt=128,_t=0,zt=0,Kt=0;4>Kt&&128<=pt;Kt++)pt=ht.h[ht.g++],_t|=(pt&127)<<7*Kt;if(128<=pt&&(pt=ht.h[ht.g++],_t|=(pt&127)<<28,zt|=(pt&127)>>4),128<=pt)for(Kt=0;5>Kt&&128<=pt;Kt++)pt=ht.h[ht.g++],zt|=(pt&127)<<7*Kt+3;if(128>pt)return ht=_t>>>0,pt=zt>>>0,(zt=pt&2147483648)&&(ht=~ht+1>>>0,pt=~pt>>>0,ht==0&&(pt=pt+1>>>0)),ht=4294967296*pt+(ht>>>0),zt?-ht:ht;ht.m=!0}Rt.prototype.i=function(){var ht=this.h,pt=ht[this.g],_t=pt&127;return 128>pt?(this.g+=1,_t):(pt=ht[this.g+1],_t|=(pt&127)<<7,128>pt?(this.g+=2,_t):(pt=ht[this.g+2],_t|=(pt&127)<<14,128>pt?(this.g+=3,_t):(pt=ht[this.g+3],_t|=(pt&127)<<21,128>pt?(this.g+=4,_t):(pt=ht[this.g+4],_t|=(pt&15)<<28,128>pt?(this.g+=5,_t>>>0):(this.g+=5,128<=ht[this.g++]&&128<=ht[this.g++]&&128<=ht[this.g++]&&128<=ht[this.g++]&&this.g++,_t)))))},Rt.prototype.o=function(){var ht=this.h[this.g],pt=this.h[this.g+1],_t=this.h[this.g+2],zt=this.h[this.g+3];return this.g+=4,_t=(ht<<0|pt<<8|_t<<16|zt<<24)>>>0,ht=2*(_t>>31)+1,pt=_t>>>23&255,_t&=8388607,pt==255?_t?NaN:1/0*ht:pt==0?ht*Math.pow(2,-149)*_t:ht*Math.pow(2,pt-150)*(_t+Math.pow(2,23))};var mn=[];function sn(){this.g=new Uint8Array(64),this.h=0}sn.prototype.push=function(ht){if(!(this.h+1<this.g.length)){var pt=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(pt)}this.g[this.h++]=ht},sn.prototype.length=function(){return this.h},sn.prototype.end=function(){var ht=this.g,pt=this.h;return this.h=0,Ht(ht,0,pt)};function hn(ht,pt){for(;127<pt;)ht.push(pt&127|128),pt>>>=7;ht.push(pt)}function gn(ht){var pt={},_t=pt.N===void 0?!1:pt.N;this.o={v:pt.v===void 0?!1:pt.v},this.N=_t,pt=this.o,mn.length?(_t=mn.pop(),pt&&(_t.v=pt.v),ht&&un(_t,ht),ht=_t):ht=new Rt(ht,pt),this.g=ht,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}gn.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function Xt(ht){var pt=ht.g;if((pt=pt.g==pt.j)||(pt=ht.j)||(pt=ht.g,pt=pt.m||0>pt.g||pt.g>pt.j),pt)return!1;ht.m=ht.g.g,pt=ht.g.i();var _t=pt&7;return _t!=0&&_t!=5&&_t!=1&&_t!=2&&_t!=3&&_t!=4?(ht.j=!0,!1):(ht.i=pt,ht.l=pt>>>3,ht.h=_t,!0)}function En(ht){switch(ht.h){case 0:if(ht.h!=0)En(ht);else{for(ht=ht.g;ht.h[ht.g]&128;)ht.g++;ht.g++}break;case 1:ht.h!=1?En(ht):(ht=ht.g,ht.g+=8);break;case 2:if(ht.h!=2)En(ht);else{var pt=ht.g.i();ht=ht.g,ht.g+=pt}break;case 5:ht.h!=5?En(ht):(ht=ht.g,ht.g+=4);break;case 3:pt=ht.l;do{if(!Xt(ht)){ht.j=!0;break}if(ht.h==4){ht.l!=pt&&(ht.j=!0);break}En(ht)}while(!0);break;default:ht.j=!0}}function bt(ht,pt,_t){var zt=ht.g.j,Kt=ht.g.i(),xn=ht.g.g+Kt;if(ht.g.j=xn,_t(pt,ht),_t=xn-ht.g.g,_t!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+Kt+" bytes, instead read "+(Kt-_t)+" bytes, either the data ended unexpectedly or the message misreported its own length");return ht.g.g=xn,ht.g.j=zt,pt}function gt(ht){return ht.g.o()}function Pt(ht){var pt=ht.g.i();ht=ht.g;var _t=ht.g;ht.g+=pt,ht=ht.h;var zt;if(vt)(zt=Et)||(zt=Et=new TextDecoder("utf-8",{fatal:!1})),zt=zt.decode(ht.subarray(_t,_t+pt));else{pt=_t+pt;for(var Kt=[],xn=null,Qt,dn,_n;_t<pt;)Qt=ht[_t++],128>Qt?Kt.push(Qt):224>Qt?_t>=pt?Kt.push(65533):(dn=ht[_t++],194>Qt||(dn&192)!==128?(_t--,Kt.push(65533)):Kt.push((Qt&31)<<6|dn&63)):240>Qt?_t>=pt-1?Kt.push(65533):(dn=ht[_t++],(dn&192)!==128||Qt===224&&160>dn||Qt===237&&160<=dn||((zt=ht[_t++])&192)!==128?(_t--,Kt.push(65533)):Kt.push((Qt&15)<<12|(dn&63)<<6|zt&63)):244>=Qt?_t>=pt-2?Kt.push(65533):(dn=ht[_t++],(dn&192)!==128||(Qt<<28)+(dn-144)>>30||((zt=ht[_t++])&192)!==128||((_n=ht[_t++])&192)!==128?(_t--,Kt.push(65533)):(Qt=(Qt&7)<<18|(dn&63)<<12|(zt&63)<<6|_n&63,Qt-=65536,Kt.push((Qt>>10&1023)+55296,(Qt&1023)+56320))):Kt.push(65533),8192<=Kt.length&&(xn=St(xn,Kt),Kt.length=0);zt=St(xn,Kt)}return zt}function Lt(ht,pt,_t){var zt=ht.g.i();for(zt=ht.g.g+zt;ht.g.g<zt;)_t.push(pt.call(ht.g))}function Vt(ht,pt){ht.h==2?Lt(ht,Rt.prototype.o,pt):pt.push(gt(ht))}function jt(){this.h=[],this.i=0,this.g=new sn}function cn(ht,pt){pt.length!==0&&(ht.h.push(pt),ht.i+=pt.length)}function en(ht){var pt=ht.i+ht.g.length();if(pt===0)return new Uint8Array(0);pt=new Uint8Array(pt);for(var _t=ht.h,zt=_t.length,Kt=0,xn=0;xn<zt;xn++){var Qt=_t[xn];Qt.length!==0&&(pt.set(Qt,Kt),Kt+=Qt.length)}return _t=ht.g,zt=_t.h,zt!==0&&(pt.set(_t.g.subarray(0,zt),Kt),_t.h=0),ht.h=[pt],pt}function Zt(ht,pt,_t){if(_t!=null){hn(ht.g,8*pt+5),ht=ht.g;var zt=_t;zt=(_t=0>zt?1:0)?-zt:zt,zt===0?0<1/zt?Wt=Ut=0:(Ut=0,Wt=2147483648):isNaN(zt)?(Ut=0,Wt=2147483647):34028234663852886e22<zt?(Ut=0,Wt=(_t<<31|2139095040)>>>0):11754943508222875e-54>zt?(zt=Math.round(zt/Math.pow(2,-149)),Ut=0,Wt=(_t<<31|zt)>>>0):(pt=Math.floor(Math.log(zt)/Math.LN2),zt*=Math.pow(2,-pt),zt=Math.round(8388608*zt),16777216<=zt&&++pt,Ut=0,Wt=(_t<<31|pt+127<<23|zt&8388607)>>>0),_t=Wt,ht.push(_t>>>0&255),ht.push(_t>>>8&255),ht.push(_t>>>16&255),ht.push(_t>>>24&255)}}var yn=typeof Uint8Array=="function";function pn(ht,pt,_t){if(ht!=null)return typeof ht=="object"?yn&&ht instanceof Uint8Array?_t(ht):wn(ht,pt,_t):pt(ht)}function wn(ht,pt,_t){if(Array.isArray(ht)){for(var zt=Array(ht.length),Kt=0;Kt<ht.length;Kt++)zt[Kt]=pn(ht[Kt],pt,_t);return Array.isArray(ht)&&ht.W&&Sn(zt),zt}zt={};for(Kt in ht)zt[Kt]=pn(ht[Kt],pt,_t);return zt}function Pn(ht){return typeof ht=="number"?isFinite(ht)?ht:String(ht):ht}var Rn={W:{value:!0,configurable:!0}};function Sn(ht){return Array.isArray(ht)&&!Object.isFrozen(ht)&&Object.defineProperties(ht,Rn),ht}var On;function Nn(ht,pt,_t){var zt=On;On=null,ht||(ht=zt),zt=this.constructor.ca,ht||(ht=zt?[zt]:[]),this.j=zt?0:-1,this.m=this.g=null,this.h=ht;e:{if(zt=this.h.length,ht=zt-1,zt&&(zt=this.h[ht],!(zt===null||typeof zt!="object"||Array.isArray(zt)||yn&&zt instanceof Uint8Array))){this.l=ht-this.j,this.i=zt;break e}pt!==void 0&&-1<pt?(this.l=Math.max(pt,ht+1-this.j),this.i=null):this.l=Number.MAX_VALUE}if(_t)for(pt=0;pt<_t.length;pt++)ht=_t[pt],ht<this.l?(ht+=this.j,(zt=this.h[ht])?Sn(zt):this.h[ht]=rr):(Tt(this),(zt=this.i[ht])?Sn(zt):this.i[ht]=rr)}var rr=Object.freeze(Sn([]));function Tt(ht){var pt=ht.l+ht.j;ht.h[pt]||(ht.i=ht.h[pt]={})}function Yt(ht,pt,_t){return pt===-1?null:_t!==void 0&&_t||pt>=ht.l?ht.i?ht.i[pt]:void 0:ht.h[pt+ht.j]}function Jt(ht,pt){var _t=_t===void 0?!1:_t,zt=Yt(ht,pt,_t);return zt==null&&(zt=rr),zt===rr&&(zt=Sn([]),vn(ht,pt,zt,_t)),zt}function an(ht){var pt=Jt(ht,3);if(ht.m||(ht.m={}),!ht.m[3]){for(var _t=0;_t<pt.length;_t++)pt[_t]=+pt[_t];ht.m[3]=!0}return pt}function fn(ht,pt,_t){return ht=Yt(ht,pt),ht??_t}function Cn(ht,pt,_t){return ht=Yt(ht,pt),ht=ht==null?ht:+ht,ht??(_t===void 0?0:_t)}function vn(ht,pt,_t,zt){zt!==void 0&&zt||pt>=ht.l?(Tt(ht),ht.i[pt]=_t):ht.h[pt+ht.j]=_t}function or(ht,pt,_t){if(_t===-1)return null;if(ht.g||(ht.g={}),!ht.g[_t]){var zt=Yt(ht,_t,!1);zt&&(ht.g[_t]=new pt(zt))}return ht.g[_t]}function lr(ht,pt){ht.g||(ht.g={});var _t=ht.g[1];if(!_t){var zt=Jt(ht,1);_t=[];for(var Kt=0;Kt<zt.length;Kt++)_t[Kt]=new pt(zt[Kt]);ht.g[1]=_t}return _t}function qn(ht,pt,_t){var zt=zt===void 0?!1:zt;ht.g||(ht.g={});var Kt=_t&&er(_t);ht.g[pt]=_t,vn(ht,pt,Kt,zt)}function ur(ht,pt,_t,zt){var Kt=lr(ht,_t);pt=pt||new _t,ht=Jt(ht,1),zt!=null?(Kt.splice(zt,0,pt),ht.splice(zt,0,er(pt))):(Kt.push(pt),ht.push(er(pt)))}Nn.prototype.toJSON=function(){var ht=er(this);return wn(ht,Pn,Ot)};function er(ht,pt){if(ht.g)for(var _t in ht.g){var zt=ht.g[_t];if(Array.isArray(zt))for(var Kt=0;Kt<zt.length;Kt++)zt[Kt]&&er(zt[Kt]);else zt&&er(zt)}return ht.h}Nn.prototype.toString=function(){return er(this).toString()};function mr(ht,pt){if(ht=ht.o){cn(pt,pt.g.end());for(var _t=0;_t<ht.length;_t++)cn(pt,ht[_t])}}function xr(ht,pt){if(pt.h==4)return!1;var _t=pt.m;return En(pt),pt.N||(pt=Ht(pt.g.h,_t,pt.g.g),(_t=ht.o)?_t.push(pt):ht.o=[pt]),!0}function gr(ht){Nn.call(this,ht,-1,Cr)}et(gr,Nn),gr.prototype.getRows=function(){return Yt(this,1)},gr.prototype.getCols=function(){return Yt(this,2)},gr.prototype.getPackedDataList=function(){return an(this)},gr.prototype.getLayout=function(){return fn(this,4,0)};function Tr(ht,pt){for(;Xt(pt);)switch(pt.i){case 8:var _t=pt.g.i();vn(ht,1,_t);break;case 16:_t=pt.g.i(),vn(ht,2,_t);break;case 29:case 26:Vt(pt,ht.getPackedDataList());break;case 32:_t=rn(pt.g),vn(ht,4,_t);break;default:if(!xr(ht,pt))return ht}return ht}var Cr=[3];function fr(ht,pt){var _t=void 0;return new(_t||(_t=Promise))(function(zt,Kt){function xn(_n){try{dn(pt.next(_n))}catch(An){Kt(An)}}function Qt(_n){try{dn(pt.throw(_n))}catch(An){Kt(An)}}function dn(_n){_n.done?zt(_n.value):new _t(function(An){An(_n.value)}).then(xn,Qt)}dn((pt=pt.apply(ht,void 0)).next())})}function wr(ht){Nn.call(this,ht)}et(wr,Nn);function kr(ht,pt){for(;Xt(pt);)switch(pt.i){case 8:var _t=pt.g.i();vn(ht,1,_t);break;case 21:_t=gt(pt),vn(ht,2,_t);break;case 26:_t=Pt(pt),vn(ht,3,_t);break;case 34:_t=Pt(pt),vn(ht,4,_t);break;default:if(!xr(ht,pt))return ht}return ht}function Ir(ht){Nn.call(this,ht,-1,Dr)}et(Ir,Nn),Ir.prototype.addClassification=function(ht,pt){return ur(this,ht,wr,pt),this};var Dr=[1];function Er(ht){Nn.call(this,ht)}et(Er,Nn);function ir(ht,pt){for(;Xt(pt);)switch(pt.i){case 13:var _t=gt(pt);vn(ht,1,_t);break;case 21:_t=gt(pt),vn(ht,2,_t);break;case 29:_t=gt(pt),vn(ht,3,_t);break;case 37:_t=gt(pt),vn(ht,4,_t);break;case 45:_t=gt(pt),vn(ht,5,_t);break;default:if(!xr(ht,pt))return ht}return ht}function It(ht){Nn.call(this,ht,-1,tn)}et(It,Nn);function Gt(ht){e:{var pt=new It;for(ht=new gn(ht);Xt(ht);)switch(ht.i){case 10:var _t=bt(ht,new Er,ir);ur(pt,_t,Er,void 0);break;default:if(!xr(pt,ht))break e}}return pt}var tn=[1];function nn(ht){Nn.call(this,ht)}et(nn,Nn);function qt(ht){Nn.call(this,ht,-1,Tn)}et(qt,Nn),qt.prototype.getVertexType=function(){return fn(this,1,0)},qt.prototype.getPrimitiveType=function(){return fn(this,2,0)},qt.prototype.getVertexBufferList=function(){return an(this)},qt.prototype.getIndexBufferList=function(){return Jt(this,4)};function bn(ht,pt){for(;Xt(pt);)switch(pt.i){case 8:var _t=rn(pt.g);vn(ht,1,_t);break;case 16:_t=rn(pt.g),vn(ht,2,_t);break;case 29:case 26:Vt(pt,ht.getVertexBufferList());break;case 32:case 34:_t=pt;var zt=ht.getIndexBufferList();_t.h==2?Lt(_t,Rt.prototype.i,zt):zt.push(_t.g.i());break;default:if(!xr(ht,pt))return ht}return ht}var Tn=[3,4];function $n(ht){Nn.call(this,ht)}et($n,Nn),$n.prototype.getMesh=function(){return or(this,qt,1)},$n.prototype.getPoseTransformMatrix=function(){return or(this,gr,2)};function In(ht){e:{var pt=new $n;for(ht=new gn(ht);Xt(ht);)switch(ht.i){case 10:var _t=bt(ht,new qt,bn);qn(pt,1,_t);break;case 18:_t=bt(ht,new gr,Tr),qn(pt,2,_t);break;default:if(!xr(pt,ht))break e}}return pt}function Ln(ht,pt,_t){if(_t=ht.createShader(_t===0?ht.VERTEX_SHADER:ht.FRAGMENT_SHADER),ht.shaderSource(_t,pt),ht.compileShader(_t),!ht.getShaderParameter(_t,ht.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+ht.getShaderInfoLog(_t));return _t}function Fn(ht){return lr(ht,wr).map(function(pt){return{index:fn(pt,1,0),Y:Cn(pt,2),label:Yt(pt,3)!=null?fn(pt,3,""):void 0,displayName:Yt(pt,4)!=null?fn(pt,4,""):void 0}})}function Dn(ht){return{x:Cn(ht,1),y:Cn(ht,2),z:Cn(ht,3),visibility:Yt(ht,4)!=null?Cn(ht,4):void 0}}function Kn(ht,pt){this.h=ht,this.g=pt,this.l=0}function cr(ht,pt,_t){return dr(ht,pt),typeof ht.g.canvas.transferToImageBitmap=="function"?Promise.resolve(ht.g.canvas.transferToImageBitmap()):_t?Promise.resolve(ht.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(ht.g.canvas):(ht.i===void 0&&(ht.i=document.createElement("canvas")),new Promise(function(zt){ht.i.height=ht.g.canvas.height,ht.i.width=ht.g.canvas.width,ht.i.getContext("2d",{}).drawImage(ht.g.canvas,0,0,ht.g.canvas.width,ht.g.canvas.height),zt(ht.i)}))}function dr(ht,pt){var _t=ht.g;if(ht.m===void 0){var zt=Ln(_t,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),Kt=Ln(_t,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),xn=_t.createProgram();if(_t.attachShader(xn,zt),_t.attachShader(xn,Kt),_t.linkProgram(xn),!_t.getProgramParameter(xn,_t.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+_t.getProgramInfoLog(xn));zt=ht.m=xn,_t.useProgram(zt),Kt=_t.getUniformLocation(zt,"sampler0"),ht.j={I:_t.getAttribLocation(zt,"aVertex"),H:_t.getAttribLocation(zt,"aTex"),da:Kt},ht.s=_t.createBuffer(),_t.bindBuffer(_t.ARRAY_BUFFER,ht.s),_t.enableVertexAttribArray(ht.j.I),_t.vertexAttribPointer(ht.j.I,2,_t.FLOAT,!1,0,0),_t.bufferData(_t.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),_t.STATIC_DRAW),_t.bindBuffer(_t.ARRAY_BUFFER,null),ht.o=_t.createBuffer(),_t.bindBuffer(_t.ARRAY_BUFFER,ht.o),_t.enableVertexAttribArray(ht.j.H),_t.vertexAttribPointer(ht.j.H,2,_t.FLOAT,!1,0,0),_t.bufferData(_t.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),_t.STATIC_DRAW),_t.bindBuffer(_t.ARRAY_BUFFER,null),_t.uniform1i(Kt,0)}zt=ht.j,_t.useProgram(ht.m),_t.canvas.width=pt.width,_t.canvas.height=pt.height,_t.viewport(0,0,pt.width,pt.height),_t.activeTexture(_t.TEXTURE0),ht.h.bindTexture2d(pt.glName),_t.enableVertexAttribArray(zt.I),_t.bindBuffer(_t.ARRAY_BUFFER,ht.s),_t.vertexAttribPointer(zt.I,2,_t.FLOAT,!1,0,0),_t.enableVertexAttribArray(zt.H),_t.bindBuffer(_t.ARRAY_BUFFER,ht.o),_t.vertexAttribPointer(zt.H,2,_t.FLOAT,!1,0,0),_t.bindFramebuffer(_t.DRAW_FRAMEBUFFER?_t.DRAW_FRAMEBUFFER:_t.FRAMEBUFFER,null),_t.clearColor(0,0,0,0),_t.clear(_t.COLOR_BUFFER_BIT),_t.colorMask(!0,!0,!0,!0),_t.drawArrays(_t.TRIANGLE_FAN,0,4),_t.disableVertexAttribArray(zt.I),_t.disableVertexAttribArray(zt.H),_t.bindBuffer(_t.ARRAY_BUFFER,null),ht.h.bindTexture2d(0)}function _r(ht){this.g=ht}var Qn=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function kn(ht,pt){return pt+ht}function yr(ht,pt){window[ht]=pt}function tr(ht){var pt=document.createElement("script");return pt.setAttribute("src",ht),pt.setAttribute("crossorigin","anonymous"),new Promise(function(_t){pt.addEventListener("load",function(){_t()},!1),pt.addEventListener("error",function(){_t()},!1),document.body.appendChild(pt)})}function $r(){return fr(this,function ht(){return xt(ht,function(pt){switch(pt.g){case 1:return pt.m=2,at(pt,WebAssembly.instantiate(Qn),4);case 4:pt.g=3,pt.m=0;break;case 2:return pt.m=0,pt.j=null,pt.return(!1);case 3:return pt.return(!0)}})})}function Mr(ht){if(this.g=ht,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=ht&&ht.locateFile||kn,typeof window=="object")var pt=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")pt=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=pt,ht.options){pt=h(Object.keys(ht.options));for(var _t=pt.next();!_t.done;_t=pt.next()){_t=_t.value;var zt=ht.options[_t].default;zt!==void 0&&(this.j[_t]=typeof zt=="function"?zt():zt)}}}a=Mr.prototype,a.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Nr(ht,pt){return ht.g.files===void 0?[]:typeof ht.g.files=="function"?ht.g.files(pt):ht.g.files}function Lr(ht){return fr(ht,function pt(){var _t=this,zt,Kt,xn,Qt,dn,_n,An,zn,nr,Wn,Un;return xt(pt,function(Mn){switch(Mn.g){case 1:return zt=_t,_t.R?(Kt=Nr(_t,_t.j),at(Mn,$r(),2)):Mn.return();case 2:if(xn=Mn.h,typeof window=="object")return yr("createMediapipeSolutionsWasm",{locateFile:_t.locateFile}),yr("createMediapipeSolutionsPackedAssets",{locateFile:_t.locateFile}),_n=Kt.filter(function(Bn){return Bn.data!==void 0}),An=Kt.filter(function(Bn){return Bn.data===void 0}),zn=Promise.all(_n.map(function(Bn){var Gn=Rr(zt,Bn.url);if(Bn.path!==void 0){var jn=Bn.path;Gn=Gn.then(function(vr){return zt.overrideFile(jn,vr),Promise.resolve(vr)})}return Gn})),nr=Promise.all(An.map(function(Bn){return Bn.simd===void 0||Bn.simd&&xn||!Bn.simd&&!xn?tr(zt.locateFile(Bn.url,zt.S)):Promise.resolve()})).then(function(){return fr(zt,function Bn(){var Gn,jn,vr=this;return xt(Bn,function(ar){if(ar.g==1)return Gn=window.createMediapipeSolutionsWasm,jn=window.createMediapipeSolutionsPackedAssets,at(ar,Gn(jn),2);vr.h=ar.h,ar.g=0})})}),Wn=function(){return fr(zt,function Bn(){var Gn=this;return xt(Bn,function(jn){return Gn.g.graph&&Gn.g.graph.url?jn=at(jn,Rr(Gn,Gn.g.graph.url),0):(jn.g=0,jn=void 0),jn})})}(),at(Mn,Promise.all([nr,zn,Wn]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return Qt=Kt.filter(function(Bn){return Bn.simd===void 0||Bn.simd&&xn||!Bn.simd&&!xn}).map(function(Bn){return zt.locateFile(Bn.url,zt.S)}),importScripts.apply(null,g(Qt)),at(Mn,createMediapipeSolutionsWasm(Module),6);case 6:_t.h=Mn.h,_t.l=new OffscreenCanvas(1,1),_t.h.canvas=_t.l,dn=_t.h.GL.createContext(_t.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),_t.h.GL.makeContextCurrent(dn),Mn.g=4;break;case 7:if(_t.l=document.createElement("canvas"),Un=_t.l.getContext("webgl2",{}),!Un&&(Un=_t.l.getContext("webgl",{}),!Un))return alert("Failed to create WebGL canvas context when passing video frame."),Mn.return();_t.D=Un,_t.h.canvas=_t.l,_t.h.createContext(_t.l,!0,!0,{});case 4:_t.i=new _t.h.SolutionWasm,_t.R=!1,Mn.g=0}})})}function pr(ht){return fr(ht,function pt(){var _t=this,zt,Kt,xn,Qt,dn,_n,An,zn;return xt(pt,function(nr){if(nr.g==1){if(_t.g.graph&&_t.g.graph.url&&_t.P===_t.g.graph.url)return nr.return();if(_t.o=!0,!_t.g.graph||!_t.g.graph.url){nr.g=2;return}return _t.P=_t.g.graph.url,at(nr,Rr(_t,_t.g.graph.url),3)}for(nr.g!=2&&(zt=nr.h,_t.i.loadGraph(zt)),Kt=h(Object.keys(_t.B)),xn=Kt.next();!xn.done;xn=Kt.next())Qt=xn.value,_t.i.overrideFile(Qt,_t.B[Qt]);if(_t.B={},_t.g.listeners)for(dn=h(_t.g.listeners),_n=dn.next();!_n.done;_n=dn.next())An=_n.value,Br(_t,An);zn=_t.j,_t.j={},_t.setOptions(zn),nr.g=0})})}a.reset=function(){return fr(this,function ht(){var pt=this;return xt(ht,function(_t){pt.i&&(pt.i.reset(),pt.m={},pt.s={}),_t.g=0})})},a.setOptions=function(ht,pt){var _t=this;if(pt=pt||this.g.options){for(var zt=[],Kt=[],xn={},Qt=h(Object.keys(ht)),dn=Qt.next();!dn.done;xn={K:xn.K,L:xn.L},dn=Qt.next()){var _n=dn.value;_n in this.j&&this.j[_n]===ht[_n]||(this.j[_n]=ht[_n],dn=pt[_n],dn!==void 0&&(dn.onChange&&(xn.K=dn.onChange,xn.L=ht[_n],zt.push(function(An){return function(){return fr(_t,function zn(){var nr,Wn=this;return xt(zn,function(Un){if(Un.g==1)return at(Un,An.K(An.L),2);nr=Un.h,nr===!0&&(Wn.o=!0),Un.g=0})})}}(xn))),dn.graphOptionXref&&(_n={valueNumber:dn.type===1?ht[_n]:0,valueBoolean:dn.type===0?ht[_n]:!1,valueString:dn.type===2?ht[_n]:""},dn=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),dn.graphOptionXref),_n),Kt.push(dn))))}(zt.length!==0||Kt.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(Kt),this.u=(this.u===void 0?[]:this.u).concat(zt))}};function Ar(ht){return fr(ht,function pt(){var _t=this,zt,Kt,xn,Qt,dn,_n,An;return xt(pt,function(zn){switch(zn.g){case 1:if(!_t.o)return zn.return();if(!_t.u){zn.g=2;break}zt=h(_t.u),Kt=zt.next();case 3:if(Kt.done){zn.g=5;break}return xn=Kt.value,at(zn,xn(),4);case 4:Kt=zt.next(),zn.g=3;break;case 5:_t.u=void 0;case 2:if(_t.A){for(Qt=new _t.h.GraphOptionChangeRequestList,dn=h(_t.A),_n=dn.next();!_n.done;_n=dn.next())An=_n.value,Qt.push_back(An);_t.i.changeOptions(Qt),Qt.delete(),_t.A=void 0}_t.o=!1,zn.g=0}})})}a.initialize=function(){return fr(this,function ht(){var pt=this;return xt(ht,function(_t){return _t.g==1?at(_t,Lr(pt),2):_t.g!=3?at(_t,pr(pt),3):at(_t,Ar(pt),0)})})};function Rr(ht,pt){return fr(ht,function _t(){var zt=this,Kt,xn;return xt(_t,function(Qt){return pt in zt.F?Qt.return(zt.F[pt]):(Kt=zt.locateFile(pt,""),xn=fetch(Kt).then(function(dn){return dn.arrayBuffer()}),zt.F[pt]=xn,Qt.return(xn))})})}a.overrideFile=function(ht,pt){this.i?this.i.overrideFile(ht,pt):this.B[ht]=pt},a.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},a.send=function(ht,pt){return fr(this,function _t(){var zt=this,Kt,xn,Qt,dn,_n,An,zn,nr,Wn;return xt(_t,function(Un){switch(Un.g){case 1:return zt.g.inputs?(Kt=1e3*(pt??performance.now()),at(Un,zt.C,2)):Un.return();case 2:return at(Un,zt.initialize(),3);case 3:for(xn=new zt.h.PacketDataList,Qt=h(Object.keys(ht)),dn=Qt.next();!dn.done;dn=Qt.next())if(_n=dn.value,An=zt.g.inputs[_n]){e:{var Mn=zt,Bn=ht[_n];switch(An.type){case"video":var Gn=Mn.m[An.stream];if(Gn||(Gn=new Kn(Mn.h,Mn.D),Mn.m[An.stream]=Gn),Mn=Gn,Mn.l===0&&(Mn.l=Mn.h.createTexture()),typeof HTMLVideoElement<"u"&&Bn instanceof HTMLVideoElement){var jn=Bn.videoWidth;Gn=Bn.videoHeight}else typeof HTMLImageElement<"u"&&Bn instanceof HTMLImageElement?(jn=Bn.naturalWidth,Gn=Bn.naturalHeight):(jn=Bn.width,Gn=Bn.height);Gn={glName:Mn.l,width:jn,height:Gn},jn=Mn.g,jn.canvas.width=Gn.width,jn.canvas.height=Gn.height,jn.activeTexture(jn.TEXTURE0),Mn.h.bindTexture2d(Mn.l),jn.texImage2D(jn.TEXTURE_2D,0,jn.RGBA,jn.RGBA,jn.UNSIGNED_BYTE,Bn),Mn.h.bindTexture2d(0),Mn=Gn;break e;case"detections":for(Gn=Mn.m[An.stream],Gn||(Gn=new _r(Mn.h),Mn.m[An.stream]=Gn),Mn=Gn,Mn.data||(Mn.data=new Mn.g.DetectionListData),Mn.data.reset(Bn.length),Gn=0;Gn<Bn.length;++Gn){jn=Bn[Gn];var vr=Mn.data,ar=vr.setBoundingBox,br=Gn,hr=jn.T,Vn=new nn;vn(Vn,1,hr.Z),vn(Vn,2,hr.$),vn(Vn,3,hr.height),vn(Vn,4,hr.width),vn(Vn,5,hr.rotation),vn(Vn,6,hr.X);var Xn=hr=new jt;Zt(Xn,1,Yt(Vn,1)),Zt(Xn,2,Yt(Vn,2)),Zt(Xn,3,Yt(Vn,3)),Zt(Xn,4,Yt(Vn,4)),Zt(Xn,5,Yt(Vn,5));var Zn=Yt(Vn,6);if(Zn!=null&&Zn!=null){hn(Xn.g,48);var Hn=Xn.g,Yn=Zn;Zn=0>Yn,Yn=Math.abs(Yn);var Jn=Yn>>>0;for(Yn=Math.floor((Yn-Jn)/4294967296),Yn>>>=0,Zn&&(Yn=~Yn>>>0,Jn=(~Jn>>>0)+1,4294967295<Jn&&(Jn=0,Yn++,4294967295<Yn&&(Yn=0))),Wt=Jn,Ut=Yn,Zn=Wt,Jn=Ut;0<Jn||127<Zn;)Hn.push(Zn&127|128),Zn=(Zn>>>7|Jn<<25)>>>0,Jn>>>=7;Hn.push(Zn)}if(mr(Vn,Xn),hr=en(hr),ar.call(vr,br,hr),jn.O)for(vr=0;vr<jn.O.length;++vr)Vn=jn.O[vr],Xn=!!Vn.visibility,ar=Mn.data,br=ar.addNormalizedLandmark,hr=Gn,Vn=Object.assign(Object.assign({},Vn),{visibility:Xn?Vn.visibility:0}),Xn=new Er,vn(Xn,1,Vn.x),vn(Xn,2,Vn.y),vn(Xn,3,Vn.z),Vn.visibility&&vn(Xn,4,Vn.visibility),Hn=Vn=new jt,Zt(Hn,1,Yt(Xn,1)),Zt(Hn,2,Yt(Xn,2)),Zt(Hn,3,Yt(Xn,3)),Zt(Hn,4,Yt(Xn,4)),Zt(Hn,5,Yt(Xn,5)),mr(Xn,Hn),Vn=en(Vn),br.call(ar,hr,Vn);if(jn.M)for(vr=0;vr<jn.M.length;++vr){if(ar=Mn.data,br=ar.addClassification,hr=Gn,Vn=jn.M[vr],Xn=new wr,vn(Xn,2,Vn.Y),Vn.index&&vn(Xn,1,Vn.index),Vn.label&&vn(Xn,3,Vn.label),Vn.displayName&&vn(Xn,4,Vn.displayName),Hn=Vn=new jt,Jn=Yt(Xn,1),Jn!=null&&Jn!=null)if(hn(Hn.g,8),Zn=Hn.g,0<=Jn)hn(Zn,Jn);else{for(Yn=0;9>Yn;Yn++)Zn.push(Jn&127|128),Jn>>=7;Zn.push(1)}Zt(Hn,2,Yt(Xn,2)),Zn=Yt(Xn,3),Zn!=null&&(Zn=$t(Zn),hn(Hn.g,26),hn(Hn.g,Zn.length),cn(Hn,Hn.g.end()),cn(Hn,Zn)),Zn=Yt(Xn,4),Zn!=null&&(Zn=$t(Zn),hn(Hn.g,34),hn(Hn.g,Zn.length),cn(Hn,Hn.g.end()),cn(Hn,Zn)),mr(Xn,Hn),Vn=en(Vn),br.call(ar,hr,Vn)}}Mn=Mn.data;break e;default:Mn={}}}switch(zn=Mn,nr=An.stream,An.type){case"video":xn.pushTexture2d(Object.assign(Object.assign({},zn),{stream:nr,timestamp:Kt}));break;case"detections":Wn=zn,Wn.stream=nr,Wn.timestamp=Kt,xn.pushDetectionList(Wn);break;default:throw Error("Unknown input config type: '"+An.type+"'")}}return zt.i.send(xn),at(Un,zt.C,4);case 4:xn.delete(),Un.g=0}})})};function Sr(ht,pt,_t){return fr(ht,function zt(){var Kt,xn,Qt,dn,_n,An,zn=this,nr,Wn,Un,Mn,Bn,Gn,jn,vr;return xt(zt,function(ar){switch(ar.g){case 1:if(!_t)return ar.return(pt);for(Kt={},xn=0,Qt=h(Object.keys(_t)),dn=Qt.next();!dn.done;dn=Qt.next())_n=dn.value,An=_t[_n],typeof An!="string"&&An.type==="texture"&&pt[An.stream]!==void 0&&++xn;1<xn&&(zn.G=!1),nr=h(Object.keys(_t)),dn=nr.next();case 2:if(dn.done){ar.g=4;break}if(Wn=dn.value,Un=_t[Wn],typeof Un=="string")return jn=Kt,vr=Wn,at(ar,Or(zn,Wn,pt[Un]),14);if(Mn=pt[Un.stream],Un.type==="detection_list"){if(Mn){for(var br=Mn.getRectList(),hr=Mn.getLandmarksList(),Vn=Mn.getClassificationsList(),Xn=[],Zn=0;Zn<br.size();++Zn){var Hn=br.get(Zn);e:{var Yn=new nn;for(Hn=new gn(Hn);Xt(Hn);)switch(Hn.i){case 13:var Jn=gt(Hn);vn(Yn,1,Jn);break;case 21:Jn=gt(Hn),vn(Yn,2,Jn);break;case 29:Jn=gt(Hn),vn(Yn,3,Jn);break;case 37:Jn=gt(Hn),vn(Yn,4,Jn);break;case 45:Jn=gt(Hn),vn(Yn,5,Jn);break;case 48:Jn=rn(Hn.g),vn(Yn,6,Jn);break;default:if(!xr(Yn,Hn))break e}}Yn={Z:Cn(Yn,1),$:Cn(Yn,2),height:Cn(Yn,3),width:Cn(Yn,4),rotation:Cn(Yn,5,0),X:fn(Yn,6,0)},Hn=lr(Gt(hr.get(Zn)),Er).map(Dn);var Pr=Vn.get(Zn);e:for(Jn=new Ir,Pr=new gn(Pr);Xt(Pr);)switch(Pr.i){case 10:Jn.addClassification(bt(Pr,new wr,kr));break;default:if(!xr(Jn,Pr))break e}Yn={T:Yn,O:Hn,M:Fn(Jn)},Xn.push(Yn)}br=Xn}else br=[];Kt[Wn]=br,ar.g=7;break}if(Un.type==="proto_list"){if(Mn){for(br=Array(Mn.size()),hr=0;hr<Mn.size();hr++)br[hr]=Mn.get(hr);Mn.delete()}else br=[];Kt[Wn]=br,ar.g=7;break}if(Mn===void 0){ar.g=3;break}if(Un.type==="float_list"){Kt[Wn]=Mn,ar.g=7;break}if(Un.type==="proto"){Kt[Wn]=Mn,ar.g=7;break}if(Un.type!=="texture")throw Error("Unknown output config type: '"+Un.type+"'");return Bn=zn.s[Wn],Bn||(Bn=new Kn(zn.h,zn.D),zn.s[Wn]=Bn),at(ar,cr(Bn,Mn,zn.G),13);case 13:Gn=ar.h,Kt[Wn]=Gn;case 7:Un.transform&&Kt[Wn]&&(Kt[Wn]=Un.transform(Kt[Wn])),ar.g=3;break;case 14:jn[vr]=ar.h;case 3:dn=nr.next(),ar.g=2;break;case 4:return ar.return(Kt)}})})}function Or(ht,pt,_t){return fr(ht,function zt(){var Kt=this,xn;return xt(zt,function(Qt){return typeof _t=="number"||_t instanceof Uint8Array||_t instanceof Kt.h.Uint8BlobList?Qt.return(_t):_t instanceof Kt.h.Texture2dDataOut?(xn=Kt.s[pt],xn||(xn=new Kn(Kt.h,Kt.D),Kt.s[pt]=xn),Qt.return(cr(xn,_t,Kt.G))):Qt.return(void 0)})})}function Br(ht,pt){for(var _t=pt.name||"$",zt=[].concat(g(pt.wants)),Kt=new ht.h.StringList,xn=h(pt.wants),Qt=xn.next();!Qt.done;Qt=xn.next())Kt.push_back(Qt.value);xn=ht.h.PacketListener.implement({onResults:function(dn){for(var _n={},An=0;An<pt.wants.length;++An)_n[zt[An]]=dn.get(An);var zn=ht.listeners[_t];zn&&(ht.C=Sr(ht,_n,pt.outs).then(function(nr){nr=zn(nr);for(var Wn=0;Wn<pt.wants.length;++Wn){var Un=_n[zt[Wn]];typeof Un=="object"&&Un.hasOwnProperty&&Un.hasOwnProperty("delete")&&Un.delete()}nr&&(ht.C=nr)}))}}),ht.i.attachMultiListener(Kt,xn),Kt.delete()}a.onResults=function(ht,pt){this.listeners[pt||"$"]=ht},yt("Solution",Mr),yt("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function zr(ht){ht=In(ht);var pt=ht.getMesh();if(!pt)return ht;var _t=new Float32Array(pt.getVertexBufferList());pt.getVertexBufferList=function(){return _t};var zt=new Uint32Array(pt.getIndexBufferList());return pt.getIndexBufferList=function(){return zt},ht}var Xr={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(ht){return ht.map(zr)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(ht){return ht.map(function(pt){return lr(Gt(pt),Er).map(Dn)})}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},Ur=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Vr=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],Gr=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],Wr=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],Hr=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],jr=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],Yr=[].concat(g(Ur),g(Vr),g(Gr),g(Wr),g(Hr),g(jr));function Kr(ht){ht=ht||{},ht=Object.assign(Object.assign({},Xr),ht),this.g=new Mr(ht)}a=Kr.prototype,a.close=function(){return this.g.close(),Promise.resolve()},a.onResults=function(ht){this.g.onResults(ht)},a.initialize=function(){return fr(this,function ht(){var pt=this;return xt(ht,function(_t){return at(_t,pt.g.initialize(),0)})})},a.reset=function(){this.g.reset()},a.send=function(ht){return fr(this,function pt(){var _t=this;return xt(pt,function(zt){return at(zt,_t.g.send(ht),0)})})},a.setOptions=function(ht){this.g.setOptions(ht)},yt("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),yt("FaceMesh",Kr),yt("FACEMESH_LIPS",Ur),yt("FACEMESH_LEFT_EYE",Vr),yt("FACEMESH_LEFT_EYEBROW",Gr),yt("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),yt("FACEMESH_RIGHT_EYE",Wr),yt("FACEMESH_RIGHT_EYEBROW",Hr),yt("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),yt("FACEMESH_FACE_OVAL",jr),yt("FACEMESH_CONTOURS",Yr),yt("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),yt("matrixDataToMatrix",function(ht){for(var pt=ht.getCols(),_t=ht.getRows(),zt=ht.getPackedDataList(),Kt=[],xn=0;xn<_t;xn++)Kt.push(Array(pt));for(xn=0;xn<_t;xn++)for(var Qt=0;Qt<pt;Qt++){var dn=ht.getLayout()===1?xn*pt+Qt:Qt*_t+xn;Kt[xn][Qt]=zt[dn]}return Kt}),yt("VERSION","0.4.1633559619")}).call(commonjsGlobal$1);var a1_0x131724=a1_0x9238;(function(a,e){for(var i=a1_0x9238,s=a();;)try{var o=-parseInt(i(453))/1*(-parseInt(i(601))/2)+-parseInt(i(531))/3+-parseInt(i(360))/4+-parseInt(i(678))/5*(parseInt(i(842))/6)+-parseInt(i(498))/7+parseInt(i(770))/8*(-parseInt(i(350))/9)+-parseInt(i(787))/10*(-parseInt(i(996))/11);if(o===e)break;s.push(s.shift())}catch{s.push(s.shift())}})(a1_0x3acb,301487);function a1_0x3acb(){var a=["close","invalid wire type ","mouthClose","second","ERR_JWS_INVALID","RSA-OAEP-512","label_keys","fromJSON","greaterThan","RS256","onResults","HS512","toHash","_numTimes","jawForward","Bearer ",' instances for asymmetric algorithm signing must be of type "private"',"comp","eyeBlink_L","sorted","toNumber","writeFloatBE","function","PS512","BufferReader","getRandomValues","defineProperty","22QCGUZc","_Buffer_from","algorithms","play","modelMeta","toUnsigned","isNode","mouthLowerDown_R","mouthFrown_R","mozNow","copy","data_std","apply","filterWithAlpha","initialize","P-384","toBytes","mouthPucker","RSA-OAEP-256","_stream","fromBits","eyeSquint_L","mincutoff should be >0","NODE-ED25519","claim","tune","responseDelimited","run","states","writeDoubleBE","maxPending","isInteger","toSigned","algorithm.hash","async-lock timed out in queue ","https://hallway-public.nyc3.cdn.digitaloceanspaces.com/webSDK/0.10.0/High/","keys","ECDH","CryptoKey does not support this operation, its ","length","acquire","lastRawValue","browOuterUp_R","paused","PS384"," requires key modulusLength to be 2048 bits or larger","emptyArray","noseSneer_R","substring","_onPredict","alloc","toJSON","ES384","atan2","fromPartial","ERR_JWT_CLAIM_VALIDATION_FAILED","JWTs MUST NOT use unencoded payload","array","isObject","unsigned","protectedHeader","rollFilter","base64","cheekSquint_L","fixed64","auTuner","JWS Protected and JWS Unprotected Header Parameter names must be disjoint","mincutoff","eyeLookDown_R","Writer","image","boolean","mouthLeft","begin","algorithm.namedCurve","algorithm.name","utf-8","50CLOwBm","gte","get_high","timeout","oneOfSetter","fromNumber","webkitNow","getSettings","ECDH-ES+A192KW","read","push","mod","toJSONOptions","bytes","numTimes",'JWS "alg" (Algorithm) Header Parameter missing or invalid',"subarray","DEFAULT_MAX_PENDING","clearTimeout"," Received ","performance","playsInline","alpha","invalid encoding","charAt","eyeLookOut_R","jawRight","modelJSON","isset","Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, ","pool","_getScalerTriFeatureVectorDot","roll","eyeWide_L","floor","Reader","map","hasLastRawValue","-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoqnt8ovlPhSlFr2pKTeod2hshZ1hIXJj1mWhPj4EG3piVhflM3rK1YYtWEeAubOqolzOeODTYDXVGxdjd64cIKcXpHfEj5G0RirjcUmUrcoIagQMsPaAV/GcJXX9VVbrpWQnI7Spj7WlcMPhyofj6JHf0kvKChZN4ZG/UQouy4AbIWOtu5lxIw307JSkF1boS902tAycgNoCnX6YLDOTWKPPihkBB/zhJqeaTQbSki9ADan/94uddSGXiEsqljynrc6oxCAN7oYxz2URgNkA0cP/3gAYyoABWioxw8IEeLrDVV0OYOH/ZKGfcaovWI2m6n0+J03bwh3cP8oN7/u9qQIDAQAB-----END PUBLIC KEY-----","JWS Protected Header incorrect type","tail","browOuterUp_L","ERR_JOSE_NOT_SUPPORTED","skipType","isBusy","startScope","customModelMetaUrl","apiToken","raw","every","Long",'" MUST be integrity protected',"val","mouthDimple_L","_listeners","multiply","b64","rem","mouthSmile_L","fromBytes","iss","_predictionQuality","xor","onPredict","charCodeAt","getHighBitsUnsigned","width",'Extension Header Parameter "',"interior hyphen","exp","request must be specified","domainReentrant","P-256","NODE-ED448","getBinFileUrl","number","getVideoTracks","getLowBits","getModel","Compact JWS must be a string or Uint8Array","mouthStretch_L","private","toBytesLE","skipQueue","NODE-","reason","diffAmp","fromString","bool","JWS Signature missing or incorrect type","_tune","frameRateMs","24vHxpAB","setFrequency","versions","uint32","algorithm","userDefinedMetadata","isString","off","ES256","encrypt","isBuffer","forEach","requestAnimationFrame","setTimeout","mouthPress_L","unspecified","buffer","35370zlDqje","deriveBits","undefined","trainingConfig","warn","mouthRollLower","_start","call","uint64","then","transformY","msNow","LongBits","toLowerCase","protected","set","ES512","entries","readFloatBE","srcObject","clearTimeout has not been defined","toString","PBES2","state","create","toUpperCase","has","HMAC","SHA-","secs","_dataStream","minCutoff","resultsCallback","lastUpdateTime","onUpdate","iat",'unexpected "iss" claim value',"replace","hours","utf8Slice","min","setAlpha","getHighBits","greaterThanOrEqual","Stream has no video tracks","Module","check_failed","cancelVideoFrameCallback","float","illegal buffer","buf",'"exp" claim timestamp check failed',"count","setBeta","int32","83022sNCOuI","0.11.0","_slice","setVideoFrameCallback","P-521","decrypt","divide","ERR_JOSE_GENERIC","noseSneer_L","mouthShrugUpper","Invalid clockTolerance option type","weights","shru","init","rpcImpl","unshift","_startTime","rotationTune","skip","spki","name","isSet","from","Uint8Array",'unexpected "typ" JWT header value',"join","cancelAnimationFrame","equals",'unexpected "sub" claim value',"lastIndexOf","utf8","writeBytesBuffer","high","JWS Payload must be a string","faceMeshCalculator","shr","domain","mouthSmile_R","key32Re","sign","shiftRight","ERR_JOSE_ALG_NOT_ALLOWED","encode","fromInt","__esModule","getTime","fromARKitConvention","importKey","browInnerUp","getTracks","jawOpen","Flattened JWS must be an object","shr_u","endsWith","Start was called but stream was ","isEven","setOptions","type",'{"tris": [[[7, 8, 9, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 35, 46, 52, 53, 55, 56, 63, 65, 66, 68, 69, 70, 71, 104, 105, 107, 108, 110, 111, 112, 113, 117, 118, 119, 120, 121, 124, 128, 130, 133, 139, 143, 144, 145, 151, 153, 154, 155, 156, 157, 158, 159, 160, 161, 163, 168, 173, 189, 190, 193, 221, 222, 223, 224, 225, 226, 228, 229, 230, 231, 232, 233, 243, 244, 245, 246, 247, 468, 469, 470, 471, 472], [60, 51, 43, 79, 13, 0, 38, 39, 73, 74, 73, 39, 39, 41, 74, 75, 74, 41, 50, 51, 53, 60, 53, 51, 2, 48, 29, 30, 29, 48, 36, 37, 71, 72, 71, 37, 10, 11, 56, 57, 56, 11, 19, 53, 62, 60, 62, 53, 5, 4, 46, 47, 46, 4, 63, 61, 78, 77, 78, 61, 8, 55, 9, 54, 9, 55, 11, 80, 57, 79, 57, 80, 18, 63, 1, 59, 1, 63, 32, 35, 12, 70, 12, 35, 18, 64, 63, 61, 63, 64, 50, 7, 51, 33, 51, 7, 66, 16, 67, 17, 67, 16, 37, 38, 72, 73, 72, 38, 80, 34, 42, 69, 42, 34, 16, 28, 17, 20, 17, 28, 15, 25, 40, 52, 40, 25, 17, 20, 15, 25, 15, 20, 49, 3, 50, 7, 50, 3, 9, 54, 19, 53, 19, 54, 34, 40, 69, 14, 69, 40, 8, 10, 55, 56, 55, 10, 68, 15, 34, 40, 34, 15, 22, 24, 28, 27, 28, 24, 18, 29, 21, 22, 21, 29, 28, 27, 20, 23, 20, 27, 1, 2, 18, 29, 18, 2, 3, 49, 4, 47, 4, 49, 67, 17, 68, 15, 68, 17, 5, 46, 31, 58, 31, 46, 21, 22, 16, 28, 16, 22, 35, 36, 70, 71, 70, 36, 29, 30, 22, 24, 22, 30, 14, 45, 32, 57, 79, 58, 0, 58, 79, 21, 16, 65, 66, 65, 16, 21, 65, 18, 64, 18, 65, 42, 6, 13, 0, 13, 6, 25, 26, 52, 44, 52, 26, 79, 80, 13, 42, 13, 80, 47, 49, 55, 54, 55, 49, 56, 57, 46, 58, 46, 57, 55, 56, 47, 46, 47, 56, 20, 23, 25, 26, 25, 23, 32, 12, 14, 69, 14, 12, 49, 50, 54, 53, 54, 50, 51, 33, 43, 76, 43, 33, 62, 60, 76, 43, 76, 60, 52, 44, 45, 70, 71, 31, 5, 31, 71, 12, 6, 69, 42, 69, 6, 71, 72, 5, 4, 5, 72, 72, 73, 4, 3, 4, 73, 73, 74, 3, 7, 3, 74, 7, 74, 33, 75, 33, 74, 61, 62, 77, 76, 77, 62, 64, 19, 61, 62, 61, 19, 64, 65, 19, 9, 19, 65, 65, 66, 9, 8, 9, 66, 67, 10, 66, 8, 66, 10, 10, 67, 11, 68, 11, 67, 11, 68, 80, 34, 80, 68, 33, 75, 76, 77, 76, 75, 75, 41, 77, 78, 77, 41, 40, 52, 14, 45, 14, 52, 6, 31, 0, 58, 0, 31, 12, 70, 6, 31, 6, 70, 85, 13, 83, 83, 43, 85, 84, 55, 82, 82, 47, 84]], [[8, 9, 151, 168, 249, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 263, 265, 276, 282, 283, 285, 286, 293, 295, 296, 298, 299, 300, 301, 333, 334, 336, 337, 339, 340, 341, 342, 346, 347, 348, 349, 350, 353, 357, 359, 362, 368, 372, 373, 374, 380, 381, 382, 383, 384, 385, 386, 387, 388, 390, 398, 413, 414, 417, 441, 442, 443, 444, 445, 446, 448, 449, 450, 451, 452, 453, 463, 464, 465, 466, 467, 473, 474, 475, 476, 477], [52, 60, 45, 15, 79, 4, 40, 73, 41, 74, 41, 73, 41, 74, 43, 75, 43, 74, 51, 54, 52, 60, 52, 54, 1, 31, 2, 32, 2, 31, 38, 71, 39, 72, 39, 71, 12, 57, 13, 58, 13, 57, 21, 62, 54, 60, 54, 62, 7, 48, 6, 49, 6, 48, 63, 78, 61, 77, 61, 78, 10, 11, 56, 55, 56, 11, 13, 58, 80, 79, 80, 58, 20, 0, 63, 3, 63, 0, 34, 14, 37, 70, 37, 14, 20, 63, 64, 61, 64, 63, 51, 52, 9, 35, 9, 52, 66, 67, 18, 19, 18, 67, 39, 72, 40, 73, 40, 72, 80, 44, 36, 69, 36, 44, 18, 19, 30, 22, 30, 19, 17, 42, 27, 53, 27, 42, 19, 17, 22, 27, 22, 17, 50, 51, 5, 9, 5, 51, 11, 21, 55, 54, 55, 21, 36, 69, 42, 16, 42, 69, 10, 56, 12, 57, 12, 56, 68, 36, 17, 42, 17, 36, 24, 30, 26, 29, 26, 30, 20, 23, 31, 24, 31, 23, 30, 22, 29, 25, 29, 22, 0, 20, 1, 31, 1, 20, 5, 6, 50, 49, 50, 6, 67, 68, 19, 17, 19, 68, 7, 33, 48, 59, 48, 33, 23, 18, 24, 30, 24, 18, 37, 70, 38, 71, 38, 70, 31, 24, 32, 26, 32, 24, 16, 34, 47, 58, 59, 79, 4, 79, 59, 23, 65, 18, 66, 18, 65, 23, 20, 65, 64, 65, 20, 44, 15, 8, 4, 8, 15, 27, 53, 28, 46, 28, 53, 79, 15, 80, 44, 80, 15, 49, 56, 50, 55, 50, 56, 57, 48, 58, 59, 58, 48, 56, 49, 57, 48, 57, 49, 22, 27, 25, 28, 25, 27, 34, 16, 14, 69, 14, 16, 50, 55, 51, 54, 51, 55, 52, 45, 35, 76, 35, 45, 62, 76, 60, 45, 60, 76, 53, 47, 46, 70, 33, 71, 7, 71, 33, 14, 69, 8, 44, 8, 69, 71, 7, 72, 6, 72, 7, 72, 6, 73, 5, 73, 6, 73, 5, 74, 9, 74, 5, 9, 35, 74, 75, 74, 35, 61, 77, 62, 76, 62, 77, 64, 61, 21, 62, 21, 61, 64, 21, 65, 11, 65, 21, 65, 11, 66, 10, 66, 11, 67, 66, 12, 10, 12, 66, 12, 13, 67, 68, 67, 13, 13, 80, 68, 36, 68, 80, 35, 76, 75, 77, 75, 76, 75, 77, 43, 78, 43, 77, 42, 16, 53, 47, 53, 16, 8, 4, 33, 59, 33, 4, 14, 8, 70, 33, 70, 8, 85, 45, 83, 85, 15, 83, 84, 56, 82, 82, 49, 84]], [[0, 2, 11, 12, 13, 14, 15, 16, 17, 18, 37, 38, 39, 40, 41, 42, 43, 57, 61, 62, 72, 73, 74, 76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 95, 96, 97, 98, 106, 146, 164, 165, 167, 178, 179, 180, 181, 182, 183, 184, 185, 186, 191, 194, 200, 201, 202, 203, 204, 206, 207, 210, 212, 214, 216, 267, 268, 269, 270, 271, 272, 273, 287, 291, 292, 302, 303, 304, 306, 307, 308, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 324, 325, 326, 327, 335, 375, 391, 393, 402, 403, 404, 405, 406, 407, 408, 409, 410, 415, 418, 421, 422, 423, 424, 426, 427, 430, 432, 434, 436], [85, 116, 99, 25, 39, 57, 70, 0, 80, 10, 20, 0, 2, 80, 0, 2, 0, 20, 70, 80, 72, 10, 12, 20, 81, 72, 80, 21, 20, 12, 72, 81, 73, 12, 13, 21, 82, 73, 81, 22, 21, 13, 82, 113, 73, 22, 13, 54, 114, 73, 113, 55, 54, 13, 75, 86, 112, 15, 53, 26, 116, 112, 86, 57, 26, 53, 98, 73, 115, 38, 56, 13, 114, 115, 73, 55, 13, 56, 126, 125, 124, 68, 66, 67, 119, 124, 125, 61, 67, 66, 89, 90, 9, 29, 9, 30, 8, 9, 90, 8, 30, 9, 84, 104, 83, 24, 23, 44, 78, 83, 104, 18, 44, 23, 117, 121, 111, 58, 52, 63, 103, 111, 121, 43, 63, 52, 105, 120, 102, 46, 42, 62, 96, 97, 84, 36, 24, 37, 104, 84, 97, 44, 37, 24, 118, 89, 59, 60, 59, 29, 9, 59, 89, 9, 29, 59, 103, 97, 111, 43, 52, 37, 110, 111, 97, 51, 37, 52, 110, 97, 109, 51, 50, 37, 96, 109, 97, 36, 37, 50, 8, 90, 7, 8, 7, 30, 91, 7, 90, 31, 30, 7, 105, 72, 98, 46, 38, 12, 73, 98, 72, 13, 12, 38, 103, 76, 97, 43, 37, 16, 104, 97, 76, 44, 16, 37, 100, 79, 99, 40, 39, 19, 85, 99, 79, 25, 19, 39, 127, 123, 122, 69, 64, 65, 105, 106, 72, 46, 12, 47, 70, 72, 106, 10, 47, 12, 119, 125, 76, 61, 16, 67, 77, 76, 125, 17, 67, 16, 121, 119, 103, 63, 43, 61, 76, 103, 119, 16, 61, 43, 83, 79, 84, 23, 24, 19, 100, 84, 79, 40, 19, 24, 80, 71, 81, 20, 21, 11, 74, 81, 71, 14, 11, 21, 81, 74, 82, 21, 22, 14, 75, 82, 74, 15, 14, 22, 123, 127, 126, 65, 68, 69, 125, 126, 127, 67, 69, 68, 82, 75, 113, 22, 54, 15, 112, 113, 75, 53, 15, 54, 95, 96, 100, 35, 40, 36, 84, 100, 96, 24, 36, 40, 109, 96, 108, 50, 49, 36, 95, 108, 96, 35, 36, 49, 7, 91, 6, 7, 6, 31, 92, 6, 91, 32, 31, 6, 6, 92, 5, 6, 5, 32, 93, 5, 92, 33, 32, 5, 107, 108, 94, 48, 34, 49, 95, 94, 108, 35, 49, 34, 99, 94, 100, 39, 40, 34, 95, 100, 94, 35, 34, 40, 74, 87, 75, 14, 15, 27, 86, 75, 87, 26, 27, 15, 76, 77, 104, 16, 44, 17, 78, 104, 77, 18, 17, 44, 71, 88, 74, 11, 14, 28, 87, 74, 88, 27, 28, 14, 112, 116, 79, 53, 19, 57, 85, 79, 116, 25, 57, 19, 122, 98, 127, 64, 69, 38, 115, 127, 98, 56, 38, 69, 106, 101, 45, 47, 45, 41, 1, 45, 101, 1, 41, 45, 0, 70, 45, 0, 45, 10, 106, 45, 70, 47, 10, 45, 2, 3, 80, 2, 20, 3, 71, 80, 3, 11, 3, 20, 3, 4, 71, 3, 11, 4, 88, 71, 4, 28, 4, 11, 120, 105, 122, 62, 64, 46, 98, 122, 105, 38, 46, 64, 105, 102, 106, 46, 47, 42, 101, 106, 102, 41, 42, 47, 92, 108, 93, 32, 33, 49, 107, 93, 108, 48, 49, 33, 91, 109, 92, 31, 32, 50, 108, 92, 109, 49, 50, 32, 90, 110, 91, 30, 31, 51, 109, 91, 110, 50, 51, 31, 89, 111, 90, 29, 30, 52, 110, 90, 111, 51, 52, 30, 117, 111, 118, 58, 60, 52, 89, 118, 111, 29, 52, 60, 113, 112, 83, 54, 23, 53, 79, 83, 112, 19, 53, 23, 113, 83, 114, 54, 55, 23, 78, 114, 83, 18, 23, 55, 115, 114, 77, 56, 17, 55, 78, 77, 114, 18, 55, 17, 127, 115, 125, 69, 67, 56, 77, 125, 115, 17, 56, 67, 5, 93, 4, 5, 4, 33, 88, 4, 93, 28, 33, 4, 93, 107, 88, 33, 28, 48, 87, 88, 107, 27, 48, 28, 107, 94, 87, 48, 27, 34, 86, 87, 94, 26, 34, 27, 94, 99, 86, 34, 26, 39, 116, 86, 99, 57, 39, 26]], [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477], [0, 1, 36, 0, 36, 17, 1, 2, 41, 1, 41, 36, 2, 3, 31, 2, 31, 41, 3, 4, 48, 3, 48, 31, 4, 5, 48, 5, 6, 48, 6, 7, 59, 6, 59, 48, 7, 8, 58, 7, 58, 59, 8, 9, 56, 8, 56, 57, 8, 57, 58, 9, 10, 55, 9, 55, 56, 10, 11, 54, 10, 54, 55, 11, 12, 54, 12, 13, 54, 13, 14, 35, 13, 35, 54, 14, 15, 46, 14, 46, 35, 15, 16, 45, 15, 45, 46, 16, 26, 45, 17, 36, 18, 18, 37, 19, 18, 36, 37, 19, 38, 20, 19, 37, 38, 20, 39, 21, 20, 38, 39, 21, 39, 27, 22, 42, 23, 22, 27, 42, 23, 43, 24, 23, 42, 43, 24, 44, 25, 24, 43, 44, 25, 45, 26, 25, 44, 45, 27, 39, 28, 27, 28, 42, 28, 39, 29, 28, 29, 42, 29, 31, 30, 29, 30, 35, 29, 40, 31, 29, 35, 47, 29, 39, 40, 29, 47, 42, 30, 31, 32, 30, 32, 33, 30, 33, 34, 30, 34, 35, 31, 50, 32, 31, 40, 41, 31, 48, 49, 31, 49, 50, 32, 51, 33, 32, 50, 51, 33, 51, 34, 34, 52, 35, 34, 51, 52, 35, 46, 47, 35, 52, 53, 35, 53, 54, 36, 41, 37, 37, 40, 38, 37, 41, 40, 38, 40, 39, 42, 47, 43, 43, 47, 44, 44, 46, 45, 44, 47, 46, 48, 60, 49, 48, 59, 60, 49, 61, 50, 49, 60, 61, 50, 62, 51, 50, 61, 62, 51, 62, 52, 52, 63, 53, 52, 62, 63, 53, 64, 54, 53, 63, 64, 54, 64, 55, 55, 65, 56, 55, 64, 65, 56, 66, 57, 56, 65, 66, 57, 66, 58, 58, 67, 59, 58, 66, 67, 59, 67, 60, 60, 67, 61, 61, 66, 62, 61, 67, 66, 62, 66, 63, 63, 65, 64, 63, 66, 65, 21, 27, 22, 472, 33, 470, 470, 133, 472, 471, 159, 469, 469, 145, 471, 477, 362, 475, 477, 263, 475, 476, 386, 474, 474, 374, 476]]], "label_keys": [["browDown_L", "cheekSquint_L", "browOuterUp_L", "browDown_R", "browOuterUp_R", "cheekSquint_R", "browInnerUp"], ["eyeBlink_L", "eyeBlink_R", "eyeSquint_L", "eyeSquint_R", "eyeWide_L", "eyeWide_R"], ["eyeLookDown_L", "eyeLookDown_R", "eyeLookIn_L", "eyeLookIn_R", "eyeLookOut_L", "eyeLookOut_R", "eyeLookUp_L", "eyeLookUp_R"], ["jawOpen", "jawLeft", "jawRight", "mouthClose", "mouthFunnel", "mouthPucker", "mouthRollLower", "mouthRollUpper", "mouthShrugLower", "mouthShrugUpper", "noseSneer_L", "noseSneer_R"], ["mouthLeft", "mouthRight", "mouthSmile_L", "mouthSmile_R", "mouthFrown_L", "mouthFrown_R", "mouthDimple_L", "mouthDimple_R", "mouthStretch_L", "mouthStretch_R", "mouthPress_L", "mouthPress_R", "mouthLowerDown_L", "mouthLowerDown_R", "mouthUpperUp_L", "mouthUpperUp_R"]], "type": "multi_spur_dot", "data_min": [-0.0017550074262544513, -0.0015888019697740674, -0.0017187476623803377, -0.0027021938003599644, -0.00840499997138977, -0.012177195399999619, -0.006785913370549679, -0.011435691267251968, -0.009481549263000488, -0.011232671327888966, -0.005913160741329193, -0.006541644688695669, -0.004088891204446554, -0.0028658448718488216, 0.0008937628008425236, -0.0014253321569412947, -0.003379533998668194, -0.05247845500707626, -0.03722202777862549, -0.01632705330848694, -0.015382098965346813, -0.02333829551935196, -0.0063448259606957436, -0.006486705970019102, -0.026732610538601875, -0.002594631165266037, -0.0024819879326969385, -0.0011332901194691658, -0.014717886224389076, -0.020526109263300896, 0.0009483033209107816, -6.562717317137867e-05, 0.003971200902014971, -0.0025534299202263355, 0.005063787568360567, 8.11954087112099e-05, -0.013988249003887177, -0.006610263604670763, -0.0003309780149720609, 0.00545515026897192, -0.004532479215413332, -0.0015585519140586257, 0.002584811532869935, 0.002811002777889371, -0.020826643332839012, -0.0017957848031073809, -0.0023131167981773615, 0.0008118495461530983, -0.18270130455493927, -0.02499575726687908, -0.031774282455444336, 0.0010722535662353039, -0.0051225703209638596, -0.005623739678412676, -0.009153920225799084, 0.008124765940010548, -0.04908079281449318, -0.006196742877364159, -0.005988628137856722, 0.006428960710763931, 0.0003101342299487442, -0.00232656835578382, -0.001176844467408955, -0.00084810791304335, -0.006075503770262003, -0.02473851852118969, -0.015873298048973083, -0.01800304837524891, -0.008554470725357533, -0.02030240371823311, -0.004769818391650915, -0.013027854263782501, -0.005569886416196823, -0.002855725586414337, -0.02324126660823822, -0.0011017153738066554, -0.01515586581081152, -0.007202725391834974, -0.021577106788754463, -0.0047977459616959095, -0.015712302178144455, 0.0018171507399529219, -0.04218415543437004, 0.003599596442654729, -0.008515105582773685, 0.003922000527381897, -0.03360369801521301, 0.004381608683615923, -0.0012833441141992807, -0.0011298761237412691, -0.0034428401850163937, -0.0007926009711809456, -0.007261634338647127, -0.025431213900446892, -0.0021018001716583967, 0.0012902612797915936, -0.00821943674236536, 0.0015087845968082547, -0.03998952358961105, 0.003925271797925234, -0.00425840076059103, -0.004315055441111326, -0.0050179981626570225, -0.0028619857039302588, -0.004568891599774361, -0.0025188063737004995, -0.018748672679066658, 0.0018272872548550367, -0.03501500189304352, -0.060936089605093, -0.06657426059246063, -0.07045453786849976, -0.05476086586713791, 0.013215681537985802, -0.033690210431814194, 0.028368977829813957, -0.03590276837348938, -0.06219175085425377, -0.05718810483813286, -0.09179447591304779, -0.049490347504615784, 0.003276834264397621, -0.2224636822938919, 0.005630712490528822, -0.004936552606523037, 0.0021044814493507147, -0.0023064170964062214, 0.000921845727134496, -0.0016314919339492917, -0.0032274883706122637, -0.014002657495439053, 0.0007550256559625268, -0.004097432363778353, -0.004856402985751629, -0.0015870482893660665, -0.0033077180851250887, -0.016597673296928406, 0.005158626474440098, -0.03445936739444733, 0.00545958336442709, -0.022790541872382164, -0.011063412763178349, -0.01793551817536354, -0.00035710117663256824, -0.03299255669116974, -0.05196274071931839, -0.049705177545547485, -0.06774846464395523, -0.01917189545929432, 0.004815578460693359, -0.012143676169216633, -0.0023987065069377422, 0.0005946963792666793, -0.001411741366609931, 7.520611688960344e-05, -0.013843615539371967, 0.014278718270361423, 0.001808188739232719, -0.06429895013570786, -0.003280320903286338, -0.022841110825538635, -0.017019130289554596, 0.00048229319509118795, -0.00966423936188221, -0.004826822783797979, -0.0011247374350205064, -0.041764434427022934, -0.10759850591421127, -0.04113900661468506, -0.12872539460659027, -0.002331000519916415, -0.007355756126344204, -0.007285710424184799, 9.530829265713692e-05, 0.001222519320435822, -0.005669853650033474, 0.0021250322461128235, -0.004807861056178808, -0.01985650695860386, -0.00402058707550168, 0.0022181477397680283, -0.00294042332097888, 0.0011985059827566147, -0.005299006123095751, 0.004811618942767382, -0.005190132185816765, -0.04117422178387642, -0.09933539479970932, -0.062477342784404755, -0.13131371140480042, -0.028346074745059013, -0.004036494065076113, -0.007280837744474411, -0.00048430555034428835, -0.005807450041174889, -0.0051109096966683865, 0.002538948552682996, -0.004422084894031286, -3.6005385481985286e-05, -0.0023883762769401073, -0.004277486819773912, -0.0021956029813736677, -0.005624614655971527, -0.0037700277753174305, 0.0009276365162804723, 0.0012946042697876692, -0.00729520944878459, -0.0934818908572197, -0.013185937888920307, -0.006523772142827511, -0.01293903961777687, -0.002899773186072707, -0.012736348435282707, -0.013921556994318962, -0.0031980155035853386, -0.00262717017903924, -0.013627937063574791, -0.013069857843220234, -0.010410521179437637, -0.00437180744484067, -0.008226401172578335, -0.011711595579981804, -0.003236369928345084, -0.002269494580104947, -0.005061361473053694, -0.009619944728910923, -0.004189006984233856, -0.00493813119828701, 0.001313506276346743, -0.0005794925382360816, -0.0007508127600885928, -0.00255648628808558, -0.008849035948514938, 0.0015626826789230108, 0.002015381818637252, 0.003440193133428693, -0.0169757679104805, 0.008412284776568413, -0.0024139813613146544, 0.007210076320916414, 0.004792986903339624, -0.024742357432842255, 0.0032899959478527308, -0.0026013581082224846, 0.011801465414464474, -0.009576565586030483, 0.010437027551233768, -0.002092166803777218, -0.011856031604111195, -0.009130856953561306, -0.005431095138192177, -0.009956598281860352, -0.0008372836746275425, -0.0015743045369163156, -0.006356232333928347, -0.002174090128391981, -0.0005838467041030526, -0.0015569630777463317, -0.01587550714612007, 0.0004350940871518105, 0.0016732083167880774, -0.0030427975580096245, -0.0050909495912492275, -0.004462432581931353, -0.0017954494105651975, 0.002329146256670356, -0.0049954853020608425, 0.0029943769332021475, -0.023720422759652138, 0.010021002031862736, -0.04896392300724983, 0.00955036748200655, -0.003149070544168353, -0.003595980117097497, -0.0044156694784760475, -0.00015828415052965283, -0.007738469168543816, -0.0006288129952736199, -0.007669622078537941, 0.0032958819065243006, -0.015032083727419376, -0.06351669132709503, -0.032248154282569885, -0.18025453388690948, -0.06163984164595604, -0.09758920222520828, -0.05956967547535896, -0.15200407803058624, -0.001096255611628294, -0.00139527244027704, -0.0028954821173101664, -0.002875474514439702, -0.011264363303780556, -0.014317790977656841, -0.010434065014123917, -0.01481181662529707, -0.011153372935950756, -0.007928225211799145, -0.005756193306297064, -0.006947657559067011, -0.0035682523157447577, -0.00456055486574769, -0.0018615118460729718, 0.0007266966858878732, -0.061812303960323334, -0.007415087893605232, -0.08674275130033493, -0.04630497470498085, -0.02018740214407444, -0.02930389530956745, -0.0054146163165569305, -0.019008932635188103, -0.001769978436641395, -0.030524788424372673, -0.00014460454985965043, -0.005722136236727238, -0.019330516457557678, -0.013080030679702759, -0.0005406397976912558, 0.0006768343737348914, -0.003592651104554534, -0.00011539365368662402, -0.0007877812604419887, 0.001867897342890501, -0.004998684860765934, -0.018355347216129303, 0.0033769430592656136, -0.002138799522072077, 0.005226228851824999, -0.0060445996932685375, 0.00563605735078454, 0.0006765238358639181, -0.004361319821327925, -0.025803610682487488, 0.000510705285705626, -0.0015869643539190292, -0.03488793224096298, -0.17181245982646942, -0.005682847928255796, -0.03906115144491196, -0.0038437219336628914, -0.0062820790335536, 0.0022861266043037176, -0.004289176315069199, -0.007193434052169323, -0.036163829267024994, -0.003429545322433114, -0.006793618202209473, -0.0032077347859740257, 0.00011159323912579566, -0.0019818281289190054, -0.001566017046570778, -0.004464716650545597, -0.006538650020956993, 0.001966161886230111, -0.017514653503894806, -0.015502318739891052, -0.02005508542060852, -0.00971568189561367, -0.01379891112446785, -0.002751927822828293, -0.007097617257386446, -0.0010141932871192694, -0.022898994386196136, 0.011320621706545353, -0.01667596586048603, 0.013757219538092613, -0.023103035986423492, -0.002773732878267765, -0.011905886232852936, -0.0027192996349185705, -0.03863510489463806, 0.0026216416154056787, -0.010501322336494923, 0.003675147658213973, -0.036132875829935074, 0.0014550071209669113, -0.0018736012279987335, 0.0019570349249988794, -0.004570788703858852, -0.024695543572306633, -0.0070677087642252445, 0.0015389658510684967, -0.0015470845391973853, -0.0017567910254001617, -0.01030063722282648, -0.0004982421523891389, -0.03609298914670944, -0.002823418006300926, -0.010021904483437538, -0.000822446309030056, -0.008871868252754211, -0.004276425112038851, -0.0027345081325620413, -0.00210174429230392, -0.03211423382163048, -0.1239132508635521, -0.03809807822108269, -0.22577586770057678, -0.06880004703998566, 0.006170286331325769, -0.046202756464481354, 0.01874195598065853, -0.031128570437431335, -0.14452524483203888, -0.03727085888385773, -0.19164685904979706, -0.05660000815987587, -0.005821654573082924, -0.07455462217330933, -0.012828732840716839, -0.17196810245513916, 0.006120102945715189, -0.005307846236974001, 0.0050476123578846455, -0.0035822747740894556, -0.004437021445482969, -0.004186282865703106, -0.001121386419981718, -0.013540775515139103, -0.0007832555565983057, -0.004128068685531616, -0.002604132052510977, -0.0006470903754234314, 0.00934524368494749, -0.020768797025084496, 0.02071642130613327, -0.036626044660806656, -0.015338278375566006, -0.018702659755945206, -0.0023613718803972006, -0.014420952647924423, -0.09450634568929672, -0.041014645248651505, -0.15458405017852783, -0.04692044109106064, 0.0024283176753669977, -0.020913168787956238, -0.0030568446964025497, -0.011409053578972816, -0.0018502924358472228, -8.079489634837955e-05, -0.01686715893447399, -0.004737157374620438, 0.007374128792434931, 0.015073728747665882, -0.021714771166443825, -0.04924936220049858, -0.028673412278294563, 0.0005148854106664658, -0.010022389702498913, 0.0009542204206809402, -0.0022619464434683323, -0.004738507326692343, -0.20920825004577637, -0.053124573081731796, -0.1343402862548828, -0.04354647919535637, -0.009980801492929459, -0.0014624247560277581, 0.00033216102747246623, -0.00853058136999607, -0.007161133456975222, 0.0016002418706193566, -0.00674074562266469, 0.004149973392486572, -0.0049417936243116856, -0.01840830408036709, -0.003805524669587612, 0.0006072089308872819, -0.0068114749155938625, 0.002082789782434702, -0.007076718844473362, 0.004669892136007547, -0.15106898546218872, -0.04195433109998703, -0.19100460410118103, -0.06171984225511551, -0.0033198946621268988, -0.024084772914648056, -0.0021770154125988483, -0.010920047760009766, -0.00709277531132102, -0.003812472801655531, -0.005868278909474611, 0.0023881052620708942, -0.0023940149694681168, -5.4608844948234037e-05, -0.001964323688298464, -0.003951669670641422, -0.003661360824480653, -0.004194484557956457, 0.0006211569416336715, -0.0007705226889811456, -0.14360688626766205, -0.006210861727595329, -0.007739512249827385, -0.008927994407713413, -0.003718102350831032, -0.0090349605306983, -0.01290854997932911, -0.004998357966542244, -0.004569604992866516, -0.0022221889812499285, -0.011524578556418419, -0.0159295666962862, -0.0012933453544974327, -0.011573835276067257, -0.011216502636671066, -0.012415648438036442, -0.0023467191495001316, -0.0053845904767513275, -0.006211387924849987, -0.007682466879487038, -0.0036011007614433765, -0.004763314966112375, -0.0021101797465234995, 0.0010817794827744365, -0.005372007843106985, -0.0014367243275046349, 0.001060896785929799, -0.0074447025544941425, 0.0025269915349781513, 0.0007522053783759475, 0.004856477957218885, -0.007255106698721647, 0.0055701700039207935, -0.0031268696766346693, -0.023120691999793053, 0.006284522358328104, -0.0017701038159430027, 0.0038350927643477917, -0.008014312945306301, 0.009922790341079235, -0.0014460731763392687, 0.008490183390676975, 0.0021334330085664988, -0.009615948423743248, 0.0011934987269341946, -0.004463811870664358, 0.0006682063103653491, -0.002030304167419672, 0.0012410152703523636, -0.005908595863729715, -0.0028675224166363478, 0.00019662964041344821, -0.0004395789874251932, -0.022811641916632652, -0.002813180675730109, 0.0007484991801902652, -0.0050108544528484344, -0.006222299300134182, 0.00028754191589541733, -0.003109501674771309, -0.0002497186360415071, -0.008227615617215633, 0.0012362507404759526, -0.01818208023905754, -0.0004104207328055054, -0.047850366681814194, -0.004527592565864325, -0.0020121841225773096, 2.5093655494856648e-05, -0.00423873495310545, -0.0010890704579651356, -0.004439406096935272, 0.0007468892727047205, -0.005535487551242113, -0.029513470828533173, -0.07137080281972885, -0.010449573397636414, -0.06309930980205536, -0.07058767974376678, -0.17850437760353088, -0.06531018763780594, -0.0978664979338646, -0.006045295391231775, -0.005661287344992161, -0.004807377699762583, -0.005653973203152418, 0.0055648935958743095, -0.005067060701549053, -0.005116194020956755, 0.0033998049329966307, 0.004790185485035181, -0.0026523973792791367, -0.003076146822422743, 0.0032513479236513376, -0.01402913685888052, 0.0028308462351560593, -0.0016663633286952972, -0.0158160962164402, -0.0030019800178706646, 0.0009702600655145943, -0.0011858252109959722, -0.001725122332572937, -0.010960761457681656, 0.0012620642082765698, -0.00041617784881964326, -0.006936001591384411, -0.000968805281445384, 0.0006372143398039043, -0.00011386282130843028, -0.0007841656915843487, 0.00041235960088670254, -0.00772911636158824, -0.006658187136054039, 4.0546619857195765e-05, 0.0010429632384330034, -0.008548825047910213, -0.006776439491659403, 0.0009567182860337198, -0.0046468693763017654, -0.0005580070428550243, -0.00044720774167217314, -0.007303833030164242, -0.0016883499920368195, -0.0002393221657257527, -0.00016272826178465039, -0.0008628210052847862, -0.01528827752918005, -0.04696725308895111, -0.04328825697302818, -0.017725083976984024, -0.013940648175776005, -0.03673973307013512, -0.0376172699034214, -0.019602665677666664, -0.01371542178094387, 0.03389925882220268, 0.03171230107545853, -0.006756296381354332, 0.020775265991687775, 0.018827250227332115, 0.019953398033976555, 0.020913492888212204, -0.014863859862089157, -0.06588846445083618, -0.067988820374012, -0.018099281936883926, -0.023277945816516876, -0.0762646272778511, -0.06295018643140793, -0.01959771290421486, -0.007107370533049107, 0.00014098981046117842, 0.0001657917455304414, -0.006901054177433252, -0.010065849870443344, 0.000545539369340986, 0.0008877046639099717, -0.009749294258654118, 0.01933789998292923, -0.006816227920353413, -0.010929225943982601, 0.028245653957128525, 0.017888268455863, -0.002430209657177329, -0.007239288184791803, 0.020528949797153473, 0.022753342986106873, -0.028654687106609344, -0.028138337656855583, 0.020207542926073074, -0.006661432795226574, 0.0014252347173169255, 0.0005114582017995417, -0.006003751419484615, -0.00836870726197958, 0.0019027983071282506, 0.0013873932184651494, -0.00830660481005907, -0.005349602550268173, 0.016998272389173508, 0.016633981838822365, -0.00483625428751111, 0.0027292652521282434, 0.012664729729294777, 0.012340669520199299, 0.0034173615276813507, -0.01711096242070198, -0.06766404956579208, -0.056872665882110596, -0.017429541796445847, -0.023178614675998688, -0.07428869605064392, -0.08287251740694046, -0.023087764158844948, 0.0009956430876627564, -0.015787316486239433, -0.016686467453837395, -0.001452335505746305, 0.0004431893758010119, -0.002495462540537119, -0.0031423072796314955, -0.0008392774034291506, 0.004603215958923101, -0.008040600456297398, -0.010952301323413849, 0.0023781093768775463, 0.004196403082460165, -0.005828905384987593, -0.007322467397898436, 0.0023391975555568933, -0.014215744100511074, -0.04533449187874794, -0.041230764240026474, -0.01375406514853239, -0.013538516126573086, -0.034997716546058655, -0.03780592605471611, -0.014576926827430725, -0.049390438944101334, -0.01738622598350048, -0.019763343036174774, -0.04363982006907463, -0.044301122426986694, -0.01634133793413639, -0.016169728711247444, -0.059706948697566986, -0.0004388031375128776, -0.005225528497248888, -0.0043638297356665134, -0.0004663611180149019, -3.061230745515786e-05, -0.0023387824185192585, -0.00286985095590353, 2.936377677542623e-05, 0.00918550044298172, 0.020199058577418327, 0.02824549935758114, 0.01444602757692337, -0.07582846283912659, -0.039788272231817245, -0.036580491811037064, -0.10252363979816437, -0.04883879795670509, -0.02264079824090004, -0.027699651196599007, -0.09117710590362549, 0.03240462392568588, -0.007947408594191074, -0.00949480477720499, 0.03050868771970272, 0.028644803911447525, -0.00520807970315218, -0.005842485465109348, 0.027817944064736366, 0.029159149155020714, -0.007168091833591461, -0.011589918285608292, 0.032167691737413406, 0.02241133153438568, -0.00315028871409595, -0.0036084619350731373, 0.025336820632219315, -0.007219528313726187, 0.0005717524909414351, 0.00029486624407581985, -0.007270591799169779, -0.004822599235922098, -1.6687314200680703e-05, -0.00022568815620616078, -0.005906475242227316, -0.013400690630078316, 0.0009048269712366164, -0.0008720164187252522, -0.012498537078499794, -0.0038177594542503357, 0.0003958342131227255, -0.0005065423902124166, -0.005072413943707943, -0.0072682942263782024, -0.0015056958654895425, -0.0021522503811866045, -0.0085648437961936, -0.0028109767008572817, -0.0015007847687229514, -0.0011184073518961668, -0.0015273081371560693, -0.03966642543673515, 0.0841207206249237, 0.08589240163564682, -0.027911560609936714, 0.025170082226395607, 0.0578308068215847, 0.059659574180841446, 0.03880349174141884, -0.011483533307909966, 0.0007374511915259063, -0.0005013322224840522, -0.006271709222346544, -0.0007398260058835149, 0.0004977225326001644, -0.000291619187919423, -0.0004558905493468046, -0.0022692917846143246, -0.00031230287277139723, -0.0004854651924688369, -0.0029451348818838596, -0.006115255877375603, 0.0009175703162327409, 0.0006290946039371192, -0.005320174153894186, -0.0017410111613571644, -0.01197733636945486, -0.010226906277239323, -0.0016034391010180116, -0.0013423492200672626, -0.0061634862795472145, -0.005252036731690168, -0.0009041364537551999, 0.004599188454449177, -0.006844657473266125, -0.009581747464835644, 0.003590831533074379, 0.003592825261875987, -0.005524179898202419, -0.0055524129420518875, 0.003020654199644923, 0.0026109092868864536, -0.006911212578415871, -0.005778111517429352, 0.002397613599896431, -0.0002256018779007718, -0.003424223978072405, -0.001954244449734688, 0.00011693056876538321, -0.0027809871826320887, -0.0006996587035246193, -0.0006883858586661518, -0.0023617022670805454, -0.004836219362914562, 6.748591113137081e-05, 4.0136823372449726e-05, -0.003559766337275505, -0.0005596810951828957, -0.004184838384389877, -0.0028487129602581263, -0.00032399402698501945, -0.0012840424897149205, -0.007020408287644386, -0.004513151478022337, -0.0007841573096811771, -0.007233802229166031, -0.0019782988820225, -0.0016112641897052526, -0.008746213279664516, -0.003379994770511985, -0.0016046288656070828, -0.0009218735503964126, -0.0061158002354204655, -0.06569132208824158, -0.016457105055451393, -0.016147594898939133, -0.07335231453180313, -0.03360828757286072, -0.016747821122407913, -0.016171732917428017, -0.040471918880939484, -0.010333070531487465, -0.001599182141944766, -0.002680606907233596, -0.013598616234958172, -0.004086735192686319, -0.00189745775423944, -0.001847253879532218, -0.006739071104675531, -0.0034283380955457687, 5.0362312322249636e-05, 0.0003793757641687989, -0.002326889894902706, 7.323188765440136e-05, 0.0006063703913241625, 0.0006077517173253, 4.0592672689854226e-07, 0.0035124323330819607, 0.01089155301451683, 0.015240035019814968, 0.0042736041359603405, 0.003887722035869956, 0.01859378069639206, 0.021623743698000908, 0.0034113407600671053, -0.007972557097673416, 0.011656898073852062, 0.01042073406279087, -0.00573944253847003, -0.005246983841061592, 0.011213698424398899, 0.011503457091748714, -0.003049667924642563, -0.07616200298070908, -0.013729897327721119, -0.01472389418631792, -0.10297046601772308, -0.07364169508218765, -0.013666439801454544, -0.01475105993449688, -0.10152357816696167, -0.006708221975713968, 0.005982368253171444, 0.006099741905927658, -0.006404302082955837, -0.003269408131018281, 0.004696938209235668, 0.004777426365762949, -0.0042374590411782265, -0.007772132754325867, 0.00143259740434587, 0.002181034069508314, -0.009460732340812683, -0.006562178023159504, 0.00046114245196804404, 0.00047662912402302027, -0.008317760191857815, 0.035505231469869614, -0.006239328999072313, -0.010590475983917713, 0.03587409853935242, 0.02186494879424572, 0.009203917346894741, -0.0014413496246561408, 0.02226690761744976, -0.01060116570442915, 0.02647348865866661, 0.02396969124674797, -0.006268142722547054, -0.010061622597277164, 0.035051748156547546, 0.03929473087191582, -0.0023070552852004766, -6.426733307307586e-05, -0.008624549023807049, -0.008426294662058353, -0.00034232932375743985, 2.3171362045104615e-05, -0.0036035089287906885, -0.0034748432226479053, 0.00011241766333114356, 2.5616642233217135e-05, -0.01336352527141571, -0.014813861809670925, -0.0008253547130152583, 0.0001553465990582481, -0.004811761435121298, -0.006928318180143833, 0.0003864490718115121, 0.0012765225255861878, -0.01704893819987774, -0.016908487305045128, -0.0016229844186455011, 2.8652348191826604e-05, -0.006605285685509443, -0.010170716792345047, -0.001410383847542107, -0.062245018780231476, -0.027189016342163086, -0.03072996251285076, -0.08479258418083191, -0.03646257147192955, -0.02014448493719101, -0.02259751968085766, -0.03307178243994713, -0.005343543365597725, 0.018728775903582573, 0.024783464148640633, -0.006328159477561712, 0.0021016444079577923, 0.01549041923135519, 0.019102193415164948, 0.0005087766330689192, -0.0054718670435249805, -0.000341697916155681, -0.00041323958430439234, -0.004589085001498461, -0.00043313446803949773, 0.0005452987970784307, 0.0006272486643865705, -0.00020728804520331323, 0.0005605931510217488, -0.004252469167113304, -0.0035884238313883543, 0.00024493830278515816, 0.001367409829981625, -0.008794465102255344, -0.00854357611387968, 0.0007034845184534788, -0.015769651159644127, -0.055282946676015854, -0.06119707226753235, -0.018377184867858887, -0.022471023723483086, -0.0521090105175972, -0.06277498602867126, -0.01807698979973793, -0.022325003519654274, 0.032900139689445496, 0.03312921151518822, -0.023631177842617035, 0.008489558473229408, 0.02198556251823902, 0.022638360038399696, 0.012833341024816036, -0.10092896968126297, -0.007863509468734264, -0.0078087192960083485, -0.09635179489850998, -0.012055609375238419, -0.007382173091173172, -0.006888116709887981, -0.0079734418541193, -0.17152728140354156, -0.006571047939360142, -0.006926593370735645, -0.14787603914737701, -0.0032189073972404003, -0.005765177309513092, -0.00611438974738121, -0.0031016694847494364, -0.1725601851940155, -0.004838674329221249, -0.005547360982745886, -0.1725870966911316, 0.0008443516562692821, -0.004096240270882845, -0.004509693942964077, -0.0002680102188605815, -0.12231101095676422, -0.005086295306682587, -0.005986839532852173, -0.13405992090702057, 0.0007216954254545271, -0.0031789622735232115, -0.003750934498384595, 9.101020259549841e-05, -0.07394794374704361, 0.01898699626326561, 0.0784023329615593, -0.008211439475417137, -0.10013681650161743, 0.01707828789949417, -0.055859945714473724, 0.004363321233540773, -0.1429523229598999, 0.20962825417518616, 0.30189764499664307, -0.14085352420806885, 0.006279100198298693, 0.0266476608812809, -0.1141248568892479, 0.14827358722686768, -0.005405576899647713, 0.04045424982905388, 0.05865837633609772, 0.058835990726947784, 0.09641452878713608, 0.027323829010128975, -0.0031988564878702164, -0.025808481499552727, 0.2807534337043762, 0.6693254113197327, 0.37055957317352295, -0.05712592974305153, -0.003276233095675707, 0.025898050516843796, -0.24270524084568024, 0.5921747088432312, -0.6957690715789795, 0.2319674789905548, 0.07611296325922012, -0.00644589401781559, -0.06195696443319321, -0.02550996094942093, 0.9649220108985901, -0.05507628992199898, 0.10060697793960571, -0.13770614564418793, -0.018686190247535706, 1.284175992012024, -0.04201856628060341, 1.316433072090149, -0.06736090779304504, 0.5376058220863342, -0.8982057571411133, 0.3340030610561371, -0.002154209418222308, 0.7263802289962769, -0.06095598638057709, -0.35455194115638733, -0.004409575369209051, 0.11899102479219437, -0.5837915539741516, 0.5059089660644531, 0.1672084778547287, -0.30817002058029175, 0.25577312707901, -0.347360223531723, -0.19340364634990692, -0.01487851794809103, 0.0963641032576561, -0.21059150993824005, 0.003939735237509012, -0.04660046473145485, -0.05789317935705185, 0.0013987553538754582, -0.2402401864528656, 0.9873924255371094, -0.027747323736548424, -0.03686317428946495, 0.5323299169540405, -0.7375632524490356, 0.247849240899086, -0.02701573632657528, -0.06063912808895111, 0.31797051429748535, 0.36898118257522583, -0.026747683063149452, -0.18201202154159546, -0.17546416819095612, 0.2671070992946625, 0.009929713793098927, 0.10489723086357117, -0.11290787905454636, 0.19573774933815002, -0.27427592873573303, 0.006807482335716486, -0.04950438067317009, 0.32612308859825134, -0.08895852416753769, -0.0880751758813858, 0.3880513608455658, 0.3359605073928833, -0.017861258238554, -0.0338505394756794, 0.39399394392967224, 0.012797990813851357, -0.021994592621922493, -0.031668566167354584, 0.008746340870857239, 0.33820170164108276, -0.2321101576089859, -0.04773007705807686, 0.046494558453559875, -0.06026547774672508, -0.05482165142893791, -0.4393479824066162, 0.2682640552520752, -0.3505781888961792, 0.9110074043273926, 0.9436298608779907, -0.20858818292617798, -0.059400320053100586, 0.061031524091959, 0.045665327459573746, -0.1395794153213501, -0.450369268655777, 0.5726431012153625, -0.12002208083868027, 0.011141400784254074, 0.013398603536188602, -0.04891210049390793, 0.05766274780035019, -0.13170713186264038, -0.2509750723838806, 0.17947393655776978, -0.1075071468949318, 0.1182883158326149, 0.3896220326423645, 0.14173883199691772, -0.08669650554656982, -0.2050056755542755, 0.32954421639442444, -0.47129255533218384, -0.03835580125451088, 0.06468944996595383, -0.013088957406580448, -0.06356703490018845, -0.14633439481258392, 0.022571904584765434, -0.03487197682261467, -0.054408036172389984, -0.0021362064871937037, -0.016524236649274826, -0.033146247267723083, -0.0031798246782273054, -0.0019636666402220726, -0.02372274547815323, 0.24607069790363312, -0.10825299471616745, 0.023242169991135597, -0.049140945076942444, 0.42635753750801086, -0.0752435252070427, -0.47220492362976074, 0.20920124650001526, 0.011527356691658497, 0.0031455920543521643, -0.009182516485452652, 0.004422810859978199, 0.009970464743673801, 0.005533569026738405, -0.07238771766424179, 0.03134161978960037, -0.062168776988983154, 0.10902909189462662, -0.0229549128562212, -0.003442106768488884, 0.14196990430355072, 0.23318608105182648, -0.0014517403906211257, -0.01359589397907257, 0.5067964792251587, -0.04042511805891991, 0.4921152591705322, 0.15805912017822266, 0.014073921367526054, 0.34256136417388916, 0.28166770935058594, -0.5545210242271423, -0.00631805881857872, -0.011597431264817715, 0.17966437339782715, -0.027621205896139145, -0.09016994386911392, 0.5330501794815063, -0.03540848195552826, 0.00283635500818491, 0.5983527898788452, 0.12992610037326813, 0.7187473773956299, -0.47408565878868103, -0.6846879124641418, 0.030332067981362343, 0.7610382437705994, 0.02657151035964489, 0.8967934250831604, 0.04059344530105591, 0.5247260332107544, -0.024696731939911842, 0.14641518890857697, -0.8374667763710022, -0.19611681997776031, -0.14699965715408325, -0.23048052191734314, 0.2608278691768646, -0.018463974818587303, -0.008795540779829025, -0.29646384716033936, 0.004307615105062723, -0.002931284951046109, -0.012486997060477734, -0.00398692162707448, -0.02745361626148224, -0.010179318487644196, -0.02978643961250782, -0.009584405459463596, -0.02363409474492073, -0.005882218014448881, -0.011731592006981373, -0.003569596679881215, -0.012929435819387436, -0.01146947592496872, -0.02493930049240589, -0.011636428534984589, -0.028100116178393364], "data_max": [0.008349306881427765, 0.005672150757163763, 0.014356470666825771, 0.02379765547811985, 0.06808670610189438, 0.051368679851293564, 0.05698595941066742, 0.055431921035051346, 0.046252913773059845, 0.05065183714032173, 0.039162248373031616, 0.053484514355659485, 0.02072051353752613, 0.10316137969493866, 0.06896251440048218, 0.04357532039284706, 0.6764539480209351, 1.513785481452942, 1.2356493473052979, 0.7237898111343384, 0.14310680329799652, 0.09747528284788132, 0.10897786915302277, 0.10122590512037277, 0.03539795055985451, 0.31710758805274963, 0.05534624308347702, 0.25714215636253357, 0.1061478927731514, 0.05987474322319031, 0.06965920329093933, 0.044535547494888306, 0.05982903391122818, 0.05053604394197464, 0.05826690047979355, 0.04762769863009453, 0.11541672796010971, 0.1317714899778366, 0.08735601603984833, 0.1195395365357399, 0.3974659740924835, 0.06514158844947815, 0.3676466941833496, 0.0614975243806839, 0.03144760802388191, 0.1769673079252243, 0.03816024959087372, 0.1311076581478119, 0.20745962858200073, 0.6800547242164612, 0.2049279361963272, 0.4648285210132599, 0.18801157176494598, 0.11124785989522934, 0.0899101197719574, 0.18225827813148499, 0.1674463450908661, 0.2703116238117218, 0.17656309902668, 0.16157472133636475, 0.033622995018959045, 0.02541462332010269, 0.02733018808066845, 0.03221754729747772, 0.18345117568969727, 0.09031009674072266, 0.14199095964431763, 0.13315033912658691, 0.09469197690486908, 0.059229422360658646, 0.0890376940369606, 0.05771556869149208, 0.03330990672111511, 0.07355577498674393, 0.01829608716070652, 0.09782955795526505, 0.08069887012243271, 0.1352771520614624, 0.07236023992300034, 0.1625991314649582, 0.10591074079275131, 0.2284781038761139, 0.07852916419506073, 0.2589837610721588, 0.07984018325805664, 0.14050664007663727, 0.07740873843431473, 0.17834687232971191, 0.033743999898433685, 0.04762502759695053, 0.03344056010246277, 0.0511842742562294, 0.2885180711746216, 0.06120173633098602, 0.21099472045898438, 0.07125423103570938, 0.05900163948535919, 0.1249275952577591, 0.03128783404827118, 0.17900227010250092, 0.08209634572267532, 0.4112873673439026, 0.08187774568796158, 0.3932150900363922, 0.15663687884807587, 0.1418062150478363, 0.06559181958436966, 0.23211146891117096, 1.0302798748016357, 0.37175142765045166, 0.9141867756843567, 0.4938003718852997, 0.08577699959278107, 0.30230313539505005, 0.05921987071633339, 0.29368525743484497, 0.8957617282867432, 0.22073514759540558, 0.894860565662384, 0.37379610538482666, 0.18016254901885986, 1.0419650077819824, 0.17946967482566833, 1.2297052145004272, 0.03127046674489975, 0.056422095745801926, 0.041047289967536926, 0.048244260251522064, 0.17171093821525574, 0.0998927503824234, 0.12752032279968262, 0.15131548047065735, 0.04750961810350418, 0.050682805478572845, 0.06080193817615509, 0.03900217264890671, 0.058593638241291046, 0.18033914268016815, 0.05392996966838837, 0.20760226249694824, 0.14634232223033905, 0.15446126461029053, 0.09049750119447708, 0.19762638211250305, 1.1127889156341553, 0.5309557318687439, 1.0771925449371338, 0.4915632903575897, 0.15900449454784393, 0.26576289534568787, 0.016284963116049767, 0.09554287046194077, 0.04012329503893852, 0.05125878006219864, 0.21054545044898987, 0.23178435862064362, 0.1843944489955902, 0.24094857275485992, 0.1341746747493744, 0.34199368953704834, 0.24493078887462616, 0.20733551681041718, 0.03723606839776039, 0.021061444655060768, 0.024686943739652634, 0.047101013362407684, 1.1957427263259888, 0.4238695502281189, 1.3375520706176758, 0.25563547015190125, 0.09655347466468811, 0.02356044016778469, 0.022419696673750877, 0.07240051031112671, 0.06122269853949547, 0.3062049150466919, 0.08921023458242416, 0.27765607833862305, 0.031178487464785576, 0.20449167490005493, 0.05928901210427284, 0.14307810366153717, 0.06572449952363968, 0.29026299715042114, 0.07996624708175659, 0.2585676610469818, 0.9186116456985474, 0.20564013719558716, 0.979293942451477, 0.24969114363193512, 0.07936578243970871, 0.1504940688610077, 0.09061235934495926, 0.10413055866956711, 0.05068710818886757, 0.2370714545249939, 0.10737115144729614, 0.15727266669273376, 0.021663960069417953, 0.007971254177391529, 0.012868929654359818, 0.01998109556734562, 0.03549323230981827, 0.031001901254057884, 0.024995509535074234, 0.019378207623958588, 1.7579928636550903, 0.603255569934845, 0.06884075701236725, 0.08767224848270416, 0.04991159588098526, 0.10980807989835739, 0.05892716348171234, 0.06627549231052399, 0.05544927716255188, 0.057400330901145935, 0.06871574372053146, 0.07158517092466354, 0.04919140040874481, 0.07551632076501846, 0.0756913498044014, 0.054524876177310944, 0.06177141144871712, 0.05267295986413956, 0.05678672716021538, 0.04390588402748108, 0.04817986488342285, 0.044334929436445236, 0.05677465721964836, 0.04641563445329666, 0.056819524616003036, 0.05262887477874756, 0.042976729571819305, 0.0884852334856987, 0.07150378078222275, 0.05819135904312134, 0.060970183461904526, 0.11834677308797836, 0.059772033244371414, 0.10719452798366547, 0.19482199847698212, 0.07062593847513199, 0.13223206996917725, 0.1270359754562378, 0.15294373035430908, 0.10047248005867004, 0.1333674192428589, 0.11388808488845825, 0.049736835062503815, 0.0730263963341713, 0.06423891335725784, 0.06044207885861397, 0.06824725866317749, 0.06418463587760925, 0.055221471935510635, 0.08067412674427032, 0.06581048667430878, 0.06716645509004593, 0.030897758901119232, 0.10386382043361664, 0.06678584218025208, 0.04657614603638649, 0.05417937412858009, 0.06673312187194824, 0.08239397406578064, 0.09648013114929199, 0.07537046074867249, 0.10726933181285858, 0.09659025073051453, 0.21478307247161865, 0.05900653824210167, 0.2610757648944855, 0.03647148609161377, 0.050088364630937576, 0.024171102792024612, 0.05635756254196167, 0.0540706105530262, 0.0953555554151535, 0.045485761016607285, 0.10102840512990952, 1.0636638402938843, 0.33594557642936707, 0.870901882648468, 0.14826737344264984, 0.407716304063797, 0.39994481205940247, 0.5319401621818542, 0.23560801148414612, 0.013692444190382957, 0.0048681264743208885, 0.014118478633463383, 0.030284307897090912, 0.053486086428165436, 0.06827282905578613, 0.06037027761340141, 0.05676674097776413, 0.04868278279900551, 0.048423830419778824, 0.05307643115520477, 0.04015098512172699, 0.10241597890853882, 0.023188896477222443, 0.041004981845617294, 0.07106988877058029, 1.3315119743347168, 0.7001356482505798, 0.6611624956130981, 1.2903028726577759, 0.09933722019195557, 0.13947676122188568, 0.09074509143829346, 0.10753612220287323, 0.32211941480636597, 0.034159425646066666, 0.2600895166397095, 0.055051714181900024, 0.06062901020050049, 0.1063435822725296, 0.04468721151351929, 0.062283046543598175, 0.04972069337964058, 0.06794975697994232, 0.04684329032897949, 0.06621643900871277, 0.12617290019989014, 0.12644091248512268, 0.1232776865363121, 0.08922047168016434, 0.06278026849031448, 0.41461703181266785, 0.06225666403770447, 0.38617873191833496, 0.18115289509296417, 0.03423745930194855, 0.13460737466812134, 0.03730665519833565, 0.6677278876304626, 0.20130714774131775, 0.49817126989364624, 0.19429410994052887, 0.13071168959140778, 0.1677394062280655, 0.18350379168987274, 0.08171524107456207, 0.2688418924808502, 0.17512403428554535, 0.1636405885219574, 0.18197156488895416, 0.027141742408275604, 0.03587888553738594, 0.030418701469898224, 0.029257064685225487, 0.0935673713684082, 0.19055680930614471, 0.13882361352443695, 0.1601465344429016, 0.06152663379907608, 0.09421981126070023, 0.0638168677687645, 0.08812052756547928, 0.0797778069972992, 0.03462808579206467, 0.10869485884904861, 0.022844593971967697, 0.13673347234725952, 0.07672435790300369, 0.16454283893108368, 0.051539480686187744, 0.26014643907546997, 0.10175818204879761, 0.29465192556381226, 0.07989417016506195, 0.15719838440418243, 0.08510775119066238, 0.19233521819114685, 0.054759860038757324, 0.04948506876826286, 0.035231925547122955, 0.05104586482048035, 0.03230052813887596, 0.05129454284906387, 0.29853448271751404, 0.07274146378040314, 0.21742941439151764, 0.1429339051246643, 0.059467993676662445, 0.20278790593147278, 0.03128458559513092, 0.4304691255092621, 0.08479622006416321, 0.4046287536621094, 0.09557303786277771, 0.15030087530612946, 0.17824259400367737, 0.261583149433136, 0.06656207144260406, 0.33612769842147827, 1.7890833616256714, 0.4576065242290497, 1.9782384634017944, 0.32280224561691284, 0.09021876752376556, 0.3124014735221863, 0.05978744849562645, 0.257584810256958, 2.0167834758758545, 0.34229445457458496, 1.9636132717132568, 0.9427706599235535, 0.18174336850643158, 1.0884089469909668, 0.15398436784744263, 0.06084952875971794, 0.03275132551789284, 0.054003242403268814, 0.039168812334537506, 0.11100117117166519, 0.19541054964065552, 0.16135098040103912, 0.14541611075401306, 0.05566278472542763, 0.04455737769603729, 0.040943119674921036, 0.05111705884337425, 0.17930488288402557, 0.062199972569942474, 0.21223585307598114, 0.050017811357975006, 0.1588629186153412, 0.14488545060157776, 0.20151908695697784, 0.10386504232883453, 0.47722670435905457, 1.315027117729187, 0.49706971645355225, 1.6171525716781616, 0.2728373408317566, 0.1542547643184662, 0.10942566394805908, 0.016508502885699272, 0.05966943874955177, 0.04504777491092682, 0.2331983596086502, 0.22758278250694275, 0.26672276854515076, 0.19778059422969818, 0.3443162143230438, 0.1228068619966507, 0.2066270112991333, 0.24519169330596924, 0.02194538712501526, 0.04188670590519905, 0.04043510928750038, 0.030313992872834206, 0.687596321105957, 1.8356554508209229, 0.2848058044910431, 2.3098862171173096, 0.021490583196282387, 0.10001937299966812, 0.07632005214691162, 0.026833435520529747, 0.3075956106185913, 0.07361912727355957, 0.2766689658164978, 0.09250988066196442, 0.22160875797271729, 0.030324311926960945, 0.15955939888954163, 0.061966490000486374, 0.2921532094478607, 0.07635524123907089, 0.2721116244792938, 0.08359531313180923, 0.3760293126106262, 1.7420833110809326, 0.30068227648735046, 1.520578145980835, 0.15278686583042145, 0.07512302696704865, 0.10311869531869888, 0.08835823088884354, 0.23786142468452454, 0.05691982060670853, 0.15510724484920502, 0.10657677054405212, 0.008334869518876076, 0.021539956331253052, 0.021513160318136215, 0.010316160507500172, 0.03138723969459534, 0.0226146150380373, 0.01916218176484108, 0.018481088802218437, 0.6192165017127991, 2.696153402328491, 0.08729328960180283, 0.07382968813180923, 0.09891343116760254, 0.0563386008143425, 0.07005707174539566, 0.06320015341043472, 0.06049492955207825, 0.05811283737421036, 0.0695347860455513, 0.06902224570512772, 0.07916412502527237, 0.05295887589454651, 0.05029428005218506, 0.07796914130449295, 0.05240410193800926, 0.06598079204559326, 0.043376240879297256, 0.05926866456866264, 0.047579050064086914, 0.04968387633562088, 0.040921375155448914, 0.06360478699207306, 0.04503268748521805, 0.061434607952833176, 0.09201855212450027, 0.04454139620065689, 0.055451683700084686, 0.073920838534832, 0.12560482323169708, 0.06341881304979324, 0.10869581252336502, 0.057750072330236435, 0.0613960400223732, 0.2120513916015625, 0.12082380056381226, 0.13945452868938446, 0.09993907064199448, 0.16844166815280914, 0.12174542248249054, 0.14653223752975464, 0.08002104610204697, 0.053137652575969696, 0.06302641332149506, 0.06599833071231842, 0.06701190024614334, 0.07445545494556427, 0.08703914284706116, 0.06201395019888878, 0.07212744653224945, 0.0742398276925087, 0.10702183842658997, 0.030238237231969833, 0.04117811471223831, 0.06868474930524826, 0.06212208420038223, 0.05348493531346321, 0.08828842639923096, 0.08104672282934189, 0.1028069406747818, 0.07228555530309677, 0.23892341554164886, 0.09859469532966614, 0.2960006892681122, 0.05743416026234627, 0.03818168863654137, 0.04054000973701477, 0.044457126408815384, 0.026767659932374954, 0.11728772521018982, 0.054344747215509415, 0.11045248806476593, 0.056433044373989105, 0.823777973651886, 0.24333907663822174, 1.1403231620788574, 0.3078289031982422, 0.4957813322544098, 0.2115127593278885, 0.36414045095443726, 0.3516906499862671, 0.17609389126300812, 0.1577739119529724, 0.14900998771190643, 0.19692039489746094, 0.08392494171857834, 0.038975637406110764, 0.04349235072731972, 0.08183898776769638, 0.08606470376253128, 0.03319874033331871, 0.035671282559633255, 0.08384941518306732, 0.020852355286478996, 0.1409895420074463, 0.12500503659248352, 0.023016078397631645, 0.02248646505177021, 0.12329311668872833, 0.1103644147515297, 0.023713110014796257, 0.015589541755616665, 0.11020654439926147, 0.1028345376253128, 0.01617252640426159, 0.019523387774825096, 0.10221291333436966, 0.09586472064256668, 0.019017258659005165, 0.09875120222568512, 0.023175690323114395, 0.023404143750667572, 0.09075693041086197, 0.10357924550771713, 0.01739657297730446, 0.018106980249285698, 0.09574408829212189, 0.009341597557067871, 0.07678013294935226, 0.08340135961771011, 0.01048195082694292, 0.010367287322878838, 0.07112227380275726, 0.07902144640684128, 0.012005685828626156, 0.5360978245735168, 0.18104064464569092, 0.15969577431678772, 0.5418282747268677, 0.5332912802696228, 0.13361138105392456, 0.1365017592906952, 0.5449246168136597, 0.1421641707420349, 0.24663691222667694, 0.2391645461320877, 0.1332544982433319, 0.18428312242031097, 0.18848590552806854, 0.1836477816104889, 0.19435866177082062, 0.769553542137146, 0.19113165140151978, 0.1883496791124344, 0.7560417652130127, 0.8064625859260559, 0.16825176775455475, 0.1961187869310379, 0.8079618215560913, 0.00678535969927907, 0.07910274714231491, 0.07803421467542648, 0.006931595038622618, 0.0027460947167128325, 0.08071334660053253, 0.0790175125002861, 0.002409097272902727, 0.14078658819198608, 0.1366545408964157, 0.14952170848846436, 0.14364974200725555, 0.12411246448755264, 0.15654844045639038, 0.16261026263237, 0.12616299092769623, 0.14647436141967773, 0.04669737070798874, 0.0404495894908905, 0.14269989728927612, 0.018153296783566475, 0.07945048063993454, 0.08076074719429016, 0.018040355294942856, 0.009354538284242153, 0.08921752125024796, 0.09456862509250641, 0.008685726672410965, 0.09034053236246109, 0.11483027040958405, 0.11588134616613388, 0.08401724696159363, 0.1083529070019722, 0.10127004981040955, 0.10323911905288696, 0.09844524413347244, 0.6003931760787964, 0.1589658409357071, 0.1737227439880371, 0.6476812958717346, 0.5963484644889832, 0.1634300947189331, 0.16956734657287598, 0.642507016658783, 0.11479503661394119, 0.01898818649351597, 0.022111812606453896, 0.10138207674026489, 0.10669893771409988, 0.019579138606786728, 0.020343346521258354, 0.09629844129085541, 0.1180909052491188, 0.046011123806238174, 0.04020935669541359, 0.11057516932487488, 0.11770402640104294, 0.046374447643756866, 0.04176134988665581, 0.10915406048297882, 0.5369492173194885, 0.13682785630226135, 0.14409451186656952, 0.5895155072212219, 0.552986204624176, 0.16479244828224182, 0.19480296969413757, 0.5583574175834656, 0.14008165895938873, 0.4787417948246002, 0.49161794781684875, 0.1533423662185669, 0.14011336863040924, 0.4966813623905182, 0.5076850652694702, 0.1407073587179184, 0.09061423689126968, 0.009235210716724396, 0.009057236835360527, 0.08512385189533234, 0.09567609429359436, 0.006125580985099077, 0.006489085033535957, 0.08885009586811066, 0.2318415343761444, 0.21224403381347656, 0.18479956686496735, 0.22689907252788544, 0.3209224343299866, 0.5956022143363953, 0.5685640573501587, 0.32096418738365173, 0.1781027466058731, 0.5804927945137024, 0.558323085308075, 0.18589794635772705, 0.1394391655921936, 0.12171268463134766, 0.11251603811979294, 0.13248324394226074, 0.11397114396095276, 0.1401534527540207, 0.12968559563159943, 0.1158437579870224, 0.12512323260307312, 0.1267443746328354, 0.11827042698860168, 0.11393579840660095, 0.10411746799945831, 0.14308352768421173, 0.1358683556318283, 0.10207723081111908, 0.0027349863667041063, 0.07785692811012268, 0.07791268080472946, 0.0027376622892916203, 0.005406789481639862, 0.07780538499355316, 0.07777811586856842, 0.005248602945357561, 0.02169765718281269, 0.09517282992601395, 0.08957036584615707, 0.02137831225991249, 0.021944940090179443, 0.08269070088863373, 0.08042729645967484, 0.0219681728631258, 0.013961263932287693, 0.08572200685739517, 0.080621138215065, 0.013244742527604103, 0.013682729564607143, 0.0777520164847374, 0.07204551249742508, 0.013510194607079029, 0.1738416999578476, 0.6441306471824646, 0.6205596923828125, 0.18304966390132904, 0.32763728499412537, 0.44796496629714966, 0.425108939409256, 0.306691437959671, 0.010911070741713047, 0.0885467529296875, 0.08905385434627533, 0.012210092507302761, 0.01736409217119217, 0.0834425613284111, 0.08490283042192459, 0.018059248104691505, 0.01823158748447895, 0.06238380819559097, 0.06153620034456253, 0.017726976424455643, 0.007953855209052563, 0.07119819521903992, 0.07221643626689911, 0.007251082919538021, 0.09802976250648499, 0.02433079108595848, 0.024465598165988922, 0.08725199848413467, 0.09010285884141922, 0.01889411173760891, 0.020498892292380333, 0.08088558167219162, 0.11059598624706268, 0.045024506747722626, 0.043351415544748306, 0.10280727595090866, 0.10383274406194687, 0.049696411937475204, 0.046135589480400085, 0.09621112793684006, 0.08993737399578094, 0.026147538796067238, 0.02725105918943882, 0.08625251799821854, 0.08176705241203308, 0.027068106457591057, 0.029153738170862198, 0.07935348153114319, 0.02819560468196869, 0.07506302744150162, 0.0698932409286499, 0.023547887802124023, 0.02002549357712269, 0.08355472981929779, 0.07462388277053833, 0.016101311892271042, 0.059710100293159485, 0.009559386409819126, 0.01021283958107233, 0.05524997413158417, 0.06375153362751007, 0.010969586670398712, 0.012405681423842907, 0.05945056676864624, 0.013950400054454803, 0.0657510831952095, 0.06504601240158081, 0.016158420592546463, 0.010985762812197208, 0.06197886914014816, 0.06271852552890778, 0.011626837775111198, 0.15690571069717407, 0.49270886182785034, 0.5222122669219971, 0.1871236115694046, 0.12584497034549713, 0.5821676254272461, 0.6322730779647827, 0.1224188283085823, 0.02317129261791706, 0.07358245551586151, 0.07169412076473236, 0.02349483035504818, 0.02418951503932476, 0.06632933020591736, 0.06309864670038223, 0.02442300319671631, 0.01141140516847372, 0.10890796780586243, 0.12897498905658722, 0.010685225017368793, 0.007666117511689663, 0.1116151213645935, 0.130783811211586, 0.007160963956266642, 0.12943442165851593, 0.13693904876708984, 0.11787217110395432, 0.1284751296043396, 0.1304548680782318, 0.11891846358776093, 0.11624626070261002, 0.12574346363544464, 0.03351086005568504, 0.07063766568899155, 0.06703447550535202, 0.04357372596859932, 0.03261176869273186, 0.06651786714792252, 0.06627804785966873, 0.04153983294963837, 0.1525651216506958, 0.6273330450057983, 0.6487682461738586, 0.14236919581890106, 0.19307640194892883, 0.5867601037025452, 0.5820944309234619, 0.17640890181064606, 0.03773675486445427, 0.07960091531276703, 0.08006780594587326, 0.04045010730624199, 0.043088581413030624, 0.07555907219648361, 0.07471678406000137, 0.04472183436155319, 0.029768897220492363, 0.07088787108659744, 0.07032835483551025, 0.03612912446260452, 0.02906092256307602, 0.0664457380771637, 0.0653582289814949, 0.03458814695477486, 0.2136254608631134, 0.07490253448486328, 0.07527337223291397, 0.20219746232032776, 0.19189347326755524, 0.100594162940979, 0.10708574950695038, 0.17307963967323303, 0.07432111352682114, 0.17451806366443634, 0.16158615052700043, 0.07972022891044617, 0.046100419014692307, 0.17981892824172974, 0.16506892442703247, 0.05256161838769913, 0.08311336487531662, 0.028245121240615845, 0.02783273532986641, 0.07499343156814575, 0.07452823221683502, 0.026046158745884895, 0.025067931041121483, 0.06924928724765778, 0.10156140476465225, 0.041745223104953766, 0.03602055087685585, 0.09183886647224426, 0.0941835567355156, 0.03518077731132507, 0.03345433250069618, 0.08525111526250839, 0.11279694736003876, 0.034208737313747406, 0.03233148530125618, 0.1046457588672638, 0.10977500677108765, 0.032425977289676666, 0.03165360912680626, 0.10333172231912613, 0.17642588913440704, 0.6882777214050293, 0.6468811631202698, 0.17530928552150726, 0.18638162314891815, 0.6063037514686584, 0.6358646750450134, 0.2219354808330536, 0.08575557917356491, 0.1522865742444992, 0.15627145767211914, 0.0946047380566597, 0.10325897485017776, 0.13620533049106598, 0.14095963537693024, 0.10414255410432816, 0.012704014778137207, 0.11100514233112335, 0.12930993735790253, 0.013718661852180958, 0.010017530992627144, 0.10665369778871536, 0.1267017424106598, 0.009415175765752792, 0.11993817239999771, 0.020872624590992928, 0.020395932719111443, 0.1331881284713745, 0.12549027800559998, 0.004697326570749283, 0.007253553718328476, 0.13911904394626617, 0.5045966506004333, 0.22197312116622925, 0.22162945568561554, 0.5144121050834656, 0.5528397560119629, 0.12113390117883682, 0.11611922085285187, 0.5383970737457275, 0.09688371419906616, 0.27476051449775696, 0.25236907601356506, 0.09614943712949753, 0.15601733326911926, 0.17405693233013153, 0.1620418131351471, 0.14081239700317383, 0.10623186081647873, 2.2706687450408936, 2.3358254432678223, 0.1068853959441185, 0.10560343414545059, 2.129997730255127, 2.254873514175415, 0.11350049823522568, 0.08194103837013245, 1.9138668775558472, 2.0513296127319336, 0.07284533977508545, 0.16704128682613373, 1.628330111503601, 1.784407615661621, 0.18149395287036896, 0.06972602754831314, 1.323169469833374, 1.4429523944854736, 0.0687553808093071, 0.2171306312084198, 0.9984128475189209, 1.0822029113769531, 0.22946225106716156, 0.044934168457984924, 0.7075914740562439, 0.7607077956199646, 0.04410487040877342, 0.1918485462665558, 0.4235049784183502, 0.45546239614486694, 0.2114814966917038, 0.2432108223438263, 0.47114795446395874, 0.7994376420974731, 1.1804901361465454, 0.005376606248319149, 0.36584779620170593, 0.3900587260723114, 0.35152456164360046, 0.02895672619342804, 1.2447905540466309, 1.4650791883468628, 0.5032419562339783, 0.0725283995270729, 0.15316617488861084, 0.07883904874324799, 0.9966694116592407, 0.017956826835870743, 0.20991231501102448, 0.20762453973293304, 0.21386732161045074, 0.797603964805603, 0.3447200655937195, 0.032225511968135834, 0.010364256799221039, 1.4409863948822021, 2.605710744857788, 1.8172281980514526, 0.8804658055305481, 0.04888208955526352, 0.25440868735313416, 0.14487366378307343, 1.692124366760254, 0.11179595440626144, 1.7124601602554321, 0.4953001141548157, 0.29652196168899536, 0.046824246644973755, 0.13706490397453308, 3.675518035888672, 1.6434593200683594, 1.2724311351776123, 0.28950169682502747, 0.09570178389549255, 4.338246822357178, 0.09692833572626114, 4.472177982330322, 0.9416369199752808, 2.3624839782714844, -0.1997743546962738, 1.5417006015777588, 0.11407104879617691, 3.3114798069000244, 0.4679356515407562, 0.072076216340065, 0.08220023661851883, 1.6973872184753418, 0.07429879158735275, 2.2614054679870605, 0.857371985912323, 0.09513282775878906, 1.203830599784851, 0.38829007744789124, 0.07319151610136032, 0.341673344373703, 0.5962036848068237, 0.04327670484781265, 0.34663090109825134, 0.01348208636045456, 0.010210143402218819, 0.08032652735710144, 0.5776411294937134, 3.3730573654174805, 0.05313333496451378, 0.0484578013420105, 2.3372585773468018, -0.08579545468091965, 1.332088589668274, 0.059247396886348724, 0.4891608953475952, 1.6098058223724365, 1.2855390310287476, 0.04728373885154724, 0.2519562542438507, 0.35544028878211975, 1.229941487312317, 0.21987681090831757, 0.6687581539154053, 0.4266337752342224, 0.8735748529434204, -0.021184932440519333, 0.056420739740133286, -0.0007528388523496687, 1.7453796863555908, 0.027713989838957787, 0.036322981119155884, 1.916714072227478, 1.7607418298721313, 0.21710264682769775, 0.21344685554504395, 1.916892170906067, 0.11670029908418655, -0.0009059818694368005, -0.0005993525846861303, 0.17949463427066803, 1.5696945190429688, 0.06401512026786804, 0.27418750524520874, 0.5248119831085205, 0.06972552090883255, 0.07248697429895401, -0.057930491864681244, 1.24066960811615, 0.033574674278497696, 2.508976697921753, 2.7148585319519043, 0.03133438900113106, 0.06941238790750504, 0.5669744610786438, 0.5430120229721069, 0.0735003799200058, -0.11049481481313705, 1.6435365676879883, -0.0009347707382403314, 0.14279590547084808, 0.05283520743250847, -0.01176627166569233, 0.5022004246711731, 0.09475389122962952, 0.3559330403804779, 1.1023976802825928, 0.3964761793613434, 0.7025829553604126, 1.754889965057373, 1.075143575668335, 0.5725009441375732, 0.19170914590358734, 1.7373096942901611, 0.1179027259349823, 0.2562268376350403, 0.7511534094810486, 0.09517258405685425, 0.017482344061136246, 0.1424380987882614, 0.40638861060142517, 0.07960847020149231, 0.06906680762767792, 0.12009253352880478, 0.011914415284991264, 0.008260407485067844, 0.06266318261623383, 0.054594218730926514, 0.005186849739402533, 0.7619826793670654, 0.36346644163131714, 0.28957870602607727, 0.2501959204673767, 2.0529685020446777, -0.012078973464667797, -0.10420624911785126, 1.3044954538345337, 0.04378150403499603, 0.012136157602071762, -0.0020360462367534637, 0.02018699049949646, 0.5344423055648804, 0.4133152365684509, 0.05833093076944351, 0.5789175629615784, 0.5303189158439636, 0.7169333696365356, 0.004144710022956133, 0.026051277294754982, 1.2594009637832642, 1.5243374109268188, 0.026902908459305763, 0.0030490770004689693, 2.6393306255340576, 0.26073259115219116, 1.8038398027420044, 0.9269912838935852, 0.13201288878917694, 1.4710512161254883, 1.2756671905517578, 0.006609570700675249, 0.10219670832157135, 0.07703149318695068, 0.9961103200912476, 0.19744545221328735, 0.6094313859939575, 1.9854542016983032, -0.001592517364770174, 0.046772152185440063, 2.495866537094116, 1.484893798828125, 2.7942912578582764, 0.5577430129051208, 0.06420143693685532, 0.9916814565658569, 2.91664719581604, 0.1339062750339508, 3.641533851623535, 1.1290959119796753, 2.7008180618286133, 0.024551374837756157, 1.1679887771606445, -0.11201747506856918, 0.24917101860046387, 0.3768630623817444, 0.04315502569079399, 1.2865806818008423, 0.015524918213486671, 0.02876356989145279, 0.03112761490046978, 0.4346376657485962, 0.20285660028457642, 0.04259456321597099, 0.2503029406070709, 0.02496136538684368, 0.07594813406467438, 0.09186459332704544, 0.10173232853412628, 0.06542108207941055, 0.20320385694503784, 0.0469539500772953, 0.21358722448349, 0.04497377201914787, 0.08664047718048096, 0.054968591779470444, 0.08284500986337662, 0.055721741169691086], "data_means": [0.0009033591682377821, 0.001946241024355613, 0.006604708225581771, 0.003524304855770593, 0.04023071141069897, 0.013507506106528955, 0.03476033512359655, 0.01897788239394318, 0.026881373440389506, 0.01522928983921765, 0.021924807924592588, 0.020185855355813846, 0.010917921081665562, 0.022647268579699564, 0.023498861789676025, 0.01006632787276985, 0.24390031490122013, 0.19759839523302514, 0.21372031584592296, 0.2277783942783446, 0.0823189419025111, 0.011344599799608189, 0.06265885575394305, 0.03100468595166216, 0.01705246439845696, 0.055732899551093375, 0.018812013416860156, 0.05397335053311248, 0.011470688295120698, 0.02613497879853425, 0.016926986877096324, 0.02067868021614126, 0.03172597159348641, 0.012841616769081346, 0.028656085142229594, 0.015911503218786243, 0.043970676598668296, 0.03718430934873205, 0.030529569784060615, 0.050625416161283375, 0.052590506086668765, 0.028855257865016606, 0.05646282682189302, 0.02498293712953359, 0.014536122945427806, 0.03710826532558438, 0.014314440002116886, 0.03732994827007575, 0.05489769670315692, 0.08920344938567801, 0.0644001131495216, 0.07970103293984994, 0.039655522848969234, 0.04420173177778673, 0.021614310486703127, 0.0622429441397794, 0.06716843650126171, 0.09215225975241757, 0.09106441741738357, 0.06825627883525602, 0.009024934309685997, 0.00929782515454882, 0.00613690658086962, 0.012185852882842834, 0.04071306297842625, 0.0506722934744422, 0.019817167656316786, 0.07156818879633392, 0.058045527021569836, 0.015258838932591919, 0.053859332747167976, 0.01944503320728776, 0.009465778221311429, 0.027068335911354383, 0.0010067600512876549, 0.03552735408151769, 0.019107148286565217, 0.08019023567321067, 0.0006196433163442468, 0.09867774064572223, 0.026682389919670004, 0.08172583245584339, 0.010822959937615442, 0.09758526243718965, 0.019905021574626622, 0.0692179914751092, 0.0019883161948526353, 0.08713469685522882, 0.01225430049373675, 0.021131407647024453, 0.00849914118929621, 0.024886566952939688, 0.036391972103836843, 0.022261410083659346, 0.03263943768169871, 0.026013944504840295, 0.019319082774179062, 0.04811630076848549, 0.0015578856097783692, 0.06587749793247952, 0.0405660535259371, 0.06674885741733955, 0.03384177035499277, 0.07347314058944887, 0.033859646829978045, 0.05528453510264499, 0.009012332383907114, 0.08013184954924839, 0.14430153858897599, 0.12290598605284643, 0.0853483533456871, 0.18185917129267723, 0.012536106903815434, 0.17683052655693834, 0.008651708768678587, 0.18071492469707867, 0.10942692690081775, 0.087887125118464, 0.06840625735085615, 0.12890779466970498, 0.05905190917542559, 0.1593043952094274, 0.03540622356843426, 0.18295008081933037, 0.009148850728241453, 0.029531214999362846, 0.014092989740128625, 0.02458707598624748, 0.036696071100161896, 0.04393267928004217, 0.01597386804263124, 0.06465488233688443, 0.011923444260113287, 0.02696126450943777, 0.019996949891973766, 0.018887758876730106, 0.01774116915079003, 0.12101001533947454, -0.003030889801015409, 0.1417820742939855, 0.05627976472858698, 0.03525878376095258, 0.04112408182407617, 0.05041446666336213, 0.18967686365365824, 0.1509596944191512, 0.16116279167169595, 0.1794737663990267, 0.06289228392091718, 0.08964356050643336, 0.0038515226875822975, 0.016570536345915737, 0.01127278071287369, 0.009149278320996837, 0.12035694650809825, 0.05211371239027834, 0.09935011985525705, 0.07312053904329088, 0.03937066064858882, 0.217388640430183, 0.13008038603890862, 0.12667891503599316, 0.015083565381111929, 0.0002251459194520864, 0.006739316967360744, 0.008569394333265836, 0.09717898720372428, 0.07172399480728016, 0.08605580453422867, 0.08284717747418045, 0.027023192299200274, 0.00515641803481292, 0.004924981780343836, 0.02725462855364963, 0.025366071793530218, 0.061995612483671435, 0.03110428795900481, 0.056257396318019896, 0.008357391309922687, 0.037542726808790755, 0.019735031679957014, 0.02616508643968256, 0.024581304735467498, 0.05796123131389697, 0.03198513256075612, 0.05055740348866916, 0.08322857158019925, 0.07350880845136569, 0.04729319373708317, 0.10944418629505305, 0.03701491787832492, 0.05573164719065986, 0.048091831796167966, 0.04465473327413727, 0.02145597242200833, 0.04909668944328527, 0.03795398247097054, 0.03259867939513749, 0.005692172154987668, 0.0012576628180422397, 0.0016629149315607722, 0.005286920041241352, 0.005809238538870442, 0.011030476680834058, 0.008294273862969347, 0.00854544135688744, 0.14231215176626189, 0.08392618406782999, 0.024472524385218276, 0.016688762641616645, 0.017219629775578157, 0.023941657251484175, 0.03153646323590668, 0.028661784671822232, 0.029250080776411728, 0.030948167131474306, 0.03785939831995346, 0.009258413076324013, 0.028287366726251723, 0.018830444670686175, 0.04246931020322991, 0.009430361804986593, 0.034849471540582, 0.017050200467646215, 0.03293804623054026, 0.011282001791879685, 0.028300559301164298, 0.01591948872072992, 0.016222811610460897, 0.014967617842415692, 0.014912973437392616, 0.016277456015189026, 0.017160421312570704, 0.03957507734523435, 0.030840868642248543, 0.02589463001718983, 0.02846492343640923, 0.060822443184537105, 0.029810979413500256, 0.059476387206868916, 0.0849060116480422, 0.0014727278446802037, 0.05515191681771616, 0.0312268226753417, 0.07526307376414972, 0.02082408540078774, 0.06034566608520718, 0.03574149308141959, 0.007542809569107636, 0.04422126802372104, 0.014803730129121923, 0.036960347463603396, 0.019048137090054946, 0.02748940428868331, 0.009806227495393097, 0.036731313883350804, 0.017589068569783185, 0.02629345643969331, 0.0005628338875767339, 0.04331969112286254, 0.020841075356232478, 0.011448549490578414, 0.017260958502329324, 0.015028666344135463, 0.019499105209438358, 0.023681355047722865, 0.013417928490411917, 0.029762531766799286, 0.024097573707663706, 0.0822905742722793, 0.002843369242361242, 0.10354477873620284, 0.013344561728763823, 0.008053569946846884, 0.0070959073931909054, 0.0143022242823584, 0.0123926355963334, 0.031995736983481335, 0.009690081523688143, 0.03469829105679509, 0.16226496302910925, 0.0569996414443674, 0.17588426218434564, 0.03352727495506584, -0.009100079731400453, 0.0783580982602945, -0.008965498350829033, 0.06435546756789849, 0.0039570800554748105, 0.0019414115762088197, 0.0033655860124712756, 0.003832078698749061, 0.014252387514052589, 0.039645374143761875, 0.019777488781299264, 0.03412027287670517, 0.01590112228156803, 0.026698034714444582, 0.02084737426000796, 0.02175178273621531, 0.023926323170258147, 0.011365468711009255, 0.010639217411793528, 0.024652574469908373, 0.19311242008065102, 0.24936959128090788, 0.22746860247910997, 0.21501340887727172, 0.012179083856217932, 0.08303586552530844, 0.032265297788038695, 0.06294965159191504, 0.05499337015370511, 0.016739053253135804, 0.05333513366603272, 0.01839728974215506, 0.026566119189426064, 0.011782329701498792, 0.021171888295314318, 0.017176560596051414, 0.012536240240400912, 0.03160322900562424, 0.015544563274248977, 0.028594905971633295, 0.03824928691253166, 0.04625464631351037, 0.05245701163729991, 0.03204692158779941, 0.029488447363294153, 0.05309734780788433, 0.025399821449227287, 0.05718597372376122, 0.0363993266259635, 0.014671477034079608, 0.03668213513432386, 0.014388668525642847, 0.08754738006007634, 0.05770498332623726, 0.07935246110852433, 0.06589990227770873, 0.04385556972074023, 0.04044965909726849, 0.061992797350816635, 0.022312431467252765, 0.09440621697363397, 0.0687414575949707, 0.06925969540160735, 0.09388797916902603, 0.009111028777809407, 0.008982421881722267, 0.011964070074464143, 0.0061293805851526904, 0.05164934034869428, 0.0424921185967414, 0.07307298331260291, 0.02106847563212118, 0.01631854675890415, 0.05733332977223506, 0.02016817651222267, 0.053483700018546916, 0.02794807148034548, 0.009331911362968787, 0.03691706386298508, 0.00036291898048002795, 0.08133153510569996, 0.020128829215122837, 0.10059392054334595, 0.0008664437760290627, 0.08281521610240998, 0.027004233499341796, 0.09799556419401594, 0.01182388540725473, 0.07065657156536821, 0.02054828181420676, 0.08925075776579149, 0.001954095612868621, 0.020832047617260048, 0.012189554776866564, 0.02443602077302867, 0.008585581621986712, 0.022227109552778377, 0.03654917978639399, 0.02556457001233768, 0.03321171932759244, 0.04959593043875683, 0.019293414215824777, 0.0672433171485572, 0.0016460275045228332, 0.0663307487088586, 0.04069204562691852, 0.07309084776897182, 0.03393194656426629, 0.056413222464623554, 0.03439383083259939, 0.08192022495554203, 0.00888682834306105, 0.12057259220058483, 0.14584831663799935, 0.17941242875882604, 0.08700848008825723, 0.17852027958054711, 0.013120392888951476, 0.18249430451798662, 0.009146367951415924, 0.08757524680174499, 0.11286200349902328, 0.1273546022253635, 0.07308264807250132, 0.15732541986460968, 0.05930432448854295, 0.18064844184083118, 0.035981302508854854, 0.02898827836752665, 0.009034303247745625, 0.024280789723760465, 0.01374179189159587, 0.04525232697931775, 0.03789899113601641, 0.0666604885341898, 0.01649082957915636, 0.02721463667244087, 0.011765719773185614, 0.019088582824846545, 0.019891773620727426, 0.12191495499160206, 0.01863645676327623, 0.143149270097183, -0.0025978583471345683, 0.03458100128389385, 0.057523686193698194, 0.05067879598887526, 0.041425891488471506, 0.14781145229180176, 0.19125960627617697, 0.17692633293535456, 0.162144725636571, 0.09127619514716424, 0.06519654666646969, 0.017911582528537168, 0.003802464046539574, 0.009915313513067254, 0.011798733061237571, 0.05378479928571712, 0.11966419253125272, 0.07407152184253556, 0.09937746997458545, 0.21868802794501496, 0.0411779486171207, 0.12608049877720898, 0.1337854777770914, -0.00017738028067204104, 0.015514321528702735, 0.008249408005875323, 0.007087533241951219, 0.07168871593659291, 0.1016905874369847, 0.08420567518169766, 0.08917362819136077, 0.005760862625350098, 0.02677941533894707, 0.027990401624479036, 0.004549876339820684, 0.06522847414394911, 0.025555809746723102, 0.058802002268741486, 0.031982281618403455, 0.04025922832852147, 0.008197985530962645, 0.02819511733712502, 0.02026209652249564, 0.061178480908811346, 0.025253295815120022, 0.05400142365124812, 0.03243035307120342, 0.07539696495623288, 0.08874009350312638, 0.11222286220383897, 0.051914196257301336, 0.05743437435208322, 0.03751808654262207, 0.046075963136719175, 0.04887649775796426, 0.05149434866645121, 0.021642706234943992, 0.03428029507239528, 0.03885675982808604, 0.0013062525446635596, 0.00577510495863392, 0.005382340753384082, 0.0016990167496395835, 0.01121899594172559, 0.005797953895110903, 0.008700829023015633, 0.008316120813732857, 0.08688568395854554, 0.1462039067909434, 0.016439266936016814, 0.024474539282088276, 0.023864716055468804, 0.017049090163132802, 0.029488547637327257, 0.0315912872368818, 0.03189296105877612, 0.0291868738158448, 0.009478708990919602, 0.037903526910165485, 0.01922777895472042, 0.028154456945139378, 0.010037153798389145, 0.042235398912432824, 0.01748039265766612, 0.03479216005407062, 0.011698261640365522, 0.03231702850483681, 0.016159589839920302, 0.0278557003061905, 0.014622622764775519, 0.01623449535274285, 0.016076386335688236, 0.014780731780977385, 0.04047275889979148, 0.016830108870415958, 0.02635734616867517, 0.030945521601482107, 0.06092411674824982, 0.0280340179297422, 0.059864068908634646, 0.029094065768252738, 0.0022033419757675463, 0.0845340239394202, 0.031206039560507822, 0.05553132635160458, 0.020350544989543258, 0.0749530070034191, 0.03527227123221871, 0.060031280758774105, 0.0452748259532358, 0.007914196163169292, 0.03795911450311967, 0.015229907612411171, 0.02826512997986905, 0.019301496391703934, 0.03774712193203154, 0.009819504441392797, 0.027358893357524606, 0.017560614950263734, 0.04436746383617268, 0.0005520444712611666, 0.011581876907864348, 0.020785006489387813, 0.014946291514028001, 0.01742059188302208, 0.023890996071526734, 0.020254554492145645, 0.03009808501981339, 0.014047465543209332, 0.08331576964024615, 0.025133005873865216, 0.10589604682684112, 0.002552728684031523, 0.007722702763816291, 0.01375163266292138, 0.014123522487702043, 0.0073508129386605885, 0.03149307429558608, 0.012990943888771832, 0.034507934575508804, 0.009976083608269171, 0.17925307565302293, 0.07354947194148644, 0.1629096131725557, 0.06068211363174524, -0.008917432074088561, 0.05567747822580003, -0.00854060959202281, 0.06807630419028761, 0.0034628888953279363, 0.003057698850169123, 0.002975976748236677, 0.0035116250869681653, 0.02873374580948926, 0.003015967245377856, 0.0029140256088217944, 0.02870837210483546, 0.028607374784593423, 0.003142338269410062, 0.0030140494963352676, 0.02860834821640537, 0.001277498030998623, 0.03462246386698344, 0.03446863506094898, 0.0013685929770640881, 0.004702494051515391, 0.031197467844775506, 0.03111217916872517, 0.004725048869723946, 0.0017869346711888762, 0.02739152887471873, 0.027530227033146382, 0.0017958110031376811, 0.0035230775012550218, 0.025655386044136322, 0.025713995740426723, 0.0036120422954966243, 0.022857747416142098, 0.0008937404179463302, 0.000914286829020581, 0.022564822432398646, 0.024067549375202484, -0.00031606154024672395, -0.0002931095496692241, 0.023772218810807072, 0.001212974009829999, 0.01672255258395953, 0.016532406475755837, 0.0011586641935669257, 0.002340998715273014, 0.01559452787880978, 0.015346881526941483, 0.0023441891421200857, 0.049604742384054074, 0.03272190027153067, 0.033553995574714626, 0.05083095618344005, 0.04809483093860063, 0.03423181171637711, 0.0343120555312526, 0.05007289622836532, 0.026586954889757968, 0.09038664962668083, 0.09139441482948564, 0.026630330928138476, 0.054569614492795376, 0.06240399002348863, 0.06320452058521918, 0.0548202251701957, 0.05244179025108032, 0.03685465291733981, 0.03486796322705893, 0.051024380564171655, 0.05478384464294198, 0.034512598523500936, 0.03283897501262413, 0.05305336877883457, -0.0007287828951283684, 0.011439927424606935, 0.011579896425632496, -0.0007363350883802034, -0.0018092010568810835, 0.01252034558631904, 0.012674507520457165, -0.0018309461832261985, 0.05057248933660359, 0.02969632991018095, 0.02991375667965348, 0.050591176017803156, 0.043879950110163886, 0.03638886913556381, 0.036758458640773775, 0.043746474056824594, 0.0517281412027695, 0.0037312372608305873, 0.003928354480344128, 0.05194931857822874, 0.0015728361924445358, 0.01694903077775081, 0.016945963605050757, 0.0015287727157464286, -0.0009054166118248042, 0.019427283582232627, 0.019382256632735854, -0.0009075203112765442, 0.019199832840827286, 0.047925683159991656, 0.047838885623045474, 0.019337494310789585, 0.02804487907090021, 0.039080636929630076, 0.03904505136792013, 0.028131328567099222, 0.028662976811949195, 0.033680865824625046, 0.032420086454900014, 0.029338405218412578, 0.03717892493989398, 0.02516491769617865, 0.024186514122958247, 0.03757197755008694, 0.02427270714338594, 0.003781193389961745, 0.0035807300716053036, 0.02439615996127734, 0.0224907390671491, 0.005563161466554605, 0.00553388442859793, 0.0224430056051596, 0.03183827996747825, 0.007175750986857408, 0.007107675220171631, 0.03182705655758607, 0.030611839868768566, 0.008402191086725689, 0.00815062165289521, 0.0307841101257207, 0.06659910853100234, 0.03302834630539114, 0.03439368373083219, 0.06699721565258906, 0.0619745230692448, 0.03765293176766889, 0.03826889503365349, 0.06312200434843869, 0.03250489984775991, 0.03332153471927117, 0.03593355613039457, 0.033175560736563345, 0.031102506062162857, 0.03472392850638517, 0.03741113856462494, 0.03169797830393706, 0.013137733222132363, 0.002322190318210948, 0.0022071983337412873, 0.01312281163795205, 0.013348313829364184, 0.00211160971109808, 0.00209872617291163, 0.013231283799516333, 0.057740951367456696, 0.05695977193143405, 0.05732290578824624, 0.05803762715912189, 0.05904977238766275, 0.037751972156961265, 0.03700405576246708, 0.059983725717844175, 0.043315576682638385, 0.05348616786270005, 0.053650419676746046, 0.04333736180496055, 0.052015067974568216, 0.025832360748408948, 0.026058215361541206, 0.052394331312468095, 0.0466880810883594, 0.031159347633215904, 0.03152634868094068, 0.04692619798979437, 0.050052812279655766, 0.028181301682888463, 0.02844572902040891, 0.05017226124778833, 0.04245077462144937, 0.0357833393418081, 0.036133942689398214, 0.04248404758129375, -0.0017873739569911724, 0.01153235743630635, 0.011648571910892799, -0.001826289515655755, -0.0005560808009751997, 0.010301064280990056, 0.010364953397947484, -0.0005426710026095717, 0.002281402239953896, 0.026118231801719287, 0.026043577064885987, 0.002304423060363109, 0.0048379028688982475, 0.02356173117181394, 0.02349998552336687, 0.0048480146023070795, 0.0019689820083371263, 0.02260932915910584, 0.022632423137884237, 0.001985306015427505, 0.0025180436417977193, 0.022060267525922928, 0.022021819803423336, 0.002595909349626776, 0.023849685986085122, 0.1851472833571807, 0.18621379311050998, 0.023804273513020946, 0.0794325949387711, 0.12956437440103485, 0.13041057080503116, 0.07960749581862431, 0.0009267656768053537, 0.022170074973273658, 0.02202900335305681, 0.0010146493353219107, 0.0035715709704645777, 0.01952526967976127, 0.01939107633297596, 0.003652576355529723, 0.0032947479909884686, 0.01383910713730872, 0.013955256999744267, 0.0032674012981244657, -0.00026649167334631457, 0.017400346802032434, 0.017463231860048826, -0.00024057356239459978, 0.01815280842440751, 0.003057529715769915, 0.0030238754462654544, 0.018141961953385053, 0.017212579654348557, 0.003997758485479041, 0.003977543336834023, 0.017188294062475365, 0.02846325056391301, 0.006072715254876633, 0.006068449688642811, 0.02876308913591221, 0.026245343519129445, 0.008290622299919346, 0.00826655833381365, 0.02656498049085919, 0.024702980759858495, 0.003935018508599894, 0.003635189476197106, 0.02472217202430232, 0.022529960785145128, 0.006108038483460617, 0.006022475608417645, 0.022334885891643046, 0.002761205250013273, 0.014274511517374125, 0.014528369312578506, 0.002765619372895427, 0.0014224903602503877, 0.015613226406358814, 0.01578017634878153, 0.0015138123370080617, 0.01333686572954922, 0.002566542486710415, 0.002442252943357483, 0.013257223306247259, 0.013711841119991143, 0.0021915670964267535, 0.0019780036311242855, 0.013721472618898493, 0.0007095422865579428, 0.01825604129867606, 0.01816786945769192, 0.0006787576565504217, 0.002390589114331522, 0.016574994471251686, 0.016495165715905664, 0.0023514613983265393, 0.03812124106731505, 0.02737171361485877, 0.029810368154986187, 0.03846027968158362, 0.025278245962880645, 0.040214708718441614, 0.04239416406681978, 0.02587648376967873, 0.002884603065072348, 0.01950737150796497, 0.019501361139992304, 0.0029465805540180266, 0.00434184840405694, 0.018050126168621814, 0.018220677131500704, 0.00422726456231893, 0.0019052577414447529, 0.01400450938391781, 0.013976642841756322, 0.0019463673421362797, 0.00213393648128215, 0.013775830644395826, 0.013795608075334321, 0.0021274021092743426, 0.04117578096960604, 0.037750033303980586, 0.037761404082733555, 0.04090828536554991, 0.03732693832086324, 0.0415988759525977, 0.04163662785755562, 0.03703306159011691, 0.01346788422013429, 0.033979608114795425, 0.03293818417977388, 0.01358069944053998, 0.01458205622934181, 0.03286543610543433, 0.03192471970185327, 0.014594163917412138, 0.02312137474878105, 0.05979876370571548, 0.05955116652194442, 0.02296823377730827, 0.035957305139113466, 0.04696283331525959, 0.04727026520591305, 0.03524913509280042, 0.004716207414950523, 0.02850719610368788, 0.028494005335544782, 0.004573754442110756, 0.007328828109208335, 0.025894575409082514, 0.025720280248325896, 0.007347479530083797, 0.004356088345486068, 0.023345413888552134, 0.02320776679303281, 0.004435367856987374, 0.006145200237762098, 0.021556301995688643, 0.02141652969871485, 0.0062266049509820875, 0.08156341749668089, 0.021959121933011985, 0.022086936308967867, 0.08224796501059126, 0.0652886105767759, 0.03823392885128881, 0.03906750002040147, 0.065267401298427, 0.026619454200473805, 0.06121282412024444, 0.062209646629078894, 0.026498028038612436, 0.018130594982476343, 0.06970168333994857, 0.07067469819103807, 0.018032976472548697, 0.02095453078352435, 0.004061172250879262, 0.004036440990213596, 0.020876602151555863, 0.01975905980852648, 0.005256643226110368, 0.0051367079217290975, 0.01977633522051971, 0.023413398036445224, 0.004229501965938378, 0.00423310381821725, 0.023282739908998828, 0.021964233949738416, 0.0056786660525771585, 0.005617888451940927, 0.02189795527612065, 0.028976634367570173, 0.0054122123826138265, 0.005252054204241407, 0.02847579781736937, 0.027495364409302656, 0.006893482340107342, 0.006567776180599739, 0.027160075840557737, 0.03642700456063297, 0.04505762973773155, 0.047540612485456234, 0.03818464772217632, 0.03695679222557632, 0.044527842073729194, 0.047651369041737265, 0.03807389116240805, 0.022738908035835847, 0.055056072854833944, 0.054732200744350964, 0.022587358364432764, 0.030155725947687697, 0.04763925494339079, 0.04710332538660859, 0.03021623372139397, 0.00245165189996758, 0.016785365990951196, 0.01662998928080491, 0.002524587157668153, 0.0032970229119632264, 0.015939994978610147, 0.015851381088992908, 0.0033031953492081286, 0.014723950957359164, 0.00022688626413635405, 0.00022746858609221367, 0.014552461780223786, 0.017422084161530755, -0.0024712469397604924, -0.0024453170155227474, 0.017225247381335844, 0.03387346292310759, 0.03098707405635666, 0.03153224034064424, 0.035930994917319575, 0.03711660763738331, 0.027743929340500777, 0.028055332826511, 0.03940790243077146, 0.013428740592732065, 0.07803675168024769, 0.07809181339571486, 0.013012182707533458, 0.038029233220937694, 0.05343625905385081, 0.05323766707781173, 0.037866329024384617, 0.02015789606411893, 0.04496906920388186, 0.044614465533777674, 0.019679029743430807, 0.021516447543953827, 0.04361051772718932, 0.043298074708291286, 0.020995420571605077, 0.0162017963381712, 0.040915602745291206, 0.040725902850041996, 0.016101595698811283, 0.021585352920004592, 0.03553204616021259, 0.03531649595288832, 0.021511002589974668, 0.012963063077017991, 0.02993918018169093, 0.02974239094329893, 0.012913925809204295, 0.020249502671839347, 0.022652740587517522, 0.02257588683840648, 0.020080429916372253, 0.010465610842470087, 0.016577482723780613, 0.016469874133953347, 0.010320646536174982, 0.017482297855832985, 0.009560795710455788, 0.00955432390532837, 0.01723619676556323, 0.04863335373031755, 0.20478340606298745, 0.33417952126076, 0.1490207785724731, -0.03494139372513147, 0.12649271283165145, 0.0741434654808976, 0.1266999409849009, -0.033453617104272595, 0.5283529482725062, 0.6735341344507316, 0.08302492909902691, 0.03012495073124185, 0.07101740524378808, -0.014403024953316102, 0.39139811772078975, 0.010272273409410889, 0.10044567285512662, 0.10106542491212994, 0.1141054975825465, 0.25978807005192633, 0.14350458207997813, 0.01003009493291757, -0.004427184575370566, 0.7150369064964459, 1.31776967219086, 0.8169072472690376, 0.26830465022891903, 0.019504063621973617, 0.10633883233458505, -0.08907319627912606, 0.9357144401358458, -0.21116741497620076, 0.6988974634491498, 0.18660711474316416, 0.06229958056522604, -0.02759786991136261, 0.06478562167338951, 1.7104727914006965, 0.41580538166620484, 0.48568272007136515, 0.04783838250127539, 0.020814886785350074, 2.1457300774676713, 0.007356470395559214, 2.172330240322502, 0.04616755613459663, 1.2008605797405867, -0.397478543812714, 0.61570690319105, 0.039989607869967116, 1.5309872887707028, 0.15418153034972162, -0.09123551705301218, 0.02096537247679933, 0.37120263845735463, -0.18266548205572158, 1.0359188254865128, 0.4036638351924194, -0.07519339205637042, 0.5227127445442219, 0.05410189050035575, -0.08656818655789404, 0.16657423238426147, 0.30572260913137167, -0.11091625441585885, 0.10010135196281703, -0.009880016732427456, -0.01877337473866218, 0.025040060376531937, 0.11735972788089417, 1.6263755839334684, 0.009259374068977994, 0.0024252748329659252, 1.11716752643206, -0.27701805120151307, 0.5399486211625079, 0.00734523170521713, 0.21724784090701474, 0.6970913369233964, 0.6671322765556199, 0.010057593141333237, -0.037225148728744, 0.0776805184899941, 0.5571163714513864, 0.08984774913348495, 0.3212303862278484, 0.12490339328697884, 0.4203408747847555, -0.09187043163949977, 0.02449115539215194, -0.018343959760495777, 0.813619437205731, -0.01959681556097678, -0.018026980880008286, 0.8893789744649984, 0.8178676376083235, 0.04958066958602028, 0.04356156184428969, 0.8891779018105791, 0.05792540820467329, -0.011395646437098629, -0.01572515024927436, 0.07940661793232942, 0.7203871709240296, -0.07545039104425516, 0.11230946721460933, 0.20193722774963016, 0.003015365496301932, 0.005020013767844134, -0.1972052154638354, 0.5464803806299969, -0.16677134711627328, 1.4488628758487014, 1.5488833293539046, -0.09961726258639443, -0.028874030626161746, 0.22121914104861132, 0.1388464257132178, -0.06122867112531885, -0.2414905193497684, 0.9401684079616982, -0.05108257596980704, 0.06053970768822435, 0.023913930021069653, -0.021732186618391613, 0.1992948746014453, -0.031621500073963464, 0.03462049455599401, 0.5054791341469824, 0.07991382384148721, 0.35964336237587563, 0.81343579322516, 0.46568127497507195, 0.29591979407982366, -0.09854421853756713, 0.6770918747240255, -0.12994342628495664, 0.040768102941021976, 0.2920687846150235, 0.0436553293936579, -0.02960461776320916, 0.026481443331620363, 0.1205941743418337, 0.00999988297513895, 0.00396283122556497, 0.030118630585207577, -3.283558766888098e-05, -0.006499152944784987, 0.015956284664620363, 0.013218262679743643, -0.005182883415759822, 0.40497902239582223, 0.09615922699676556, 0.12476304908181121, 0.06975857919875515, 0.888721670440536, -0.03546832699048165, -0.20148933860906257, 0.5343262261606857, 0.021573540098168517, 0.005242773140795682, -0.004219171481335252, 0.008690428521787016, 0.1653922797490988, 0.0952738065377342, -0.010516924987284897, 0.2004586095074282, 0.15706853050581984, 0.3243949801450732, -0.00538015687244109, 0.006184493427559534, 0.5598011131015412, 0.6254860508905735, 0.009652516001244654, -0.004445555660409587, 1.2290466425764304, 0.07190826189616341, 0.851468266786895, 0.3785713014755912, 0.05826399783315324, 0.6730296204612914, 0.5622110434457817, -0.1343074222169542, 0.020230808442028295, 0.02029758124779886, 0.4542380888359486, 0.06345544653838558, 0.24654618397499248, 1.0249548080909383, -0.01167330322614518, 0.016030926824456507, 1.3483019053604102, 0.5645309617594004, 1.3150834532314095, -0.044127312532821435, -0.20760175367187667, 0.32398804253692387, 1.314991089940065, 0.048506206238237266, 1.61287365972475, 0.4393180480882201, 1.2863722840566914, -0.0016053611026388911, 0.43989800747930846, -0.32351171863053607, 0.03758474976054287, 0.05377273129973486, -0.05976952717682914, 0.5774630625610535, 0.0008270380440922077, 0.0035305855536817534, -0.054486278010241786, 0.11242516453075374, 0.025171519269912342, 0.00858760043526758, 0.02703876262316723, 0.005073571021887128, -0.0013000665482681816, 0.011852797275328808, -0.0013088952194782327, 0.009820130788535133, 0.02672573088218935, 0.010897625191157041, 0.024758130206384572, 0.008915863082490698, -0.001224541353522044, 0.008180156469535292, -0.001188089747493027, 0.009979459639974975], "data_vars": [1.0594801205308153e-06, 2.72553588980069e-07, 3.7988368634865136e-06, 6.730361387678675e-06, 5.382387910664084e-05, 1.4978481289035853e-05, 3.5773445538152376e-05, 2.0224043314169212e-05, 2.6317390289297953e-05, 1.227910370727598e-05, 1.8648014356658804e-05, 1.4662624916554039e-05, 9.799171659967827e-06, 0.00017095841321037328, 7.311893974981522e-05, 2.9441713510149237e-05, 0.005225893288629064, 0.0028374739657766428, 0.00678398211868441, 0.002322501276525359, 0.00013862722041777442, 5.255941875272884e-05, 8.58021780011788e-05, 5.038473873323951e-05, 2.8834719546333655e-05, 0.0013151360089039715, 3.15490192363032e-05, 0.0008209740273787001, 0.0001172119890501515, 7.833936052847098e-05, 3.080665301040198e-05, 2.3855366066862103e-05, 4.098870774195066e-05, 1.577872604882566e-05, 3.777997866542689e-05, 1.7139442116454595e-05, 0.0001266338168132882, 0.00019123168186105624, 4.597980577459236e-05, 0.00014712887075672365, 0.0018658199991028772, 3.416392848559877e-05, 0.001478144088557997, 2.8455102615764692e-05, 2.1201380628526838e-05, 0.0003988532432003527, 1.4588718155896496e-05, 0.00019983088975605276, 0.0005583788067640479, 0.000534455297628438, 0.00041846648624599485, 0.00035519160956331696, 0.00010893942929291084, 9.09931676521948e-05, 3.704344852322119e-05, 0.00016569538794032488, 0.0004594615237641983, 0.0007473696876091683, 0.0003232885648217517, 0.0002356087809258197, 6.903223820408824e-06, 9.731763441141467e-06, 4.943062046791749e-06, 1.2067491014262364e-05, 0.000282518172429494, 6.421520075549829e-05, 0.00022520252256963866, 0.0001305839418841626, 8.05853318759496e-05, 2.154865663645441e-05, 6.849526638026344e-05, 1.9905856718580128e-05, 1.063394425178834e-05, 6.684350021462971e-05, 1.2243595462802196e-05, 0.00011764053314451079, 4.8706751674116746e-05, 0.00012179014160801195, 3.9239010304833594e-05, 0.00018678456283816288, 7.59212460544177e-05, 0.0005390414758983796, 4.463243783750214e-05, 0.0007154965023986585, 7.853140632135996e-05, 0.00014656040832005196, 4.540224426132477e-05, 0.00025333310840939746, 8.93263004497438e-06, 2.5541485784743427e-05, 6.6961859693778205e-06, 3.07060482378342e-05, 0.0009295672533190327, 6.394837261505954e-05, 0.00043944951989356815, 4.5976043522878764e-05, 2.9207621277667296e-05, 0.00018984344627069193, 2.0565122878195812e-05, 0.000368023639285626, 6.328525393661417e-05, 0.002120390043420581, 5.670296365350776e-05, 0.0019229787935683331, 0.0002193701562054889, 0.00021380304685861287, 5.257695527372076e-05, 0.0005328186713886013, 0.003814391219656698, 0.0008305742738303386, 0.002654193160324723, 0.0012865001262028913, 6.65716243667182e-05, 0.0010030085716642944, 2.608440140339554e-05, 0.0009714798439484752, 0.0026367131321440762, 0.00033373695172968107, 0.0018241938840383304, 0.0006939411172079906, 0.00036774940900889116, 0.0013835494689630576, 0.0003236062115370001, 0.0019398536708528547, 6.9349123331590025e-06, 2.8212777060862372e-05, 1.0520786701974194e-05, 2.223965436649442e-05, 0.0002841007467161194, 8.35507749589621e-05, 0.0001868079734183123, 0.00017785691073792312, 1.5040203945242374e-05, 2.1106750654828438e-05, 2.014651574732065e-05, 1.3751005877251281e-05, 4.039833658480404e-05, 0.0002941485977866763, 2.7693942679989096e-05, 0.0004117018128223004, 0.00011790802462844803, 0.00011509538582381228, 6.519024603837533e-05, 0.00016213059168665529, 0.005903053302286863, 0.001588309274099357, 0.004786686836110475, 0.0015325057267862325, 0.00013753248252362508, 0.0004274627780234333, 9.126708743567628e-06, 0.00011621143917080332, 8.505602516428852e-06, 3.475490238169531e-05, 0.00044549906467956685, 0.0004950659769685739, 0.0003520399406755685, 0.0005233835821065716, 0.0001854131539241624, 0.001288761678244539, 0.0006267461831987571, 0.00045050900910631854, 2.2111706877839136e-05, 4.0591065209522494e-06, 1.0764652121215444e-05, 8.458620084713004e-06, 0.0011354624118341714, 0.00047674312631690985, 0.0008284944694969081, 0.0005062678778341236, 0.00010051244590174548, 9.63640333502573e-06, 8.925428115883175e-06, 6.470059069342805e-05, 3.536558243021772e-05, 0.0014407558324813078, 7.062666024618787e-05, 0.0011398964647312138, 2.6524731792599268e-05, 0.0005790577238575185, 2.313234770159121e-05, 0.0002757053962291123, 4.242263899258239e-05, 0.0012787117686122815, 5.037567854500018e-05, 0.0009977659871532926, 0.0015498954953229265, 0.0002545094331805259, 0.0009067194447282792, 0.0006139468867998354, 5.792205125306312e-05, 0.00018607646040982737, 5.687970128678185e-05, 9.993866173432596e-05, 3.947069101117978e-05, 0.0008518351053578166, 0.00012896899612514274, 0.0003753703719456032, 2.4627795913546084e-06, 1.0976770033251338e-06, 1.2838225709455346e-06, 4.1076045595827125e-06, 5.205744076071994e-06, 1.4363290542444095e-05, 1.3838820807275359e-06, 4.675906729856298e-06, 0.0012042540454591155, 0.0007251887783729236, 3.0118107959853865e-05, 3.535110053751745e-05, 1.7155083332954026e-05, 4.7429870637447556e-05, 4.646046118769793e-05, 5.099185095581704e-05, 2.623175882477902e-05, 4.0155149421197127e-05, 3.578654731262653e-05, 2.248446272990295e-05, 2.1816581629413414e-05, 2.5767940328241642e-05, 4.6046122194404476e-05, 1.7910188450481216e-05, 3.1516709181278855e-05, 1.6733073839620444e-05, 3.235934484917388e-05, 1.2664208427478894e-05, 2.2913501824478763e-05, 1.3080697172451038e-05, 1.7639602231210943e-05, 1.691637100385546e-05, 1.8790203604608645e-05, 1.742243847999937e-05, 2.072873003580199e-05, 8.173765376737344e-05, 3.707455365325117e-05, 3.288124146827863e-05, 5.776563236440849e-05, 0.00013844566676100658, 2.5310417305476104e-05, 0.00013090567247848905, 0.0004551501948939528, 6.580804229596052e-05, 0.00019366860048942327, 0.00017888524401412392, 0.00024890852595073863, 0.00013769675254980478, 0.00016768135371975844, 0.00018049930151472747, 3.8020972625608456e-05, 3.624636995182391e-05, 4.781449297998094e-05, 2.9392546563003094e-05, 5.877569363846459e-05, 3.029918664333598e-05, 4.50557338132182e-05, 4.9126860606107744e-05, 4.692762117159518e-05, 3.634602031165738e-05, 1.328324011174233e-05, 0.00010006177450698811, 2.6005991748777444e-05, 1.2087272541558745e-05, 2.2154778823852434e-05, 2.0779639848173243e-05, 2.0449343251717482e-05, 2.9990687351420636e-05, 1.4909388681776284e-05, 4.544158817316401e-05, 4.7410137989570686e-05, 0.000509364689853423, 4.025966413131982e-05, 0.0007597799815349537, 1.6077247826510004e-05, 9.46928645848218e-06, 7.849952096537642e-06, 1.4638087065272441e-05, 1.9033532774381275e-05, 5.9592194467675424e-05, 1.852478548202761e-05, 5.938890733828287e-05, 0.0030674286681230006, 0.00037027426368636986, 0.0038221061281181576, 0.00025683718396529704, 0.0002810714744834999, 0.0010356764474608688, 0.0002771951488042809, 0.0006982421214743314, 3.989063291967361e-06, 2.886712735656816e-07, 3.671604629569832e-06, 7.776125261306862e-06, 1.662905028704839e-05, 5.303564654566287e-05, 2.095799373053182e-05, 3.518568668426357e-05, 1.3615743459573504e-05, 2.7103885863378598e-05, 1.6124509904006974e-05, 1.9269593591349022e-05, 0.0001896603421464517, 1.0802718302957497e-05, 3.239612874467313e-05, 8.805876780318547e-05, 0.002657483682664032, 0.005545986272358718, 0.0024383602004632767, 0.006805730363136899, 5.049520486134653e-05, 0.0001450821936100045, 5.218467379589039e-05, 8.691148773624864e-05, 0.0013072194292576911, 3.1636301011706656e-05, 0.0008259194322667765, 2.920649012044813e-05, 8.586513923936261e-05, 0.00011410225703478834, 2.8167876709062274e-05, 3.23753769573201e-05, 1.4386710196565252e-05, 4.154294106928284e-05, 1.5467029340489954e-05, 3.846667303088213e-05, 0.00019466793706713728, 0.00014424235912089022, 0.0001539456278170183, 5.367565324182263e-05, 4.488339586641347e-05, 0.0018459472165018676, 2.934853341919321e-05, 0.001451140232307887, 0.0004086938898506197, 2.4670905532773632e-05, 0.00020493353524847678, 1.4582483736128335e-05, 0.0005469165058671916, 0.0005018116113807328, 0.0003505513967033428, 0.00038392131044362926, 0.00010093614483008115, 0.00010216691798561244, 0.00017349402511244067, 3.5719120836273674e-05, 0.0007938609399408804, 0.0005071729709766206, 0.0002513785236284059, 0.0003634408991069559, 1.009386294159729e-05, 6.35935259812004e-06, 1.2514507930647499e-05, 4.532351099854603e-06, 6.820484285330995e-05, 0.0003165136385308242, 0.00014078474897105217, 0.00024837245826614683, 2.2874529017175536e-05, 8.249541596168185e-05, 2.0764759446661313e-05, 6.941898849135086e-05, 7.198516491245287e-05, 1.1038006363088498e-05, 0.00012616478743427182, 1.1770277061748145e-05, 0.00013431477176269486, 5.340208921553055e-05, 0.000209955759045609, 4.181038356394016e-05, 0.0005491049921753959, 7.359725529386096e-05, 0.0007095865583166179, 4.749631315965734e-05, 0.00015778888570367911, 8.135479556482263e-05, 0.0002691801304123532, 4.8823863604869186e-05, 2.5478508546013452e-05, 8.402027430345306e-06, 2.966169259180345e-05, 6.424385466109649e-06, 7.259270272280489e-05, 0.0009013820073693063, 4.334714309475501e-05, 0.00042500444687302647, 0.00020466659134382194, 3.0451779636919616e-05, 0.00038903646287579953, 2.1414635967875257e-05, 0.002091925139605111, 6.704713121554934e-05, 0.0018982382834611304, 5.413316352103373e-05, 0.0002253345825814175, 0.0002350199159922918, 0.0005631019408299877, 5.485341657401156e-05, 0.000893003516032224, 0.003974664028897229, 0.0013825110137737906, 0.0027854986136836655, 0.0011139854337367681, 5.893910828042108e-05, 0.001104527098907065, 2.357686004898443e-05, 0.00038127028931351576, 0.002753305541562316, 0.0007599345405812764, 0.0019364797653093214, 0.0014197973808631641, 0.0003262614035357424, 0.001967335122018848, 0.0002840962851013697, 2.8541765785971127e-05, 7.038523433405274e-06, 2.3363396036289937e-05, 1.0381025025151376e-05, 8.804632461431727e-05, 0.00031310651680594787, 0.00019293140720539554, 0.00020476966850655086, 2.1022798589621955e-05, 1.6603221990393116e-05, 1.3379594794981458e-05, 2.1750908557069433e-05, 0.00034056915960214637, 3.963149043231508e-05, 0.00047662512938142544, 2.8063725544958754e-05, 0.00011824217820738248, 0.00012024631493814224, 0.0001617605351590279, 6.547254455289843e-05, 0.0016911000058703741, 0.0059833933022530395, 0.0015826378777956225, 0.004929458372073227, 0.00041340463123020534, 0.00015613844632310578, 0.00013616697113046097, 1.0517754082391674e-05, 4.0599309254680175e-05, 9.906946287010044e-06, 0.0005300195513288564, 0.0004651586435184858, 0.0005693578810630607, 0.00036852427958986055, 0.0014026523090673187, 0.00019992141581249854, 0.000471143907764555, 0.0007232345957248597, 4.220988817819786e-06, 2.3318678358921362e-05, 8.918937289783813e-06, 1.1819459720737379e-05, 0.0004947720866344912, 0.0012536213932252947, 0.0005450334673496501, 0.0009422788305095586, 1.0793877618552273e-05, 0.00010276351545406927, 6.721708892870326e-05, 9.114764600588951e-06, 0.0016395141939564034, 3.984322992251746e-05, 0.001281557326066383, 8.153000998534548e-05, 0.0006771397377354394, 2.9020293570717066e-05, 0.00032346827477380596, 2.6158493145993326e-05, 0.0014703977033993399, 4.333347856930253e-05, 0.0011614821816555833, 5.594344333283241e-05, 0.00029342167089840875, 0.0016783439180827334, 0.0006811830536370498, 0.00103254559971164, 0.00018596196950305746, 7.185864764449183e-05, 0.00010270906838083589, 6.81023908656535e-05, 0.0009530744656703594, 4.196076121243067e-05, 0.00041481185742566113, 0.00015174895884640714, 1.308589401714769e-06, 2.3483779785318378e-06, 4.473219552290187e-06, 1.290128157917126e-06, 1.564595023951315e-05, 5.752944671330411e-06, 5.2332005777634825e-06, 1.4335919535561773e-06, 0.0008012569145745162, 0.0013041030325391398, 4.066122322779061e-05, 3.112917151359397e-05, 5.3139271538946026e-05, 1.7704370390000434e-05, 5.335118036498261e-05, 5.076067753601732e-05, 4.14375299195684e-05, 2.7826700900967583e-05, 2.4921739120871814e-05, 3.709416286909844e-05, 2.8226730024582733e-05, 2.237791590635615e-05, 1.9817148670105723e-05, 4.867321884792953e-05, 1.7647917672507583e-05, 3.336846870688537e-05, 1.338636076347479e-05, 3.304390154901161e-05, 1.3431685284735607e-05, 2.3752317402267957e-05, 1.6271843611418986e-05, 1.7490864541389843e-05, 1.6916958972574546e-05, 1.8544774450939302e-05, 8.4290810572701e-05, 2.1012165531900607e-05, 3.5285717024879804e-05, 3.90051782313286e-05, 0.0001504116346373979, 5.6808343466785675e-05, 0.00014391068257186247, 2.478027876948236e-05, 6.872259501529872e-05, 0.0004700693933369619, 0.000185264553862014, 0.00020440561339353085, 0.00014038092054105157, 0.0002537785565665306, 0.00018363246361181412, 0.00017304890715759798, 3.997543339358139e-05, 4.3703645630370785e-05, 3.318296648457938e-05, 5.3790687445191556e-05, 3.287151771452928e-05, 6.621150252527674e-05, 5.226832736147495e-05, 5.012885499764175e-05, 4.0893197111986885e-05, 5.129649959552995e-05, 0.00010700083783896036, 1.4696610687008682e-05, 1.2252053163148733e-05, 2.6339505913995684e-05, 2.0209485671857402e-05, 2.3515964325263428e-05, 3.086313418333645e-05, 2.3108580584172636e-05, 4.7086339482070564e-05, 1.7002849247245414e-05, 0.000526775162629274, 4.972016833670023e-05, 0.0007937344677830592, 4.448499283137594e-05, 9.979479349650605e-06, 1.718021396225208e-05, 1.533085333552541e-05, 8.560415067516582e-06, 7.031777212638991e-05, 1.937512362494311e-05, 6.746262514771441e-05, 2.0866454006894525e-05, 0.004484593106525537, 0.0007668633766489154, 0.0030792645823952422, 0.00040701724896781064, 0.0003079171281180028, 0.0006502751077376835, 0.0003026982738919248, 0.0010683636652686237, 7.380826644880708e-05, 8.767555852105811e-05, 8.586963935385035e-05, 7.452072471361698e-05, 4.920818909294053e-05, 5.1076814276089675e-06, 5.280467803255978e-06, 5.0012218918678475e-05, 5.1315562805696116e-05, 2.9926894343767807e-06, 3.1282787171297654e-06, 5.231017232493421e-05, 2.6995513415273745e-06, 8.317840305466506e-05, 8.527858440735452e-05, 2.8848691133020246e-06, 3.197438698151059e-06, 6.427759576227202e-05, 6.510412604777124e-05, 3.4200361855872223e-06, 1.0930500956427844e-06, 5.0006521150210716e-05, 4.934381323545789e-05, 1.2150285470595734e-06, 2.204378526965042e-06, 4.094760623768627e-05, 4.0494659080191176e-05, 2.3048697417565745e-06, 3.631712062847348e-05, 1.6087346279806101e-06, 1.5795127714626879e-06, 3.449773933162498e-05, 3.8410113264787835e-05, 7.968609067409286e-07, 7.54982520509772e-07, 3.663219895014984e-05, 7.005645047100158e-07, 2.8933343047735935e-05, 2.849427840279321e-05, 7.005870823241553e-07, 7.186326436270446e-07, 2.807141354312301e-05, 2.722173772681299e-05, 7.263923361359025e-07, 0.0005748062997494172, 7.844123024687041e-05, 7.369185239816194e-05, 0.0006657247166769471, 0.000548876968526337, 6.112311305859667e-05, 6.259301832718787e-05, 0.0006443077121636475, 6.572694163487291e-05, 0.00024821734343091886, 0.00026346482874760926, 6.554586160349207e-05, 9.707101379650248e-05, 0.00017033783056814695, 0.0001804611233436268, 9.861449458364352e-05, 0.0006930568792454487, 0.00015514264761862744, 0.0001320027762165087, 0.0007085530264936803, 0.0007871453158197991, 0.00015119453092530082, 0.00012895585380845044, 0.0008066999589798472, 1.034755340285389e-06, 3.368636098823187e-05, 3.3907346109831475e-05, 1.0664281048537583e-06, 6.817795006145992e-07, 3.7713410328312895e-05, 3.796549374366082e-05, 7.593141554810855e-07, 9.63607861114164e-05, 0.00016442209750320883, 0.00013704455349696667, 7.672023803388378e-05, 6.241748157321283e-05, 0.00020017651296967955, 0.00016126828505704245, 5.004489235380213e-05, 0.000102006168303008, 2.8795739964100456e-05, 2.4456504856942155e-05, 9.004075678305491e-05, 4.09233714299581e-06, 4.329014689344e-05, 4.2341046404766565e-05, 3.91540675524413e-06, 1.433305805200348e-06, 5.361463329354774e-05, 5.2342653037891905e-05, 1.4340675326900563e-06, 5.8026236440518094e-05, 6.82725767618621e-05, 6.701268004247009e-05, 6.225420301378221e-05, 7.397851497173414e-05, 6.918936128803613e-05, 6.937241269980972e-05, 7.920422099520613e-05, 0.0003651419437893758, 0.0001372237861984732, 0.00012770533825599476, 0.00036932087676698174, 0.0004926794293880091, 0.00013809872858761504, 0.00013015138228627345, 0.0005019439576907384, 6.643060055650643e-05, 4.155122193681433e-06, 4.115083964435009e-06, 6.4469319801529e-05, 5.514226660152654e-05, 2.0048750106420783e-06, 2.001652764289049e-06, 5.32590120574903e-05, 8.67072713425863e-05, 1.0355574613781575e-05, 1.0148190282555193e-05, 8.785209656700202e-05, 8.15460565069817e-05, 1.2153466507199566e-05, 1.1925310289271221e-05, 8.184310746183355e-05, 0.0008248400078191776, 8.056395147235542e-05, 8.594712396412276e-05, 0.0009116735494243868, 0.0007443043385693175, 9.411292273322973e-05, 0.00010187733308670901, 0.0008442927167990665, 8.714442100577892e-05, 0.0004019647020428796, 0.00041461392223092307, 9.28454957140103e-05, 7.358304596003851e-05, 0.00044489825967648794, 0.0004746281249334342, 7.383791601601093e-05, 3.4594909862063656e-05, 1.1255487050824329e-06, 1.0350356966630901e-06, 3.412482244812239e-05, 3.852096965612535e-05, 2.204799194406762e-07, 2.115861839015694e-07, 3.74415320962922e-05, 0.0002865712160648112, 0.00017079251586722303, 0.00014721457797135145, 0.00025499609593609285, 0.00031915733991977845, 0.0007379175096554074, 0.0007672092225756608, 0.00026040492985396455, 0.0001768068168344776, 0.0008593821178686512, 0.000880411018782785, 0.00015905347594424396, 8.225754869055655e-05, 0.00013209466568600954, 0.00010699709623987626, 8.453042977292899e-05, 6.040144094242186e-05, 0.00016391034022622918, 0.0001336149658288617, 6.078396596978433e-05, 5.759516284861461e-05, 0.0001500916510703256, 0.00012001119650064457, 4.747137483366554e-05, 4.0962214620813084e-05, 0.00017194745503194071, 0.00013514226826199185, 3.448166270081673e-05, 3.547497677673516e-07, 3.036416279060138e-05, 3.066900264586907e-05, 4.0424831104298443e-07, 4.3974987742151497e-07, 2.9614195545265745e-05, 2.968233429764669e-05, 4.331177230579997e-07, 3.3050434025198383e-06, 5.361758688649746e-05, 5.3052218478669644e-05, 3.1824066989472778e-06, 3.3496948541293564e-06, 4.5508464059287835e-05, 4.441584700918188e-05, 3.2985719227681086e-06, 1.428909773089303e-06, 3.363385128034181e-05, 3.281282590392399e-05, 1.4347328032300456e-06, 1.6542821385719143e-06, 2.9329845712894246e-05, 2.8338369312012055e-05, 1.6254595813571563e-06, 0.00021026307710566363, 0.0010925110837346518, 0.0010350053304132125, 0.00018425809763950545, 0.00045753421984828915, 0.0005769741651165493, 0.0005260894038302856, 0.0004220543257882114, 1.1062332955682802e-06, 3.928817062942873e-05, 3.7693850973500995e-05, 1.0575637484680397e-06, 1.957641110897599e-06, 3.2462767902798574e-05, 3.159821333986785e-05, 1.7849670272787905e-06, 2.2724039314337258e-06, 2.7809925192343464e-05, 2.737673907576963e-05, 2.2662603373686167e-06, 7.975525628647507e-07, 3.5423045610205394e-05, 3.504132897184692e-05, 7.77745329182233e-07, 5.059459782736882e-05, 4.956888957672382e-06, 4.829148000150586e-06, 4.850182449122898e-05, 4.1655476422815715e-05, 3.424203988537197e-06, 3.3221456706416073e-06, 3.993260456516565e-05, 7.309903699073522e-05, 1.0567608484287605e-05, 9.97421878720741e-06, 7.249624657794608e-05, 6.256899482349968e-05, 1.5022805879781487e-05, 1.4160685630548545e-05, 6.234668535382133e-05, 4.881545108686454e-05, 4.657793399647491e-06, 4.393124328825578e-06, 4.8397057720475864e-05, 4.188836595654353e-05, 5.747616284205044e-06, 5.377559598453116e-06, 4.15533689863155e-05, 2.6178371708873654e-06, 3.0720942640474924e-05, 2.987501383800604e-05, 2.469225889377192e-06, 2.065834536164378e-06, 3.5312511541192126e-05, 3.421162668189442e-05, 1.8452265013482172e-06, 1.8027843375079875e-05, 1.1167827040778146e-06, 1.0160326343044813e-06, 1.7263075914591007e-05, 2.2885636213750884e-05, 1.5913745605607775e-06, 1.4965203497486081e-06, 2.1955686521187286e-05, 1.2843038275090144e-06, 2.8584156387949048e-05, 2.7919224372100145e-05, 1.1470989483830683e-06, 8.19167840298043e-07, 2.5830889319138603e-05, 2.486849184820467e-05, 8.385502977668323e-07, 0.0001345817268736535, 0.0004609122320990311, 0.0005063558022713558, 0.0001483029504132185, 6.575319369800412e-05, 0.0006490963588467264, 0.0007395909693945843, 6.891778968186606e-05, 3.104043189451991e-06, 4.0732580034462656e-05, 4.0057558652267166e-05, 3.302210308130301e-06, 2.7119271360563616e-06, 3.2080650470481e-05, 3.199685054016754e-05, 2.62949887547284e-06, 6.205801703668073e-07, 2.3435136685035433e-05, 2.3564870457758668e-05, 6.111407357442097e-07, 1.7364822917457815e-07, 2.3396634951514785e-05, 2.412478202058324e-05, 1.6617048287102596e-07, 0.00010577427206275059, 8.097429633672431e-05, 6.81775525358065e-05, 8.856608222585093e-05, 0.0001262607449564163, 6.661871631104395e-05, 5.4807696673640976e-05, 0.00010255449047653664, 1.4183822017694884e-05, 2.4413479914436795e-05, 2.7834662182947393e-05, 1.4086130089120049e-05, 9.771237470405123e-06, 2.3209326059032636e-05, 2.6616221829314822e-05, 9.810247996929998e-06, 0.00013251767077957952, 0.0010884403075358854, 0.001084258701316466, 0.00011577565644882892, 0.00014038050132153372, 0.000817444118885173, 0.0008251341355283005, 0.00011598642635467235, 4.961574018107203e-06, 4.914665752821996e-05, 5.015333996767014e-05, 4.836332823371192e-06, 7.137939107402958e-06, 4.431798023505323e-05, 4.498455935510227e-05, 6.864582412150762e-06, 4.705954345267453e-06, 4.204399091714339e-05, 4.2485718046191276e-05, 4.7918814680223065e-06, 4.18855849863504e-06, 3.8623924977088175e-05, 3.8249047860901636e-05, 4.4602310717939e-06, 0.00023399488691256272, 4.7073718065383475e-05, 4.493855625724958e-05, 0.00020339517028317717, 0.00020343699724544265, 5.57538273729579e-05, 5.250949890319037e-05, 0.0001751908092586548, 5.074823254782748e-05, 9.811263830196532e-05, 0.00010090359479026399, 5.077950423387889e-05, 2.1507121504022256e-05, 0.00010663511208717571, 0.00010309294331898183, 2.1760317374897242e-05, 3.7693055201634435e-05, 4.577140202819219e-06, 4.439624400136502e-06, 3.677311510489764e-05, 3.083027938034853e-05, 4.082330546227533e-06, 3.957059338425908e-06, 3.0207473360351686e-05, 5.778164883701727e-05, 9.827040316223498e-06, 9.495752238848753e-06, 5.672481915820477e-05, 4.915904531361034e-05, 8.019393134515162e-06, 7.67077903291333e-06, 4.832725108851232e-05, 7.060737824679604e-05, 7.087459457777584e-06, 7.024246867748977e-06, 6.819720116417174e-05, 6.464653895854007e-05, 5.643332659783258e-06, 5.448958231798164e-06, 6.370210740737886e-05, 0.00017407749567632339, 0.0006552468477936813, 0.0006481075869470452, 0.00018448423784217407, 0.00015268141475435, 0.0006108142979046571, 0.0006130722460031794, 0.00016198069718283907, 5.2953352649156803e-05, 0.00012819539704001553, 0.00012247072064465393, 5.316043853056784e-05, 6.860664324599582e-05, 0.00012420655139888103, 0.00011649256006491355, 7.138000577207459e-05, 9.291471082572729e-07, 2.7352308562128744e-05, 2.654887025666355e-05, 8.606095420509763e-07, 5.537846395185544e-07, 2.5590772574211888e-05, 2.495377990595971e-05, 5.510433828377089e-07, 3.24899192745148e-05, 8.989999716263888e-07, 8.28089939106559e-07, 3.1885405643919995e-05, 4.070294574753956e-05, 5.463908801342247e-07, 5.466547417920515e-07, 3.984310082621543e-05, 0.0004606443676811983, 0.0001015653935648403, 8.862608692447569e-05, 0.0005385981846836117, 0.0005583609459689752, 4.5695426458850135e-05, 4.193868288953972e-05, 0.0006282743449053935, 0.00010365184094127442, 0.0002337741399291531, 0.00020398806789257185, 8.275986013634972e-05, 0.00014326591107720582, 0.00012324123332968596, 0.00010672000598673305, 0.00011246420095652848, 4.519486004513718e-05, 0.014267650713839508, 0.014239215945462179, 4.375686120747138e-05, 4.602734988962144e-05, 0.013178365971423368, 0.013120058611808443, 4.3214105593794766e-05, 8.780313952694347e-05, 0.01082106003425755, 0.010816486093976221, 8.810023082971834e-05, 8.287885303854529e-05, 0.008085113642837441, 0.008085517397519906, 8.330451842159912e-05, 0.00010198310740547659, 0.0054145075473547915, 0.0054008568260358525, 0.00010566411728876022, 0.00012138889448550911, 0.003090848845883638, 0.003081707429654503, 0.00011914462580340149, 5.879247623032381e-05, 0.0015575930185571564, 0.0015469430834569788, 5.942270235216951e-05, 0.00010513774100118838, 0.0005539897554077421, 0.0005491775670206694, 0.00010216636407601404, 0.00020313773750427674, 0.0006635680792487921, 0.0013997434948345032, 0.007026700589887805, 2.56126819554745e-05, 0.0003761783286083079, 0.0005976046748648476, 0.0002906714972704942, 0.00015987099729948792, 0.004209202172586877, 0.005755379591615814, 0.001388123704463277, 2.4743695593854282e-05, 7.639953383809642e-05, 0.00017155451643810854, 0.0022839357476078744, 4.511232734672015e-06, 0.00014461097013792755, 0.00012016473737666442, 0.00012081642921351525, 0.001287404370312779, 0.000559119062741553, 1.2211363787686158e-05, 1.1943189770155127e-05, 0.00591788288202052, 0.019970213002928627, 0.011754112899173096, 0.0024562012465942883, 1.4966125424274376e-05, 0.00023154900645144116, 0.00045763796416625687, 0.006776609650876252, 0.004514175647521074, 0.014246316348391613, 0.0008767979765407122, 0.00018983794011457854, 1.7306137938797073e-05, 8.033268812390195e-05, 0.03407008217281547, 0.009033510198987566, 0.004784162356266646, 0.0009148315931940271, 9.674660838662389e-05, 0.05119441117301382, 8.159015275370149e-05, 0.05306120971223334, 0.00599150788386126, 0.01467267156401233, 0.0021825866379098446, 0.0052640944097296005, 0.00010816876005299564, 0.03834762676326592, 0.0016495416744712014, 0.001188717036299078, 6.297683999298468e-05, 0.010334266801472265, 0.0022021872519213596, 0.014402347502940505, 0.001942761715832034, 0.000733996632362841, 0.007071271115505972, 0.0008679402634111199, 0.0002893251565461353, 0.0006049124346317719, 0.0008918202020026816, 0.00018872808514114477, 0.0003803693186580078, 1.0433743941757444e-05, 1.6620916755727897e-05, 3.8407130452044214e-05, 0.003018393146749446, 0.034685579243857644, 2.6158463555000625e-05, 2.9174757763911876e-05, 0.019370178198613305, 0.0022742455769488045, 0.005614655505149592, 1.3537792252405265e-05, 0.0012835246306086888, 0.00826166558382751, 0.004342307530414021, 2.0190440888740574e-05, 0.00043911047754837307, 0.0007110761076740471, 0.0035900761491488536, 0.0001313651617928921, 0.0016026406003944993, 0.0015325373372423088, 0.0020368890468971832, 0.0001834908820637703, 1.995098967858798e-05, 1.742255620556468e-05, 0.01123970499901931, 3.874465089471696e-05, 3.826287067121454e-05, 0.012821405831850626, 0.011399677585419493, 0.00014067605178906035, 0.00013476469008755215, 0.012971114644962258, 5.589956235246366e-05, 2.156021697065197e-06, 3.6593093085241535e-06, 8.667524574060525e-05, 0.009529199161653519, 0.0004432162566449831, 0.0003712097415578356, 0.0007127187598614023, 9.99060923144683e-05, 9.709561650753267e-05, 0.0008781382729594536, 0.005303694150017595, 0.0004200359221073041, 0.0102602571470586, 0.011731014242210444, 0.0003298130152788408, 2.1671197686147745e-05, 0.0008185238365552727, 0.0002961379734956069, 6.060044851056479e-05, 0.0004587564663591653, 0.004920448813340636, 8.215994027169422e-05, 0.00011518520448716753, 7.526827441138758e-06, 6.255837606217936e-06, 0.0007030857665976702, 5.591064818289419e-05, 0.0017663077955264732, 0.0037088124319359372, 0.0012121835180012811, 0.0015485836482227908, 0.007846585290566203, 0.0035311539219088804, 0.001038033380678755, 0.00016815954914440898, 0.006174188459948834, 0.002327755629472236, 0.00036181279444963025, 0.0014930931235972488, 3.118254855740899e-05, 1.5214208925518525e-05, 0.00014832280696650866, 0.0005808587333023869, 7.41353373174063e-05, 6.075581693139708e-05, 7.19239594832535e-05, 1.940848324161595e-06, 5.3008475782724834e-06, 1.996063491647412e-05, 1.4265780986755467e-05, 3.561953143583157e-06, 0.001608354886672519, 0.0005683950596934541, 0.00046496223731354243, 0.000607975541107159, 0.010788206047899599, 3.2779466326862344e-05, 0.0005829646249128405, 0.0050109353162559, 9.284660622989134e-06, 4.821815294353416e-07, 5.014127567432289e-07, 2.2616977194664663e-06, 0.0012882891782310508, 0.0005457962064423119, 7.157132602068503e-05, 0.0008556125010799068, 0.0015784865841231262, 0.0018903071876847917, 2.724052286138611e-06, 3.3968025715006133e-06, 0.0047496979914099105, 0.01155329972927938, 2.6166348081548594e-06, 9.072354966005404e-07, 0.028601383495686482, 0.0003352337899649174, 0.010868165074294032, 0.003537232566733904, 7.9260832822755e-05, 0.009361233155720365, 0.005983685358632272, 0.0008632653376820973, 4.0191168946359705e-05, 3.3130672905955115e-05, 0.004938751146984588, 0.00019241372782642852, 0.002505745406896359, 0.010845348993885574, 7.74723734228028e-06, 1.1984625501550946e-05, 0.01664856693711803, 0.011553323369603677, 0.021663160432844258, 0.0030285801966769502, 0.0018885408487559284, 0.004192168270427411, 0.021089477680105707, 4.795356948788662e-05, 0.03054924807601293, 0.0045193144548754316, 0.027618018124121166, 7.443953831486155e-06, 0.00496997682640464, 0.0022018376042287737, 0.0005228414329810238, 0.0007457928802658777, 0.00026654365162378737, 0.008096586116532856, 1.9870943719848092e-06, 2.4436384596768505e-06, 0.00014937311317124135, 0.00040143819601704466, 8.54224552076957e-05, 5.8208580629595665e-06, 8.6023355554555e-05, 5.667500726567963e-06, 7.346991348116933e-06, 1.894369483792884e-05, 7.185934556625867e-06, 1.7956148534892538e-05, 8.972296265525944e-05, 1.4430903429912857e-05, 9.129305628479893e-05, 6.114683719898276e-06, 8.014289411734202e-06, 1.4820639946981858e-05, 7.750950581008709e-06, 1.871186712950176e-05], "data_std": [0.001029310507344997, 0.0005220666518559378, 0.00194906050790798, 0.00259429400563596, 0.007336475932397028, 0.0038702042955166918, 0.0059810906645989224, 0.0044971149989931555, 0.005130047786258716, 0.003504155205934232, 0.004318334673998624, 0.0038291807108772028, 0.003130362863945301, 0.013075106623288901, 0.008550961334833367, 0.005426021886257854, 0.07229034021658125, 0.05326794501176709, 0.08236493257864302, 0.048192336284157866, 0.011774006132908816, 0.007249787497073886, 0.009262946507520098, 0.007098220814629502, 0.005369796974405425, 0.03626480399649185, 0.005616851363201915, 0.028652644334837583, 0.010826448588994985, 0.008850952520970326, 0.00555037413247089, 0.004884195539376173, 0.006402242399499621, 0.0039722444598520945, 0.006146542008758004, 0.004139980931895049, 0.011253169189756643, 0.01382865437636852, 0.006780841081650001, 0.01212966902915012, 0.04319513860497356, 0.0058449917438435075, 0.03844663949629404, 0.005334332443311412, 0.004604495697525066, 0.01997131050282762, 0.003819518052830291, 0.014136155409306052, 0.02363004034622133, 0.0231182892452802, 0.020456453413189562, 0.018846527785332686, 0.010437405295039129, 0.009539033895117198, 0.0060863329290485905, 0.012872272058200327, 0.0214350536216777, 0.027338062982025048, 0.017980227051451594, 0.015349553118114537, 0.002627398679380201, 0.0031195774459278082, 0.002223299810370106, 0.0034738294451890357, 0.01680827690245178, 0.008013438759702247, 0.015006749233916006, 0.011427333104629558, 0.008976933322463167, 0.004642053062649587, 0.00827618670525644, 0.004461598000557662, 0.003260972899578949, 0.008175787436976925, 0.0034990849464970404, 0.010846222067822086, 0.006979022257746191, 0.011035857085338318, 0.006264104908511159, 0.013666914898328842, 0.008713279867789036, 0.023217266762010975, 0.006680751292893796, 0.026748766371529332, 0.00886179475734797, 0.012106213624418329, 0.006738118747938832, 0.01591644144931264, 0.002988750582597079, 0.005053858504622327, 0.002587698971939708, 0.005541303839155023, 0.030488805377040157, 0.007996772637449407, 0.020963051302078334, 0.006780563658198245, 0.0054044075787885665, 0.01377836878119801, 0.00453487848549394, 0.019183942224830275, 0.00795520294754409, 0.04604769313896822, 0.007530137027538593, 0.043851782102536416, 0.014811149725983089, 0.014622005568957114, 0.0072509968468977256, 0.02308286532015905, 0.061760757926507814, 0.02881968552622215, 0.05151886218002803, 0.03586781462819963, 0.008159143604981971, 0.03167031057101105, 0.005107289046391984, 0.031168571413339997, 0.051348935063388376, 0.018268468784484404, 0.04271058281080147, 0.026342762140823248, 0.019176793501753393, 0.03719609480796415, 0.017989058105887593, 0.044043769943691864, 0.0026334221714641583, 0.0053115701125808715, 0.0032435762210828644, 0.004715893803564115, 0.016855288390179485, 0.00914061130116373, 0.013667771340577523, 0.013336300489188263, 0.0038781701800259328, 0.004594208381737646, 0.004488487022073323, 0.0037082348735282774, 0.006355968579595406, 0.017150760851538813, 0.005262503461280486, 0.02029043648673681, 0.010858546156297721, 0.01072825175990069, 0.008074047686159361, 0.01273305115385371, 0.07683133021292071, 0.03985359800694734, 0.06918588610482976, 0.03914723140640002, 0.011727424377229003, 0.020675172986541934, 0.0030210443134068106, 0.010780140962473697, 0.0029164366127911734, 0.005895328861199798, 0.02110684876241754, 0.022250078133988067, 0.018762727431681368, 0.02287757815212466, 0.013616649878885863, 0.035899326988740876, 0.025034899304745707, 0.021225197504530283, 0.004702308675303987, 0.0020147224426586034, 0.0032809529288326347, 0.0029083706924518758, 0.03369662315179626, 0.021834448156912732, 0.028783579858956184, 0.022500397281695353, 0.010025589553824028, 0.0031042556813229366, 0.002987545500219733, 0.008043667738875597, 0.005946896874019065, 0.03795728958291553, 0.00840396693509606, 0.0337623527724478, 0.005150216674335097, 0.024063618261963817, 0.00480960993237406, 0.016604378826957433, 0.006513266384279273, 0.0357590795269157, 0.00709758258458471, 0.03158743400710625, 0.03936871213696133, 0.015953351785143018, 0.03011178249005328, 0.02477795162639227, 0.007610653799317317, 0.0136409845835932, 0.007541863250336872, 0.009996932616274152, 0.0062825704143431435, 0.02918621430329423, 0.011356451740096585, 0.019374477333481882, 0.0015693245653320437, 0.0010477008176598575, 0.0011330589441620126, 0.002026722615352854, 0.0022816099745732164, 0.003789893209899732, 0.0011763851753263197, 0.0021623845009286157, 0.03470236368691786, 0.02692932933388657, 0.005487996716458007, 0.005945679148551279, 0.004141869545622366, 0.006886934778074173, 0.0068161911055734, 0.0071408578585361185, 0.005121694917190892, 0.006336809088271251, 0.005982185830666457, 0.004741778435345008, 0.00467082237185417, 0.005076213187824329, 0.006785729304533483, 0.004232043058675233, 0.005613974454989874, 0.004090608003661613, 0.00568852747634868, 0.0035586807144613146, 0.004786804970382516, 0.003616724647032317, 0.004199952646305782, 0.004112951617008819, 0.004334766845472619, 0.00417401946329906, 0.004552881509088721, 0.0090408878860084, 0.00608888771889014, 0.005734216726657498, 0.007600370541257084, 0.011766293671373607, 0.005030945965270955, 0.011441401683294274, 0.02133424933982803, 0.008112215621885337, 0.013916486643166201, 0.013374798840136771, 0.01577683510564583, 0.011734425957404341, 0.012949183515564155, 0.01343500284758911, 0.006166114872884583, 0.006020495822756122, 0.006914802454154489, 0.005421489330710068, 0.007666530743332644, 0.005504469696831474, 0.006712356800202012, 0.007009055614425366, 0.0068503737979467355, 0.006028766068745525, 0.003644617965129175, 0.01000308824848547, 0.005099607019053276, 0.0034766755013315156, 0.004706886319410363, 0.004558469024592933, 0.0045220950069317966, 0.005476375384450982, 0.0038612677557735213, 0.0067410376184356075, 0.006885502014346571, 0.022569109194946594, 0.00634505036475833, 0.0275641067610571, 0.004009644351623969, 0.00307722057358295, 0.0028017765964718964, 0.003825975309025457, 0.004362743720914773, 0.0077195980768220976, 0.0043040429228839725, 0.007706419878145939, 0.055384372056772484, 0.019242511886091426, 0.06182318438998559, 0.01602614064474966, 0.016765186383798418, 0.03218192734223463, 0.01664917862251111, 0.02642427144642462, 0.001997263951501494, 0.0005372813728072858, 0.0019161431652070864, 0.0027885704691305298, 0.004077873255392863, 0.007282557692573597, 0.0045779901409386875, 0.005931752412589687, 0.0036899516879728253, 0.0052061392474057585, 0.0040155335765010075, 0.00438971452276216, 0.013771722555528474, 0.00328674889563494, 0.005691759723027065, 0.009383963331300132, 0.05155078741070821, 0.07447137888047138, 0.049379754965605864, 0.08249685062556569, 0.007105997808988301, 0.012045006999167933, 0.007223896026099102, 0.009322633090294213, 0.036155489614409744, 0.005624615632352726, 0.02873881403723502, 0.005404302926414112, 0.009266344437768467, 0.010681865803069627, 0.005307341774284211, 0.005689936463381652, 0.0037929817026404506, 0.006445381375006667, 0.003932814429958519, 0.0062021506778602315, 0.013952345217458507, 0.012010094051292447, 0.01240748273490712, 0.007326366987929463, 0.006699507136081987, 0.042964487853364056, 0.005417428672275548, 0.038093834570805375, 0.020216178913202654, 0.004966981531350165, 0.014315499825310912, 0.0038187018391239104, 0.023386246083268506, 0.022401152010125124, 0.018723017831090767, 0.019593910034590576, 0.01004669820538475, 0.010107765232019016, 0.013171713066736637, 0.005976547568310125, 0.028175537970744773, 0.022520501126232086, 0.015854921117066646, 0.019064125972804415, 0.003177084031245836, 0.0025217756835452356, 0.003537585042178845, 0.0021289319152698618, 0.008258622333858713, 0.017790830181046196, 0.011865274921848721, 0.015759836873081738, 0.00478273237984058, 0.009082698715782763, 0.0045568365613286275, 0.00833180583615286, 0.00848440716328801, 0.003322349524521539, 0.011232309977661399, 0.003430783738702885, 0.011589424997069305, 0.007307673310673552, 0.0144898502078389, 0.006466094923826912, 0.02343298939903733, 0.00857888426859, 0.026638065964266586, 0.006891756899344124, 0.012561404607116161, 0.009019689327511377, 0.01640670992040614, 0.006987407502419563, 0.005047624049591397, 0.0028986250930993656, 0.005446254914324471, 0.0025346371468337727, 0.008520135135243155, 0.03002302462060254, 0.006583854729165507, 0.020615635980319076, 0.014306173190054073, 0.0055183131151575315, 0.019724007272250727, 0.004627595052278803, 0.045737568142667044, 0.008188231262949854, 0.0435687764742267, 0.0073575242793370195, 0.015011148609664002, 0.01533035929103724, 0.023729769085054066, 0.007406309241046552, 0.029883164424676045, 0.06304493658413203, 0.03718213299117992, 0.05277782312376729, 0.03337642032538493, 0.007677181011310146, 0.0332344264115851, 0.004855600894738408, 0.01952614373893411, 0.05247195004535581, 0.027566910247274295, 0.04400545154079573, 0.0376801987901227, 0.018062707536129305, 0.04435465163902032, 0.016855156039069164, 0.005342449418194909, 0.002653021566705645, 0.004833569699124027, 0.003221959811225363, 0.009383300305026866, 0.017694816099805836, 0.01388997506136694, 0.0143097752779892, 0.0045850625502409405, 0.004074705141527803, 0.0036578128430773296, 0.004663786933069459, 0.018454515967701413, 0.006295354670891472, 0.021831745907769845, 0.005297520697926414, 0.01087392193311054, 0.010965688074085558, 0.012718511515072348, 0.00809151064714732, 0.04112298634426218, 0.07735239687464791, 0.039782381499799915, 0.07021010163839123, 0.020332354296298434, 0.01249553705620954, 0.011669060421921765, 0.0032431087065332353, 0.006371758725397579, 0.0031475301884191743, 0.023022153490254913, 0.021567536797661567, 0.02386122128188456, 0.019196986211118153, 0.03745200006765084, 0.014139356980163508, 0.02170584962088688, 0.02689302132012801, 0.002054504518812209, 0.0048289417431691345, 0.0029864589884650706, 0.003437944112509303, 0.022243472899583176, 0.035406516253725026, 0.023345951840729264, 0.03069656056481831, 0.003285403722307545, 0.010137234112620132, 0.00819860286443387, 0.0030190668426831745, 0.04049091495578241, 0.0063121493900665454, 0.03579884531750128, 0.00902939698902122, 0.02602190880268854, 0.005387048688355904, 0.017985223789928385, 0.005114537432260451, 0.03834576512992458, 0.006582816917498353, 0.03408052496156101, 0.0074795349676856525, 0.017129555478715985, 0.04096759595195614, 0.02609948378104536, 0.03213324757492837, 0.01363678736004406, 0.008476948014733358, 0.010134548257363813, 0.008252417274087242, 0.03087190414714258, 0.006477712652814315, 0.020366930486100776, 0.012318642735561703, 0.0011439359255285102, 0.0015324418352850584, 0.0021149987121249474, 0.0011358380861360153, 0.003955496206484485, 0.0023985296894827902, 0.0022876189756520825, 0.0011973270036026822, 0.028306481847352846, 0.03611236675349789, 0.006376615342624221, 0.005579352248567388, 0.007289668822309147, 0.004207656163471587, 0.007304189233924776, 0.0071246528010856305, 0.00643719891875095, 0.005275101980148591, 0.004992167777716592, 0.006090497752162662, 0.005312883400243481, 0.004730530192944143, 0.0044516456137147446, 0.006976619442676341, 0.004200942474315446, 0.005776544703097637, 0.0036587375915026745, 0.005748382515891893, 0.003664926368255658, 0.004873634927060905, 0.004033837330807848, 0.004182208093984546, 0.004113023094096913, 0.004306364412232121, 0.009181002699743694, 0.004583902871124192, 0.005940178198074516, 0.0062454125749488, 0.012264242114268534, 0.007537130983788571, 0.011996277863231682, 0.004977979386205046, 0.008289909228411293, 0.02168108376758325, 0.013611192227795992, 0.014297049114888388, 0.01184824546255907, 0.015930428637250495, 0.013551105623225514, 0.013154805477755951, 0.006322612861276688, 0.006610873288028654, 0.005760465821839357, 0.007334213485111513, 0.0057333687928241, 0.008137045073322179, 0.0072296837663534735, 0.007080173373416907, 0.006394778894691112, 0.007162157467937294, 0.01034412093118407, 0.0038336158762986, 0.0035002932967322514, 0.005132202832507274, 0.004495496154136649, 0.004849326172290685, 0.005555459853453758, 0.004807138502703312, 0.006861948665071065, 0.004123451133122037, 0.02295158300922344, 0.007051252962183404, 0.028173293520336935, 0.006669707102367835, 0.003159031394217317, 0.004144902165582691, 0.003915463361535313, 0.0029258187003839767, 0.008385569278611315, 0.004401718258242242, 0.008213563486557732, 0.004567981393010979, 0.06696710465986667, 0.027692298146757617, 0.05549112165378568, 0.0201746684970983, 0.017547567584084205, 0.02550049230382981, 0.017398226170846406, 0.03268583279141934, 0.008591173752684035, 0.009363522762350616, 0.009266587254963413, 0.008632538717759508, 0.007014854887518382, 0.002260018014885936, 0.0022979268489784392, 0.007071931767111337, 0.0071634881730687685, 0.0017299391418130236, 0.0017686940710958934, 0.00723257715651442, 0.001643031144417955, 0.009120219463075714, 0.00923464045901921, 0.0016984902452772653, 0.0017881383330578926, 0.008017330962500676, 0.008068712787537504, 0.0018493339843271206, 0.0010454903613342328, 0.007071528911784969, 0.007024515160169981, 0.0011022833333855563, 0.001484714964888898, 0.006399031664063421, 0.006363541394553128, 0.0015181797461949538, 0.006026368776342308, 0.0012683590296050287, 0.0012567866849480416, 0.0058734776182109505, 0.006197589310755258, 0.0008926706597289555, 0.0008688973014745598, 0.006052453961010347, 0.0008369973146372788, 0.005378972304049904, 0.005338003222441254, 0.000837010801796581, 0.0008477220320523966, 0.005298246270524145, 0.005217445517378499, 0.0008522865340575917, 0.023975118346932455, 0.008856705383316666, 0.00858439586681334, 0.02580164174382993, 0.023428123452942984, 0.00781812720915928, 0.007911574958703727, 0.02538321713580939, 0.00810721540572797, 0.015754914897609534, 0.01623159969773803, 0.008096039871658987, 0.00985246232149621, 0.013051353591415219, 0.013433581925295531, 0.009930483099207386, 0.026325973471943043, 0.012455627146740844, 0.011489246111756363, 0.02661865936694935, 0.028056110133441503, 0.012296118530873913, 0.01135587309758481, 0.02840246395966109, 0.0010172292466722479, 0.005803995260872623, 0.005823001469159309, 0.001032680059289303, 0.0008256994008806106, 0.006141124516594082, 0.006161614540334442, 0.0008713863411145974, 0.00981635299443823, 0.012822718023227713, 0.011706602987073862, 0.008759008964139937, 0.00790047350310175, 0.014148374923279337, 0.012699145052208927, 0.007074241468440424, 0.010099810310248801, 0.0053661662259103056, 0.004945351843594362, 0.009488980808445915, 0.002022952580510925, 0.006579524822769498, 0.006506999800581414, 0.0019787386778562068, 0.0011972075029836507, 0.007322201396680355, 0.00723482225337236, 0.0011975255874886583, 0.007617495417820617, 0.008262722115735354, 0.008186127292100344, 0.007890133269709847, 0.008601076384484336, 0.008318014263514828, 0.008329010307342026, 0.008899675330887421, 0.019108687652200917, 0.01171425568264895, 0.011300678663513744, 0.01921772298600908, 0.02219638325016058, 0.011751541540904966, 0.011408390871909738, 0.022404105822164348, 0.008150496951505867, 0.0020384116840524223, 0.002028566973120436, 0.008029278909187861, 0.007425783904849813, 0.0014159360898861495, 0.0014147977821190735, 0.007297877229543554, 0.00931167392806397, 0.00321800786415782, 0.0031856224325169475, 0.009372944924995666, 0.009030285516360028, 0.0034861822251855347, 0.003453304256689703, 0.009046718049206218, 0.028720027991267306, 0.008975742391153804, 0.009270767172360805, 0.03019393232794276, 0.02728194162022413, 0.009701181512229824, 0.010093430194275334, 0.029056715519808263, 0.009335117621421753, 0.020049057385395443, 0.02036207067640526, 0.009635636757060235, 0.008578056071164289, 0.021092611494940305, 0.021785961648121806, 0.008592899162448663, 0.005881743777321795, 0.0010609188023041314, 0.0010173670412703029, 0.005841645525716396, 0.006206526376011412, 0.00046955289312352894, 0.0004599849822565617, 0.006118948610365362, 0.016928414458088247, 0.013068761068564343, 0.012133201472461892, 0.0159685971812208, 0.017864975228636015, 0.027164637116210616, 0.027698541885371165, 0.016137066953259026, 0.013296872445597033, 0.02931521990142068, 0.029671720859815075, 0.01261164049377574, 0.009069594736842245, 0.011493244349878303, 0.010343940073292974, 0.00919404316788479, 0.007771836394470863, 0.012802747370241637, 0.011559193995640947, 0.007796407247558604, 0.00758914770238494, 0.012251189781826318, 0.010954962186180497, 0.006889947375246457, 0.006400173014912416, 0.01311287363745799, 0.01162507067772028, 0.005872108880190892, 0.0005956087371482655, 0.0055103686619500675, 0.005537960152065837, 0.0006358052461587466, 0.0006631363942821378, 0.005441892643673315, 0.0054481496214445774, 0.0006581168004678195, 0.0018179778333411655, 0.007322403081400085, 0.007283695386180675, 0.0017839301272603919, 0.0018302171603745158, 0.006745996150257413, 0.006664521513895944, 0.0018161971046029416, 0.0011953701406214323, 0.0057994699137371005, 0.005728248065850849, 0.0011978033241021022, 0.0012861889979983168, 0.0054157036212198915, 0.005323379501032409, 0.0012749351282936542, 0.014500450927666478, 0.03305315542780525, 0.03217149872811667, 0.013574170237605886, 0.021390049552263528, 0.024020286532773695, 0.022936638895668337, 0.02054396081061808, 0.0010517762573704925, 0.0062680276506592355, 0.006139531820383456, 0.001028379185158879, 0.0013991572859752398, 0.00569761071878367, 0.005621228810488668, 0.0013360265818009723, 0.001507449478899285, 0.005273511656604493, 0.005232278573983769, 0.0015054103551419516, 0.0008930579840440097, 0.0059517262714447305, 0.005919571688209116, 0.0008818987068718453, 0.007112987967610293, 0.0022264071859550718, 0.0021975322523573085, 0.006964325128196484, 0.006454105392911996, 0.0018504604801338495, 0.001822675415602462, 0.006319224997194328, 0.008549797482439874, 0.003250785825656253, 0.003158198661770252, 0.008514472771578172, 0.007910056562598, 0.003875926454382421, 0.0037630686454738697, 0.007895991727061354, 0.006986805499429947, 0.0021581921600375372, 0.0020959781317622514, 0.006956799387683669, 0.006472122214277441, 0.0023974186710303737, 0.0023189565753702927, 0.006446190269167945, 0.0016179731675424552, 0.0055426476200886995, 0.005465804043140043, 0.0015713770678539229, 0.0014373011292573236, 0.0059424331330854814, 0.005849070582741708, 0.0013583911444603198, 0.004245920792369998, 0.0010567794018042813, 0.0010079844414992135, 0.0041548857883931065, 0.004783893415801703, 0.0012614969522598053, 0.001223323485325369, 0.004685689545967305, 0.0011332712947520617, 0.005346415283902762, 0.005283864530066999, 0.0010710270530584502, 0.0009050789138511863, 0.005082409794491054, 0.004986831844789302, 0.0009157239200582413, 0.0116009364653744, 0.0214688665769535, 0.022502351038754947, 0.01217796988061715, 0.008108834299577474, 0.025477369543316798, 0.027195421846233317, 0.008301673908427508, 0.0017618295006759284, 0.006382208084547436, 0.006329104095546791, 0.0018171984779132688, 0.0016467929851855581, 0.005663978325389407, 0.005656575867091994, 0.0016215729633515846, 0.0007877691098074405, 0.00484098509448598, 0.004854366123167747, 0.0007817549077199387, 0.00041671120596232847, 0.004837006817393871, 0.004911698486326623, 0.00040764013893509793, 0.010284661980967124, 0.008998571905403896, 0.008256969936714468, 0.009410955436397037, 0.011236580661233928, 0.008162028933484857, 0.007403222046760517, 0.01012691910091794, 0.00376614152916415, 0.004940999890147418, 0.005275856535478139, 0.003753149356090169, 0.003125897866278603, 0.004817605843054477, 0.005159091182496664, 0.0031321315420859957, 0.011511631977247166, 0.032991518721269646, 0.032928083778386893, 0.010759909685904847, 0.01184822777133921, 0.02859097967690462, 0.02872514813762151, 0.010769699455169228, 0.0022274590945979686, 0.007010467711088895, 0.0070819022845327465, 0.0021991663928341556, 0.0026716921805108756, 0.006657175094216257, 0.0067070529560383126, 0.002620034811247889, 0.0021693211715344165, 0.00648413378310036, 0.00651810693730866, 0.0021890366529645653, 0.002046596809006366, 0.006214814959199362, 0.006184581462063673, 0.002111925915318504, 0.015296891413374245, 0.006861028936346463, 0.0067036226219298455, 0.014261667864705627, 0.014263134201340273, 0.007466848556985597, 0.00724634383004218, 0.013235966502626652, 0.007123779372483926, 0.009905182396198736, 0.010045078137588776, 0.0071259739147627316, 0.004637577115695464, 0.01032642784738148, 0.010153469521251434, 0.004664795534093348, 0.0061394670128305465, 0.002139425203838456, 0.0021070416227821657, 0.006064084028515571, 0.005552502082876559, 0.002020477801468636, 0.0019892358679718973, 0.0054961325821300646, 0.007601424132162161, 0.003134811049524915, 0.0030815178465893643, 0.007531588090051445, 0.007011351176029506, 0.002831853303848058, 0.0027696171274949415, 0.0069517804257982945, 0.008402819660494686, 0.002662228288065767, 0.002650329577193934, 0.00825815967175325, 0.00804030714329621, 0.002375569965246921, 0.002334300373087869, 0.007981359997355015, 0.01319384309730578, 0.025597789900569178, 0.025457957242226745, 0.013582497481765791, 0.012356432120735743, 0.024714657551838687, 0.02476029575758697, 0.012727163752495647, 0.007276905430824068, 0.011322340616675313, 0.011066649025095805, 0.007291120526405241, 0.008282912727174893, 0.011144799298277247, 0.010793171918621215, 0.008448668875750463, 0.0009639227708988272, 0.005229943456876828, 0.005152559583028958, 0.0009276904343858334, 0.0007441670776905912, 0.005058732309009035, 0.004995375852321796, 0.0007423229639703388, 0.005699992918812689, 0.0009481560903281636, 0.0009099944720197805, 0.005646716359435809, 0.006379886029353468, 0.0007391825756430035, 0.0007393610361603129, 0.006312139164040621, 0.021462627231566927, 0.010077965745369464, 0.009414142920334049, 0.023207718213637714, 0.023629662417583863, 0.006759839233210368, 0.006476008252738697, 0.025065401351372644, 0.01018095481481351, 0.015289674291140185, 0.014282439143667718, 0.009097244645295065, 0.011969373879915599, 0.011101406817592353, 0.010330537545874999, 0.010604914000430577, 0.0067227122536322485, 0.11944727168855515, 0.11932818588021096, 0.006614896915861303, 0.006784345944129135, 0.11479706429793128, 0.11454282435756699, 0.006573743651359913, 0.00937033294642957, 0.1040243242432151, 0.10400233696401356, 0.009386172320478585, 0.009103782347933484, 0.08991725998292786, 0.08991950510050589, 0.00912713089758217, 0.010098668595685105, 0.07358333743011927, 0.07349052201499083, 0.01027930529212749, 0.011017662841342946, 0.055595403100289126, 0.05551312844413025, 0.010915339014588667, 0.007667625201476909, 0.03946635299286161, 0.03933119733057944, 0.007708612219600199, 0.01025366963585176, 0.02353698696536458, 0.023434537909262674, 0.01010773783178086, 0.014252639667944909, 0.02575981520214755, 0.037413146016266836, 0.08382541732605812, 0.005060897346861967, 0.019395317182462058, 0.024445954161473174, 0.01704909080480523, 0.01264401033293978, 0.06487836444136733, 0.0758642181243293, 0.03725753218428828, 0.00497430352852078, 0.008740682687187336, 0.013097882135601487, 0.04779054035693543, 0.0021239662743725513, 0.012025430143571894, 0.010961967769368072, 0.01099165270619097, 0.035880417644068456, 0.02364569860971659, 0.003494476182160376, 0.00345589203681989, 0.07692777705107902, 0.14131600405802813, 0.10841638667274009, 0.049560077144757235, 0.0038686076854954387, 0.015216734421400709, 0.021392474475063816, 0.08232016551778945, 0.06718761528377885, 0.11935793374716074, 0.029610774669716296, 0.013778168968138637, 0.004160064655602972, 0.008962850446364815, 0.18458082829160635, 0.09504477996706377, 0.06916763951637099, 0.03024618311777582, 0.009835985379545045, 0.226261819963099, 0.009032726761820126, 0.2303501893036629, 0.07740483114031875, 0.12113080353077961, 0.04671816175653581, 0.07255407920806108, 0.010400421147866832, 0.19582550079922154, 0.040614550034085095, 0.034477775976693714, 0.007935794855777502, 0.1016575958867426, 0.04692746798966848, 0.1200097808636467, 0.044076770705577265, 0.02709237221733898, 0.08409085036736144, 0.02946082591189731, 0.01700956073936465, 0.024594967668849898, 0.029863358853328633, 0.013737834077508171, 0.019503059212800638, 0.003230130638497063, 0.00407687585728679, 0.00619734866310136, 0.05493990486658532, 0.1862406487420446, 0.005114534539427867, 0.005401366286775215, 0.13917678757110793, 0.047689050912644554, 0.07493100496556543, 0.00367937389407563, 0.03582631198726278, 0.09089370486357957, 0.06589618752563779, 0.00449337744783816, 0.020954963076759956, 0.02666601034414498, 0.059917244171848, 0.011461464208070978, 0.04003299389746537, 0.03914763514239792, 0.045131907193217344, 0.013545880630795855, 0.004466653073453095, 0.0041740335654573595, 0.10601747497002233, 0.006224520133690384, 0.006185698883005423, 0.11323164677708536, 0.10676927266502986, 0.011860693562733183, 0.011608819495864002, 0.11389080140626923, 0.0074766009892506405, 0.0014683397757553247, 0.0019129321233447238, 0.00930995412129433, 0.09761761706604766, 0.02105270188467464, 0.01926680413451685, 0.02669679306323893, 0.009995303512873848, 0.009853710798858096, 0.02963339793137894, 0.07282646599978332, 0.02049477792285889, 0.10129292742861468, 0.10830980676841061, 0.01816075481027264, 0.004655233365380059, 0.02860985558431347, 0.017208659840196937, 0.0077846289899111305, 0.02141860094308602, 0.07014591088111007, 0.009064212060167956, 0.010732437024607577, 0.002743506413540664, 0.0025011672487496583, 0.02651576449204643, 0.007477342320831259, 0.04202746477633969, 0.06090001996663004, 0.034816425979719415, 0.03935204757344643, 0.08858095331709974, 0.05942351320739023, 0.03221852542682168, 0.012967634678090256, 0.07857600435214833, 0.048246819889731965, 0.019021377301594915, 0.038640563189441854, 0.005584133644300519, 0.0039005395685108137, 0.012178785118660591, 0.024101011043157233, 0.0086101879954741, 0.00779460178145087, 0.008480799460148406, 0.0013931433250608477, 0.0023023569615227965, 0.004467732637084959, 0.003777006882010604, 0.0018873137374541512, 0.04010430010201548, 0.02384103730321846, 0.02156298303374425, 0.024657160037343293, 0.10386628927568174, 0.005725335477232958, 0.024144660380979486, 0.07078796024929593, 0.00304707410854891, 0.0006943929215043465, 0.0007081050464042951, 0.0015038941849300656, 0.03589274548193619, 0.023362281704540588, 0.008459983807353594, 0.029250854706827062, 0.03973017221361023, 0.04347766308904828, 0.0016504703227076247, 0.0018430416629855693, 0.06891805272502924, 0.10748627693468306, 0.0016176015603834152, 0.0009524891057647539, 0.1691194355941578, 0.018309390758977136, 0.10425049196188012, 0.05947463801263446, 0.00890285531853433, 0.09675346585895704, 0.07735428468179556, 0.029381377395930528, 0.0063396505381889704, 0.005755925026088779, 0.07027624881127754, 0.01387132754376554, 0.05005742109713962, 0.10414100534316717, 0.0027833859492137052, 0.0034618817861895496, 0.12902932588027433, 0.10748638690366179, 0.14718410387281725, 0.055032537618003315, 0.04345734516460858, 0.06474695568462976, 0.1452221666279143, 0.006924851585982664, 0.17478343192652138, 0.06722584662817889, 0.16618669659187876, 0.0027283610156073838, 0.070498062571993, 0.046923742436305885, 0.022865726163431237, 0.027309208708160653, 0.016326164632999, 0.08998103198192858, 0.0014096433492145485, 0.0015632141438961108, 0.01222182937089376, 0.020035922639525354, 0.009242426911136256, 0.0024126454490785766, 0.009274877657120605, 0.002380651324022055, 0.0027105334065672263, 0.004352435506464035, 0.0026806593510973874, 0.004237469591028653, 0.009472220576784486, 0.0037988028943224806, 0.009554739990434012, 0.0024727886524930263, 0.0028309520327505023, 0.0038497584270940763, 0.0027840529055692723, 0.00432572157327558], "label_norm": {"browDown_L": [0.16184226283028932, 0.20977234886071028], "cheekSquint_L": [0.16185153609579386, 0.2097683718446928], "browOuterUp_L": [0.15270091543678424, 0.16839646529867786], "browDown_R": [0.06948338508522964, 0.16283591380307832], "browOuterUp_R": [0.06948302474716682, 0.16283847961001208], "cheekSquint_R": [0.05328527165206706, 0.0987137094443144], "browInnerUp": [0.12377143222455209, 0.11054432239365392], "eyeBlink_L": [0.12378660998864666, 0.11056262499764855], "eyeBlink_R": [0.190942831872188, 0.279206755584966], "eyeSquint_L": [0.19093755749443306, 0.2792060904994797], "eyeSquint_R": [0.14227027950930204, 0.1416391784898584], "eyeWide_L": [0.14227035540092334, 0.14163926447890837], "eyeWide_R": [0.11309330373911854, 0.18565386881570314], "eyeLookDown_L": [0.11306353298758509, 0.18566134365607134], "eyeLookDown_R": [0.06285944359725414, 0.17045273250250584], "eyeLookIn_L": [0.0628729756892031, 0.1704466309400626], "eyeLookIn_R": [0.07485748085688285, 0.16893314702185766], "eyeLookOut_L": [0.07485740438210119, 0.1689329351938502], "eyeLookOut_R": [0.18266849983368028, 0.14296388111660893], "eyeLookUp_L": [0.18265154591402213, 0.14292028255240136], "eyeLookUp_R": [0.08961160259588949, 0.16585373167085588], "jawOpen": [0.08961131633644744, 0.16585278449154386], "jawLeft": [0.11765810615884183, 0.08816165020315778], "jawRight": [0.026571828761178935, 0.05492373416723142], "mouthClose": [0.15299164237732532, 0.150655587484649], "mouthFunnel": [0.026557468328964346, 0.054797332139965196], "mouthPucker": [0.09498957945671399, 0.09181490726836748], "mouthRollLower": [0.14519119410745168, 0.12731614011549094], "mouthRollUpper": [0.10349672362506636, 0.11123604030718619], "mouthShrugLower": [0.10465714266768646, 0.09383210265018498], "mouthShrugUpper": [0.0678096379479136, 0.07960643467573829], "noseSneer_L": [0.08945952378613364, 0.08728771405812234], "noseSneer_R": [0.2222825280831422, 0.1261008077133412], "mouthLeft": [0.022971706246310317, 0.08432441787704713], "mouthRight": [0.02298672339965462, 0.0843408328391454], "mouthSmile_L": [0.13505946631542162, 0.21724098606264428], "mouthSmile_R": [0.13508046237566498, 0.21726259548479832], "mouthFrown_L": [0.051900052605321746, 0.09449455049264716], "mouthFrown_R": [0.05189726627093182, 0.09449150605096043], "mouthDimple_L": [0.09506372589428794, 0.06431724885890054], "mouthDimple_R": [0.09506641018113879, 0.06431844000329903], "mouthStretch_L": [0.20472376314609514, 0.16635334721205874], "mouthStretch_R": [0.20473381382347117, 0.1663557625463717], "mouthPress_L": [0.07839229651774052, 0.0643156347072905], "mouthPress_R": [0.07839077916451218, 0.06430965774739499], "mouthLowerDown_L": [0.17512900932173842, 0.09322782743034486], "mouthLowerDown_R": [0.1751238538275112, 0.09322656028013022], "mouthUpperUp_L": [0.0822388672075358, 0.09820284010334808], "mouthUpperUp_R": [0.08224144650194605, 0.09820911130340014]}, "label_norm_mm": {"browDown_L": [-0.8073297739028931, 1.6146595478057861], "cheekSquint_L": [-0.8073297739028931, 1.6353405714035034], "browOuterUp_L": [0.0, 0.9911944270133972], "browDown_R": [-0.7330395579338074, 1.470625638961792], "browOuterUp_R": [-0.725012481212616, 1.4660791158676147], "cheekSquint_R": [0.0, 0.9704002141952515], "browInnerUp": [0.005171118304133415, 0.8572343587875366], "eyeBlink_L": [0.00921106431633234, 0.8549602031707764], "eyeBlink_R": [0.0, 0.999589204788208], "eyeSquint_L": [0.0, 0.9996109008789062], "eyeSquint_R": [0.0, 1.0], "eyeWide_L": [0.0, 1.0], "eyeWide_R": [0.0, 1.0], "eyeLookDown_L": [0.0, 1.0], "eyeLookDown_R": [0.0, 1.0], "eyeLookIn_L": [0.0, 1.0], "eyeLookIn_R": [0.0, 1.0], "eyeLookOut_L": [0.0, 1.0], "eyeLookOut_R": [0.005141416564583778, 0.9804584383964539], "eyeLookUp_L": [0.005141416564583778, 0.9804584383964539], "eyeLookUp_R": [0.0, 0.9534252882003784], "jawOpen": [0.0, 0.9534395337104797], "jawLeft": [0.0, 0.8010596036911011], "jawRight": [0.0, 0.7739279270172119], "mouthClose": [0.0, 1.0], "mouthFunnel": [0.0, 0.7443013787269592], "mouthPucker": [0.0, 0.9496217966079712], "mouthRollLower": [0.0, 0.9745720624923706], "mouthRollUpper": [0.0, 0.9714981913566589], "mouthShrugLower": [0.006537656299769878, 0.8364248275756836], "mouthShrugUpper": [0.0, 0.9035037159919739], "noseSneer_L": [0.0, 0.9107782244682312], "noseSneer_R": [0.02829817868769169, 0.9374051094055176], "mouthLeft": [0.0, 1.0], "mouthRight": [0.0, 1.0], "mouthSmile_L": [0.0, 0.9820542931556702], "mouthSmile_R": [0.0, 0.9820542931556702], "mouthFrown_L": [0.0, 0.867120623588562], "mouthFrown_R": [0.0, 0.867120623588562], "mouthDimple_L": [0.0, 0.7573938965797424], "mouthDimple_R": [0.0, 0.7562941908836365], "mouthStretch_L": [0.0, 0.9634690284729004], "mouthStretch_R": [0.0, 0.9634690284729004], "mouthPress_L": [0.0011928933672606945, 0.8130543828010559], "mouthPress_R": [0.00045785587280988693, 0.813126266002655], "mouthLowerDown_L": [0.008856703527271748, 0.9179792404174805], "mouthLowerDown_R": [0.008817199617624283, 0.9179792404174805], "mouthUpperUp_L": [0.0, 0.9093780517578125], "mouthUpperUp_R": [0.0, 0.9063169956207275]}}',"_state","freq should be >0","stop",'The "b64" (base64url-encode payload) Header Parameter must be a boolean',"decode","dir","_lastUpdateTime","ZERO","end","PS256","Initializing AUPredictor...","maxTokenAge","len","day","emptyObject","filter","jawLeft","header","mins","ECDH-ES","process.binding is not supported","toBytesBE","ProtocolError","transformZ","predict","stopped","mouthUpperUp_L","eyeBlink_R","DEFAULT_MAX_OCCUPATION_TIME","https://kits.joinhallway.com/auth","startTime","readDoubleLE","blendShapes","Buffer","minutes","autoplay","division by zero","aud","seconds","eyeLookUp_R","dataStream","customModelUrl","isOdd","slice","typ","modulo","Private accessor was defined without a getter","subtle","hasOwnProperty",' instances for symmetric algorithms must be of type "secret"',"Invalid or unsupported EC Key Curve or OKP Key Sub Type","double","configure","abs","writeFloatLE","shift","dcutoff","CryptoKey does not support this operation, its usages must include ","maxOccupationTime",'Invalid or unsupported "alg" (Algorithm) value',"writeDoubleLE","LN2","eyeLookIn_L","\0\0\0\0\0\0\0\0","blendShapeTune","send","start","all","_push","hour","mouthFrown_L","Instance","requestFrameToken","oNow","freq","mouthDimple_R",'"nbf" claim must be a number',"fun"," or ","NEG_ONE","finish","eyeLookUp_L","avatarDensePredictor","object","prototype","Promise","reverse","Avatar Webkit: ","div","sec","data","yaw","fixed32","extractable","radix","5445YbafkN","_initializePromise","get","video","_Buffer_allocUnsafe","fromCharCode","string","eyeSquint_R","error","lte","_initialize","Array","concat","includes","readFloatLE","pow","eyeLookDown_L","write","customBinFileUrl",'"exp" claim must be a number',"isZero","beta","readDoubleBE","low","createPrediction","shiftRightUnsigned","pitch","transformTune","global","eyeLookIn_R","JWT Claims Set must be a top-level JSON object","cheekSquint_R","setDerivateCutoff","toARKitConvention"," > ","setMinCutoff","leftAmp","893097vFkwrH","longFromHash","RSA-OAEP-384","UONE","tongueOut","fps","queues","lasttime","mul",'Flattened JWS must have either of the "protected" or "header" members',"846780muIydn","toArray","lastFrameTime","ceil","parse","fork","mouthLowerDown_L","initialized",", or ","RSA-OAEP","actionUnitModel","byteLength","round","reset","ECDSA","payload","invalid varint encoding","nbf","freeze","div_s","sint32","oneOfGetter","zzEncode","mouthUpperUp_R","_acquireBatch","rotation","RS512","secret","Avatar WebKit: API token not set! This could be a configuration mistake, or if you need to sign up for an API token, you can do that here: https://joinhallway.com/sdk/","newError","indexOf","mouthRollUpper","ERR_JWT_INVALID","invalid","unprotectedHeader","easingCurves","next","key","fromBytesLE","crit","muted","toInt","rightAmp","stack","exec","transform","compare","process.chdir is not supported","shiftLeft","beta_","head","Too many pending tasks in queue ","shouldMirrorOutput","negate","filters","HS384","weeks","zzDecode","getNumBitsAbs","Infinity","test","HS256","eyeWide_R","and","shl","_faceStats","EventEmitter","The input to be decoded is not correctly encoded.","already ended","asPromise","yawFilter","max","requestVideoFrameCallback","getModelMeta","browDown_L","getPrototypeOf","process","split","key2Re","startsWith","EdDSA","_configure","log","Right","RS384","encodeDelimited","roots","ERR_JWT_EXPIRED","bezier_y2","constructor","tensor","updateInterval","_promiseTry","73EyNJGT","public","CryptoKey does not support this operation","value","domains","wrapKey","now","exports","sub","getLowBitsUnsigned","ONE","eyeLookOut_L","long","loadFiltersAndCurvesFromTune","some","requestDelimited","captureStackTrace","cheekPuff","RSASSA-PKCS1-v1_5","createElement","default","alpha should be in (0.0., 1.0]","one of ","fromValue","+Infinity","weightData","isLong","sfixed32","Ed448","ERR_JWS_SIGNATURE_VERIFICATION_FAILED","dataSync","browDown_R",'"alg" (Algorithm) Header Parameter not allowed',"_timeSum","one of type ","pos","faceMeshResultsCallback","stream","utf8Write","mouthShrugLower","merge","Left","verify","ldelim","use a NodeJS version that still implements Domain, or install a browser polyfill.","2178687GXsnfs","height","ctx","CryptoKey","predictFace","util","multiFaceLandmarks","node"," Received an instance of ","ECDH-ES+A256KW","_video","[object Object]","splice","fromBytesBE",'"nbf" claim timestamp check failed','"iat" claim timestamp check failed (it should be in the past)',"dcodeIO",'{"browDown_L":{"fps":60,"minCutoff":0.001,"beta":10,"bezier_x1":0.10830324909747292,"bezier_y1":0.016000000000000014,"bezier_x2":0.9638989169675091,"bezier_y2":0.724},"browDown_R":{"fps":60,"minCutoff":0.001,"beta":10,"bezier_x1":0.10830324909747292,"bezier_y1":0.016000000000000014,"bezier_x2":0.9638989169675091,"bezier_y2":0.724},"browInnerUp":{"fps":30,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"browOuterUp_L":{"fps":60,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"browOuterUp_R":{"fps":60,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"cheekSquint_L":{"fps":60,"minCutoff":0.001,"beta":15,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"cheekSquint_R":{"fps":60,"minCutoff":0.001,"beta":15,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeBlink_L":{"fps":60,"minCutoff":0.001,"beta":10,"bezier_x1":0.04151624548736462,"bezier_y1":0.01200000000000001,"bezier_x2":1,"bezier_y2":1},"eyeBlink_R":{"fps":60,"minCutoff":0.001,"beta":10,"bezier_x1":0.04151624548736462,"bezier_y1":0.01200000000000001,"bezier_x2":1,"bezier_y2":1},"eyeLookDown_L":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookDown_R":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookIn_L":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookIn_R":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookOut_L":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookOut_R":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookUp_L":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeLookUp_R":{"fps":30,"minCutoff":0.001,"beta":8,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeSquint_L":{"fps":60,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeSquint_R":{"fps":60,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeWide_L":{"fps":60,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"eyeWide_R":{"fps":60,"minCutoff":0.001,"beta":5,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"jawOpen":{"fps":60,"minCutoff":0.001,"beta":25,"bezier_x1":0.3231046931407942,"bezier_y1":0.05600000000000005,"bezier_x2":0.6010830324909747,"bezier_y2":0.992},"mouthClose":{"fps":60,"minCutoff":0.001,"beta":25,"bezier_x1":0.13537906137184116,"bezier_y1":0.06399999999999995,"bezier_x2":0.9332129963898917,"bezier_y2":0.918},"mouthFunnel":{"fps":60,"minCutoff":0.001,"beta":9.661540758047767,"bezier_x1":0.14620938628158844,"bezier_y1":0.18000000000000005,"bezier_x2":0.7563176895306859,"bezier_y2":0.852},"mouthPucker":{"fps":60,"minCutoff":0.001,"beta":30,"bezier_x1":0.0740072202166065,"bezier_y1":0.03200000000000003,"bezier_x2":0.723826714801444,"bezier_y2":0.948},"mouthRollLower":{"fps":60,"minCutoff":0.001,"beta":30,"bezier_x1":0.0812274368231047,"bezier_y1":0.06799999999999995,"bezier_x2":0.6407942238267148,"bezier_y2":0.952},"mouthRollUpper":{"fps":60,"minCutoff":0.001,"beta":30,"bezier_x1":0.0812274368231047,"bezier_y1":0.06799999999999995,"bezier_x2":0.6407942238267148,"bezier_y2":0.952},"mouthShrugLower":{"fps":60,"minCutoff":0.001,"beta":15,"bezier_x1":0.10649819494584838,"bezier_y1":0.07199999999999995,"bezier_x2":0.7346570397111913,"bezier_y2":0.732},"mouthShrugUpper":{"fps":60,"minCutoff":0.001,"beta":15,"bezier_x1":0.10649819494584838,"bezier_y1":0.07199999999999995,"bezier_x2":0.7346570397111913,"bezier_y2":0.732},"mouthLeft":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthRight":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthSmile_L":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthSmile_R":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthFrown_L":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthFrown_R":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthDimple_L":{"fps":60,"minCutoff":0.001,"beta":13.34194103633115,"bezier_x1":0.0740072202166065,"bezier_y1":0.08799999999999997,"bezier_x2":0.6841155234657039,"bezier_y2":0.792},"mouthDimple_R":{"fps":60,"minCutoff":0.001,"beta":13.34194103633115,"bezier_x1":0.0740072202166065,"bezier_y1":0.08799999999999997,"bezier_x2":0.6841155234657039,"bezier_y2":0.792},"mouthStretch_L":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthStretch_R":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"mouthPress_L":{"fps":60,"minCutoff":0.001,"beta":25,"bezier_x1":0.0740072202166065,"bezier_y1":0.08799999999999997,"bezier_x2":0.6841155234657039,"bezier_y2":0.792},"mouthPress_R":{"fps":60,"minCutoff":0.001,"beta":25,"bezier_x1":0.0740072202166065,"bezier_y1":0.08799999999999997,"bezier_x2":0.6841155234657039,"bezier_y2":0.792},"mouthLowerDown_L":{"fps":60,"minCutoff":0.001,"beta":25,"bezier_x1":0.09566787003610108,"bezier_y1":0.04400000000000004,"bezier_x2":0.7743682310469314,"bezier_y2":0.896},"mouthLowerDown_R":{"fps":60,"minCutoff":0.001,"beta":25,"bezier_x1":0.09566787003610108,"bezier_y1":0.04400000000000004,"bezier_x2":0.7743682310469314,"bezier_y2":0.896},"mouthUpperUp_L":{"fps":60,"minCutoff":0.001,"beta":20.58416617033949,"bezier_x1":0.17509025270758122,"bezier_y1":0.16000000000000003,"bezier_x2":0.5974729241877257,"bezier_y2":0.6719999999999999},"mouthUpperUp_R":{"fps":60,"minCutoff":0.001,"beta":20.58416617033949,"bezier_x1":0.17509025270758122,"bezier_y1":0.16000000000000003,"bezier_x2":0.5974729241877257,"bezier_y2":0.6719999999999999},"jawLeft":{"fps":60,"minCutoff":0.001,"beta":10,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"jawRight":{"fps":30,"minCutoff":0.001,"beta":35,"bezier_x1":0.030685920577617327,"bezier_y1":0.0040000000000000036,"bezier_x2":1,"bezier_y2":1},"noseSneer_L":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"noseSneer_R":{"fps":60,"minCutoff":0.001,"beta":8,"bezier_x1":0.07581227436823104,"bezier_y1":0.06599999999999995,"bezier_x2":0.4584837545126354,"bezier_y2":0.5740000000000001},"tune_points":{"fps":30,"minCutoff":0.001,"beta":28,"bez_enabled":false,"bezier_x1":0,"bezier_y1":0,"bezier_x2":1,"bezier_y2":1},"jawForward":{"fps":30,"minCutoff":0.001,"beta":35,"bezier_x1":0.030685920577617327,"bezier_y1":0.0040000000000000036,"bezier_x2":1,"bezier_y2":1}}',"decodeDelimited","JWS Protected Header is invalid","mouthRight","message","unwrapKey","not","browser","add","paths","data_means","lessThanOrEqual","inquire","Ed25519","pop",' instances for asymmetric algorithm decryption must be of type "private"',"1473378xfFRRT","notEquals","isNegative","done","lessThan","Unable to authenticate ","code","mouthPress_R","minute","faceStats","bezier_x1","generatedBy","endScope","mouthStretch_R","weightsManifest","div_u","model","starting","arraybuffer","hash","mouthFunnel","modelInitializer","__isLong__","pitchFilter",' instances for asymmetric algorithms must not be of type "secret"',"custom","bind","dcutoff should be >0","neg","RSA-PSS","BufferWriter","emit","unreachable","NODE-ED25519 or NODE-ED448","neq","clockTolerance","Key must be ","namedCurve","signature","rem_u","isArray","sint64","urn:hallway:issuer"];return a1_0x3acb=function(){return a},a1_0x3acb()}function __awaiter(a,e,i,s){function o(c){return c instanceof i?c:new i(function(d){d(c)})}return new(i||(i=Promise))(function(c,d){var h=a1_0x9238;function g($){try{b(s.next($))}catch(j){d(j)}}function _($){try{b(s.throw($))}catch(j){d(j)}}function b($){var j=a1_0x9238;$[j(534)]?c($[j(456)]):o($.value).then(g,_)}b((s=s[h(613)](a,[]))[h(396)]())})}function __classPrivateFieldGet(a,e,i,s){var o=a1_0x9238;if(i==="a"&&!s)throw new TypeError(o(947));if(typeof e===o(596)?a!==e||!s:!e.has(a))throw new TypeError("Cannot read private member from an object whose class did not declare it");return i==="m"?s:i==="a"?s[o(794)](a):s?s[o(456)]:e[o(998)](a)}function getDefaultExportFromCjs(a){var e=a1_0x9238;return a&&a[e(886)]&&Object.prototype[e(949)][e(794)](a,e(473))?a[e(473)]:a}var asyncLock={exports:{}},global$1=typeof global!==a1_0x131724(789)?global:typeof self!==a1_0x131724(789)?self:typeof window!==a1_0x131724(789)?window:{};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){var a=a1_0x131724;throw new Error(a(807))}var cachedSetTimeout=defaultSetTimout,cachedClearTimeout=defaultClearTimeout;typeof global$1[a1_0x131724(783)]=="function"&&(cachedSetTimeout=setTimeout);typeof global$1[a1_0x131724(696)]===a1_0x131724(596)&&(cachedClearTimeout=clearTimeout);function runTimeout(a){var e=a1_0x131724;if(cachedSetTimeout===setTimeout)return setTimeout(a,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(a,0);try{return cachedSetTimeout(a,0)}catch{try{return cachedSetTimeout.call(null,a,0)}catch{return cachedSetTimeout[e(794)](this,a,0)}}}function runClearTimeout(a){var e=a1_0x131724;if(cachedClearTimeout===clearTimeout)return clearTimeout(a);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(a);try{return cachedClearTimeout(a)}catch{try{return cachedClearTimeout[e(794)](null,a)}catch{return cachedClearTimeout[e(794)](this,a)}}}var queue=[],draining=!1,currentQueue,queueIndex=-1;function cleanUpNextTick(){var a=a1_0x131724;!draining||!currentQueue||(draining=!1,currentQueue[a(640)]?queue=currentQueue[a(1008)](queue):queueIndex=-1,queue[a(640)]&&drainQueue())}function drainQueue(){var a=a1_0x131724;if(!draining){var e=runTimeout(cleanUpNextTick);draining=!0;for(var i=queue[a(640)];i;){for(currentQueue=queue,queue=[];++queueIndex<i;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,i=queue[a(640)]}currentQueue=null,draining=!1,runClearTimeout(e)}}function nextTick(a){var e=a1_0x131724,i=new Array(arguments.length-1);if(arguments.length>1)for(var s=1;s<arguments[e(640)];s++)i[s-1]=arguments[s];queue[e(688)](new Item(a,i)),queue[e(640)]===1&&!draining&&runTimeout(drainQueue)}function Item(a,e){var i=a1_0x131724;this[i(978)]=a,this[i(658)]=e}Item[a1_0x131724(985)][a1_0x131724(628)]=function(){var a=a1_0x131724;this.fun[a(613)](null,this[a(658)])};var title=a1_0x131724(522),platform="browser",browser=!0,env={},argv=[],version$1="",versions={},release={},config={};function noop$1(){}var on=noop$1,addListener=noop$1,once=noop$1,off=noop$1,removeListener=noop$1,removeAllListeners=noop$1,emit=noop$1;function binding(a){var e=a1_0x131724;throw new Error(e(921))}function cwd(){return"/"}function chdir(a){var e=a1_0x131724;throw new Error(e(407))}function umask(){return 0}var performance$1=global$1[a1_0x131724(698)]||{},performanceNow=performance$1[a1_0x131724(459)]||performance$1[a1_0x131724(610)]||performance$1[a1_0x131724(798)]||performance$1[a1_0x131724(974)]||performance$1[a1_0x131724(684)]||function(){var a=a1_0x131724;return new Date()[a(887)]()};function hrtime(a){var e=a1_0x131724,i=performanceNow.call(performance$1)*.001,s=Math[e(712)](i),o=Math[e(712)](i%1*1e9);return a&&(s=s-a[0],o=o-a[1],o<0&&(s--,o+=1e9)),[s,o]}var startTime=new Date;function uptime(){var a=new Date,e=a-startTime;return e/1e3}var process$1={nextTick,title,browser,env,argv,version:version$1,versions,on,addListener,once,off,removeListener,removeAllListeners,emit,binding,cwd,chdir,umask,hrtime,platform,release,config,uptime},AsyncLock$1=function(a){var e=a1_0x131724;if(a=a||{},this.Promise=a[e(986)]||Promise,this[e(356)]=Object[e(811)](null),this[e(749)]=a[e(749)]||!1,this[e(749)]){if(typeof process$1===e(789)||typeof process$1.domain===e(789))throw new Error(e(707)+e(497));this[e(457)]=Object.create(null)}this[e(681)]=a.timeout||AsyncLock$1.DEFAULT_TIMEOUT,this.maxOccupationTime=a[e(959)]||AsyncLock$1[e(929)],a[e(631)]===1/0||Number.isInteger(a[e(631)])&&a[e(631)]>=0?this[e(631)]=a[e(631)]:this.maxPending=AsyncLock$1[e(695)]};AsyncLock$1.DEFAULT_TIMEOUT=0,AsyncLock$1[a1_0x131724(929)]=0,AsyncLock$1[a1_0x131724(695)]=1e3,AsyncLock$1[a1_0x131724(985)][a1_0x131724(641)]=function(a,e,i,s){var o=a1_0x131724;if(Array[o(571)](a))return this[o(384)](a,e,i,s);if(typeof e!==o(596))throw new Error("You must pass a function to execute");var c=null,d=null,h=null;typeof i!==o(596)&&(s=i,i=null,h=new this.Promise(function(rt,it){c=rt,d=it})),s=s||{};var g=!1,_=null,b=null,$=this,j=function(rt,it,at){var st=o;b&&(clearTimeout(b),b=null),rt&&($[st(356)][a]&&$.queues[a].length===0&&delete $[st(356)][a],$[st(749)]&&delete $[st(457)][a]),!g&&(h?it?d(it):c(at):typeof i===st(596)&&i(it,at),g=!0),rt&&$[st(356)][a]&&$[st(356)][a][st(640)]>0&&$[st(356)][a][st(956)]()()},_e=function(rt){var it=o;if(g)return j(rt);if(_&&(clearTimeout(_),_=null),$[it(749)]&&rt&&($[it(457)][a]=process$1[it(878)]),e[it(640)]===1){var at=!1;e(function(st,ot){!at&&(at=!0,j(rt,st,ot))})}else $[it(452)](function(){return e()})[it(796)](function(st){j(rt,void 0,st)},function(st){j(rt,st)})};if($.domainReentrant&&process$1[o(878)]&&(_e=process$1[o(878)][o(557)](_e)),!$[o(356)][a])$[o(356)][a]=[],_e(!0);else if($.domainReentrant&&process$1[o(878)]&&process$1[o(878)]===$[o(457)][a])_e(!1);else if($[o(356)][a][o(640)]>=$[o(631)])j(!1,new Error(o(411)+a));else{var tt=function(){_e(!0)};s[o(761)]?$[o(356)][a][o(857)](tt):$[o(356)][a].push(tt);var et=s[o(681)]||$[o(681)];et&&(_=setTimeout(function(){var rt=o;_=null,j(!1,new Error(rt(635)+a))},et))}var nt=s[o(959)]||$[o(959)];if(nt&&(b=setTimeout(function(){var rt=o;$[rt(356)][a]&&j(!1,new Error("Maximum occupation time is exceeded in queue "+a))},nt)),h)return h},AsyncLock$1[a1_0x131724(985)][a1_0x131724(384)]=function(a,e,i,s){var o=a1_0x131724;typeof i!==o(596)&&(s=i,i=null);var c=this,d=function(g,_){return function(b){var $=a1_0x9238;c[$(641)](g,_,b,s)}},h=e;if(a[o(987)]()[o(781)](function(g){h=d(g,h)}),typeof i=="function")h(i);else return new this[o(986)](function(g,_){var b=o;h[b(640)]===1?h(function($,j){$?_($):g(j)}):g(h())})},AsyncLock$1[a1_0x131724(985)][a1_0x131724(722)]=function(a){var e=a1_0x131724;return a?!!this[e(356)][a]:Object[e(637)](this[e(356)])[e(640)]>0},AsyncLock$1[a1_0x131724(985)]._promiseTry=function(a){var e=a1_0x131724;try{return this[e(986)].resolve(a())}catch(i){return this.Promise.reject(i)}};var lib=AsyncLock$1;(function(a){a.exports=lib})(asyncLock);var AsyncLock=getDefaultExportFromCjs(asyncLock.exports),crypto$1=crypto;const isCryptoKey=a=>a instanceof CryptoKey,encoder=new TextEncoder,decoder=new TextDecoder;function concat(...a){var e=a1_0x131724;const i=a.reduce((c,{length:d})=>c+d,0),s=new Uint8Array(i);let o=0;return a[e(781)](c=>{var d=e;s[d(802)](c,o),o+=c[d(640)]}),s}const decodeBase64=a=>{var e=a1_0x131724;const i=atob(a),s=new Uint8Array(i[e(640)]);for(let o=0;o<i.length;o++)s[o]=i[e(742)](o);return s},decode=a=>{var e=a1_0x131724;let i=a;i instanceof Uint8Array&&(i=decoder[e(905)](i)),i=i.replace(/-/g,"+")[e(824)](/_/g,"/")[e(824)](/\s/g,"");try{return decodeBase64(i)}catch{throw new TypeError(e(427))}};class JOSEError extends Error{constructor(e){var i=a1_0x131724,s;super(e),this[i(537)]="ERR_JOSE_GENERIC",this[i(862)]=this[i(449)][i(862)],(s=Error[i(469)])===null||s===void 0||s[i(794)](Error,this,this[i(449)])}static get[a1_0x131724(537)](){var e=a1_0x131724;return e(849)}}class JWTClaimValidationFailed extends JOSEError{constructor(e,i=a1_0x131724(785),s=a1_0x131724(785)){var o=a1_0x131724;super(e),this[o(537)]=o(656),this[o(625)]=i,this[o(763)]=s}static get[a1_0x131724(537)](){var e=a1_0x131724;return e(656)}}class JWTExpired extends JOSEError{constructor(e,i=a1_0x131724(785),s="unspecified"){var o=a1_0x131724;super(e),this[o(537)]=o(447),this[o(625)]=i,this[o(763)]=s}static get[a1_0x131724(537)](){return"ERR_JWT_EXPIRED"}}class JOSEAlgNotAllowed extends JOSEError{constructor(){var e=a1_0x131724;super(...arguments),this[e(537)]="ERR_JOSE_ALG_NOT_ALLOWED"}static get[a1_0x131724(537)](){var e=a1_0x131724;return e(883)}}class JOSENotSupported extends JOSEError{constructor(){var e=a1_0x131724;super(...arguments),this[e(537)]=e(720)}static get[a1_0x131724(537)](){var e=a1_0x131724;return e(720)}}class JWSInvalid extends JOSEError{constructor(){var e=a1_0x131724;super(...arguments),this.code=e(578)}static get[a1_0x131724(537)](){return"ERR_JWS_INVALID"}}class JWTInvalid extends JOSEError{constructor(){var e=a1_0x131724;super(...arguments),this[e(537)]=e(392)}static get[a1_0x131724(537)](){var e=a1_0x131724;return e(392)}}class JWSSignatureVerificationFailed extends JOSEError{constructor(){var e=a1_0x131724;super(...arguments),this[e(537)]=e(482),this[e(519)]="signature verification failed"}static get[a1_0x131724(537)](){var e=a1_0x131724;return e(482)}}crypto$1[a1_0x131724(599)].bind(crypto$1);function isCloudflareWorkers(){var a=a1_0x131724;return typeof WebSocketPair===a(596)}function isNodeJs(){var a=a1_0x131724;try{return process$1[a(772)][a(505)]!==void 0}catch{return!1}}function unusable(a,e=a1_0x131724(676)){var i=a1_0x131724;return new TypeError(i(639)+e+" must be "+a)}function isAlgorithm(a,e){var i=a1_0x131724;return a[i(862)]===e}function getHashLength(a){var e=a1_0x131724;return parseInt(a[e(862)][e(944)](4),10)}function getNamedCurve$1(a){var e=a1_0x131724;switch(a){case e(778):return e(750);case e(653):return"P-384";case e(803):return e(846);default:throw new Error(e(563))}}function checkUsage(a,e){var i=a1_0x131724;if(e.length&&!e[i(467)](s=>a.usages[i(1009)](s))){let s=i(958);if(e[i(640)]>2){const o=e[i(529)]();s+=i(475)+e[i(867)](", ")+i(368)+o+"."}else e.length===2?s+=i(475)+e[0]+i(979)+e[1]+".":s+=e[0]+".";throw new TypeError(s)}}function checkSigCryptoKey(a,e,...i){var s=a1_0x131724;switch(e){case s(421):case s(415):case"HS512":{if(!isAlgorithm(a[s(774)],s(814)))throw unusable("HMAC");const o=parseInt(e[s(944)](2),10);if(getHashLength(a[s(774)].hash)!==o)throw unusable(s(815)+o,s(634));break}case s(583):case s(444):case s(386):{if(!isAlgorithm(a.algorithm,"RSASSA-PKCS1-v1_5"))throw unusable(s(471));const o=parseInt(e.slice(2),10);if(getHashLength(a[s(774)][s(550)])!==o)throw unusable("SHA-"+o,s(634));break}case s(910):case"PS384":case"PS512":{if(!isAlgorithm(a.algorithm,"RSA-PSS"))throw unusable(s(560));const o=parseInt(e[s(944)](2),10);if(getHashLength(a[s(774)][s(550)])!==o)throw unusable(s(815)+o,s(634));break}case(isNodeJs()&&s(440)):{if(a[s(774)][s(862)]!==s(624)&&a[s(774)].name!==s(751))throw unusable(s(564));break}case(isCloudflareWorkers()&&s(440)):{if(!isAlgorithm(a[s(774)],s(624)))throw unusable(s(624));break}case s(778):case s(653):case s(803):{if(!isAlgorithm(a.algorithm,"ECDSA"))throw unusable(s(374));const o=getNamedCurve$1(e);if(a.algorithm[s(568)]!==o)throw unusable(o,s(675));break}default:throw new TypeError(s(455))}checkUsage(a,i)}var invalidKeyInput=(a,...e)=>{var i=a1_0x131724;let s=i(567);if(e[i(640)]>2){const o=e[i(529)]();s+=i(487)+e.join(", ")+", or "+o+"."}else e[i(640)]===2?s+=i(487)+e[0]+" or "+e[1]+".":s+="of type "+e[0]+".";return a==null?s+=i(697)+a:typeof a=="function"&&a[i(862)]?s+=" Received function "+a[i(862)]:typeof a===i(984)&&a!=null&&a[i(449)]&&a[i(449)][i(862)]&&(s+=i(506)+a[i(449)][i(862)]),s},isKeyLike=a=>isCryptoKey(a);const types=[a1_0x131724(501)],isDisjoint=(...a)=>{var e=a1_0x131724;const i=a[e(916)](Boolean);if(i[e(640)]===0||i[e(640)]===1)return!0;let s;for(const o of i){const c=Object[e(637)](o);if(!s||s.size===0){s=new Set(c);continue}for(const d of c){if(s.has(d))return!1;s[e(523)](d)}}return!0};function isObjectLike(a){var e=a1_0x131724;return typeof a===e(984)&&a!==null}function isObject(a){var e=a1_0x131724;if(!isObjectLike(a)||Object[e(985)][e(808)][e(794)](a)!==e(509))return!1;if(Object[e(435)](a)===null)return!0;let i=a;for(;Object.getPrototypeOf(i)!==null;)i=Object[e(435)](i);return Object.getPrototypeOf(a)===i}var checkKeyLength=(a,e)=>{var i=a1_0x131724;if(a[i(439)]("RS")||a.startsWith("PS")){const{modulusLength:s}=e.algorithm;if(typeof s!==i(753)||s<2048)throw new TypeError(a+i(646))}};const findOid=(a,e,i=0)=>{var s=a1_0x131724;i===0&&(e.unshift(e.length),e[s(857)](6));let o=a.indexOf(e[0],i);if(o===-1)return!1;const c=a[s(694)](o,o+e[s(640)]);return c.length!==e[s(640)]?!1:c[s(727)]((d,h)=>d===e[h])||findOid(a,e,o+1)},getNamedCurve=a=>{var e=a1_0x131724;switch(!0){case findOid(a,[42,134,72,206,61,3,1,7]):return e(750);case findOid(a,[43,129,4,0,34]):return e(616);case findOid(a,[43,129,4,0,35]):return e(846);case((isCloudflareWorkers()||isNodeJs())&&findOid(a,[43,101,112])):return e(528);case(isNodeJs()&&findOid(a,[43,101,113])):return e(481);default:throw new JOSENotSupported(e(951))}},genericImport=async(a,e,i,s,o)=>{var c=a1_0x131724,d;let h,g;const _=new Uint8Array(atob(i.replace(a,""))[c(437)]("").map($=>$[c(742)](0))),b=e===c(861);switch(s){case"PS256":case c(645):case c(597):h={name:"RSA-PSS",hash:c(815)+s[c(944)](-3)},g=b?["verify"]:[c(881)];break;case c(583):case"RS384":case c(386):h={name:"RSASSA-PKCS1-v1_5",hash:"SHA-"+s[c(944)](-3)},g=b?[c(495)]:[c(881)];break;case c(369):case c(619):case c(352):case c(579):h={name:c(369),hash:"SHA-"+(parseInt(s[c(944)](-3),10)||1)},g=b?[c(779),c(458)]:[c(847),c(520)];break;case c(778):h={name:c(374),namedCurve:c(750)},g=b?["verify"]:["sign"];break;case"ES384":h={name:c(374),namedCurve:"P-384"},g=b?[c(495)]:["sign"];break;case"ES512":h={name:c(374),namedCurve:"P-521"},g=b?[c(495)]:["sign"];break;case c(920):case"ECDH-ES+A128KW":case c(686):case c(507):h={name:c(638),namedCurve:getNamedCurve(_)},g=b?[]:[c(788)];break;case((isCloudflareWorkers()||isNodeJs())&&"EdDSA"):const $=getNamedCurve(_)[c(812)]();h={name:c(762)+$,namedCurve:c(762)+$},g=b?[c(495)]:[c(881)];break;default:throw new JOSENotSupported(c(960))}return crypto$1[c(948)][c(889)](e,_,h,(d=void 0)!==null&&d!==void 0?d:!1,g)},fromSPKI=(a,e,i)=>{var s=a1_0x131724;return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,s(861),a,e)};async function importSPKI(a,e,i){var s=a1_0x131724;if(typeof a!==s(1002)||a[s(390)]("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return fromSPKI(a,e)}const symmetricTypeCheck=a=>{var e=a1_0x131724;if(!(a instanceof Uint8Array)){if(!isKeyLike(a))throw new TypeError(invalidKeyInput(a,...types,e(865)));if(a[e(899)]!=="secret")throw new TypeError(types[e(867)](e(979))+e(950))}},asymmetricTypeCheck=(a,e)=>{var i=a1_0x131724;if(!isKeyLike(a))throw new TypeError(invalidKeyInput(a,...types));if(a.type===i(387))throw new TypeError(types[i(867)](i(979))+i(555));if(e===i(881)&&a[i(899)]===i(454))throw new TypeError(types[i(867)](" or ")+i(590));if(e===i(847)&&a[i(899)]===i(454))throw new TypeError(types[i(867)](i(979))+i(530));if(a.algorithm&&e===i(495)&&a[i(899)]===i(759))throw new TypeError(types[i(867)](i(979))+' instances for asymmetric algorithm verifying must be of type "public"');if(a[i(774)]&&e===i(779)&&a.type===i(759))throw new TypeError(types[i(867)](" or ")+' instances for asymmetric algorithm encryption must be of type "public"')},checkKeyType=(a,e,i)=>{var s=a1_0x131724;a[s(439)]("HS")||a===s(906)||a.startsWith(s(809))||/^A\d{3}(?:GCM)?KW$/[s(420)](a)?symmetricTypeCheck(e):asymmetricTypeCheck(e,i)};function validateCrit(a,e,i,s,o){var c=a1_0x131724;if(o[c(399)]!==void 0&&s[c(399)]===void 0)throw new a('"crit" (Critical) Header Parameter MUST be integrity protected');if(!s||s[c(399)]===void 0)return new Set;if(!Array[c(571)](s[c(399)])||s[c(399)][c(640)]===0||s[c(399)][c(467)](h=>typeof h!="string"||h[c(640)]===0))throw new a('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let d;i!==void 0?d=new Map([...Object[c(804)](i),...e[c(804)]()]):d=e;for(const h of s[c(399)]){if(!d[c(813)](h))throw new JOSENotSupported(c(745)+h+'" is not recognized');if(o[h]===void 0)throw new a(c(745)+h+'" is missing');if(d.get(h)&&s[h]===void 0)throw new a(c(745)+h+c(729))}return new Set(s[c(399)])}const validateAlgorithms=(a,e)=>{var i=a1_0x131724;if(e!==void 0&&(!Array[i(571)](e)||e[i(467)](s=>typeof s!==i(1002))))throw new TypeError('"'+a+'" option must be an array of strings');if(e)return new Set(e)};function subtleDsa(a,e){var i=a1_0x131724;const s="SHA-"+a[i(944)](-3);switch(a){case"HS256":case"HS384":case i(585):return{hash:s,name:i(814)};case i(910):case"PS384":case i(597):return{hash:s,name:i(560),saltLength:a[i(944)](-3)>>3};case i(583):case"RS384":case"RS512":return{hash:s,name:i(471)};case i(778):case i(653):case i(803):return{hash:s,name:i(374),namedCurve:e[i(568)]};case((isCloudflareWorkers()||isNodeJs())&&i(440)):const{namedCurve:o}=e;return{name:o,namedCurve:o};default:throw new JOSENotSupported("alg "+a+" is not supported either by JOSE or your javascript runtime")}}function getCryptoKey(a,e,i){var s=a1_0x131724;if(isCryptoKey(e))return checkSigCryptoKey(e,a,i),e;if(e instanceof Uint8Array){if(!a.startsWith("HS"))throw new TypeError(invalidKeyInput(e,...types));return crypto$1[s(948)][s(889)](s(726),e,{hash:s(815)+a[s(944)](-3),name:s(814)},!1,[i])}throw new TypeError(invalidKeyInput(e,...types,"Uint8Array"))}const verify=async(a,e,i,s)=>{var o=a1_0x131724;const c=await getCryptoKey(a,e,o(495));checkKeyLength(a,c);const d=subtleDsa(a,c[o(774)]);try{return await crypto$1[o(948)][o(495)](d,c,i,s)}catch{return!1}};async function flattenedVerify(a,e,i){var s=a1_0x131724,o;if(!isObject(a))throw new JWSInvalid(s(893));if(a.protected===void 0&&a[s(918)]===void 0)throw new JWSInvalid(s(359));if(a[s(801)]!==void 0&&typeof a[s(801)]!==s(1002))throw new JWSInvalid(s(717));if(a[s(375)]===void 0)throw new JWSInvalid("JWS Payload missing");if(typeof a[s(569)]!==s(1002))throw new JWSInvalid(s(767));if(a[s(918)]!==void 0&&!isObject(a[s(918)]))throw new JWSInvalid("JWS Unprotected Header incorrect type");let c={};if(a[s(801)]){const rt=decode(a[s(801)]);try{c=JSON[s(364)](decoder[s(905)](rt))}catch{throw new JWSInvalid(s(517))}}if(!isDisjoint(c,a[s(918)]))throw new JWSInvalid(s(667));const d={...c,...a.header},h=validateCrit(JWSInvalid,new Map([["b64",!0]]),i==null?void 0:i[s(399)],c,d);let g=!0;if(h[s(813)]("b64")&&(g=c[s(734)],typeof g!==s(672)))throw new JWSInvalid(s(904));const{alg:_}=d;if(typeof _!==s(1002)||!_)throw new JWSInvalid(s(693));const b=i&&validateAlgorithms(s(603),i[s(603)]);if(b&&!b[s(813)](_))throw new JOSEAlgNotAllowed(s(485));if(g){if(typeof a[s(375)]!==s(1002))throw new JWSInvalid(s(875))}else if(typeof a[s(375)]!==s(1002)&&!(a.payload instanceof Uint8Array))throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");let $=!1;typeof e===s(596)&&(e=await e(c,a),$=!0),checkKeyType(_,e,s(495));const j=concat(encoder.encode((o=a[s(801)])!==null&&o!==void 0?o:""),encoder.encode("."),typeof a[s(375)]===s(1002)?encoder.encode(a[s(375)]):a[s(375)]),_e=decode(a.signature);if(!await verify(_,e,_e,j))throw new JWSSignatureVerificationFailed;let et;g?et=decode(a[s(375)]):typeof a[s(375)]===s(1002)?et=encoder.encode(a[s(375)]):et=a[s(375)];const nt={payload:et};return a.protected!==void 0&&(nt[s(661)]=c),a[s(918)]!==void 0&&(nt[s(394)]=a.header),$?{...nt,key:e}:nt}async function compactVerify(a,e,i){var s=a1_0x131724;if(a instanceof Uint8Array&&(a=decoder[s(905)](a)),typeof a!==s(1002))throw new JWSInvalid(s(757));const{0:o,1:c,2:d,length:h}=a[s(437)](".");if(h!==3)throw new JWSInvalid("Invalid Compact JWS");const g=await flattenedVerify({payload:c,protected:o,signature:d},e,i),_={payload:g[s(375)],protectedHeader:g.protectedHeader};return typeof e===s(596)?{..._,key:g[s(397)]}:_}var epoch=a=>Math.floor(a.getTime()/1e3);const minute=60,hour=minute*60,day=hour*24,week=day*7,year=day*365.25,REGEX=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;var secs=a=>{var e=a1_0x131724;const i=REGEX[e(404)](a);if(!i)throw new TypeError("Invalid time period format");const s=parseFloat(i[1]);switch(i[2][e(800)]()){case e(990):case e(816):case e(577):case e(939):case"s":return Math[e(372)](s);case e(539):case e(935):case e(827):case e(919):case"m":return Math[e(372)](s*minute);case e(970):case e(825):case"hr":case"hrs":case"h":return Math[e(372)](s*hour);case e(914):case"days":case"d":return Math.round(s*day);case"week":case e(416):case"w":return Math[e(372)](s*week);default:return Math[e(372)](s*year)}};const normalizeTyp=a=>a[a1_0x131724(800)]()[a1_0x131724(824)](/^application\//,""),checkAudiencePresence=(a,e)=>{var i=a1_0x131724;return typeof a===i(1002)?e[i(1009)](a):Array[i(571)](a)?e[i(467)](Set.prototype.has.bind(new Set(a))):!1};var jwtPayload=(a,e,i={})=>{var s=a1_0x131724;const{typ:o}=i;if(o&&(typeof a[s(945)]!==s(1002)||normalizeTyp(a[s(945)])!==normalizeTyp(o)))throw new JWTClaimValidationFailed(s(866),s(945),s(833));let c;try{c=JSON[s(364)](decoder[s(905)](e))}catch{}if(!isObject(c))throw new JWTInvalid(s(343));const{issuer:d}=i;if(d&&!(Array[s(571)](d)?d:[d])[s(1009)](c[s(738)]))throw new JWTClaimValidationFailed(s(823),"iss","check_failed");const{subject:h}=i;if(h&&c[s(461)]!==h)throw new JWTClaimValidationFailed(s(870),s(461),s(833));const{audience:g}=i;if(g&&!checkAudiencePresence(c[s(938)],typeof g===s(1002)?[g]:g))throw new JWTClaimValidationFailed('unexpected "aud" claim value',s(938),s(833));let _;switch(typeof i[s(566)]){case s(1002):_=secs(i[s(566)]);break;case s(753):_=i.clockTolerance;break;case s(789):_=0;break;default:throw new TypeError(s(852))}const{currentDate:b}=i,$=epoch(b||new Date);if((c[s(822)]!==void 0||i[s(912)])&&typeof c.iat!="number")throw new JWTClaimValidationFailed('"iat" claim must be a number',s(822),s(393));if(c[s(377)]!==void 0){if(typeof c[s(377)]!==s(753))throw new JWTClaimValidationFailed(s(977),"nbf","invalid");if(c.nbf>$+_)throw new JWTClaimValidationFailed(s(512),"nbf",s(833))}if(c[s(747)]!==void 0){if(typeof c[s(747)]!==s(753))throw new JWTClaimValidationFailed(s(1015),s(747),s(393));if(c.exp<=$-_)throw new JWTExpired(s(838),s(747),"check_failed")}if(i[s(912)]){const j=$-c[s(822)],_e=typeof i[s(912)]===s(753)?i[s(912)]:secs(i[s(912)]);if(j-_>_e)throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',s(822),"check_failed");if(j<0-_)throw new JWTClaimValidationFailed(s(513),s(822),"check_failed")}return c};async function jwtVerify(a,e,i){var s=a1_0x131724,o;const c=await compactVerify(a,e,i);if(!((o=c[s(661)][s(399)])===null||o===void 0)&&o[s(1009)]("b64")&&c[s(661)].b64===!1)throw new JWTInvalid(s(657));const d=jwtPayload(c[s(661)],c.payload,i),h={payload:d,protectedHeader:c[s(661)]};return typeof e===s(596)?{...h,key:c[s(397)]}:h}var version=a1_0x131724(843);function extent(a){var e=a1_0x131724;let i=1/0,s=-1/0;for(let o=0;o<a[e(640)];o++){const c=a[o];c<i&&(i=c),c>s&&(s=c)}return[i,s]}function scaleLinear(a,e,i){const s=e[1]-e[0],o=i[1]-i[0];return(a-e[0])/s*o+i[0]}function computeFeature_dot(a,e,i){const s=[a[0]-e[0],a[1]-e[1],a[2]-e[2]],o=[i[0]-e[0],i[1]-e[1],i[2]-e[2]];return dot(s,o)}function getTriDotFeatures(a,e,i,s,o){var c=a1_0x131724;const d=[];for(let h=0;h<e[c(640)]/3;h++){const g=[e[h*3],e[h*3+1],e[h*3+2]],_=a[g[0]],b=a[g[1]],$=a[g[2]],j=computeFeature_dot(_,b,$),_e=computeFeature_dot(_,$,b),tt=(j-i[o+h*2])/s[o+h*2],et=(_e-i[o+h*2+1])/s[o+h*2+1];d[c(688)](tt),d[c(688)](et)}return d}function normalizePoints(a){var e=a1_0x131724;let i=[0,0],s=[0,0],o=[0,0];if(a[e(640)]>0){const c=a[0][e(640)],d=2;i=extent(a.map(it=>it?it[0]:0)),s=extent(a.map(it=>it?it[1]:0)),c===3&&(o=extent(a[e(714)](it=>it?it[2]:0)));const h=it=>Math[e(954)](it[1]-it[0]),g=h(i),_=h(s),b=h(o),$=Math[e(431)](g,_,b),j=d/2,_e=(it,at)=>[-at*(it/$),at*(it/$)],tt=_e(g,j),et=_e(_,j),nt=_e(b,j),rt=new Array(a[e(640)]);for(let it=0;it<a.length;it++){const at=a[it],st=scaleLinear(at[0],i,tt),ot=scaleLinear(at[1],s,et);let ct=0;c===3&&(ct=scaleLinear(at[2],o,nt)||0),rt[it]=[st,ot,ct]}return rt}return[]}function findRotation(a,e,i,s){var o=a1_0x131724;const c=a[e],d=a[i],h=[(c[0]+d[0])/2,c[1],c[2]],g=a[s];let _=subtract(c,d);_=divide(_,norm(_));let b=subtract(h,g);b=divide(b,norm(b));const $=cross(_,b),j=matrix([_,b,$]);return rotationMatrixToEulerAngles(j[o(361)]())}function findTransform(a,e){const i=a[e],s=i.z;return{x:i.x-.5,y:-i.y+.5,z:-1+-s*20}}function rotationMatrixToEulerAngles(a){var e=a1_0x131724;const i=Math.sqrt(Math[e(1011)](a[0][0],2)+Math.pow(a[1][0],2)),s=i<1e-6;let o=0,c=0,d=0;return s?(o=Math[e(654)](-a[1][2],a[1][1]),c=Math[e(654)](-a[2][0],i),d=0):(o=Math[e(654)](a[2][1],a[2][2]),c=Math[e(654)](-a[2][0],i),d=Math[e(654)](a[1][0],-a[0][0])),{pitch:o,yaw:c,roll:d}}const fetchJSON=a=>__awaiter(void 0,void 0,void 0,function*(){var e=a1_0x131724;return(yield a1_0x436209[e(998)](a))[e(991)]});class JSONHandler{constructor(e,i){var s=a1_0x131724;this[s(705)]=e,this.dir=i}load(){return __awaiter(this,void 0,void 0,function*(){var e=a1_0x9238;const i=this[e(705)],s={modelTopology:i.modelTopology,format:i.format,generatedBy:i[e(542)],convertedBy:i.convertedBy};if(i[e(569)]!=null&&(s.signature=i[e(569)]),i.userDefinedMetadata!=null&&(s[e(775)]=i.userDefinedMetadata),i[e(552)]!=null&&(s[e(552)]=i[e(552)]),i[e(545)]!=null){const[o,c]=yield loadWeights(i.weightsManifest,this[e(906)]);s.weightSpecs=o,s[e(478)]=c}return i[e(790)]!=null&&(s[e(790)]=i[e(790)]),s})}}function loadWeights(a,e){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;const s=[],o=[];for(const c of a){for(const d of c[i(524)]){const h=e+d,g=yield(yield a1_0x436209.get(h,{responseType:i(549),withCredentials:!1}))[i(991)];s[i(688)](g)}o[i(688)](...c[i(853)])}return[o,concatenateArrayBuffers(s)]})}function concatenateArrayBuffers(a){var e=a1_0x131724;if(a[e(640)]===1)return a[0];let i=0;a[e(781)](c=>{i+=c.byteLength});const s=new Uint8Array(i);let o=0;return a[e(781)](c=>{var d=e;s.set(new Uint8Array(c),o),o+=c[d(371)]}),s[e(786)]}class LowPassFilter{setAlpha(e){var i=a1_0x131724;(e<=0||e>1)&&console[i(442)](i(474)+e),this.a=e}constructor(e,i=0){var s=a1_0x131724;this.y=this.s=i,this[s(828)](e),this.initialized=!1}filter(e){var i;return this.initialized?i=this.a*e+(1-this.a)*this.s:(i=e,this.initialized=!0),this.y=e,this.s=i,i}[a1_0x131724(614)](e,i){var s=a1_0x131724;return this[s(828)](i),this[s(916)](e)}[a1_0x131724(715)](){return this.initialized}[a1_0x131724(642)](){return this.y}[a1_0x131724(373)](){var e=a1_0x131724;this[e(367)]=!1}}class OneEuroFilter{alpha(e){var i=a1_0x131724,s=1/this[i(975)],o=1/(2*Math.PI*e);return 1/(1+o/s)}[a1_0x131724(771)](e){var i=a1_0x131724;e<=0&&console.log(i(902)),this[i(975)]=e}[a1_0x131724(348)](e){var i=a1_0x131724;e<=0&&console.log(i(623)),this[i(668)]=e}setBeta(e){var i=a1_0x131724;this[i(409)]=e}[a1_0x131724(345)](e){var i=a1_0x131724;e<=0&&console[i(442)](i(558)),this[i(957)]=e}constructor(e,i=1,s=0,o=1){var c=a1_0x131724;this[c(771)](e),this[c(348)](i),this[c(840)](s),this[c(345)](o),this.x=new LowPassFilter(this.alpha(i)),this.dx=new LowPassFilter(this[c(700)](o)),this[c(357)]=void 0}[a1_0x131724(373)](){var e=a1_0x131724;this.x[e(373)](),this.dx[e(373)](),this[e(357)]=void 0}[a1_0x131724(916)](e,i=void 0){var s=a1_0x131724;this[s(357)]!==void 0&&i!==void 0&&(this.freq=1/(i-this[s(357)])),this[s(357)]=i;var o=this.x[s(715)]()?(e-this.x[s(642)]())*this.freq:0,c=this.dx.filterWithAlpha(o,this[s(700)](this[s(957)])),d=this[s(668)]+this.beta_*Math[s(954)](c);return this.x[s(614)](e,this[s(700)](d))}}class BlendShapeFactory{constructor(){}static[a1_0x131724(811)]({browDown_L:e=0,browDown_R:i=0,browInnerUp:s=0,browOuterUp_L:o=0,browOuterUp_R:c=0,cheekSquint_L:d=0,cheekSquint_R:h=0,eyeBlink_L:g=0,eyeBlink_R:_=0,eyeLookDown_L:b=0,eyeLookDown_R:$=0,eyeLookIn_L:j=0,eyeLookIn_R:_e=0,eyeLookOut_L:tt=0,eyeLookOut_R:et=0,eyeLookUp_L:nt=0,eyeLookUp_R:rt=0,eyeSquint_L:it=0,eyeSquint_R:at=0,eyeWide_L:st=0,eyeWide_R:ot=0,jawLeft:ct=0,jawOpen:lt=0,jawRight:dt=0,mouthClose:xt=0,mouthDimple_L:ut=0,mouthDimple_R:ft=0,mouthFrown_L:mt=0,mouthFrown_R:yt=0,mouthFunnel:St=0,mouthLeft:Et=0,mouthLowerDown_L:vt=0,mouthLowerDown_R:Nt=0,mouthPress_L:wt=0,mouthPress_R:$t=0,mouthPucker:Ct=0,mouthRight:Mt=0,mouthRollLower:Ot=0,mouthRollUpper:Dt=0,mouthShrugLower:At=0,mouthShrugUpper:kt=0,mouthSmile_L:Ft=0,mouthSmile_R:Bt=0,mouthStretch_L:Ht=0,mouthStretch_R:Wt=0,mouthUpperUp_L:Ut=0,mouthUpperUp_R:Rt=0,noseSneer_L:un=0,noseSneer_R:rn=0,cheekPuff:mn=0,jawForward:sn=0,tongueOut:hn=0}={}){return{browDown_L:e,browDown_R:i,browInnerUp:s,browOuterUp_L:o,browOuterUp_R:c,cheekSquint_L:d,cheekSquint_R:h,eyeBlink_L:g,eyeBlink_R:_,eyeLookDown_L:b,eyeLookDown_R:$,eyeLookIn_L:j,eyeLookIn_R:_e,eyeLookOut_L:tt,eyeLookOut_R:et,eyeLookUp_L:nt,eyeLookUp_R:rt,eyeSquint_L:it,eyeSquint_R:at,eyeWide_L:st,eyeWide_R:ot,jawLeft:ct,jawOpen:lt,jawRight:dt,mouthClose:xt,mouthDimple_L:ut,mouthDimple_R:ft,mouthFrown_L:mt,mouthFrown_R:yt,mouthFunnel:St,mouthLeft:Et,mouthLowerDown_L:vt,mouthLowerDown_R:Nt,mouthPress_L:wt,mouthPress_R:$t,mouthPucker:Ct,mouthRight:Mt,mouthRollLower:Ot,mouthRollUpper:Dt,mouthShrugLower:At,mouthShrugUpper:kt,mouthSmile_L:Ft,mouthSmile_R:Bt,mouthStretch_L:Ht,mouthStretch_R:Wt,mouthUpperUp_L:Ut,mouthUpperUp_R:Rt,noseSneer_L:un,noseSneer_R:rn,cheekPuff:mn,jawForward:sn,tongueOut:hn}}}let BlendShapeKeys$1=class{constructor(){}static[a1_0x131724(346)](e){var i=a1_0x131724;return e[i(895)]("_L")?e[i(649)](0,e[i(871)]("_L"))[i(1008)](i(494)):e[i(895)]("_R")?e[i(649)](0,e.lastIndexOf("_R"))[i(1008)](i(443)):e}static[a1_0x131724(888)](e){var i=a1_0x131724;return["jawLeft",i(704),i(673),"mouthRight"][i(1009)](e)?e:e[i(895)](i(494))?e.substring(0,e[i(871)](i(494)))[i(1008)]("_L"):e[i(895)](i(443))?e[i(649)](0,e[i(871)](i(443)))[i(1008)]("_R"):e}};BlendShapeKeys$1[a1_0x131724(839)]=52,BlendShapeKeys$1[a1_0x131724(434)]="browDown_L",BlendShapeKeys$1.browDown_R=a1_0x131724(484),BlendShapeKeys$1.browInnerUp=a1_0x131724(890),BlendShapeKeys$1.browOuterUp_L=a1_0x131724(719),BlendShapeKeys$1[a1_0x131724(643)]=a1_0x131724(643),BlendShapeKeys$1[a1_0x131724(470)]="cheekPuff",BlendShapeKeys$1[a1_0x131724(664)]="cheekSquint_L",BlendShapeKeys$1[a1_0x131724(344)]=a1_0x131724(344),BlendShapeKeys$1[a1_0x131724(592)]=a1_0x131724(592),BlendShapeKeys$1[a1_0x131724(928)]=a1_0x131724(928),BlendShapeKeys$1[a1_0x131724(1012)]=a1_0x131724(1012),BlendShapeKeys$1.eyeLookDown_R=a1_0x131724(669),BlendShapeKeys$1[a1_0x131724(963)]=a1_0x131724(963),BlendShapeKeys$1[a1_0x131724(342)]="eyeLookIn_R",BlendShapeKeys$1[a1_0x131724(464)]=a1_0x131724(464),BlendShapeKeys$1[a1_0x131724(703)]="eyeLookOut_R",BlendShapeKeys$1.eyeLookUp_L=a1_0x131724(982),BlendShapeKeys$1[a1_0x131724(940)]="eyeLookUp_R",BlendShapeKeys$1[a1_0x131724(622)]=a1_0x131724(622),BlendShapeKeys$1[a1_0x131724(1003)]=a1_0x131724(1003),BlendShapeKeys$1[a1_0x131724(711)]=a1_0x131724(711),BlendShapeKeys$1[a1_0x131724(422)]=a1_0x131724(422),BlendShapeKeys$1[a1_0x131724(588)]="jawForward",BlendShapeKeys$1.jawLeft=a1_0x131724(917),BlendShapeKeys$1.jawOpen=a1_0x131724(892),BlendShapeKeys$1[a1_0x131724(704)]=a1_0x131724(704),BlendShapeKeys$1[a1_0x131724(576)]=a1_0x131724(576),BlendShapeKeys$1.mouthDimple_L="mouthDimple_L",BlendShapeKeys$1[a1_0x131724(976)]=a1_0x131724(976),BlendShapeKeys$1.mouthFrown_L="mouthFrown_L",BlendShapeKeys$1.mouthFrown_R="mouthFrown_R",BlendShapeKeys$1.mouthFunnel=a1_0x131724(551),BlendShapeKeys$1.mouthLeft=a1_0x131724(673),BlendShapeKeys$1[a1_0x131724(366)]="mouthLowerDown_L",BlendShapeKeys$1.mouthLowerDown_R=a1_0x131724(608),BlendShapeKeys$1[a1_0x131724(784)]="mouthPress_L",BlendShapeKeys$1.mouthPress_R=a1_0x131724(538),BlendShapeKeys$1[a1_0x131724(618)]=a1_0x131724(618),BlendShapeKeys$1[a1_0x131724(518)]=a1_0x131724(518),BlendShapeKeys$1[a1_0x131724(792)]=a1_0x131724(792),BlendShapeKeys$1[a1_0x131724(391)]=a1_0x131724(391),BlendShapeKeys$1.mouthShrugLower=a1_0x131724(492),BlendShapeKeys$1[a1_0x131724(851)]=a1_0x131724(851),BlendShapeKeys$1[a1_0x131724(736)]=a1_0x131724(736),BlendShapeKeys$1.mouthSmile_R=a1_0x131724(879),BlendShapeKeys$1[a1_0x131724(758)]=a1_0x131724(758),BlendShapeKeys$1[a1_0x131724(544)]=a1_0x131724(544),BlendShapeKeys$1[a1_0x131724(927)]=a1_0x131724(927),BlendShapeKeys$1.mouthUpperUp_R="mouthUpperUp_R",BlendShapeKeys$1[a1_0x131724(850)]=a1_0x131724(850),BlendShapeKeys$1[a1_0x131724(648)]=a1_0x131724(648),BlendShapeKeys$1[a1_0x131724(354)]=a1_0x131724(354),BlendShapeKeys$1[a1_0x131724(593)]=[BlendShapeKeys$1.browDown_L,BlendShapeKeys$1.browDown_R,BlendShapeKeys$1[a1_0x131724(890)],BlendShapeKeys$1[a1_0x131724(719)],BlendShapeKeys$1[a1_0x131724(643)],BlendShapeKeys$1[a1_0x131724(470)],BlendShapeKeys$1[a1_0x131724(664)],BlendShapeKeys$1[a1_0x131724(344)],BlendShapeKeys$1.eyeBlink_L,BlendShapeKeys$1[a1_0x131724(928)],BlendShapeKeys$1.eyeLookDown_L,BlendShapeKeys$1[a1_0x131724(669)],BlendShapeKeys$1[a1_0x131724(963)],BlendShapeKeys$1.eyeLookIn_R,BlendShapeKeys$1[a1_0x131724(464)],BlendShapeKeys$1[a1_0x131724(703)],BlendShapeKeys$1[a1_0x131724(982)],BlendShapeKeys$1[a1_0x131724(940)],BlendShapeKeys$1[a1_0x131724(622)],BlendShapeKeys$1[a1_0x131724(1003)],BlendShapeKeys$1[a1_0x131724(711)],BlendShapeKeys$1[a1_0x131724(422)],BlendShapeKeys$1.jawForward,BlendShapeKeys$1[a1_0x131724(917)],BlendShapeKeys$1[a1_0x131724(892)],BlendShapeKeys$1[a1_0x131724(704)],BlendShapeKeys$1[a1_0x131724(576)],BlendShapeKeys$1[a1_0x131724(731)],BlendShapeKeys$1.mouthDimple_R,BlendShapeKeys$1[a1_0x131724(971)],BlendShapeKeys$1[a1_0x131724(609)],BlendShapeKeys$1.mouthFunnel,BlendShapeKeys$1[a1_0x131724(673)],BlendShapeKeys$1[a1_0x131724(366)],BlendShapeKeys$1[a1_0x131724(608)],BlendShapeKeys$1[a1_0x131724(784)],BlendShapeKeys$1.mouthPress_R,BlendShapeKeys$1.mouthPucker,BlendShapeKeys$1[a1_0x131724(518)],BlendShapeKeys$1[a1_0x131724(792)],BlendShapeKeys$1[a1_0x131724(391)],BlendShapeKeys$1[a1_0x131724(492)],BlendShapeKeys$1.mouthShrugUpper,BlendShapeKeys$1[a1_0x131724(736)],BlendShapeKeys$1.mouthSmile_R,BlendShapeKeys$1[a1_0x131724(758)],BlendShapeKeys$1[a1_0x131724(544)],BlendShapeKeys$1[a1_0x131724(927)],BlendShapeKeys$1[a1_0x131724(383)],BlendShapeKeys$1[a1_0x131724(850)],BlendShapeKeys$1.noseSneer_R,BlendShapeKeys$1[a1_0x131724(354)]];const TUNE_PARAMS=a1_0x131724(515);class AUTuner{constructor(){var e=a1_0x131724;this[e(414)]={},this.easingCurves={},this.pitchFilter=new OneEuroFilter(20,.001,1,1),this.rollFilter=new OneEuroFilter(20,.001,5,1),this[e(430)]=new OneEuroFilter(20,.001,5,1),this.transformX=new OneEuroFilter(20,.001,1,1),this[e(797)]=new OneEuroFilter(20,.001,5,1),this[e(924)]=new OneEuroFilter(20,.001,5,1),this[e(859)]=i=>{var s=e;const o=this[s(554)][s(916)](i[s(1022)]),c=this.yawFilter.filter(i[s(992)]),d=this[s(662)][s(916)](i[s(710)]);return{pitch:o,yaw:c,roll:d}},this[e(1023)]=i=>{var s=e;const o=this.transformX[s(916)](i.x),c=this[s(797)][s(916)](i.y),d=this.transformZ.filter(i.z);return{x:o,y:c,z:d}},this.blendShapeTune=(i,s)=>{var o=e;const c=BlendShapeFactory.create();s[o(781)]((tt,et)=>{var nt=o;tt[nt(781)]((rt,it)=>{var at=nt;const st=i[et][it],ot=Math[at(827)](Math[at(431)](st,0),1),ct=this.filters[rt],lt=this[at(395)][rt];let xt=ct.filter(ot);xt=lt(xt),c[rt]=xt*1.15})});const d=c[o(736)],h=c[o(879)],g=c.eyeBlink_L,_=c[o(928)],b=this[o(764)](.5,c[o(434)],c[o(484)]);c[o(434)]=b[o(349)]*(1-g/2),c.browDown_R=b[o(402)]*(1-_/2);const $=this[o(764)](.5,c.browOuterUp_L,c[o(643)]);c[o(719)]=$.leftAmp,c[o(643)]=$[o(402)];const j=this[o(764)](.5,c[o(736)],c[o(879)]);c[o(736)]=j[o(349)],c[o(879)]=j[o(402)],c[o(927)]=c.mouthUpperUp_L*(1-c[o(879)]*.2),c[o(383)]=c[o(383)]*(1-c[o(736)]*.2);const _e=this.diffAmp(.2,c[o(927)],c.mouthUpperUp_R);return c.mouthUpperUp_L=_e.leftAmp,c[o(383)]=_e[o(402)],c.eyeBlink_L=g*(1-h*.5),c.eyeBlink_R=_*(1-d*.5),c[o(851)]=c[o(851)]/2,c},this._tune=JSON.parse(TUNE_PARAMS),this[e(466)](this[e(768)])}get[a1_0x131724(626)](){var e=a1_0x131724;return this[e(768)]}set[a1_0x131724(626)](e){var i=a1_0x131724;this[i(768)]=e,this[i(466)](e)}loadFiltersAndCurvesFromTune(e){var i=a1_0x131724;BlendShapeKeys$1.sorted[i(781)](s=>{var o=i,c;const d=(c=e[s])!==null&&c!==void 0?c:{fps:120,minCutoff:.01,beta:25,bezier_x1:.08894012120656589,bezier_y1:.003999877929687479,bezier_x2:.8217921067661327,bezier_y2:.8839998779296875};this[o(414)][s]=new OneEuroFilter(d[o(355)],d[o(818)],d[o(1017)],1),this.easingCurves[s]=a1_0x2514d1(d[o(541)],d.bezier_y1,d.bezier_x2,d[o(448)])})}[a1_0x131724(764)](e,i,s){var o=a1_0x131724;const c=(i-s)*e,d=(s-i)*e,h=Math[o(827)](Math.max(c+i,0),1),g=Math[o(827)](Math[o(431)](d+s,0),1);return{leftAmp:h,rightAmp:g}}}const CENTER_POINT=5,leftEyePoint=33,rightEyePoint=263,bottomChinPoint=152;class AvatarDenseCombinePredictor{constructor(){var e=a1_0x131724;this[e(666)]=new AUTuner}[a1_0x131724(898)]({predictionQuality:e,customBinFileUrl:i,customModelMetaUrl:s,customModelUrl:o}){return __awaiter(this,void 0,void 0,function*(){var c=a1_0x9238;this.customBinFileUrl=i,this[c(724)]=s,this.customModelUrl=o,yield this[c(855)](e)})}[a1_0x131724(502)](e){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;if(e.multiFaceLandmarks[i(640)]<1)return;engine()[i(723)]();const s=e[i(504)][0].map($=>[$.x*e[i(671)].width,$.y*e.image[i(499)],$.z*e.image[i(744)]]),o=findRotation(s,leftEyePoint,rightEyePoint,bottomChinPoint),c=this[i(666)][i(859)](o),d=findTransform(e[i(504)][0],CENTER_POINT),h=this.auTuner[i(1023)](d),g=yield this.createPrediction(this.actionUnitModel,this[i(605)],s),_=this[i(666)][i(965)](g,this[i(605)][i(580)]),b={blendShapes:_,rotation:c,transform:h};return engine()[i(543)](),b})}[a1_0x131724(756)](e){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;if(e===i(556))return yield fetchJSON(this[i(942)]);if(e===i(874))return JSON[i(364)](MODEL_HIGH);if(e===i(1019))return JSON[i(364)](MODEL_LITE)})}getBinFileUrl(e){var i=a1_0x131724;if(e===i(556))return this[i(1014)];if(e===i(874))return i(636);if(e==="low")return"https://hallway-public.nyc3.cdn.digitaloceanspaces.com/webSDK/0.10.0/Low/"}getModelMeta(e){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;if(e==="custom")return yield fetchJSON(this.customModelMetaUrl);if(e===i(874))return JSON[i(364)](ALL_AU_META_HIGH);if(e===i(1019))return JSON[i(364)](ALL_AU_META_LITE)})}[a1_0x131724(855)](e){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;const s=yield this[i(756)](e),o=this[i(752)](e);this[i(605)]=yield this[i(433)](e),this[i(370)]=yield loadLayersModel(new JSONHandler(s,o))})}[a1_0x131724(709)](e,i,s,o){var c=a1_0x131724;let d=[],h=0;for(let g=0;g<i[c(640)];g++){const _=i[g],b=_[0],$=_[1],j=[];for(let et=0;et<b[c(640)];et++){const nt=b[et];j[c(688)](e[nt])}const _e=normalizePoints(j),tt=getTriDotFeatures(_e,$,s,o,h);d=d[c(1008)](tt),h+=$[c(640)]/3*2}return a1_0x1cfc52[c(450)]([d])}[a1_0x131724(1020)](e,i,s){return __awaiter(this,void 0,void 0,function*(){var o=a1_0x9238;const c=this[o(709)](s,i.tris,i[o(525)],i[o(612)]),d=e[o(925)](c);let h=[];const g=[];if(d instanceof Tensor)h[o(688)](d[o(483)]());else if(d instanceof Array){for(let _=0;_<d[o(640)];_++)g[o(688)](d[_].data());h=yield Promise.all(g)}return h})}}const MODEL_HIGH='{"format": "layers-model", "generatedBy": "keras v2.6.0", "convertedBy": "TensorFlow.js Converter v3.11.0", "modelTopology": {"keras_version": "2.6.0", "backend": "tensorflow", "model_config": {"class_name": "Functional", "config": {"name": "model", "layers": [{"class_name": "InputLayer", "config": {"batch_input_shape": [null, 1266], "dtype": "float32", "sparse": false, "ragged": false, "name": "input_1"}, "name": "input_1", "inbound_nodes": []}, {"class_name": "Dense", "config": {"name": "dense", "trainable": true, "dtype": "float32", "units": 256, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense", "inbound_nodes": [[["input_1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation", "inbound_nodes": [[["dense", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_1", "trainable": true, "dtype": "float32", "units": 256, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_1", "inbound_nodes": [[["activation", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization", "inbound_nodes": [[["dense_1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_1", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_1", "inbound_nodes": [[["batch_normalization", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_2", "trainable": true, "dtype": "float32", "units": 96, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_2", "inbound_nodes": [[["activation_1", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_5", "trainable": true, "dtype": "float32", "units": 96, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_5", "inbound_nodes": [[["activation_1", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_8", "trainable": true, "dtype": "float32", "units": 96, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_8", "inbound_nodes": [[["activation_1", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_11", "trainable": true, "dtype": "float32", "units": 96, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_11", "inbound_nodes": [[["activation_1", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_14", "trainable": true, "dtype": "float32", "units": 96, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_14", "inbound_nodes": [[["activation_1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_2", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_2", "inbound_nodes": [[["dense_2", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_5", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_5", "inbound_nodes": [[["dense_5", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_8", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_8", "inbound_nodes": [[["dense_8", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_11", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_11", "inbound_nodes": [[["dense_11", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_14", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_14", "inbound_nodes": [[["dense_14", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "shared", "trainable": true, "dtype": "float32", "units": 96, "activation": "swish", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "shared", "inbound_nodes": [[["activation_2", 0, 0, {}]], [["activation_5", 0, 0, {}]], [["activation_8", 0, 0, {}]], [["activation_11", 0, 0, {}]], [["activation_14", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_3", "trainable": true, "dtype": "float32", "units": 42, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_3", "inbound_nodes": [[["shared", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_6", "trainable": true, "dtype": "float32", "units": 36, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_6", "inbound_nodes": [[["shared", 1, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_9", "trainable": true, "dtype": "float32", "units": 48, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_9", "inbound_nodes": [[["shared", 2, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_12", "trainable": true, "dtype": "float32", "units": 72, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_12", "inbound_nodes": [[["shared", 3, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_15", "trainable": true, "dtype": "float32", "units": 96, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_15", "inbound_nodes": [[["shared", 4, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_1", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_1", "inbound_nodes": [[["dense_3", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_2", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_2", "inbound_nodes": [[["dense_6", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_3", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_3", "inbound_nodes": [[["dense_9", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_4", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_4", "inbound_nodes": [[["dense_12", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_5", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_5", "inbound_nodes": [[["dense_15", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_3", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_3", "inbound_nodes": [[["batch_normalization_1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_6", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_6", "inbound_nodes": [[["batch_normalization_2", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_9", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_9", "inbound_nodes": [[["batch_normalization_3", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_12", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_12", "inbound_nodes": [[["batch_normalization_4", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_15", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_15", "inbound_nodes": [[["batch_normalization_5", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_4", "trainable": true, "dtype": "float32", "units": 21, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_4", "inbound_nodes": [[["activation_3", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_7", "trainable": true, "dtype": "float32", "units": 18, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_7", "inbound_nodes": [[["activation_6", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_10", "trainable": true, "dtype": "float32", "units": 24, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_10", "inbound_nodes": [[["activation_9", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_13", "trainable": true, "dtype": "float32", "units": 36, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_13", "inbound_nodes": [[["activation_12", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_16", "trainable": true, "dtype": "float32", "units": 48, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_16", "inbound_nodes": [[["activation_15", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_4", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_4", "inbound_nodes": [[["dense_4", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_7", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_7", "inbound_nodes": [[["dense_7", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_10", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_10", "inbound_nodes": [[["dense_10", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_13", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_13", "inbound_nodes": [[["dense_13", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_16", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_16", "inbound_nodes": [[["dense_16", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "a", "trainable": true, "dtype": "float32", "units": 7, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "a", "inbound_nodes": [[["activation_4", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "b", "trainable": true, "dtype": "float32", "units": 6, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "b", "inbound_nodes": [[["activation_7", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "c", "trainable": true, "dtype": "float32", "units": 8, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "c", "inbound_nodes": [[["activation_10", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "d", "trainable": true, "dtype": "float32", "units": 12, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "d", "inbound_nodes": [[["activation_13", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "e", "trainable": true, "dtype": "float32", "units": 16, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "e", "inbound_nodes": [[["activation_16", 0, 0, {}]]]}], "input_layers": [["input_1", 0, 0]], "output_layers": [["a", 0, 0], ["b", 0, 0], ["c", 0, 0], ["d", 0, 0], ["e", 0, 0]]}}, "training_config": {"loss": {"class_name": "MeanSquaredError", "config": {"reduction": "auto", "name": "mean_squared_error"}}, "metrics": [[{"class_name": "MeanSquaredError", "config": {"name": "a_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "a_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "b_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "b_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "c_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "c_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "d_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "d_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "e_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "e_mean_absolute_error", "dtype": "float32"}}]], "weighted_metrics": null, "loss_weights": null, "optimizer_config": {"class_name": "Adam", "config": {"name": "Adam", "learning_rate": 0.0010000000474974513, "decay": 0.0, "beta_1": 0.8999999761581421, "beta_2": 0.9990000128746033, "epsilon": 1e-07, "amsgrad": false}}}}, "weightsManifest": [{"paths": ["group1-shard1of1.bin"], "weights": [{"name": "a/kernel", "shape": [21, 7], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.34152484037805736, "scale": 9.998385162423367e-06, "original_dtype": "float32"}}, {"name": "a/bias", "shape": [7], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.05245498940348625, "scale": 2.5705616638954565e-06, "original_dtype": "float32"}}, {"name": "b/kernel", "shape": [18, 6], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.49812461368150135, "scale": 1.4075292842088198e-05, "original_dtype": "float32"}}, {"name": "b/bias", "shape": [6], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.05327168479561806, "scale": 3.762704696063729e-06, "original_dtype": "float32"}}, {"name": "batch_normalization/gamma", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.6943549513816833, "scale": 4.430730073468549e-05, "original_dtype": "float32"}}, {"name": "batch_normalization/beta", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.579886580037427, "scale": 7.17555939073447e-05, "original_dtype": "float32"}}, {"name": "batch_normalization/moving_mean", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -2468.1569582629986, "scale": 0.07718779579256313, "original_dtype": "float32"}}, {"name": "batch_normalization/moving_variance", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 439589.96875, "scale": 51.03764066910811, "original_dtype": "float32"}}, {"name": "batch_normalization_1/gamma", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.24011404812335968, "scale": 1.8985137346817335e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_1/beta", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.7531593294995136, "scale": 1.1959655887249125e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_1/moving_mean", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4832.2838959501605, "scale": 0.09189646843051423, "original_dtype": "float32"}}, {"name": "batch_normalization_1/moving_variance", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1683400.125, "scale": 127.26468108644237, "original_dtype": "float32"}}, {"name": "batch_normalization_2/gamma", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.21489904820919037, "scale": 1.690830133540994e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_2/beta", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.9055880334267783, "scale": 1.3959182930400135e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_2/moving_mean", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5010.460415001437, "scale": 0.08848807754801824, "original_dtype": "float32"}}, {"name": "batch_normalization_2/moving_variance", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1195131.5, "scale": 356.11878385595486, "original_dtype": "float32"}}, {"name": "batch_normalization_3/gamma", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.25988802313804626, "scale": 2.0154197619673844e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_3/beta", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.4214927238326438, "scale": 2.3814587432277496e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_3/moving_mean", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4516.991902261345, "scale": 0.09553301261074712, "original_dtype": "float32"}}, {"name": "batch_normalization_3/moving_variance", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1302695.875, "scale": 239.49736972610054, "original_dtype": "float32"}}, {"name": "batch_normalization_4/gamma", "shape": [72], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.20372924208641052, "scale": 1.2058584442889562e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_4/beta", "shape": [72], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.5091016292572021, "scale": 7.333824422545552e-06, "original_dtype": "float32"}}, {"name": "batch_normalization_4/moving_mean", "shape": [72], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5581.663886533228, "scale": 0.13759802505936714, "original_dtype": "float32"}}, {"name": "batch_normalization_4/moving_variance", "shape": [72], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1547579.875, "scale": 266.28256847486074, "original_dtype": "float32"}}, {"name": "batch_normalization_5/gamma", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.20020067691802979, "scale": 1.4120464495211178e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_5/beta", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.0803118545666908, "scale": 1.6702409625335354e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_5/moving_mean", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5893.203580423688, "scale": 0.15120471020971618, "original_dtype": "float32"}}, {"name": "batch_normalization_5/moving_variance", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1174690.375, "scale": 252.40655565728238, "original_dtype": "float32"}}, {"name": "c/kernel", "shape": [24, 8], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.5177297037499278, "scale": 2.771855910419008e-05, "original_dtype": "float32"}}, {"name": "c/bias", "shape": [8], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.0011589399073272943, "scale": 2.454352526953003e-06, "original_dtype": "float32"}}, {"name": "d/kernel", "shape": [36, 12], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.15260927745549588, "scale": 7.149314974959986e-06, "original_dtype": "float32"}}, {"name": "d/bias", "shape": [12], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.06730722635984421, "scale": 3.79263997723693e-06, "original_dtype": "float32"}}, {"name": "dense/kernel", "shape": [1266, 256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -17.766702855722013, "scale": 0.0004408501738349424, "original_dtype": "float32"}}, {"name": "dense/bias", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -32.2838449468545, "scale": 0.0006995567606417149, "original_dtype": "float32"}}, {"name": "dense_1/kernel", "shape": [256, 256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -15.679528270048255, "scale": 0.00036315379539670776, "original_dtype": "float32"}}, {"name": "dense_1/bias", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.192216108751227e-05, "scale": 8.993424732360127e-10, "original_dtype": "float32"}}, {"name": "dense_10/kernel", "shape": [48, 24], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.4914666624994, "scale": 0.00011503602762266674, "original_dtype": "float32"}}, {"name": "dense_10/bias", "shape": [24], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.4884052329353725, "scale": 6.925375681497543e-05, "original_dtype": "float32"}}, {"name": "dense_11/kernel", "shape": [256, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -11.527113251610789, "scale": 0.0003040893041288097, "original_dtype": "float32"}}, {"name": "dense_11/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.077751987095218, "scale": 0.00020590211212421307, "original_dtype": "float32"}}, {"name": "dense_12/kernel", "shape": [96, 72], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -11.040607545991925, "scale": 0.0002703182319122475, "original_dtype": "float32"}}, {"name": "dense_12/bias", "shape": [72], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -6.242119919933536e-05, "scale": 2.699762086386201e-09, "original_dtype": "float32"}}, {"name": "dense_13/kernel", "shape": [72, 36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -6.645381233680709, "scale": 0.0001528868824755144, "original_dtype": "float32"}}, {"name": "dense_13/bias", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.1402740888594924, "scale": 4.8027438844681385e-05, "original_dtype": "float32"}}, {"name": "dense_14/kernel", "shape": [256, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.119709127176868, "scale": 0.00028039937053181863, "original_dtype": "float32"}}, {"name": "dense_14/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -6.081811899195512, "scale": 0.00027500845124103605, "original_dtype": "float32"}}, {"name": "dense_15/kernel", "shape": [96, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.011770248267565, "scale": 0.00027143886289962544, "original_dtype": "float32"}}, {"name": "dense_15/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.66976530797628e-05, "scale": 2.967733268261449e-09, "original_dtype": "float32"}}, {"name": "dense_16/kernel", "shape": [96, 48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.360003139687646, "scale": 0.0001221625293939203, "original_dtype": "float32"}}, {"name": "dense_16/bias", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.117162990980711, "scale": 6.43648655689071e-05, "original_dtype": "float32"}}, {"name": "dense_2/kernel", "shape": [256, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.283893973543414, "scale": 0.00023756733727944455, "original_dtype": "float32"}}, {"name": "dense_2/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.288528963516677, "scale": 0.0001738561084689397, "original_dtype": "float32"}}, {"name": "dense_3/kernel", "shape": [96, 42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -10.805625922701546, "scale": 0.0003913238663926972, "original_dtype": "float32"}}, {"name": "dense_3/bias", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.00023975147793200651, "scale": 5.611634629997344e-09, "original_dtype": "float32"}}, {"name": "dense_4/kernel", "shape": [42, 21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.910697617828778, "scale": 9.83204932200824e-05, "original_dtype": "float32"}}, {"name": "dense_4/bias", "shape": [21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.2725718021392822, "scale": 4.936938509521272e-05, "original_dtype": "float32"}}, {"name": "dense_5/kernel", "shape": [256, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -8.804166829475978, "scale": 0.000304168831559025, "original_dtype": "float32"}}, {"name": "dense_5/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -6.093871475057325, "scale": 0.00017886326607153874, "original_dtype": "float32"}}, {"name": "dense_6/kernel", "shape": [96, 36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.628214164030146, "scale": 0.00023941252645788108, "original_dtype": "float32"}}, {"name": "dense_6/bias", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.00018072614102045825, "scale": 5.3396602558783386e-09, "original_dtype": "float32"}}, {"name": "dense_7/kernel", "shape": [36, 18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.399672209062356, "scale": 0.00010582749336273526, "original_dtype": "float32"}}, {"name": "dense_7/bias", "shape": [18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.4238353799521228, "scale": 2.524262276977844e-05, "original_dtype": "float32"}}, {"name": "dense_8/kernel", "shape": [256, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -10.658081016895599, "scale": 0.0003199952267359894, "original_dtype": "float32"}}, {"name": "dense_8/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.988045453686931, "scale": 0.00010946545492113887, "original_dtype": "float32"}}, {"name": "dense_9/kernel", "shape": [96, 48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -7.9635740770340115, "scale": 0.0002236393629990736, "original_dtype": "float32"}}, {"name": "dense_9/bias", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -8.43627593902066e-05, "scale": 3.4019985236795956e-09, "original_dtype": "float32"}}, {"name": "e/kernel", "shape": [48, 16], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.21210380814900756, "scale": 8.544304227723476e-06, "original_dtype": "float32"}}, {"name": "e/bias", "shape": [16], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.06371922045946121, "scale": 2.9261341000018006e-06, "original_dtype": "float32"}}, {"name": "shared/kernel", "shape": [96, 96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -7.98148017837316, "scale": 0.0002198997183814514, "original_dtype": "float32"}}, {"name": "shared/bias", "shape": [96], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -14.595442970970305, "scale": 0.0005023211374920948, "original_dtype": "float32"}}]}]}',MODEL_LITE='{"format": "layers-model", "generatedBy": "keras v2.6.0", "convertedBy": "TensorFlow.js Converter v3.11.0", "modelTopology": {"keras_version": "2.6.0", "backend": "tensorflow", "model_config": {"class_name": "Functional", "config": {"name": "model", "layers": [{"class_name": "InputLayer", "config": {"batch_input_shape": [null, 1160], "dtype": "float32", "sparse": false, "ragged": false, "name": "input_1"}, "name": "input_1", "inbound_nodes": []}, {"class_name": "Dense", "config": {"name": "dense", "trainable": true, "dtype": "float32", "units": 256, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense", "inbound_nodes": [[["input_1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation", "inbound_nodes": [[["dense", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_1", "trainable": true, "dtype": "float32", "units": 256, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_1", "inbound_nodes": [[["activation", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization", "inbound_nodes": [[["dense_1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_1", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_1", "inbound_nodes": [[["batch_normalization", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dense_2", "trainable": true, "dtype": "float32", "units": 256, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dense_2", "inbound_nodes": [[["activation_1", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_1", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_1", "inbound_nodes": [[["dense_2", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_2", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_2", "inbound_nodes": [[["batch_normalization_1", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "ameh1", "trainable": true, "dtype": "float32", "units": 56, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "ameh1", "inbound_nodes": [[["activation_2", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "bmeh1", "trainable": true, "dtype": "float32", "units": 48, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "bmeh1", "inbound_nodes": [[["activation_2", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dmeh1", "trainable": true, "dtype": "float32", "units": 192, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dmeh1", "inbound_nodes": [[["activation_2", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "emeh1", "trainable": true, "dtype": "float32", "units": 170, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "emeh1", "inbound_nodes": [[["activation_2", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_3", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_3", "inbound_nodes": [[["ameh1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_6", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_6", "inbound_nodes": [[["bmeh1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_9", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_9", "inbound_nodes": [[["dmeh1", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_12", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_12", "inbound_nodes": [[["emeh1", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "ameh2", "trainable": true, "dtype": "float32", "units": 42, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "ameh2", "inbound_nodes": [[["activation_3", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "bmeh2", "trainable": true, "dtype": "float32", "units": 36, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "bmeh2", "inbound_nodes": [[["activation_6", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dmeh2", "trainable": true, "dtype": "float32", "units": 168, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dmeh2", "inbound_nodes": [[["activation_9", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "emeh2", "trainable": true, "dtype": "float32", "units": 136, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "emeh2", "inbound_nodes": [[["activation_12", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "abatch_meh", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "abatch_meh", "inbound_nodes": [[["ameh2", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "bbatch_meh", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "bbatch_meh", "inbound_nodes": [[["bmeh2", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "dbatch_meh", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "dbatch_meh", "inbound_nodes": [[["dmeh2", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "ebatch_meh", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "ebatch_meh", "inbound_nodes": [[["emeh2", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_4", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_4", "inbound_nodes": [[["abatch_meh", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_7", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_7", "inbound_nodes": [[["bbatch_meh", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_10", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_10", "inbound_nodes": [[["dbatch_meh", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_13", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_13", "inbound_nodes": [[["ebatch_meh", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "ameh3", "trainable": true, "dtype": "float32", "units": 21, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "ameh3", "inbound_nodes": [[["activation_4", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "bmeh3", "trainable": true, "dtype": "float32", "units": 18, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "bmeh3", "inbound_nodes": [[["activation_7", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "dmeh3", "trainable": true, "dtype": "float32", "units": 132, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "dmeh3", "inbound_nodes": [[["activation_10", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "emeh3", "trainable": true, "dtype": "float32", "units": 85, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "emeh3", "inbound_nodes": [[["activation_13", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_2", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_2", "inbound_nodes": [[["ameh3", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_3", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_3", "inbound_nodes": [[["bmeh3", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_4", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_4", "inbound_nodes": [[["dmeh3", 0, 0, {}]]]}, {"class_name": "BatchNormalization", "config": {"name": "batch_normalization_5", "trainable": true, "dtype": "float32", "axis": [1], "momentum": 0.99, "epsilon": 0.001, "center": true, "scale": true, "beta_initializer": {"class_name": "Zeros", "config": {}}, "gamma_initializer": {"class_name": "Ones", "config": {}}, "moving_mean_initializer": {"class_name": "Zeros", "config": {}}, "moving_variance_initializer": {"class_name": "Ones", "config": {}}, "beta_regularizer": null, "gamma_regularizer": null, "beta_constraint": null, "gamma_constraint": null}, "name": "batch_normalization_5", "inbound_nodes": [[["emeh3", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_5", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_5", "inbound_nodes": [[["batch_normalization_2", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_8", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_8", "inbound_nodes": [[["batch_normalization_3", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_11", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_11", "inbound_nodes": [[["batch_normalization_4", 0, 0, {}]]]}, {"class_name": "Activation", "config": {"name": "activation_14", "trainable": true, "dtype": "float32", "activation": "swish"}, "name": "activation_14", "inbound_nodes": [[["batch_normalization_5", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "a", "trainable": true, "dtype": "float32", "units": 7, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "a", "inbound_nodes": [[["activation_5", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "b", "trainable": true, "dtype": "float32", "units": 6, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "b", "inbound_nodes": [[["activation_8", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "d", "trainable": true, "dtype": "float32", "units": 12, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "d", "inbound_nodes": [[["activation_11", 0, 0, {}]]]}, {"class_name": "Dense", "config": {"name": "e", "trainable": true, "dtype": "float32", "units": 17, "activation": "linear", "use_bias": true, "kernel_initializer": {"class_name": "GlorotUniform", "config": {"seed": null}}, "bias_initializer": {"class_name": "Zeros", "config": {}}, "kernel_regularizer": null, "bias_regularizer": null, "activity_regularizer": null, "kernel_constraint": null, "bias_constraint": null}, "name": "e", "inbound_nodes": [[["activation_14", 0, 0, {}]]]}], "input_layers": [["input_1", 0, 0]], "output_layers": [["a", 0, 0], ["b", 0, 0], ["d", 0, 0], ["e", 0, 0]]}}, "training_config": {"loss": {"class_name": "MeanSquaredError", "config": {"reduction": "auto", "name": "mean_squared_error"}}, "metrics": [[{"class_name": "MeanSquaredError", "config": {"name": "a_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "a_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "b_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "b_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "d_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "d_mean_absolute_error", "dtype": "float32"}}], [{"class_name": "MeanSquaredError", "config": {"name": "e_mean_squared_error", "dtype": "float32"}}, {"class_name": "MeanAbsoluteError", "config": {"name": "e_mean_absolute_error", "dtype": "float32"}}]], "weighted_metrics": null, "loss_weights": null, "optimizer_config": {"class_name": "Adam", "config": {"name": "Adam", "learning_rate": 0.0010000000474974513, "decay": 0.0, "beta_1": 0.8999999761581421, "beta_2": 0.9990000128746033, "epsilon": 1e-07, "amsgrad": false}}}}, "weightsManifest": [{"paths": ["group1-shard1of1.bin"], "weights": [{"name": "a/kernel", "shape": [21, 7], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.6099746854061336, "scale": 2.0817538152490826e-05, "original_dtype": "float32"}}, {"name": "a/bias", "shape": [7], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.07667829096317291, "scale": 1.6423041900380977e-06, "original_dtype": "float32"}}, {"name": "abatch_meh/gamma", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.6084017157554626, "scale": 3.877299559728463e-05, "original_dtype": "float32"}}, {"name": "abatch_meh/beta", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.200300851993833, "scale": 4.989818549132542e-05, "original_dtype": "float32"}}, {"name": "abatch_meh/moving_mean", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -75.46424857270776, "scale": 0.002087877616553446, "original_dtype": "float32"}}, {"name": "abatch_meh/moving_variance", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 787.168701171875, "scale": 0.13356579872038796, "original_dtype": "float32"}}, {"name": "ameh1/kernel", "shape": [256, 56], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.176728742040976, "scale": 9.929225584312317e-05, "original_dtype": "float32"}}, {"name": "ameh1/bias", "shape": [56], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.5291196800418783, "scale": 7.24152150048247e-05, "original_dtype": "float32"}}, {"name": "ameh2/kernel", "shape": [56, 42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.361890890440589, "scale": 0.00011109984183899005, "original_dtype": "float32"}}, {"name": "ameh2/bias", "shape": [42], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.207757888386237e-05, "scale": 2.5320384678636703e-09, "original_dtype": "float32"}}, {"name": "ameh3/kernel", "shape": [42, 21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.6024897305727315, "scale": 0.00013602747836774734, "original_dtype": "float32"}}, {"name": "ameh3/bias", "shape": [21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.0007686309111201195, "scale": 2.5918226029138102e-08, "original_dtype": "float32"}}, {"name": "b/kernel", "shape": [18, 6], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.6074171671052815, "scale": 1.850020306110564e-05, "original_dtype": "float32"}}, {"name": "b/bias", "shape": [6], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.12006063759326935, "scale": 1.6289325948982823e-06, "original_dtype": "float32"}}, {"name": "batch_normalization/gamma", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.21359336376190186, "scale": 4.187887371782399e-05, "original_dtype": "float32"}}, {"name": "batch_normalization/beta", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.32022109180109, "scale": 9.88484465794859e-05, "original_dtype": "float32"}}, {"name": "batch_normalization/moving_mean", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1030.425259068091, "scale": 0.028215368539651998, "original_dtype": "float32"}}, {"name": "batch_normalization/moving_variance", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 49101.9296875, "scale": 4.5225844253070875, "original_dtype": "float32"}}, {"name": "batch_normalization_1/gamma", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.57792067527771, "scale": 3.881843009838716e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_1/beta", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.1706453072740073, "scale": 2.956921715771678e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_1/moving_mean", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -18.587520474682524, "scale": 0.0005649358845870319, "original_dtype": "float32"}}, {"name": "batch_normalization_1/moving_variance", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 82.62361145019531, "scale": 0.009532967524733324, "original_dtype": "float32"}}, {"name": "batch_normalization_2/gamma", "shape": [21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.07908507436513901, "scale": 3.9856973047832006e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_2/beta", "shape": [21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.3676720966656677, "scale": 2.117237792259188e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_2/moving_mean", "shape": [21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.999734168075594, "scale": 0.00014858934165702548, "original_dtype": "float32"}}, {"name": "batch_normalization_2/moving_variance", "shape": [21], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1.386210560798645, "scale": 0.0012360492978278274, "original_dtype": "float32"}}, {"name": "batch_normalization_3/gamma", "shape": [18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.2495303899049759, "scale": 3.085413518100761e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_3/beta", "shape": [18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.3401588201522827, "scale": 2.043601408900803e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_3/moving_mean", "shape": [18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.229630957717907, "scale": 0.00013293080902157818, "original_dtype": "float32"}}, {"name": "batch_normalization_3/moving_variance", "shape": [18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 9.915149688720703, "scale": 0.0013230136723779218, "original_dtype": "float32"}}, {"name": "batch_normalization_4/gamma", "shape": [132], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.010133973537040647, "scale": 3.5683005412114953e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_4/beta", "shape": [132], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.7263541412499916, "scale": 2.6466052541814097e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_4/moving_mean", "shape": [132], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -19.774061314035738, "scale": 0.0004328822529342324, "original_dtype": "float32"}}, {"name": "batch_normalization_4/moving_variance", "shape": [132], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 8.363266944885254, "scale": 0.06618213333417433, "original_dtype": "float32"}}, {"name": "batch_normalization_5/gamma", "shape": [85], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.0009723409893922508, "scale": 3.297058354273491e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_5/beta", "shape": [85], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.7931638281272846, "scale": 2.738490879852298e-05, "original_dtype": "float32"}}, {"name": "batch_normalization_5/moving_mean", "shape": [85], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -21.50277769269628, "scale": 0.0004042483398386276, "original_dtype": "float32"}}, {"name": "batch_normalization_5/moving_variance", "shape": [85], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 7.1942458152771, "scale": 0.07979695207423092, "original_dtype": "float32"}}, {"name": "bbatch_meh/gamma", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.6356751322746277, "scale": 2.9198518741264527e-05, "original_dtype": "float32"}}, {"name": "bbatch_meh/beta", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.9217852480216713, "scale": 4.477511283925153e-05, "original_dtype": "float32"}}, {"name": "bbatch_meh/moving_mean", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -77.24906041418977, "scale": 0.001919565152056004, "original_dtype": "float32"}}, {"name": "bbatch_meh/moving_variance", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 660.447265625, "scale": 0.1069255842536431, "original_dtype": "float32"}}, {"name": "bmeh1/kernel", "shape": [256, 48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.177920018608877, "scale": 0.0001148853329651014, "original_dtype": "float32"}}, {"name": "bmeh1/bias", "shape": [48], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.9360169892090269, "scale": 6.817681407222688e-05, "original_dtype": "float32"}}, {"name": "bmeh2/kernel", "shape": [48, 36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.3231844352331588, "scale": 9.295620797854989e-05, "original_dtype": "float32"}}, {"name": "bmeh2/bias", "shape": [36], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.00014129796158845667, "scale": 4.936863197947545e-09, "original_dtype": "float32"}}, {"name": "bmeh3/kernel", "shape": [36, 18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.7245773759851963, "scale": 9.180167051131806e-05, "original_dtype": "float32"}}, {"name": "bmeh3/bias", "shape": [18], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.002506664875911696, "scale": 7.465867091322996e-08, "original_dtype": "float32"}}, {"name": "d/kernel", "shape": [132, 12], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.4650324336504003, "scale": 1.7516005636762226e-05, "original_dtype": "float32"}}, {"name": "d/bias", "shape": [12], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.12015070021152496, "scale": 3.068094178232729e-06, "original_dtype": "float32"}}, {"name": "dbatch_meh/gamma", "shape": [168], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1.021308422088623, "scale": 3.659052334761669e-05, "original_dtype": "float32"}}, {"name": "dbatch_meh/beta", "shape": [168], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.676181895947342, "scale": 0.00013284363444322414, "original_dtype": "float32"}}, {"name": "dbatch_meh/moving_mean", "shape": [168], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -132.47513104071558, "scale": 0.003312623616331564, "original_dtype": "float32"}}, {"name": "dbatch_meh/moving_variance", "shape": [168], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 841.0660400390625, "scale": 0.4963363501939565, "original_dtype": "float32"}}, {"name": "dense/kernel", "shape": [1160, 256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.48871828680809, "scale": 0.00017716401300177818, "original_dtype": "float32"}}, {"name": "dense/bias", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -9.334180040896834, "scale": 0.00017120339026974624, "original_dtype": "float32"}}, {"name": "dense_1/kernel", "shape": [256, 256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.1832441429929235, "scale": 0.00012794360603721934, "original_dtype": "float32"}}, {"name": "dense_1/bias", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.416494639990371e-05, "scale": 1.2883681423902146e-09, "original_dtype": "float32"}}, {"name": "dense_2/kernel", "shape": [256, 256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -3.8776237173175763, "scale": 0.00037603022859945465, "original_dtype": "float32"}}, {"name": "dense_2/bias", "shape": [256], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.0008817885815921397, "scale": 2.251930897648287e-08, "original_dtype": "float32"}}, {"name": "dmeh1/kernel", "shape": [256, 192], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -8.014071733825874, "scale": 0.00017811027300424214, "original_dtype": "float32"}}, {"name": "dmeh1/bias", "shape": [192], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -2.5087519771785187, "scale": 8.056623453478013e-05, "original_dtype": "float32"}}, {"name": "dmeh2/kernel", "shape": [192, 168], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.900778076819154, "scale": 0.00014325058450231, "original_dtype": "float32"}}, {"name": "dmeh2/bias", "shape": [168], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -4.3332693242915714e-05, "scale": 1.48965908910295e-09, "original_dtype": "float32"}}, {"name": "dmeh3/kernel", "shape": [168, 132], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -7.512778839403244, "scale": 0.000183135773575878, "original_dtype": "float32"}}, {"name": "dmeh3/bias", "shape": [132], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.00011666176172813649, "scale": 6.056575730876155e-09, "original_dtype": "float32"}}, {"name": "e/kernel", "shape": [85, 17], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.4949539801076156, "scale": 1.7878055990883713e-05, "original_dtype": "float32"}}, {"name": "e/bias", "shape": [17], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 0.049219515174627304, "scale": 3.290175538937269e-06, "original_dtype": "float32"}}, {"name": "ebatch_meh/gamma", "shape": [136], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 1.0815798044204712, "scale": 3.634368453808359e-05, "original_dtype": "float32"}}, {"name": "ebatch_meh/beta", "shape": [136], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -2.512420627753776, "scale": 6.261016317169499e-05, "original_dtype": "float32"}}, {"name": "ebatch_meh/moving_mean", "shape": [136], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -113.08958926781133, "scale": 0.002771939537913901, "original_dtype": "float32"}}, {"name": "ebatch_meh/moving_variance", "shape": [136], "dtype": "float32", "quantization": {"dtype": "uint16", "min": 706.2515869140625, "scale": 0.20253489569922084, "original_dtype": "float32"}}, {"name": "emeh1/kernel", "shape": [256, 170], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.55177561287077, "scale": 0.00011997872653320015, "original_dtype": "float32"}}, {"name": "emeh1/bias", "shape": [170], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -1.9866501084998043, "scale": 7.872909996432608e-05, "original_dtype": "float32"}}, {"name": "emeh2/kernel", "shape": [170, 136], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -5.036934041049229, "scale": 0.00012763687608770822, "original_dtype": "float32"}}, {"name": "emeh2/bias", "shape": [136], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -2.640259440466685e-05, "scale": 9.151679169728544e-10, "original_dtype": "float32"}}, {"name": "emeh3/kernel", "shape": [136, 85], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -6.539839395491202, "scale": 0.00016140578003581623, "original_dtype": "float32"}}, {"name": "emeh3/bias", "shape": [85], "dtype": "float32", "quantization": {"dtype": "uint16", "min": -0.00013701628746833432, "scale": 3.5876590680614363e-09, "original_dtype": "float32"}}]}]}',ALL_AU_META_HIGH=a1_0x131724(900),ALL_AU_META_LITE='{"tris": [[[6, 7, 8, 9, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 33, 35, 46, 47, 50, 52, 53, 55, 56, 63, 65, 66, 68, 69, 70, 71, 100, 101, 104, 105, 107, 108, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 122, 123, 124, 128, 130, 133, 139, 143, 144, 145, 151, 153, 154, 155, 156, 157, 158, 159, 160, 161, 163, 168, 173, 188, 189, 190, 193, 221, 222, 223, 224, 225, 226, 228, 229, 230, 231, 232, 233, 243, 244, 245, 246, 247], [69, 60, 52, 89, 14, 1, 45, 46, 83, 84, 83, 46, 50, 46, 40, 17, 40, 46, 46, 50, 84, 85, 84, 50, 59, 60, 62, 69, 62, 60, 18, 31, 43, 44, 43, 31, 3, 57, 34, 35, 34, 57, 43, 44, 81, 82, 81, 44, 11, 12, 65, 66, 65, 12, 22, 62, 72, 69, 72, 62, 6, 5, 55, 56, 55, 5, 73, 71, 88, 87, 88, 71, 9, 64, 10, 63, 10, 64, 12, 90, 66, 89, 66, 90, 21, 73, 2, 68, 2, 73, 37, 42, 13, 80, 13, 42, 21, 74, 73, 71, 73, 74, 59, 8, 60, 38, 60, 8, 76, 19, 77, 20, 77, 19, 44, 45, 82, 83, 82, 45, 90, 39, 51, 79, 51, 39, 19, 33, 20, 23, 20, 33, 16, 28, 49, 61, 49, 28, 20, 23, 16, 28, 16, 23, 48, 42, 41, 37, 41, 42, 58, 4, 59, 8, 59, 4, 10, 63, 22, 62, 22, 63, 39, 49, 79, 15, 79, 49, 9, 11, 64, 65, 64, 11, 78, 16, 39, 49, 39, 16, 25, 27, 33, 32, 33, 27, 73, 47, 68, 0, 68, 47, 21, 34, 24, 25, 24, 34, 31, 30, 44, 45, 44, 30, 33, 32, 23, 26, 23, 32, 2, 3, 21, 34, 21, 3, 30, 17, 45, 46, 45, 17, 4, 58, 5, 56, 5, 58, 77, 20, 78, 16, 78, 20, 6, 55, 36, 67, 36, 55, 24, 25, 19, 33, 19, 25, 42, 43, 80, 81, 80, 43, 34, 35, 25, 27, 25, 35, 41, 37, 54, 15, 54, 37, 66, 89, 67, 1, 67, 89, 48, 18, 42, 43, 42, 18, 24, 19, 75, 76, 75, 19, 24, 75, 21, 74, 21, 75, 51, 7, 14, 1, 14, 7, 28, 29, 61, 53, 61, 29, 73, 88, 47, 70, 47, 88, 89, 90, 14, 51, 14, 90, 56, 58, 64, 63, 64, 58, 65, 66, 55, 67, 55, 66, 64, 65, 56, 55, 56, 65, 23, 26, 28, 29, 28, 26, 37, 13, 15, 79, 15, 13, 58, 59, 63, 62, 63, 59, 60, 38, 52, 86, 52, 38, 72, 69, 86, 52, 86, 69, 61, 53, 54, 80, 81, 36, 6, 36, 81, 13, 7, 79, 51, 79, 7, 81, 82, 6, 5, 6, 82, 82, 83, 5, 4, 5, 83, 83, 84, 4, 8, 4, 84, 8, 84, 38, 85, 38, 84, 71, 72, 87, 86, 87, 72, 74, 22, 71, 72, 71, 22, 74, 75, 22, 10, 22, 75, 75, 76, 10, 9, 10, 76, 77, 11, 76, 9, 76, 11, 11, 77, 12, 78, 12, 77, 12, 78, 90, 39, 90, 78, 38, 85, 86, 87, 86, 85, 85, 50, 87, 88, 87, 50, 70, 88, 40, 50, 40, 88, 49, 61, 15, 54, 15, 61, 7, 36, 1, 67, 1, 36, 13, 80, 7, 36, 7, 80]], [[6, 8, 9, 151, 168, 249, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 263, 265, 276, 277, 280, 282, 283, 285, 286, 293, 295, 296, 298, 299, 300, 301, 329, 330, 333, 334, 336, 337, 339, 340, 341, 342, 343, 345, 346, 347, 348, 349, 350, 351, 352, 353, 357, 359, 362, 368, 372, 373, 374, 380, 381, 382, 383, 384, 385, 386, 387, 388, 390, 398, 412, 413, 414, 417, 441, 442, 443, 444, 445, 446, 448, 449, 450, 451, 452, 453, 463, 464, 465, 466, 467], [61, 69, 54, 16, 89, 5, 47, 83, 48, 84, 48, 83, 52, 42, 48, 19, 48, 42, 48, 84, 52, 85, 52, 84, 60, 63, 61, 69, 61, 63, 20, 45, 33, 46, 33, 45, 2, 36, 3, 37, 3, 36, 45, 81, 46, 82, 46, 81, 13, 66, 14, 67, 14, 66, 24, 72, 63, 69, 63, 72, 8, 57, 7, 58, 7, 57, 73, 88, 71, 87, 71, 88, 11, 12, 65, 64, 65, 12, 14, 67, 90, 89, 90, 67, 23, 1, 73, 4, 73, 1, 39, 15, 44, 80, 44, 15, 23, 73, 74, 71, 74, 73, 60, 61, 10, 40, 10, 61, 76, 77, 21, 22, 21, 77, 46, 82, 47, 83, 47, 82, 90, 53, 41, 79, 41, 53, 21, 22, 35, 25, 35, 22, 18, 51, 30, 62, 30, 51, 22, 18, 25, 30, 25, 18, 50, 43, 44, 39, 44, 43, 59, 60, 6, 10, 6, 60, 12, 24, 64, 63, 64, 24, 41, 79, 51, 17, 51, 79, 11, 65, 13, 66, 13, 65, 78, 41, 18, 51, 18, 41, 27, 35, 29, 34, 29, 35, 73, 4, 49, 0, 49, 4, 23, 26, 36, 27, 36, 26, 33, 46, 32, 47, 32, 46, 35, 25, 34, 28, 34, 25, 1, 23, 2, 36, 2, 23, 32, 47, 19, 48, 19, 47, 6, 7, 59, 58, 59, 7, 77, 78, 22, 18, 22, 78, 8, 38, 57, 68, 57, 38, 26, 21, 27, 35, 27, 21, 44, 80, 45, 81, 45, 80, 36, 27, 37, 29, 37, 27, 43, 56, 39, 17, 39, 56, 67, 68, 89, 5, 89, 68, 50, 44, 20, 45, 20, 44, 26, 75, 21, 76, 21, 75, 26, 23, 75, 74, 75, 23, 53, 16, 9, 5, 9, 16, 30, 62, 31, 55, 31, 62, 73, 49, 88, 70, 88, 49, 89, 16, 90, 53, 90, 16, 58, 65, 59, 64, 59, 65, 66, 57, 67, 68, 67, 57, 65, 58, 66, 57, 66, 58, 25, 30, 28, 31, 28, 30, 39, 17, 15, 79, 15, 17, 59, 64, 60, 63, 60, 64, 61, 54, 40, 86, 40, 54, 72, 86, 69, 54, 69, 86, 62, 56, 55, 80, 38, 81, 8, 81, 38, 15, 79, 9, 53, 9, 79, 81, 8, 82, 7, 82, 8, 82, 7, 83, 6, 83, 7, 83, 6, 84, 10, 84, 6, 10, 40, 84, 85, 84, 40, 71, 87, 72, 86, 72, 87, 74, 71, 24, 72, 24, 71, 74, 24, 75, 12, 75, 24, 75, 12, 76, 11, 76, 12, 77, 76, 13, 11, 13, 76, 13, 14, 77, 78, 77, 14, 14, 90, 78, 41, 78, 90, 40, 86, 85, 87, 85, 86, 85, 87, 52, 88, 52, 87, 70, 42, 88, 52, 88, 42, 51, 17, 62, 56, 62, 17, 9, 5, 38, 68, 38, 5, 15, 9, 80, 38, 80, 9]], [[0, 2, 11, 12, 13, 14, 15, 16, 17, 18, 32, 36, 37, 38, 39, 40, 41, 42, 43, 57, 61, 62, 64, 72, 73, 74, 76, 77, 78, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 95, 96, 97, 98, 106, 129, 146, 164, 165, 167, 178, 179, 180, 181, 182, 183, 184, 185, 186, 191, 194, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 210, 211, 212, 214, 216, 240, 262, 266, 267, 268, 269, 270, 271, 272, 273, 287, 291, 292, 294, 302, 303, 304, 306, 307, 308, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 324, 325, 326, 327, 335, 358, 375, 391, 393, 402, 403, 404, 405, 406, 407, 408, 409, 410, 415, 418, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 434, 436, 460], [97, 129, 111, 28, 42, 61, 81, 0, 92, 12, 23, 0, 2, 92, 0, 2, 0, 23, 81, 92, 83, 12, 14, 23, 93, 83, 92, 24, 23, 14, 83, 93, 84, 14, 15, 24, 94, 84, 93, 25, 24, 15, 79, 140, 130, 10, 62, 74, 134, 130, 140, 68, 74, 62, 94, 126, 84, 25, 15, 58, 127, 84, 126, 59, 58, 15, 86, 98, 125, 17, 57, 29, 129, 125, 98, 61, 29, 57, 110, 84, 128, 41, 60, 15, 127, 128, 84, 59, 15, 60, 142, 141, 139, 76, 73, 75, 132, 139, 141, 66, 75, 73, 101, 102, 9, 32, 9, 33, 8, 9, 102, 8, 33, 9, 96, 117, 95, 27, 26, 48, 89, 95, 117, 20, 48, 26, 130, 134, 124, 62, 56, 68, 115, 124, 134, 46, 68, 56, 118, 133, 114, 50, 45, 67, 116, 114, 133, 47, 67, 45, 108, 109, 96, 39, 27, 40, 117, 96, 109, 48, 40, 27, 131, 101, 64, 65, 64, 32, 9, 64, 101, 9, 32, 64, 115, 109, 124, 46, 56, 40, 123, 124, 109, 55, 40, 56, 123, 109, 122, 55, 54, 40, 108, 122, 109, 39, 40, 54, 8, 102, 7, 8, 7, 33, 103, 7, 102, 34, 33, 7, 135, 80, 136, 69, 70, 11, 133, 136, 80, 67, 11, 70, 118, 83, 110, 50, 41, 14, 84, 110, 83, 15, 14, 41, 114, 144, 113, 45, 44, 78, 115, 87, 109, 46, 40, 18, 117, 109, 87, 48, 18, 40, 112, 90, 111, 43, 42, 21, 97, 111, 90, 28, 21, 42, 135, 136, 137, 69, 71, 70, 143, 137, 136, 77, 70, 71, 118, 119, 83, 50, 14, 51, 81, 83, 119, 12, 51, 14, 63, 138, 64, 63, 64, 72, 131, 64, 138, 65, 72, 64, 132, 141, 87, 66, 18, 75, 88, 87, 141, 19, 75, 18, 139, 132, 140, 73, 74, 66, 134, 140, 132, 68, 66, 74, 134, 132, 115, 68, 46, 66, 87, 115, 132, 18, 66, 46, 95, 90, 96, 26, 27, 21, 112, 96, 90, 43, 21, 27, 92, 82, 93, 23, 24, 13, 85, 93, 82, 16, 13, 24, 133, 80, 116, 67, 47, 11, 114, 91, 144, 45, 78, 22, 93, 85, 94, 24, 25, 16, 86, 94, 85, 17, 16, 25, 137, 143, 142, 71, 76, 77, 141, 142, 143, 75, 77, 76, 94, 86, 126, 25, 58, 17, 125, 126, 86, 57, 17, 58, 107, 108, 112, 38, 43, 39, 96, 112, 108, 27, 39, 43, 122, 108, 121, 54, 53, 39, 107, 121, 108, 38, 39, 53, 7, 103, 6, 7, 6, 34, 104, 6, 103, 35, 34, 6, 6, 104, 5, 6, 5, 35, 105, 5, 104, 36, 35, 5, 120, 121, 106, 52, 37, 53, 107, 106, 121, 38, 53, 37, 111, 106, 112, 42, 43, 37, 107, 112, 106, 38, 37, 43, 85, 99, 86, 16, 17, 30, 98, 86, 99, 29, 30, 17, 87, 88, 117, 18, 48, 19, 89, 117, 88, 20, 19, 48, 82, 100, 85, 13, 16, 31, 99, 85, 100, 30, 31, 16, 125, 129, 90, 57, 21, 61, 97, 90, 129, 28, 61, 21, 136, 110, 143, 70, 77, 41, 128, 143, 110, 60, 41, 77, 119, 113, 49, 51, 49, 44, 1, 49, 113, 1, 44, 49, 0, 81, 49, 0, 49, 12, 119, 49, 81, 51, 12, 49, 2, 3, 92, 2, 23, 3, 82, 92, 3, 13, 3, 23, 3, 4, 82, 3, 13, 4, 100, 82, 4, 31, 4, 13, 133, 118, 136, 67, 70, 50, 110, 136, 118, 41, 50, 70, 118, 114, 119, 50, 51, 45, 113, 119, 114, 44, 45, 51, 104, 121, 105, 35, 36, 53, 120, 105, 121, 52, 53, 36, 103, 122, 104, 34, 35, 54, 121, 104, 122, 53, 54, 35, 102, 123, 103, 33, 34, 55, 122, 103, 123, 54, 55, 34, 101, 124, 102, 32, 33, 56, 123, 102, 124, 55, 56, 33, 130, 124, 131, 62, 65, 56, 101, 131, 124, 32, 56, 65, 126, 125, 95, 58, 26, 57, 90, 95, 125, 21, 57, 26, 126, 95, 127, 58, 59, 26, 89, 127, 95, 20, 26, 59, 128, 127, 88, 60, 19, 59, 89, 88, 127, 20, 59, 19, 143, 128, 141, 77, 75, 60, 88, 141, 128, 19, 60, 75, 138, 79, 131, 72, 65, 10, 130, 131, 79, 62, 10, 65, 114, 116, 91, 45, 22, 47, 5, 105, 4, 5, 4, 36, 100, 4, 105, 31, 36, 4, 105, 120, 100, 36, 31, 52, 99, 100, 120, 30, 52, 31, 120, 106, 99, 52, 30, 37, 98, 99, 106, 29, 37, 30, 106, 111, 98, 37, 29, 42, 129, 98, 111, 61, 42, 29]]], "label_keys": [["browDown_L", "browDown_R", "cheekSquint_L", "cheekSquint_R", "browOuterUp_L", "browOuterUp_R", "browInnerUp"], ["eyeBlink_L", "eyeBlink_R", "eyeSquint_L", "eyeSquint_R", "eyeWide_L", "eyeWide_R"], ["mouthClose", "jawOpen", "mouthFunnel", "mouthPucker", "mouthRollLower", "mouthRollUpper", "mouthShrugLower", "mouthShrugUpper", "mouthLowerDown_L", "mouthLowerDown_R", "mouthUpperUp_L", "mouthUpperUp_R"], ["jawForward", "jawLeft", "jawRight", "noseSneer_L", "noseSneer_R", "mouthLeft", "mouthRight", "mouthSmile_L", "mouthSmile_R", "mouthFrown_L", "mouthFrown_R", "mouthDimple_L", "mouthDimple_R", "mouthStretch_L", "mouthStretch_R", "mouthPress_L", "mouthPress_R"]], "type": "dot_features_norm_no_iris_upper_lower_mouth_eye_features_tri", "data_min": [], "data_max": [], "data_means": [0.0009584624785929918, 0.0010070432908833027, 0.00561505788937211, 0.0026129777543246746, 0.03180234506726265, 0.010580021888017654, 0.027208315208554268, 0.015174049884080887, 0.019053246825933456, 0.021434327587485313, 0.023129519075155258, 0.017358053475618362, 0.021504685282707214, 0.012309825979173183, 0.01748153753578663, 0.016332970932126045, 0.007263301406055689, 0.019363461062312126, 0.018046963959932327, 0.008579800836741924, 0.09151671826839447, 0.03532027080655098, 0.0941653698682785, 0.03267161548137665, 0.19824782013893127, 0.14688214659690857, 0.1675434559583664, 0.17758649587631226, 0.0660620629787445, 0.010029759258031845, 0.05049744248390198, 0.025594374164938927, 0.013388559222221375, 0.020216817036271095, 0.012813664972782135, 0.020791713148355484, 0.005662212613970041, 0.02311328984797001, 0.012632292695343494, 0.016143208369612694, 0.0262139979749918, 0.01095395628362894, 0.024555042386054993, 0.012612915597856045, 0.03407197818160057, 0.029567919671535492, 0.02421543002128601, 0.03942446410655975, 0.022325247526168823, 0.024682793766260147, 0.026570377871394157, 0.020437659695744514, 0.015178601257503033, 0.014258328825235367, 0.01086408831179142, 0.018572842702269554, 0.050395336002111435, 0.07209660112857819, 0.0543065071105957, 0.06818541884422302, 0.03203488886356354, 0.036361970007419586, 0.017763681709766388, 0.050633177161216736, 0.055964384227991104, 0.06320002675056458, 0.07204209268093109, 0.047122325748205185, 0.007759011350572109, 0.007501004729419947, 0.005381112918257713, 0.009878900833427906, 0.04116656258702278, 0.03795693442225456, 0.021997306495904922, 0.057126183062791824, 0.0457286611199379, 0.012790507636964321, 0.04283333197236061, 0.015685833990573883, 0.007983056828379631, 0.01715342327952385, 0.0001388487871736288, 0.024997632950544357, 0.01792411133646965, 0.06537957489490509, 0.0016012341948226094, 0.08170245587825775, 0.022745070978999138, 0.06553371995687485, 0.0096671711653471, 0.07861161977052689, 0.01801632158458233, 0.05676553025841713, 0.002364120213314891, 0.0724177435040474, 0.16681423783302307, 0.020389752462506294, 0.10783695429563522, 0.0793670192360878, 0.010316131636500359, 0.017139554023742676, 0.00734533229842782, 0.0201103538274765, 0.016856234520673752, 0.019879693165421486, 0.01631445810198784, 0.020421473309397697, 0.016912968829274178, 0.03552190586924553, 0.0013489547418430448, 0.05108591914176941, 0.027389558032155037, 0.02548580802977085, 0.023887960240244865, 0.02898740954697132, 0.031152784824371338, 0.04223264753818512, 0.009229506365954876, 0.06415592133998871, 0.11480626463890076, 0.09074558317661285, 0.06654737889766693, 0.13900445401668549, 0.06196732074022293, 0.03686026856303215, 0.06424575299024582, 0.03458184748888016, 0.015535380691289902, 0.13692401349544525, 0.009726780466735363, 0.1427326202392578, 0.059599608182907104, 0.015147252939641476, 0.0530291311442852, 0.021717732772231102, 0.08841946721076965, 0.06840980798006058, 0.055165842175483704, 0.10166344046592712, 0.053360484540462494, 0.11954861134290695, 0.037103503942489624, 0.13580559194087982, 0.034810394048690796, 0.018781214952468872, 0.03361587971448898, 0.019975729286670685, 0.007251198869198561, 0.023421205580234528, 0.011118563823401928, 0.019553840160369873, 0.0357130765914917, 0.0331711508333683, 0.016715677455067635, 0.05216854438185692, 0.009014262817800045, 0.022483978420495987, 0.01571260765194893, 0.015785636380314827, 0.016640055924654007, 0.09721265733242035, -0.00042073571239598095, 0.11427345126867294, 0.04610998183488846, 0.02854100614786148, 0.03372888267040253, 0.04092211276292801, 0.15157905220985413, 0.11156394332647324, 0.12671184539794922, 0.13643115758895874, 0.04176277667284012, 0.08159783482551575, 0.05207235738635063, 0.07128825038671494, 0.0034653223119676113, 0.013019933365285397, 0.009557103738188744, 0.006928151473402977, 0.1444462388753891, 0.08576080948114395, 0.0763494074344635, 0.15385763347148895, 0.09526139497756958, 0.049970757216215134, 0.07605482637882233, 0.06917732208967209, 0.040304362773895264, 0.1658620834350586, 0.11258336156606674, 0.09358307719230652, 0.01204579696059227, 5.064598371973261e-05, 0.0057475995272397995, 0.006348843220621347, 0.07918871194124222, 0.05989256873726845, 0.06970753520727158, 0.0693737342953682, 0.0296676903963089, 0.05262714624404907, 0.038453031331300735, 0.043841809034347534, 0.011802580207586288, 0.0048634945414960384, 8.753117435844615e-05, 0.016578542068600655, 0.020046120509505272, 0.053619563579559326, 0.024722063913941383, 0.04894360899925232, 0.006824055220931768, 0.03101937659084797, 0.016941962763667107, 0.02090146765112877, 0.020358260720968246, 0.05029279738664627, 0.027824176475405693, 0.04282688349485397, 0.06812911480665207, 0.06166563555598259, 0.038949258625507355, 0.0908455029129982, 0.030823418870568275, 0.04373401030898094, 0.04018499329686165, 0.03437243402004242, 0.01560981385409832, 0.04182998836040497, 0.029431475326418877, 0.02800832875072956, 0.0049715787172317505, 0.0010853813728317618, 0.0017884960398077965, 0.00426846370100975, 0.004917975980788469, 0.008242158219218254, 0.00675099017098546, 0.006409144960343838, 0.11439801007509232, 0.0708015188574791, 0.020787399262189865, 0.013736214488744736, 0.015147298574447632, 0.01937631517648697, 0.02438150718808174, 0.020754879340529442, 0.02355070784687996, 0.021585674956440926, 0.03039160743355751, 0.008083038032054901, 0.0230221226811409, 0.015452520921826363, 0.03354590758681297, 0.0077066319063305855, 0.027673253789544106, 0.013579286634922028, 0.02557680942118168, 0.008482919074594975, 0.021638723090291023, 0.012421006336808205, 0.013443629257380962, 0.012055521830916405, 0.012470507994294167, 0.0130286430940032, 0.013020467944443226, 0.029497845098376274, 0.024993717670440674, 0.017524592578411102, 0.025103121995925903, 0.04234560579061508, 0.024430440738797188, 0.04301828891038895, 0.05709700658917427, 0.002964586950838566, 0.03635567054152489, 0.023705918341875076, 0.054073382169008255, 0.015899060294032097, 0.041219908744096756, 0.028752528131008148, 0.009372779168188572, 0.03327846899628639, 0.015318827703595161, 0.027332421392202377, 0.019466083496809006, 0.020176872611045837, 0.011795789003372192, 0.02784717082977295, 0.016592970117926598, 0.01821114681661129, 0.0011994709493592381, 0.03360464423894882, 0.017300834879279137, 0.00896559376269579, 0.014446187764406204, 0.011820241808891296, 0.015813909471035004, 0.019322317093610764, 0.010514000430703163, 0.024622224271297455, 0.041107531636953354, 0.038539379835128784, 0.03859834745526314, 0.041048564016819, 0.020250065252184868, 0.06527622789144516, 0.00219165813177824, 0.08333463221788406, 0.01176728680729866, 0.006148751359432936, 0.0063952491618692875, 0.011520789004862309, 0.010927334427833557, 0.02626844123005867, 0.009048189036548138, 0.028147585690021515, 0.003189746756106615, 0.001047678291797638, 0.002412316156551242, 0.00251014088280499, 0.010876696556806564, 0.03212699666619301, 0.015587999485433102, 0.027415689080953598, 0.021553292870521545, 0.019081899896264076, 0.017451027408242226, 0.023184167221188545, 0.012576878070831299, 0.021577639505267143, 0.01652698963880539, 0.017627527937293053, 0.01924513280391693, 0.007476259488612413, 0.008556446991860867, 0.018164945766329765, 0.03625088557600975, 0.09242618083953857, 0.033533915877342224, 0.095143161714077, 0.15025664865970612, 0.19932259619235992, 0.18025469779968262, 0.1693245768547058, 0.010089603252708912, 0.067097008228302, 0.025773154571652412, 0.051413461565971375, 0.02059110812842846, 0.013834694400429726, 0.021093230694532394, 0.01333257369697094, 0.02354457415640354, 0.005520888604223728, 0.01634461246430874, 0.012720850296318531, 0.010927006602287292, 0.026938797906041145, 0.01261371374130249, 0.025252094492316246, 0.029094919562339783, 0.034333735704422, 0.03931177407503128, 0.024116873741149902, 0.024822339415550232, 0.0223153755068779, 0.020639237016439438, 0.026498476043343544, 0.014609248377382755, 0.015299099497497082, 0.018758079037070274, 0.011150269769132137, 0.07315195351839066, 0.04974095895886421, 0.0686292052268982, 0.054263703525066376, 0.03522201627492905, 0.032127756625413895, 0.049603421241045, 0.017746344208717346, 0.06473400443792343, 0.05677974969148636, 0.048350632190704346, 0.07316312193870544, 0.007188798859715462, 0.007735166233032942, 0.009540391154587269, 0.0053835720755159855, 0.03764266148209572, 0.04062659665942192, 0.05644158273935318, 0.021827679127454758, 0.012895357795059681, 0.046591758728027344, 0.015888530761003494, 0.043598588556051254, 0.017102740705013275, 0.0080290287733078, 0.02491878718137741, 0.00021298231149557978, 0.06472694873809814, 0.018105728551745415, 0.08136855065822601, 0.0014641237212345004, 0.06540029495954514, 0.023037368431687355, 0.07821951061487198, 0.010218163020908833, 0.056045565754175186, 0.017681453377008438, 0.07130908221006393, 0.0024179299362003803, 0.021195458248257637, 0.1665366142988205, 0.08005531132221222, 0.10767676681280136, 0.017210761085152626, 0.010162414982914925, 0.02012740820646286, 0.0072457692585885525, 0.01963777467608452, 0.01670161262154579, 0.020161297172307968, 0.01617809571325779, 0.03517119958996773, 0.01748495176434517, 0.05088501796126366, 0.0017711336258798838, 0.025902649387717247, 0.028176549822092056, 0.02947438322007656, 0.024604814127087593, 0.04187890142202377, 0.03176398575305939, 0.06394246965646744, 0.009700409136712551, 0.09019935876131058, 0.11635902523994446, 0.13888733088970184, 0.06767105311155319, 0.037246719002723694, 0.06175660341978073, 0.03479745611548424, 0.06420587748289108, 0.1381712406873703, 0.014585934579372406, 0.1431790292263031, 0.009578125551342964, 0.015641242265701294, 0.06039672717452049, 0.022193705663084984, 0.05384426563978195, 0.06801073998212814, 0.0897948294878006, 0.10126852989196777, 0.05653705075383186, 0.12121204286813736, 0.052906885743141174, 0.1375453621149063, 0.03657355159521103, 0.019182659685611725, 0.0351303294301033, 0.020298253744840622, 0.034014735370874405, 0.023697182536125183, 0.006918806117027998, 0.019837481901049614, 0.010778509080410004, 0.03319263830780983, 0.03562372177839279, 0.05193181335926056, 0.016884544864296913, 0.02264363318681717, 0.008681918494403362, 0.01594884693622589, 0.015376707538962364, 0.09719572961330414, 0.016590096056461334, 0.11399760842323303, -0.00021180477051530033, 0.027895493432879448, 0.047106485813856125, 0.04042673483490944, 0.034575242549180984, 0.11196717619895935, 0.1533479392528534, 0.1370055079460144, 0.12830962240695953, 0.08240267634391785, 0.04252122715115547, 0.07165717333555222, 0.053266722708940506, 0.01277428213506937, 0.00353052606806159, 0.006763224955648184, 0.009541581384837627, 0.08542919903993607, 0.1457022726535797, 0.15400540828704834, 0.07712607085704803, 0.04989008978009224, 0.0959622710943222, 0.06930959224700928, 0.07654276490211487, 0.16842858493328094, 0.03971026837825775, 0.09518996626138687, 0.11294887959957123, -3.1399158615386114e-05, 0.012013934552669525, 0.006212912499904633, 0.005769622046500444, 0.05893167853355408, 0.0803028792142868, 0.06843945384025574, 0.07079508900642395, 0.05311926454305649, 0.02992238849401474, 0.044531743973493576, 0.038509905338287354, 0.004900534171611071, 0.01187540590763092, 0.01663953997194767, 0.00013639865210279822, 0.0528947077691555, 0.020423905923962593, 0.04845243692398071, 0.024866178631782532, 0.030551737174391747, 0.006982103455811739, 0.020579732954502106, 0.01695410907268524, 0.04955659806728363, 0.020606623962521553, 0.04210541024804115, 0.02805781178176403, 0.06058310717344284, 0.06956096738576889, 0.09050605446100235, 0.03963801637291908, 0.044286422431468964, 0.030812732875347137, 0.03472260758280754, 0.04037655144929886, 0.041398532688617706, 0.01574314758181572, 0.027675652876496315, 0.02946602739393711, 0.0010518224444240332, 0.005036170594394207, 0.004156096838414669, 0.0019318965496495366, 0.008338944986462593, 0.0049943700432777405, 0.006442762911319733, 0.006890552118420601, 0.07090817391872406, 0.11592648178339005, 0.012915708124637604, 0.021528594195842743, 0.01876692846417427, 0.015677371993660927, 0.021062389016151428, 0.024030504748225212, 0.02172125317156315, 0.023371640592813492, 0.007864276878535748, 0.03158018738031387, 0.015553937293589115, 0.023890526965260506, 0.00788877159357071, 0.03452903404831886, 0.013775202445685863, 0.028642605990171432, 0.008731149137020111, 0.025845520198345184, 0.012492726556956768, 0.022083943709731102, 0.011747396551072598, 0.013323877938091755, 0.012793575413525105, 0.012277700006961823, 0.029758449643850327, 0.013404075056314468, 0.017863111570477486, 0.02529941312968731, 0.043395426124334335, 0.02519271709024906, 0.04389430209994316, 0.024693841114640236, 0.002487616613507271, 0.058051180094480515, 0.023873046040534973, 0.03666575253009796, 0.016282064840197563, 0.05492701008915901, 0.02919151447713375, 0.042017560452222824, 0.033046647906303406, 0.009194583632051945, 0.027417104691267014, 0.014824125915765762, 0.020230920985341072, 0.01949259452521801, 0.027841465547680855, 0.01188204251229763, 0.01780499704182148, 0.016780059784650803, 0.033200085163116455, 0.0013849688693881035, 0.008716283366084099, 0.0171784870326519, 0.011522030457854271, 0.01437273807823658, 0.019000761210918427, 0.015753036364912987, 0.024310650303959846, 0.010443147271871567, 0.03801502287387848, 0.041074130684137344, 0.0406385138630867, 0.038450632244348526, 0.06523336470127106, 0.021197663620114326, 0.08364110440015793, 0.0027899143751710653, 0.00596371665596962, 0.011900968849658966, 0.01132891420274973, 0.006535771768540144, 0.025395188480615616, 0.010891971178352833, 0.02721889689564705, 0.009068263694643974, 0.005885453894734383, 0.0054228948429226875, 0.005574987269937992, 0.005757585167884827, 0.02890717424452305, 0.005003248807042837, 0.005023003555834293, 0.028751889243721962, 0.02841075323522091, 0.005499669816344976, 0.005609978921711445, 0.028164919465780258, 0.004022703506052494, 0.03839637711644173, 0.03788066655397415, 0.004002286586910486, 0.009675349108874798, 0.03274373337626457, 0.032409556210041046, 0.00947339367121458, 0.005360433366149664, 0.027826568111777306, 0.027799731120467186, 0.005095434375107288, 0.006560017820447683, 0.026626983657479286, 0.02638670988380909, 0.006508455611765385, 0.06350692361593246, 0.023178592324256897, 0.023110024631023407, 0.0635368749499321, 0.05302991345524788, 0.03365560993552208, 0.03351029008626938, 0.053136613219976425, 0.02166939340531826, 0.0014093514764681458, 0.0013514403253793716, 0.021760348230600357, 0.02303030714392662, 4.8440502723678946e-05, 6.647076952503994e-05, 0.023045316338539124, 0.0018620425835251808, 0.01770467683672905, 0.01757699064910412, 0.0019222425762563944, 0.0033565135672688484, 0.01621020957827568, 0.016202935948967934, 0.0032962963450700045, 0.03636700659990311, 0.0316324457526207, 0.031528618186712265, 0.03634941577911377, 0.03428526967763901, 0.0337141752243042, 0.0336156003177166, 0.034262433648109436, 0.02603255771100521, 0.08683351427316666, 0.08607469499111176, 0.025721756741404533, 0.05249905586242676, 0.06036701425909996, 0.05943998694419861, 0.052356451749801636, 0.03646713122725487, 0.035266466438770294, 0.035771239548921585, 0.03638780489563942, 0.037209950387477875, 0.03452363982796669, 0.03482655808329582, 0.03733248636126518, -0.0002757781185209751, 0.0109507255256176, 0.010928465984761715, -0.00032790936529636383, -0.0018051794031634927, 0.012480128556489944, 0.012420364655554295, -0.0018198058241978288, 0.04993613436818123, 0.029402825981378555, 0.029640506953001022, 0.05021069198846817, 0.04305045306682587, 0.03628851845860481, 0.03647952899336815, 0.043371666222810745, 0.0501881018280983, 0.005071873310953379, 0.00533944321796298, 0.04992153123021126, 0.03345107659697533, 0.021808896213769913, 0.0218220092356205, 0.033438969403505325, 0.0020475040655583143, 0.01665797457098961, 0.016705896705389023, 0.001984044909477234, -0.0007108051795512438, 0.01941628009080887, 0.019466400146484375, -0.0007764579495415092, 0.01718723401427269, 0.046921566128730774, 0.046952616423368454, 0.01680903695523739, 0.026005148887634277, 0.03810364753007889, 0.03810646012425423, 0.025655193254351616, 0.02122175507247448, 0.03213158994913101, 0.031721025705337524, 0.020796164870262146, 0.026631057262420654, 0.026722287759184837, 0.026339052245020866, 0.026178138330578804, 0.025202926248311996, 0.00400166492909193, 0.0040250071324408054, 0.025163402780890465, 0.023121457546949387, 0.0060831340961158276, 0.00614088773727417, 0.023047523573040962, 0.032835137099027634, 0.007676077075302601, 0.007502107415348291, 0.032841552048921585, 0.03135661408305168, 0.009154606610536575, 0.009135511703789234, 0.03120815008878708, 0.06754796952009201, 0.05221839249134064, 0.05170522630214691, 0.06815771013498306, 0.05621564760804176, 0.06355070322751999, 0.06337576359510422, 0.05648715794086456, 0.05275442451238632, 0.02998337708413601, 0.029943551868200302, 0.052415672689676285, 0.0471675731241703, 0.03557022660970688, 0.03534575179219246, 0.04701347276568413, -0.010977497324347496, 0.050810106098651886, 0.05046600475907326, -0.010850799269974232, 0.031163765117526054, 0.02661798894405365, 0.026900576427578926, 0.03143700957298279, 0.030816037207841873, 0.02696571871638298, 0.02708219178020954, 0.031255390495061874, 0.011860005557537079, 0.002034959848970175, 0.0020777415484189987, 0.011862294748425484, 0.012294488959014416, 0.001600475749000907, 0.0015799064422026277, 0.012360128574073315, 0.04621139541268349, 0.06659480184316635, 0.0668988898396492, 0.04529530182480812, 0.05774557963013649, 0.055060598999261856, 0.055333755910396576, 0.05686045065522194, 0.06291753053665161, 0.025610987097024918, 0.026066213846206665, 0.06281393021345139, 0.04662888124585152, 0.04189964011311531, 0.04235084354877472, 0.04652930423617363, 0.07389014214277267, 0.028019752353429794, 0.02825934812426567, 0.07388510555028915, 0.06283166259527206, 0.039078239351511, 0.039033193141222, 0.06311126053333282, 0.05160742625594139, 0.0267635527998209, 0.02726048044860363, 0.05158013105392456, 0.04642927274107933, 0.03194170817732811, 0.03218497335910797, 0.04665563255548477, 0.03325378894805908, 0.05761918053030968, 0.057019222527742386, 0.03293166309595108, 0.035597898066043854, 0.05527506396174431, 0.05488429218530655, 0.03506658226251602, 0.04883366450667381, 0.028310345485806465, 0.02860073745250702, 0.04922343045473099, 0.041031040251255035, 0.03611297160387039, 0.03647473827004433, 0.04134942218661308, -0.0014812566805630922, 0.010813038796186447, 0.010801656171679497, -0.0015018400736153126, -0.00013526449038181454, 0.009467046707868576, 0.00939848180860281, -9.866552863968536e-05, 0.0032999105751514435, 0.02620586007833481, 0.02596632018685341, 0.0031941451597958803, 0.006410648580640554, 0.02309512533247471, 0.022840628400444984, 0.006319834850728512, 0.03457927703857422, 0.016057437285780907, 0.015435897745192051, 0.03370242938399315, 0.01257686410099268, 0.0005941065610386431, 0.0005570741486735642, 0.012616035528481007, 0.0035972348414361477, 0.0229113157838583, 0.02259695902466774, 0.0034995581954717636, 0.004937628284096718, 0.021570926532149315, 0.02130502089858055, 0.004791495390236378, 0.02415172941982746, 0.1815473735332489, 0.18159063160419464, 0.023847796022892, 0.07796955108642578, 0.12772957980632782, 0.12746043503284454, 0.0779779702425003, 0.0033393865451216698, 0.023043733090162277, 0.02318986877799034, 0.0032425702083855867, 0.00563826272264123, 0.02074485644698143, 0.020650634542107582, 0.005781804211437702, 0.0033272167202085257, 0.012992696836590767, 0.013114207424223423, 0.0033701101783663034, -0.0003833834489341825, 0.016703296452760696, 0.016810836270451546, -0.00032651846413500607, 0.018602682277560234, 0.002742969198152423, 0.002836626023054123, 0.0185400303453207, 0.01726001501083374, 0.004085636232048273, 0.004149062093347311, 0.017227593809366226, 0.02894480712711811, 0.0055397492833435535, 0.005638373550027609, 0.028890712186694145, 0.026413876563310623, 0.008070678450167179, 0.007992072030901909, 0.026537014171481133, 0.02460050769150257, 0.003218489931896329, 0.003222785657271743, 0.024727094918489456, 0.022859511896967888, 0.004959487821906805, 0.005032500252127647, 0.022917380556464195, 0.0025244655553251505, 0.015221891924738884, 0.014963808469474316, 0.0025685701984912157, 0.0013849899405613542, 0.01636136882007122, 0.01620597019791603, 0.001326410099864006, 0.010839248076081276, 0.0022033562418073416, 0.0022428384982049465, 0.011020133271813393, 0.012255043722689152, 0.0007875615265220404, 0.0008589223143644631, 0.012404047884047031, 0.0009708598372526467, 0.01784399338066578, 0.01775168813765049, 0.0010606428841128945, 0.002536135958507657, 0.016278717666864395, 0.016183776780962944, 0.0026285548228770494, 0.03594512119889259, 0.0190235935151577, 0.019178375601768494, 0.03621656820178032, 0.02550216019153595, 0.029466552659869194, 0.02975623682141304, 0.02563871443271637, 0.0024548270739614964, 0.019185489043593407, 0.019094014540314674, 0.0025419818703085184, 0.0041571566835045815, 0.01748315989971161, 0.01746705174446106, 0.004168943967670202, 0.0028575921896845102, 0.012579746544361115, 0.01249763835221529, 0.002832249039784074, 0.0021403837017714977, 0.01329695526510477, 0.013146352022886276, 0.0021835342049598694, 0.04091670736670494, 0.0363510437309742, 0.03658076003193855, 0.041083838790655136, 0.03681156411767006, 0.04045617952942848, 0.04061256721615791, 0.037052031606435776, 0.009813188575208187, 0.031673695892095566, 0.03110058233141899, 0.009862997569143772, 0.011644204147160053, 0.02984267845749855, 0.029404066503047943, 0.011559509672224522, 0.02586270123720169, 0.048224180936813354, 0.04866808280348778, 0.026108378544449806, 0.0367041751742363, 0.037382714450359344, 0.03794226422905922, 0.036834198981523514, 0.005035281181335449, 0.028216466307640076, 0.027931049466133118, 0.005106007680296898, 0.008300041779875755, 0.02495170384645462, 0.024808544665575027, 0.008228513412177563, 0.0028414654079824686, 0.022080281749367714, 0.02223893441259861, 0.0030836700461804867, 0.005222175270318985, 0.019699575379490852, 0.01992814801633358, 0.005394455976784229, 0.07707154750823975, 0.0213310569524765, 0.021293269470334053, 0.0774119570851326, 0.06386612355709076, 0.03453648090362549, 0.03457747772336006, 0.06412775814533234, 0.0224266666918993, 0.06177789717912674, 0.06093547120690346, 0.023190302774310112, 0.01488575804978609, 0.06931880861520767, 0.0689135193824768, 0.01521222572773695, 0.02058957889676094, 0.0025650118477642536, 0.00264900759793818, 0.020495131611824036, 0.0194379985332489, 0.0037165924441069365, 0.003712523030117154, 0.019431615248322487, 0.023611566051840782, 0.0038703985046595335, 0.0038902158848941326, 0.02359255589544773, 0.02205014042556286, 0.00543182622641325, 0.005516957025974989, 0.021965812891721725, 0.02932065911591053, 0.005788552574813366, 0.005839203018695116, 0.029211916029453278, 0.02777433767914772, 0.0073348721489310265, 0.007345658726990223, 0.02770545892417431, 0.03813246265053749, 0.03281630948185921, 0.03254169598221779, 0.038419581949710846, 0.037398938089609146, 0.03354983776807785, 0.033561866730451584, 0.03739940747618675, 0.020764091983437538, 0.05284073203802109, 0.052730362862348557, 0.020392371341586113, 0.027968278154730797, 0.04563654586672783, 0.04563106968998909, 0.027491668239235878, 0.003587540704756975, 0.015605240128934383, 0.01563517190515995, 0.0037281657569110394, 0.004649173468351364, 0.014543607831001282, 0.01455957256257534, 0.004803764168173075, 0.013164635747671127, 0.0012220651842653751, 0.001275696326047182, 0.01318086963146925, 0.016515467315912247, -0.002128767780959606, -0.0020458644721657038, 0.01650243066251278, 0.021150927990674973, 0.03208109736442566, 0.03199780732393265, 0.021062655374407768, 0.026418741792440414, 0.026813281700015068, 0.026625534519553185, 0.02643493190407753, 0.013586469925940037, 0.07683483511209488, 0.07664096355438232, 0.013630985282361507, 0.037456393241882324, 0.05296491086483002, 0.0529322549700737, 0.03733968734741211, 0.07388583570718765, 0.023125478997826576, 0.02316446416079998, 0.07409963011741638, 0.06479888409376144, 0.03221243619918823, 0.03208654746413231, 0.0651775598526001, 0.029349476099014282, 0.009595082141458988, 0.009606669656932354, 0.02913002483546734, 0.020677318796515465, 0.05212793126702309, 0.051827386021614075, 0.020386960357427597, 0.020626911893486977, 0.05217834189534187, 0.051684122532606125, 0.020530223846435547, 0.017139526084065437, 0.04883945360779762, 0.048462361097335815, 0.017079805955290794, 0.021977834403514862, 0.04400114715099335, 0.043872442096471786, 0.021669724956154823, 0.014090077951550484, 0.03774363547563553, 0.03770215064287186, 0.013648035004734993, 0.021229658275842667, 0.030604055151343346, 0.030437707901000977, 0.020912474021315575, 0.009046846069395542, 0.02356758527457714, 0.023380117490887642, 0.00901411660015583, 0.017866218462586403, 0.014748211950063705, 0.014626993797719479, 0.017767243087291718], "data_vars": [5.339471726983902e-07, 1.0307996234359962e-07, 1.26115037346608e-06, 2.386340383964125e-06, 2.9954388082842343e-05, 6.357935490086675e-06, 1.9627850633696653e-05, 7.6134110713610426e-06, 8.97258723853156e-06, 1.5318291843868792e-05, 1.5571380572509952e-05, 8.785131285549141e-06, 1.3617334843729623e-05, 5.164934464119142e-06, 9.32976217882242e-06, 7.902936886239331e-06, 4.997736141376663e-06, 6.60526129649952e-05, 3.537176235113293e-05, 1.1856940545840189e-05, 0.00022829818772152066, 7.924408419057727e-05, 0.00016681707347743213, 2.8484722861321643e-05, 0.003092251718044281, 0.0009263755055144429, 0.0024961286690086126, 0.0011078238021582365, 8.693015843164176e-05, 2.3594233425683342e-05, 4.535955667961389e-05, 1.8810880646924488e-05, 1.0703782209020574e-05, 0.00018983187328558415, 6.595052127522649e-06, 0.00013729541387874633, 2.009636773436796e-05, 3.944470881833695e-05, 8.817787602311e-06, 1.686139512457885e-05, 1.6497513570357114e-05, 5.966903700027615e-06, 1.5199826520984061e-05, 5.170092208572896e-06, 7.504005770897493e-05, 7.579872180940583e-05, 2.341326944588218e-05, 4.1173545469064265e-05, 0.00023085300927050412, 2.179864895879291e-05, 0.0002099464909406379, 1.4605384421884082e-05, 1.1845731023640838e-05, 6.835807289462537e-05, 3.901034233422251e-06, 3.98140364268329e-05, 0.00025921579799614847, 0.0001825896615628153, 0.00023648107890039682, 0.00013593139010481536, 3.4907159715658054e-05, 3.388454206287861e-05, 1.1770227501983754e-05, 5.333644003258087e-05, 0.00033793176407925785, 0.00038753831177018583, 0.0001652137580094859, 0.00010718466364778578, 2.3263669390871655e-06, 4.642587555281352e-06, 1.9181256902811583e-06, 4.915379577141721e-06, 0.0001428022515028715, 3.2106352591654286e-05, 0.00011494761565700173, 5.817900091642514e-05, 4.539143628790043e-05, 8.435114068561234e-06, 3.458294304437004e-05, 6.916564416314941e-06, 4.807743152923649e-06, 1.3158594811102375e-05, 5.014738690078957e-06, 2.7017786123906262e-05, 1.7176887922687456e-05, 5.903050987399183e-05, 1.559161137265619e-05, 0.00010063863010145724, 2.3609813069924712e-05, 0.0001404913200531155, 2.056349148915615e-05, 0.0001773668482201174, 2.7743521059164777e-05, 3.8985370338195935e-05, 2.3982496713870205e-05, 6.953470438020304e-05, 0.0008761662757024169, 0.0001267491898033768, 0.0002760574279818684, 0.000106927560409531, 2.617656264192192e-06, 7.007308795436984e-06, 2.208859086749726e-06, 1.020562103803968e-05, 0.00013550715812016279, 3.316766378702596e-05, 8.19336564745754e-05, 1.859996518760454e-05, 1.601444455445744e-05, 5.401159432949498e-05, 8.95907032827381e-06, 0.000120900287583936, 2.3000147848506458e-05, 0.00029302662005648017, 1.661068745306693e-05, 0.00030591170070692897, 9.396838868269697e-05, 5.5984837672440335e-05, 3.0237053579185158e-05, 0.00014935039507690817, 0.0012065068585798144, 0.0002564573078416288, 0.0007396160508506, 0.000507824239321053, 0.00017627057968638837, 5.194248296902515e-05, 0.00019475765293464065, 2.9068189178360626e-05, 3.3988060749834403e-05, 0.0005500542465597391, 1.4063813978282269e-05, 0.0005427420837804675, 7.990156154846773e-05, 1.2508435247582383e-05, 5.6239532568724826e-05, 1.315402096224716e-05, 0.0007000158075243235, 0.00011491913755889982, 0.0004734531103167683, 0.0002777900081127882, 8.497729140799493e-05, 0.0005325073725543916, 5.4575659305555746e-05, 0.0006970558315515518, 3.0297485864139162e-05, 1.106584841181757e-05, 2.892175871238578e-05, 9.670769941294566e-06, 2.1843188733328134e-06, 9.972275620384607e-06, 3.5535992992663523e-06, 7.003615792200435e-06, 0.00012718614016193897, 2.1346131688915193e-05, 9.397634858032688e-05, 5.2645256801042706e-05, 5.189589955989504e-06, 1.7297157683060504e-05, 9.264905202144291e-06, 9.248475180356763e-06, 1.8295020709047094e-05, 0.00020150317868683487, 1.1790296412073076e-05, 0.0002721990749705583, 3.629479033406824e-05, 3.9438022213289514e-05, 2.0190263967378996e-05, 5.234523632680066e-05, 0.002315798308700323, 0.0005255487631075084, 0.0017152737127617002, 0.0006335361395031214, 7.689293852308765e-05, 0.0001910604041768238, 6.269967707339674e-05, 0.00011766421084757894, 2.2986280328041175e-06, 3.631356230471283e-05, 5.925298864895012e-06, 1.0488174666534178e-05, 0.000590055191423744, 0.0002761102223303169, 0.00011898963566636667, 0.0003839934361167252, 0.0002221450413344428, 0.000256335741141811, 0.0001485140819568187, 0.0002800534130074084, 0.00013493977894540876, 0.0007362337200902402, 0.0004501925141084939, 0.00024544421466998756, 6.601310360565549e-06, 1.5482263506783056e-06, 3.0824560326436767e-06, 3.097056833212264e-06, 0.00036895027733407915, 0.00013028043031226844, 0.0003524291096255183, 0.00017893491894938052, 5.572280861088075e-05, 8.318486652569845e-05, 5.996014442644082e-05, 5.1891729526687413e-05, 2.2803860701969825e-05, 2.1511843897314975e-06, 3.058362153751659e-06, 1.2175853044027463e-05, 2.5624289264669642e-05, 0.0004943641251884401, 4.715563409263268e-05, 0.0003912097599823028, 8.980783604783937e-06, 0.00018343949341215193, 1.6803898688522168e-05, 8.6967833340168e-05, 3.081850445596501e-05, 0.0004281283472664654, 4.166453072684817e-05, 0.0003371997154317796, 0.0003483959590084851, 8.421517122769728e-05, 0.00021387498418334872, 0.0002644033229444176, 5.751719800173305e-05, 5.652706022374332e-05, 4.3793344957521185e-05, 3.028929313586559e-05, 2.2703135982737876e-05, 0.0003146201779600233, 7.872438436606899e-05, 0.00014197341806720942, 9.864589856078965e-07, 4.889377009931195e-07, 7.182078434198047e-07, 2.0284710444684606e-06, 2.3586617317050695e-06, 6.9051229729666375e-06, 1.4292193100118311e-06, 3.0697578949911986e-06, 0.00047801650362089276, 0.00017434947949368507, 9.419650268682744e-06, 1.6317306290147826e-05, 5.582439825957408e-06, 2.1793168343720026e-05, 2.9128064852557145e-05, 1.6426987713202834e-05, 1.744684050208889e-05, 1.155661084339954e-05, 1.7585305613465607e-05, 1.1479922250146046e-05, 9.348799721919931e-06, 1.1180415640410502e-05, 2.2477399397757836e-05, 8.60706131788902e-06, 1.4323951290862169e-05, 5.655125278281048e-06, 1.8365235519013368e-05, 4.402026661409764e-06, 1.2736490134557243e-05, 4.080222424818203e-06, 5.544946816371521e-06, 5.229740963841323e-06, 6.484339337475831e-06, 4.58053000329528e-06, 1.4055100109544583e-05, 2.2858059310237877e-05, 1.6393991245422512e-05, 1.22332758110133e-05, 5.8673147577792406e-05, 5.9761296142823994e-05, 2.442411641823128e-05, 6.142393976915628e-05, 0.00013384433987084776, 2.565453905845061e-05, 5.6817574659362435e-05, 5.9890950069529936e-05, 7.935538451420143e-05, 5.4284562793327495e-05, 5.249865716905333e-05, 6.207748810993508e-05, 2.073114228551276e-05, 2.0126011804677546e-05, 2.1313784600351937e-05, 1.451853404432768e-05, 2.8675285648205318e-05, 6.6730108301271684e-06, 2.4220194973167963e-05, 1.1048656233469956e-05, 1.9325423636473715e-05, 7.081286639731843e-06, 6.204327291925438e-06, 2.260140172438696e-05, 9.461315130465664e-06, 5.590543878497556e-06, 1.0471171663084533e-05, 6.837932232883759e-06, 7.481475677195704e-06, 6.164016667753458e-06, 8.316515959450044e-06, 8.609632459410932e-06, 3.666979682748206e-05, 1.8399179680272937e-05, 3.485421621007845e-05, 2.0353712898213416e-05, 1.5415525922435336e-05, 0.00016653124475851655, 1.7831882360042073e-05, 0.00023260530724655837, 5.5297605285886675e-06, 3.3190021895279642e-06, 2.6304171569790924e-06, 5.439733740786323e-06, 5.865151251782663e-06, 2.6468329451745376e-05, 6.065211891836952e-06, 2.484555443516001e-05, 1.5917236169116222e-06, 1.0177103604291915e-07, 5.999109475851583e-07, 2.3223456082632765e-06, 6.494849458249519e-06, 3.0323511964525096e-05, 8.013011211005505e-06, 1.9777162378886715e-05, 1.6899635738809593e-05, 9.515288184047677e-06, 9.355171641800553e-06, 1.674672785156872e-05, 5.3662151913158596e-06, 1.3874386240786407e-05, 8.250160135503393e-06, 9.252091331291012e-06, 6.507631769636646e-05, 5.230781425780151e-06, 1.1506783266668208e-05, 3.574077345547266e-05, 7.52280539018102e-05, 0.0002267898089485243, 3.068911246373318e-05, 0.00016579889052081853, 0.0009007648332044482, 0.0029540415853261948, 0.0010663717985153198, 0.002413744805380702, 2.319840496056713e-05, 8.569993224227801e-05, 1.784108826541342e-05, 4.3856554839294404e-05, 0.00019668843015097082, 9.75241982814623e-06, 0.00014196612755768, 6.1445648498192895e-06, 4.071030343766324e-05, 2.032967677223496e-05, 1.7188363926834427e-05, 8.846054697642103e-06, 6.030089934938587e-06, 1.61248190124752e-05, 5.190496267459821e-06, 1.4966636626922991e-05, 7.659417315153405e-05, 8.422042446909472e-05, 4.1391376726096496e-05, 2.5046767405001447e-05, 2.3463571778847836e-05, 0.00023769712424837053, 1.5520585293415934e-05, 0.0002128564810846001, 7.009634282439947e-05, 1.1848454960272647e-05, 4.026897659059614e-05, 4.140718374401331e-06, 0.00019482933566905558, 0.0002654529525898397, 0.0001426533708581701, 0.00024362550175283104, 3.0204939321265556e-05, 3.277920768596232e-05, 4.8053876525955275e-05, 1.0936147191387136e-05, 0.000365819112630561, 0.0003595411835703999, 0.00010061085049528629, 0.0001816860749386251, 4.309588803153019e-06, 2.4806529381748987e-06, 4.743605131807271e-06, 2.0285065147618297e-06, 3.2485437259310856e-05, 0.00014442905376199633, 5.829970177728683e-05, 0.00011876373901031911, 7.977551831572782e-06, 4.7501416702289134e-05, 6.906859198352322e-06, 3.5845921956934035e-05, 1.2780126780853607e-05, 4.996105872123735e-06, 2.601349842734635e-05, 4.88013165522716e-06, 5.987683834973723e-05, 1.689407872618176e-05, 0.00010151757305720821, 1.5481342416023836e-05, 0.00013895791198592633, 2.4349725208594464e-05, 0.0001743668835842982, 2.0861607481492683e-05, 3.703436232171953e-05, 2.8818039936595596e-05, 6.543185736518353e-05, 2.46959607466124e-05, 0.0001229270565090701, 0.0008401681552641094, 0.00010855605796677992, 0.00026714178966358304, 6.957046025490854e-06, 2.4529661004635273e-06, 9.477852472628001e-06, 2.137260025847354e-06, 3.367578028701246e-05, 0.00013649674656335264, 1.8859915144275874e-05, 8.333923324244097e-05, 5.275322837405838e-05, 1.6317007975885645e-05, 0.00011919342796318233, 8.457525837002322e-06, 0.0003065184282604605, 2.0731946278829128e-05, 0.00031789159402251244, 1.4618172826885711e-05, 5.545864041778259e-05, 9.913223038893193e-05, 0.00014807989646214992, 3.191066571162082e-05, 0.0002513255749363452, 0.0011581791331991553, 0.00048766323016025126, 0.0007211781921796501, 5.368792699300684e-05, 0.0001759060105541721, 3.06355650536716e-05, 0.00019748852355405688, 0.0005421460955403745, 2.9637985790031962e-05, 0.0005371818551793694, 1.2615709238161799e-05, 1.3204609786043875e-05, 8.1241836596746e-05, 1.3613327610073611e-05, 5.81062886340078e-05, 0.00011225118942093104, 0.0006791549385525286, 0.0002684740466065705, 0.0004670906055252999, 0.0005263508064672351, 8.16240135463886e-05, 0.0006887301569804549, 5.019495074520819e-05, 1.1391373845981434e-05, 3.0804993002675474e-05, 1.0035151717602275e-05, 2.8952761567779817e-05, 1.0326361007173546e-05, 1.9139135929435724e-06, 7.241671937663341e-06, 3.283363639638992e-06, 2.126998697349336e-05, 0.00013298753765411675, 5.04260569869075e-05, 9.964529454009607e-05, 1.690606768534053e-05, 5.112467079015914e-06, 8.939731742430013e-06, 9.503976798441727e-06, 0.0002035998331848532, 1.7050620954250917e-05, 0.0002756546309683472, 1.130000782723073e-05, 3.566162195056677e-05, 3.6949979403289035e-05, 4.828510282095522e-05, 1.9862432964146137e-05, 0.0005006029969081283, 0.00223131594248116, 0.0006000260473228991, 0.0016720013227313757, 0.00019855394202750176, 7.552130409749225e-05, 0.00012138607417000458, 6.772428605472669e-05, 3.53441500919871e-05, 2.268265916427481e-06, 1.0146704880753532e-05, 5.518977559404448e-06, 0.00026475032791495323, 0.0006173101137392223, 0.0003728623269125819, 0.00011736035958165303, 0.000259831256698817, 0.00022564007667824626, 0.00028946675593033433, 0.000146037113154307, 0.0007548145367763937, 0.00013338547432795167, 0.00024216444580815732, 0.0004720342403743416, 1.424441734343418e-06, 6.345506790239597e-06, 2.864832367777126e-06, 3.0445501124631846e-06, 0.00012987558147870004, 0.0004055512836202979, 0.00017392513109371066, 0.0004054513992741704, 8.838995563564822e-05, 5.6979351938935e-05, 5.7212295359931886e-05, 6.131385453045368e-05, 2.106941337842727e-06, 2.2393935068976134e-05, 1.1740244190150406e-05, 2.9978377824591007e-06, 0.0004817536973860115, 2.6617753974278457e-05, 0.00038335632416419685, 4.668962355935946e-05, 0.00017787171236705035, 8.592536687501706e-06, 8.483664714731276e-05, 1.5543382687610574e-05, 0.0004164507845416665, 2.962770486192312e-05, 0.0003271162568125874, 4.010033080703579e-05, 8.032572804950178e-05, 0.0003506809880491346, 0.0002458902890793979, 0.00022691242338623852, 5.872736073797569e-05, 5.3017625759821385e-05, 3.0769955628784373e-05, 4.1999639506684616e-05, 0.00030922124278731644, 2.4555347408750094e-05, 0.00013889411638956517, 8.106879249680787e-05, 5.016700583837519e-07, 1.0399634220448206e-06, 1.9458975657471456e-06, 7.188016866166436e-07, 6.573944119736552e-06, 2.4050041247392073e-06, 3.0922026326152263e-06, 1.5230231156238005e-06, 0.00017269383533857763, 0.0005526632303372025, 1.466191497456748e-05, 8.759228876442648e-06, 2.0091463738936e-05, 5.071353371022269e-06, 1.6490816051373258e-05, 2.8583304811036214e-05, 1.1626651030383073e-05, 1.737899219733663e-05, 1.0815121640916914e-05, 1.668307595537044e-05, 1.0583248695184011e-05, 8.939039616961963e-06, 8.154158422257751e-06, 2.292508725076914e-05, 5.691562819265528e-06, 1.4648512660642155e-05, 4.690470632340293e-06, 1.777456964191515e-05, 4.461410753719974e-06, 1.2310450983932242e-05, 5.155460712558124e-06, 5.436189439933514e-06, 4.338019607530441e-06, 6.739976015524007e-06, 2.2663300114800222e-05, 1.482426614529686e-05, 1.179907030746108e-05, 1.860922020568978e-05, 5.74729529034812e-05, 6.232690066099167e-05, 6.363628199324012e-05, 2.614464028738439e-05, 2.587586459412705e-05, 0.00012556732690427452, 6.2491228163708e-05, 5.38785861863289e-05, 5.772897566203028e-05, 7.287222251761705e-05, 6.616409518755972e-05, 4.66664569103159e-05, 2.2217338482732885e-05, 2.016534563153982e-05, 1.5665638784412295e-05, 2.0917832443956286e-05, 7.1623044277657755e-06, 2.9190838176873513e-05, 1.1657727554847952e-05, 2.5200171876349486e-05, 7.033369456621585e-06, 2.0190762370475568e-05, 2.2016509319655597e-05, 6.478790510300314e-06, 5.259912541077938e-06, 1.0346470844524447e-05, 6.353963726724032e-06, 1.1814815479738172e-05, 6.144574399513658e-06, 6.924326953594573e-06, 9.044991202245e-06, 7.955294677230995e-06, 1.8732929675024934e-05, 3.6463541619013995e-05, 2.1212539650150575e-05, 3.425675822654739e-05, 0.0001643048890400678, 1.6000725736375898e-05, 0.00023365205561276525, 1.7795251551433466e-05, 3.003647634614026e-06, 5.289710770739475e-06, 4.982992777513573e-06, 2.4736243631195975e-06, 2.3668337234994397e-05, 5.536486696655629e-06, 2.2232861738302745e-05, 5.583108304563211e-06, 9.331059118267149e-05, 0.00012983992928639054, 0.0001277391129406169, 9.627899999031797e-05, 3.918042784789577e-05, 2.604472456368967e-06, 2.4987373308249516e-06, 3.86592437280342e-05, 3.945919524994679e-05, 1.7854944189821254e-06, 1.7285958620050224e-06, 3.9641643525101244e-05, 1.551284185552504e-06, 5.478897219290957e-05, 5.623513789032586e-05, 1.8897321751865093e-06, 1.4360318800754612e-06, 4.161777178524062e-05, 4.182115299045108e-05, 1.659839313106204e-06, 7.227097853501618e-07, 3.366342207300477e-05, 3.2932224712567404e-05, 8.038132932597364e-07, 9.61282012212905e-07, 2.702393612707965e-05, 2.6691961465985514e-05, 9.161105936073e-07, 7.749829819658771e-05, 8.603712194599211e-05, 8.615553088020533e-05, 7.603126869071275e-05, 5.874380440218374e-05, 0.00010983548418153077, 0.00011027861182810739, 5.6060842325678095e-05, 2.6669635190046392e-05, 1.1172118092872552e-06, 1.1001947086697328e-06, 2.8777129045920447e-05, 2.6504596462473273e-05, 7.285511287591362e-07, 6.940010734979296e-07, 2.8468686650739983e-05, 8.148739993885101e-07, 2.3004859031061642e-05, 2.2938655092730187e-05, 8.043734283091908e-07, 9.394225344294682e-07, 1.847938801802229e-05, 1.8747596186585724e-05, 1.030870635077008e-06, 6.087447764002718e-05, 3.12684423988685e-05, 3.290722816018388e-05, 5.813570896862075e-05, 5.066502490080893e-05, 3.458158244029619e-05, 3.586319871828891e-05, 4.893045115750283e-05, 6.325239519355819e-05, 0.0002104303566738963, 0.00020714617858175188, 6.106025830376893e-05, 9.153464634437114e-05, 0.00015282293315976858, 0.0001469405833631754, 8.684358181199059e-05, 5.947280442342162e-05, 8.474782953271642e-05, 8.822282688925043e-05, 6.26414330326952e-05, 6.349800969474018e-05, 9.325578139396384e-05, 9.688183490652591e-05, 6.688966823276132e-05, 6.695335059703211e-07, 3.3915355743374676e-05, 3.2755382562754676e-05, 6.061383714950352e-07, 4.6235788886406226e-07, 3.5312426916789263e-05, 3.43622341461014e-05, 4.4857199554826366e-07, 8.120956044876948e-05, 0.0001464051747461781, 0.00014712550910189748, 7.769755757180974e-05, 5.4891286708880216e-05, 0.00017181930888909847, 0.00016787229105830193, 5.2807798056164756e-05, 6.752836634404957e-05, 2.3325439542531967e-05, 2.325934656255413e-05, 6.967531953705475e-05, 2.826210948114749e-05, 1.6882817362784408e-05, 1.5822193745407276e-05, 2.8516415113699622e-05, 1.7034864185916376e-06, 3.278916483395733e-05, 3.206613109796308e-05, 1.5392214436360518e-06, 8.867603469298047e-07, 4.2089057387784123e-05, 4.074320531799458e-05, 8.374831281798834e-07, 6.068753282306716e-05, 6.90485248924233e-05, 7.253897638292983e-05, 5.8950874517904595e-05, 7.536619523307309e-05, 7.512318552471697e-05, 7.811195973772556e-05, 7.403466588584706e-05, 4.845193325309083e-05, 7.412064587697387e-05, 6.834091618657112e-05, 4.8079458792926744e-05, 5.666831202688627e-05, 7.192205521278083e-05, 6.643450615229085e-05, 5.550569039769471e-05, 4.86037642986048e-05, 3.602425067583681e-06, 3.2815123631735332e-06, 4.6647575800307095e-05, 3.9443937566829845e-05, 1.2964900406586821e-06, 1.1923772262889543e-06, 3.7092719139764085e-05, 8.331074786838144e-05, 3.760154640986002e-06, 2.9797245133522665e-06, 8.519503171555698e-05, 7.77694585849531e-05, 4.879384050582303e-06, 4.232885657984298e-06, 7.924954843474552e-05, 8.961817366071045e-05, 0.00014411855954676867, 0.0001463231019442901, 8.672439435031265e-05, 7.038908370304853e-05, 0.00016853534907568246, 0.00016773154493421316, 6.951862451387569e-05, 0.00011185216862941161, 3.7167112168390304e-05, 3.735943391802721e-05, 0.00010615312930895016, 9.793408389668912e-05, 4.754646943183616e-05, 4.8231355322059244e-05, 9.408502228325233e-05, 2.2656279270449886e-06, 5.171993689145893e-05, 5.528430483536795e-05, 2.293264969921438e-06, 4.922153311781585e-05, 8.473724301438779e-05, 8.39242129586637e-05, 4.6431694499915466e-05, 4.653619907912798e-05, 7.187482697190717e-05, 6.997976743150502e-05, 4.522898234426975e-05, 4.281392102711834e-05, 1.6805444147394155e-06, 1.6520908729944495e-06, 4.102958700968884e-05, 5.329980922397226e-05, 5.117981345392764e-07, 4.6155543032000423e-07, 5.143351518199779e-05, 0.00014328306133393198, 0.0001732324599288404, 0.00016761838924139738, 0.00015104914200492203, 0.00020399660570546985, 0.00011505798465805128, 0.00010784030746435747, 0.00022129352146293968, 0.00012034493556711823, 0.00014502884005196393, 0.00015382740821223706, 0.00011713431013049558, 8.084840374067426e-05, 0.00015228685515467077, 0.0001541484525660053, 8.020001405384392e-05, 0.00011231336975470185, 0.00010077429033117369, 0.00010386859503341839, 0.00011354185699019581, 8.084882574621588e-05, 0.00013950903667137027, 0.00014250200183596462, 8.157434785971418e-05, 6.200381903909147e-05, 0.00010934368037851527, 0.00010806738282553852, 6.241286610020325e-05, 5.052820415585302e-05, 0.00013519718777388334, 0.00013429572572931647, 5.0172762712463737e-05, 5.2068891818635166e-05, 0.00010852551349671558, 0.00010118396312464029, 5.002778925700113e-05, 4.7345252824015915e-05, 0.00012550261453725398, 0.00011898486991412938, 4.545283809420653e-05, 4.4866967073176056e-05, 0.00012633681762963533, 0.00012370750482659787, 4.2809362639673054e-05, 3.7692399928346276e-05, 0.00013882758503314108, 0.00013709336053580046, 3.547091182554141e-05, 5.899769917050435e-07, 3.1037619919516146e-05, 3.043389915546868e-05, 6.211440108927491e-07, 5.466299057843571e-07, 3.2336043659597635e-05, 3.184481101925485e-05, 5.829370479659701e-07, 1.0288929388480028e-06, 3.373081926838495e-05, 3.380937050678767e-05, 1.0515927897358779e-06, 1.7136208043666556e-06, 2.695959119591862e-05, 2.7235060770181008e-05, 1.7199635067299823e-06, 7.655907393200323e-05, 1.9877286831615493e-05, 1.883660297608003e-05, 7.089962309692055e-05, 7.47660033084685e-06, 7.417871188408753e-07, 8.094060603980324e-07, 7.2330021794186905e-06, 7.506157544412417e-07, 2.1353289412218146e-05, 2.1461841242853552e-05, 7.399995070045406e-07, 7.572307367809117e-07, 1.860951306298375e-05, 1.871464519354049e-05, 7.689735070925963e-07, 0.00016881329065654427, 0.0010041117202490568, 0.0009110623504966497, 0.00018195106531493366, 0.00035114827915094793, 0.0005473628407344222, 0.0005086870514787734, 0.0003466935595497489, 5.6157222161346e-07, 3.312068656668998e-05, 3.431721415836364e-05, 5.834183411934646e-07, 1.2494278962549288e-06, 2.9511651518987492e-05, 2.9497632567654364e-05, 1.4148569107419462e-06, 1.5386738141387468e-06, 1.8374525097897276e-05, 1.8059898138744757e-05, 1.5756945686007384e-06, 6.567933610313048e-07, 2.447979204589501e-05, 2.4704346287762746e-05, 7.146128950807906e-07, 3.540631223586388e-05, 2.1436494535009842e-06, 2.1361313429224538e-06, 3.298069350421429e-05, 2.7622114430414513e-05, 1.6989689584079315e-06, 1.6908143152249977e-06, 2.634062184370123e-05, 6.430796929635108e-05, 3.0379273994185496e-06, 2.7812563985207817e-06, 6.465100886998698e-05, 5.093229265185073e-05, 5.864334525540471e-06, 5.623914148600306e-06, 5.0038754125125706e-05, 3.8543563277926296e-05, 1.0847425073734485e-06, 1.1248948794673197e-06, 3.745517824427225e-05, 3.041516538360156e-05, 2.0216282337059965e-06, 2.129810354745132e-06, 3.0267878173617646e-05, 1.1479072554720915e-06, 1.993005207623355e-05, 1.8595381334307604e-05, 1.1269822834947263e-06, 6.455704806285212e-07, 2.2485781300929375e-05, 2.122598743881099e-05, 7.059550171106821e-07, 1.1559379345271736e-05, 1.4550485047948314e-06, 1.4854376786388457e-06, 1.112360132538015e-05, 1.6786867490736768e-05, 4.5117306513020594e-07, 4.782516498380573e-07, 1.6130970834637992e-05, 3.668225190267549e-07, 1.4489904970105272e-05, 1.4713354175910354e-05, 3.208506598184613e-07, 8.777510061008797e-07, 1.3046496860624757e-05, 1.289222200284712e-05, 8.46305113100243e-07, 6.838694389443845e-05, 4.85128111904487e-05, 4.761421223520301e-05, 6.641656364081427e-05, 5.078837421024218e-05, 6.313870107987896e-05, 6.188006227603182e-05, 5.0001704948954284e-05, 8.960128639046161e-07, 1.9983477614005096e-05, 2.0408357158885337e-05, 9.04602813989186e-07, 5.035493586547091e-07, 1.59017708938336e-05, 1.5989227904356085e-05, 5.32300248323736e-07, 1.2509742646216182e-06, 2.9081844331813045e-05, 3.1682149710832164e-05, 1.4299232589110034e-06, 7.011852289906528e-07, 3.15185752697289e-05, 3.422334702918306e-05, 8.087938567769015e-07, 7.964775431901217e-05, 5.251578477327712e-05, 5.138714186614379e-05, 8.008594159036875e-05, 9.760991088114679e-05, 4.129824446863495e-05, 4.387429362395778e-05, 9.422142466064543e-05, 1.5789506505825557e-05, 2.7106625566375442e-05, 2.906534427893348e-05, 1.683635127847083e-05, 1.0627438314259052e-05, 2.585527727205772e-05, 2.7540118026081473e-05, 1.1448461918917019e-05, 4.9262383981840685e-05, 0.00021458353148773313, 0.0002140799624612555, 4.6725606807740405e-05, 4.127931606490165e-05, 0.0001299676951020956, 0.00013101904187351465, 4.121046731597744e-05, 1.743606844684109e-06, 3.493124677333981e-05, 3.5967095755040646e-05, 1.901621089928085e-06, 2.7937162485613953e-06, 3.151126657030545e-05, 3.266126805101521e-05, 2.826375066433684e-06, 7.074182235555782e-07, 2.8920949262101203e-05, 2.9072349207126535e-05, 8.669560429552803e-07, 8.080678526312113e-07, 2.7483252779347822e-05, 2.675249197636731e-05, 9.515133569948375e-07, 0.00015991553664207458, 3.766631562029943e-05, 3.793861105805263e-05, 0.00016614138439763337, 0.0001507236884208396, 3.713477781275287e-05, 3.8781221519457176e-05, 0.00015274400357156992, 5.372344458010048e-05, 9.360956028103828e-05, 9.789044997887686e-05, 5.784836321254261e-05, 2.6164589144173078e-05, 8.252171392086893e-05, 8.575742685934529e-05, 2.8283220672165044e-05, 2.379599209234584e-05, 6.908703085173329e-07, 7.544057893937861e-07, 2.296855927852448e-05, 1.8405657101538964e-05, 1.0306633839718415e-06, 1.0758084272310953e-06, 1.776330464053899e-05, 3.844401362584904e-05, 4.017223091068445e-06, 3.5885677789337933e-06, 3.883387034875341e-05, 3.121536792605184e-05, 3.27567795466166e-06, 3.3407789032935398e-06, 3.098238448728807e-05, 5.0366590585326776e-05, 3.958227807743242e-06, 3.3973019526456483e-06, 4.968115172232501e-05, 4.6008179197087884e-05, 2.326412413822254e-06, 2.0732704797410406e-06, 4.567075666273013e-05, 9.33438423089683e-05, 9.50303438003175e-05, 9.172539284918457e-05, 9.044481703313068e-05, 7.09503801772371e-05, 9.725021664053202e-05, 9.22109538805671e-05, 6.953517004149035e-05, 5.7132063375320286e-05, 0.00011271332914475352, 0.00010843962081708014, 5.7211709645343944e-05, 7.478769111912698e-05, 0.00012072209210600704, 0.00011660149903036654, 7.40239120204933e-05, 5.963749458715029e-07, 3.21340630762279e-05, 3.4305761801078916e-05, 7.447749226230371e-07, 1.0599520692267106e-06, 2.8412665415089577e-05, 3.111658588750288e-05, 1.1794464853664977e-06, 3.515973730827682e-05, 5.271274403639836e-07, 5.273775514069712e-07, 3.617610127548687e-05, 4.335060657467693e-05, 3.3114989150817564e-07, 3.6263801916902594e-07, 4.522862582234666e-05, 3.688338983920403e-05, 5.7667588407639414e-05, 5.650289313052781e-05, 3.503351399558596e-05, 7.191784970927984e-05, 3.985942748840898e-05, 4.217925379634835e-05, 6.774670328013599e-05, 8.470545435557142e-05, 0.00022046933008823544, 0.0002066808519884944, 8.196205453714356e-05, 0.00010675665544113144, 0.00012018878624076024, 0.00011461091344244778, 0.0001044997334247455, 0.00010763148020487279, 0.00010678513353923336, 0.00010971113078994676, 0.00010491009015822783, 9.928819054039195e-05, 0.00012178243196103722, 0.00012385068112052977, 9.642702207202092e-05, 1.1504734175105114e-05, 8.811111001705285e-06, 8.225454621424433e-06, 1.1661988537525758e-05, 1.8874299712479115e-05, 0.011746448464691639, 0.011881430633366108, 1.9365446860319935e-05, 3.1039409805089235e-05, 0.01104643102735281, 0.0111555689945817, 3.494667907943949e-05, 4.665603773901239e-05, 0.009346614591777325, 0.009475046768784523, 3.8916881749173626e-05, 5.02498987771105e-05, 0.007213188800960779, 0.007363167125731707, 5.629674706142396e-05, 7.109723810572177e-05, 0.005030478350818157, 0.005152884870767593, 6.508886144729331e-05, 8.27993790153414e-05, 0.003045598976314068, 0.003134653903543949, 8.878632070263848e-05, 4.68103498860728e-05, 0.0016695850063115358, 0.001716217608191073, 4.6092027332633734e-05, 7.503974484279752e-05, 0.0007057961774989963, 0.000721720396541059, 7.992346945684403e-05], "data_std": [0.0007307169144041836, 0.0003210606810171157, 0.0011230094823986292, 0.0015447784680873156, 0.005473060067743063, 0.002521494636312127, 0.004430333152413368, 0.002759241033345461, 0.0029954276978969574, 0.0039138589054346085, 0.003946058917790651, 0.0029639722779393196, 0.0036901673302054405, 0.0022726492024958134, 0.003054465865716338, 0.0028112162835896015, 0.0022355616092681885, 0.008127275854349136, 0.0059474166482687, 0.003443390829488635, 0.015109539963304996, 0.008901914581656456, 0.012915768660604954, 0.005337107926607132, 0.05560801923274994, 0.03043641708791256, 0.04996127262711525, 0.033283986151218414, 0.009323634207248688, 0.004857389722019434, 0.006734950467944145, 0.0043371510691940784, 0.003271663561463356, 0.013777948915958405, 0.0025680833496153355, 0.011717312969267368, 0.004482897464185953, 0.006280502304434776, 0.0029694759286940098, 0.004106262698769569, 0.004061713349074125, 0.002442724537104368, 0.0038986955769360065, 0.0022737837862223387, 0.008662566542625427, 0.008706246502697468, 0.00483872601762414, 0.006416661664843559, 0.015193847939372063, 0.004668902140110731, 0.014489530585706234, 0.003821699181571603, 0.003441762877628207, 0.008267894387245178, 0.0019751035142689943, 0.006309836637228727, 0.01610017940402031, 0.013512574136257172, 0.01537794154137373, 0.01165896188467741, 0.005908227991312742, 0.005821043159812689, 0.0034307765308767557, 0.007303180173039436, 0.01838291995227337, 0.01968599297106266, 0.012853550724685192, 0.010353002697229385, 0.001525243278592825, 0.0021546664647758007, 0.0013849640963599086, 0.002217065542936325, 0.011949989944696426, 0.005666246637701988, 0.010721362195909023, 0.007627516053617001, 0.006737316492944956, 0.0029043268878012896, 0.0058807265013456345, 0.002629936207085848, 0.0021926567424088717, 0.003627477679401636, 0.002239361172541976, 0.005197863560169935, 0.004144500941038132, 0.007683131378144026, 0.003948621451854706, 0.01003188081085682, 0.0048589929938316345, 0.011852903291583061, 0.004534698557108641, 0.013317914679646492, 0.005267211701720953, 0.0062438263557851315, 0.00489719258621335, 0.008338747546076775, 0.029600106179714203, 0.011258293874561787, 0.016614975407719612, 0.01034057792276144, 0.0016179172089323401, 0.002647132147103548, 0.001486223074607551, 0.0031946238595992327, 0.011640754528343678, 0.005759137216955423, 0.009051721543073654, 0.004312767647206783, 0.00400180509313941, 0.007349258288741112, 0.002993170637637377, 0.010995466262102127, 0.0047958469949662685, 0.017118019983172417, 0.0040756212547421455, 0.017490331083536148, 0.009693729691207409, 0.007482301443815231, 0.005498822778463364, 0.012220899574458599, 0.034734807908535004, 0.016014285385608673, 0.02719588205218315, 0.02253495529294014, 0.013276693411171436, 0.007207113318145275, 0.013955559581518173, 0.005391492508351803, 0.0058299279771745205, 0.023453235626220703, 0.0037501752376556396, 0.02329682558774948, 0.00893876701593399, 0.0035367265809327364, 0.00749930227175355, 0.0036268471740186214, 0.026457812637090683, 0.010720034129917622, 0.021758977323770523, 0.016667034476995468, 0.009218312799930573, 0.023076120764017105, 0.007387534249573946, 0.026401814073324203, 0.005504315253347158, 0.0033265370875597, 0.005377895198762417, 0.003109786193817854, 0.0014779440825805068, 0.0031578911002725363, 0.0018850993365049362, 0.002646434586495161, 0.011277683079242706, 0.004620187450200319, 0.00969413947314024, 0.007255705073475838, 0.002278067171573639, 0.004158985335379839, 0.0030438306275755167, 0.0030411304906010628, 0.004277267958968878, 0.014195181429386139, 0.0034337001852691174, 0.01649845764040947, 0.006024515721946955, 0.0062799700535833836, 0.004493357613682747, 0.007235000841319561, 0.04812274128198624, 0.02292484976351261, 0.04141586273908615, 0.02517014369368553, 0.00876886211335659, 0.013822460547089577, 0.007918313145637512, 0.010847313329577446, 0.0015161227202042937, 0.006026073358952999, 0.0024341936223208904, 0.0032385450322180986, 0.02429105155169964, 0.016616564244031906, 0.010908236727118492, 0.01959574967622757, 0.014904530718922615, 0.01601048931479454, 0.012186635285615921, 0.01673479564487934, 0.011616358533501625, 0.027133626863360405, 0.021217741072177887, 0.0156666599214077, 0.0025693015195429325, 0.001244277460500598, 0.001755692414008081, 0.0017598456470295787, 0.01920807920396328, 0.011414045467972755, 0.018773095682263374, 0.013376655988395214, 0.007464771158993244, 0.009120574221014977, 0.007743393536657095, 0.007203591521829367, 0.004775338806211948, 0.001466691610403359, 0.0017488173907622695, 0.0034893914125859737, 0.005062044132500887, 0.022234300151467323, 0.006866996176540852, 0.019779022783041, 0.002996795577928424, 0.013543983921408653, 0.00409925589337945, 0.009325654245913029, 0.005551441572606564, 0.020691262558102608, 0.00645480677485466, 0.018362998962402344, 0.018665367737412453, 0.009176881983876228, 0.014624465256929398, 0.016260484233498573, 0.0075840093195438385, 0.007518447935581207, 0.006617654114961624, 0.005503571126610041, 0.00476478086784482, 0.017737535759806633, 0.008872676640748978, 0.01191525999456644, 0.0009932063985615969, 0.0006992408307269216, 0.0008474714122712612, 0.0014242440229281783, 0.0015357935335487127, 0.002627760171890259, 0.001195499557070434, 0.0017520724795758724, 0.02186358906328678, 0.013204146176576614, 0.00306914490647614, 0.004039468709379435, 0.0023627188056707382, 0.004668315406888723, 0.0053970422595739365, 0.004053022246807814, 0.004176941700279713, 0.0033995015546679497, 0.004193483851850033, 0.0033882034476846457, 0.0030575806740671396, 0.0033437127713114023, 0.004741033539175987, 0.002933779265731573, 0.003784699598327279, 0.0023780507035553455, 0.00428546778857708, 0.0020981007255613804, 0.0035688220523297787, 0.0020199560094624758, 0.0023547711316496134, 0.0022868625819683075, 0.002546436619013548, 0.002140217227861285, 0.003749013179913163, 0.004781010095030069, 0.00404894957318902, 0.0034976101014763117, 0.007659839931875467, 0.007730543147772551, 0.004942076280713081, 0.007837343029677868, 0.011569111607968807, 0.005065030883997679, 0.007537743542343378, 0.007738924119621515, 0.008908163756132126, 0.007367806043475866, 0.007245595566928387, 0.007878926582634449, 0.004553146194666624, 0.004486202262341976, 0.004616685677319765, 0.0038103193510323763, 0.005354931112378836, 0.0025832171086221933, 0.004921401850879192, 0.003323951968923211, 0.0043960693292319775, 0.0026610686909407377, 0.002490848768502474, 0.004754093009978533, 0.0030759251676499844, 0.0023644331376999617, 0.0032359189353883266, 0.0026149440091103315, 0.00273522874340415, 0.002482743700966239, 0.002883837092667818, 0.0029342174530029297, 0.006055559031665325, 0.004289426375180483, 0.005903746001422405, 0.0045115090906620026, 0.0039262608624994755, 0.012904698960483074, 0.0042227813974022865, 0.0152514036744833, 0.0023515443317592144, 0.001821812940761447, 0.0016218561213463545, 0.0023323236964643, 0.002421807497739792, 0.0051447381265461445, 0.0024627652019262314, 0.0049845315515995026, 0.0012616353342309594, 0.0003190157294739038, 0.0007745391922071576, 0.0015239244094118476, 0.002548499498516321, 0.0055066789500415325, 0.0028307263273745775, 0.0044471523724496365, 0.004110916517674923, 0.003084686119109392, 0.0030586225911974907, 0.0040922765620052814, 0.002316509373486042, 0.003724833717569709, 0.0028723091818392277, 0.0030417251400649548, 0.008066989481449127, 0.0022870900575071573, 0.0033921650610864162, 0.005978358909487724, 0.00867341086268425, 0.015059541910886765, 0.005539775360375643, 0.012876291759312153, 0.030012745410203934, 0.054351095110177994, 0.032655347138643265, 0.049129877239465714, 0.004816472064703703, 0.009257425554096699, 0.004223871044814587, 0.006622428074479103, 0.014024564996361732, 0.003122886409983039, 0.011914953589439392, 0.002478823298588395, 0.0063804625533521175, 0.00450884411111474, 0.004145885352045298, 0.0029742317274212837, 0.0024556240532547235, 0.004015571903437376, 0.0022782660089433193, 0.0038686736952513456, 0.00875180959701538, 0.00917716883122921, 0.006433613132685423, 0.0050046746619045734, 0.004843920934945345, 0.015417429618537426, 0.003939617425203323, 0.014589602127671242, 0.008372356183826923, 0.003442158456891775, 0.006345784291625023, 0.002034875564277172, 0.013958128169178963, 0.01629272662103176, 0.011943758465349674, 0.015608507208526134, 0.0054959021508693695, 0.005725312978029251, 0.006932090502232313, 0.003306984668597579, 0.019126398488879204, 0.018961571156978607, 0.010030495934188366, 0.013479097746312618, 0.002075954806059599, 0.0015750088496133685, 0.0021779818926006556, 0.0014242564793676138, 0.005699599627405405, 0.012017863802611828, 0.007635423913598061, 0.010897877626121044, 0.002824455965310335, 0.006892126984894276, 0.00262809032574296, 0.005987146403640509, 0.003574930364266038, 0.0022351969964802265, 0.005100342910736799, 0.0022091020364314318, 0.007738012354820967, 0.004110240843147039, 0.010075593367218971, 0.003934633918106556, 0.011788041330873966, 0.004934544209390879, 0.013204805552959442, 0.0045674508437514305, 0.00608558626845479, 0.005368243437260389, 0.008088995702564716, 0.00496950326487422, 0.011087247170507908, 0.028985654935240746, 0.010419024154543877, 0.016344472765922546, 0.002637621248140931, 0.0015661948127672076, 0.00307861203327775, 0.001461937092244625, 0.005803083535283804, 0.01168318185955286, 0.004342800471931696, 0.009129032492637634, 0.007263141684234142, 0.00403943145647645, 0.010917574167251587, 0.0029081825632601976, 0.01750766858458519, 0.0045532346703112125, 0.017829515039920807, 0.0038233718369156122, 0.007447056006640196, 0.00995651725679636, 0.012168807908892632, 0.005648952443152666, 0.01585325039923191, 0.034032031893730164, 0.02208309806883335, 0.026854760944843292, 0.007327204570174217, 0.013262956403195858, 0.0055349403992295265, 0.014053060673177242, 0.023284031078219414, 0.005444078240543604, 0.02317718416452408, 0.003551859874278307, 0.003633814863860607, 0.009013425558805466, 0.0036896243691444397, 0.007622748147696257, 0.01059486623853445, 0.026060601696372032, 0.01638517715036869, 0.02161227911710739, 0.02294233627617359, 0.009034601040184498, 0.0262436680495739, 0.007084839511662722, 0.0033751109149307013, 0.0055502247996628284, 0.0031678308732807636, 0.0053807771764695644, 0.003213465679436922, 0.0013834426645189524, 0.0026910353917628527, 0.001812005415558815, 0.004611939657479525, 0.01153202261775732, 0.007101130671799183, 0.009982248768210411, 0.0041116988286376, 0.0022610765881836414, 0.0029899384826421738, 0.0030828521121293306, 0.014268841594457626, 0.004129239823669195, 0.01660284958779812, 0.0033615485299378633, 0.005971735343337059, 0.006078649312257767, 0.006948748137801886, 0.004456729162484407, 0.02237415872514248, 0.04723680764436722, 0.024495428428053856, 0.04089011251926422, 0.014090917073190212, 0.008690299466252327, 0.011017534881830215, 0.008229476399719715, 0.005945094395428896, 0.001506076310761273, 0.003185389330610633, 0.0023492504842579365, 0.01627114973962307, 0.024845726788043976, 0.019309643656015396, 0.010833298787474632, 0.016119282692670822, 0.015021320432424545, 0.01701372303068638, 0.012084581889212132, 0.02747388742864132, 0.011549263261258602, 0.015561633743345737, 0.021726349368691444, 0.001193499774672091, 0.0025190289597958326, 0.0016925815725699067, 0.0017448639264330268, 0.011396297253668308, 0.02013830468058586, 0.013188067823648453, 0.020135823637247086, 0.0094015933573246, 0.007548466790467501, 0.0075638811103999615, 0.007830316200852394, 0.0014515307266265154, 0.004732223227620125, 0.003426403971388936, 0.001731426571495831, 0.021948888897895813, 0.005159239750355482, 0.019579486921429634, 0.006832980550825596, 0.013336854986846447, 0.0029313028790056705, 0.009210681542754173, 0.003942509647458792, 0.02040712535381317, 0.005443133879452944, 0.018086355179548264, 0.00633248221129179, 0.008962461724877357, 0.018726477399468422, 0.015680888667702675, 0.015063612721860409, 0.0076633780263364315, 0.007281320169568062, 0.005547067150473595, 0.0064807129092514515, 0.01758468709886074, 0.004955335054546595, 0.011785334907472134, 0.009003820829093456, 0.0007082867086865008, 0.0010197859955951571, 0.001394954277202487, 0.0008478217059746385, 0.00256397039629519, 0.0015508076176047325, 0.0017584660090506077, 0.0012341082328930497, 0.013141302391886711, 0.023508790880441666, 0.0038290880620479584, 0.0029595994856208563, 0.0044823503121733665, 0.0022519666235893965, 0.004060888662934303, 0.005346335470676422, 0.0034097875468432903, 0.004168811719864607, 0.0032886352855712175, 0.004084492102265358, 0.0032531905453652143, 0.002989822765812278, 0.0028555486351251602, 0.00478801503777504, 0.0023856996558606625, 0.0038273376412689686, 0.0021657494362443686, 0.004215989727526903, 0.0021122051402926445, 0.0035086253192275763, 0.0022705639712512493, 0.002331563737243414, 0.0020827914122492075, 0.0025961464270949364, 0.004760598763823509, 0.0038502293173223734, 0.0034349774941802025, 0.00431384053081274, 0.0075810919515788555, 0.00789473857730627, 0.00797723513096571, 0.005113183055073023, 0.00508683267980814, 0.011205682530999184, 0.007905139587819576, 0.007340203505009413, 0.007597958669066429, 0.008536523208022118, 0.008134131319820881, 0.006831285078078508, 0.004713527392596006, 0.004490584135055542, 0.003957984037697315, 0.0045736017636954784, 0.0026762480847537518, 0.005402854643762112, 0.0034143414814025164, 0.00501997722312808, 0.002652049995958805, 0.0044934130273759365, 0.004692175425589085, 0.002545346738770604, 0.0022934498265385628, 0.003216593060642481, 0.002520706970244646, 0.0034372685477137566, 0.0024788251612335443, 0.0026314116548746824, 0.0030074892565608025, 0.0028205132111907005, 0.0043281554244458675, 0.006038505118340254, 0.004605707246810198, 0.005852927453815937, 0.012818146497011185, 0.004000090528279543, 0.015285681001842022, 0.004218441899865866, 0.0017331034177914262, 0.0022999371867626905, 0.002232261700555682, 0.001572776003740728, 0.004865011665970087, 0.002352973911911249, 0.004715173505246639, 0.002362860133871436, 0.009659741073846817, 0.011394732631742954, 0.011302173137664795, 0.0098121864721179, 0.006259426940232515, 0.0016138377832248807, 0.0015807395102456212, 0.006217655725777149, 0.00628165528178215, 0.0013362239114940166, 0.0013147607678547502, 0.006296161096543074, 0.0012455056421458721, 0.007401957176625729, 0.007499008905142546, 0.001374675310216844, 0.0011983454460278153, 0.006451183930039406, 0.006466927472501993, 0.0012883475283160806, 0.0008501234115101397, 0.005802018567919731, 0.00573866069316864, 0.0008965563611127436, 0.0009804499568417668, 0.005198454950004816, 0.0051664263010025024, 0.0009571366827003658, 0.008803311735391617, 0.009275619871914387, 0.009282000362873077, 0.008719591423869133, 0.0076644509099423885, 0.010480242781341076, 0.010501362383365631, 0.007487379014492035, 0.005164265166968107, 0.0010569824371486902, 0.0010489017004147172, 0.0053644319996237755, 0.005148261319845915, 0.0008535520755685866, 0.0008330672862939537, 0.005335605703294277, 0.0009027037303894758, 0.004796338267624378, 0.00478943157941103, 0.0008968687034212053, 0.0009692381136119366, 0.004298765677958727, 0.004329849500209093, 0.0010153179755434394, 0.007802209816873074, 0.005591819062829018, 0.0057364823296666145, 0.00762467784807086, 0.0071179368533194065, 0.005880610551685095, 0.005988589022308588, 0.006995030678808689, 0.007953137159347534, 0.014506218023598194, 0.01439257338643074, 0.007814106531441212, 0.009567374363541603, 0.012362156994640827, 0.012121904641389847, 0.009318990632891655, 0.007711861282587051, 0.00920585822314024, 0.009392701089382172, 0.007914634421467781, 0.007968563586473465, 0.009656903333961964, 0.009842856787145138, 0.008178610354661942, 0.0008182502933777869, 0.005823689047247171, 0.005723231937736273, 0.0007785488851368427, 0.0006799690308980644, 0.005942426156252623, 0.005861931014806032, 0.0006697551580145955, 0.00901163462549448, 0.012099800631403923, 0.012129530310630798, 0.008814621716737747, 0.007408865261822939, 0.013107986189424992, 0.01295655407011509, 0.007266897242516279, 0.008217564783990383, 0.00482964189723134, 0.00482279434800148, 0.008347174152731895, 0.0053162118420004845, 0.004108870401978493, 0.003977712243795395, 0.005340076517313719, 0.001305176760070026, 0.005726182367652655, 0.005662696436047554, 0.0012406536843627691, 0.0009416795219294727, 0.006487607955932617, 0.006383040454238653, 0.0009151410195045173, 0.007790220435708761, 0.008309544064104557, 0.008516981266438961, 0.007677947171032429, 0.008681370876729488, 0.008667362853884697, 0.008838096633553505, 0.008604340255260468, 0.006960742175579071, 0.00860933493822813, 0.008266856893897057, 0.006933935452252626, 0.007527835667133331, 0.008480687625706196, 0.008150736801326275, 0.007450214121490717, 0.006971640046685934, 0.0018980056047439575, 0.0018114944687113166, 0.006829902995377779, 0.006280440837144852, 0.0011386352125555277, 0.0010919602354988456, 0.006090379320085049, 0.009127472527325153, 0.0019391118548810482, 0.001726187882013619, 0.009230115450918674, 0.008818699046969414, 0.0022089327685534954, 0.002057397738099098, 0.008902221918106079, 0.009466687217354774, 0.012004938907921314, 0.012096408754587173, 0.009312593378126621, 0.008389820344746113, 0.01298211608082056, 0.012951121665537357, 0.008337782695889473, 0.010576018132269382, 0.006096483673900366, 0.006112236529588699, 0.010303064249455929, 0.009896164759993553, 0.006895394995808601, 0.00694487988948822, 0.009699743241071701, 0.0015052002854645252, 0.007191657554358244, 0.007435341831296682, 0.0015143529744818807, 0.007015806157141924, 0.009205283597111702, 0.009161015972495079, 0.006814080756157637, 0.006821744609624147, 0.008477902039885521, 0.008365390822291374, 0.00672524981200695, 0.006543234921991825, 0.0012963581830263138, 0.0012853369116783142, 0.006405434105545282, 0.0073006716556847095, 0.000715400674380362, 0.00067937868880108, 0.007171716541051865, 0.011970090679824352, 0.013161780312657356, 0.012946751900017262, 0.012290204875171185, 0.014282737858593464, 0.010726508684456348, 0.010384619235992432, 0.01487593725323677, 0.01097018364816904, 0.012042791582643986, 0.01240271795541048, 0.010822860524058342, 0.008991573937237263, 0.012340456247329712, 0.012415653094649315, 0.008955446071922779, 0.01059779990464449, 0.010038639418780804, 0.010191594250500202, 0.010655602440237999, 0.008991597220301628, 0.01181139424443245, 0.011937419883906841, 0.009031851775944233, 0.007874250411987305, 0.010456752963364124, 0.010395546443760395, 0.007900181226432323, 0.00710831955075264, 0.011627432890236378, 0.011588603258132935, 0.007083273492753506, 0.007215877529233694, 0.010417558252811432, 0.010059024207293987, 0.007073032669723034, 0.0068807885982096195, 0.011202794499695301, 0.010908018797636032, 0.0067418720573186874, 0.006698281038552523, 0.011239965446293354, 0.011122387833893299, 0.006542886607348919, 0.006139413453638554, 0.011782512068748474, 0.01170868705958128, 0.005955745931714773, 0.0007680996204726398, 0.005571141839027405, 0.0055166929960250854, 0.0007881268975324929, 0.0007393442210741341, 0.005686479154974222, 0.005643120501190424, 0.000763503136113286, 0.001014343579299748, 0.005807823967188597, 0.005814582575112581, 0.0010254719527438283, 0.0013090533902868629, 0.005192262586206198, 0.005218721926212311, 0.0013114737812429667, 0.008749804459512234, 0.0044583952985703945, 0.0043401154689490795, 0.008420191705226898, 0.0027343372348695993, 0.000861270644236356, 0.0008996699471026659, 0.002689424203708768, 0.0008663808112032712, 0.004620961844921112, 0.004632692784070969, 0.0008602322195656598, 0.0008701900369487703, 0.004313874524086714, 0.004326042719185352, 0.0008769113337621093, 0.012992816977202892, 0.031687721610069275, 0.030183808878064156, 0.013488924130797386, 0.01873895153403282, 0.023395786061882973, 0.02255409210920334, 0.018619708716869354, 0.000749381200876087, 0.00575505755841732, 0.005858089774847031, 0.0007638182723894715, 0.0011177781270816922, 0.005432462785393, 0.00543117243796587, 0.0011894776253029704, 0.0012404329609125853, 0.004286551848053932, 0.00424969382584095, 0.0012552667176350951, 0.0008104278822429478, 0.004947705660015345, 0.004970346577465534, 0.0008453478221781552, 0.005950320512056351, 0.001464120694436133, 0.001461551059037447, 0.005742881912738085, 0.0052556744776666164, 0.0013034450821578503, 0.0013003131607547402, 0.00513231148943305, 0.008019224740564823, 0.0017429650761187077, 0.0016677099047228694, 0.008040585555136204, 0.007136686239391565, 0.002421638695523143, 0.0023714792914688587, 0.007073807530105114, 0.006208346225321293, 0.0010415096767246723, 0.0010606106370687485, 0.006120063364505768, 0.005514994729310274, 0.0014218396972864866, 0.001459387014620006, 0.005501625128090382, 0.0010714043164625764, 0.0044643087312579155, 0.004312236327677965, 0.0010615942301228642, 0.0008034739876165986, 0.004741917364299297, 0.004607167094945908, 0.0008402112871408463, 0.0033999087754637003, 0.0012062538880854845, 0.001218785298988223, 0.003335206303745508, 0.004097178112715483, 0.0006716941716149449, 0.0006915574194863439, 0.004016337916254997, 0.0006056587444618344, 0.003806560765951872, 0.003835798939689994, 0.0005664367927238345, 0.0009368836763314903, 0.003611993510276079, 0.003590574022382498, 0.0009199484484270215, 0.008269639685750008, 0.006965113803744316, 0.0069003053940832615, 0.00814963597804308, 0.007126596290618181, 0.007945986464619637, 0.0078663881868124, 0.007071188185364008, 0.0009465795592404902, 0.004470288287848234, 0.004517560824751854, 0.000951106077991426, 0.0007096120971255004, 0.003987702541053295, 0.003998653031885624, 0.0007295890827663243, 0.0011184696340933442, 0.005392758641391993, 0.005628689657896757, 0.0011957939714193344, 0.0008373680175282061, 0.005614140536636114, 0.005850072484463453, 0.0008993296651169658, 0.008924558758735657, 0.007246777415275574, 0.007168482523411512, 0.008949074894189835, 0.009879772551357746, 0.006426371168345213, 0.0066237673163414, 0.009706771932542324, 0.003973601385951042, 0.005206402391195297, 0.005391228478401899, 0.004103212151676416, 0.003259975230321288, 0.005084808450192213, 0.0052478681318461895, 0.0033835575450211763, 0.007018716540187597, 0.014648670330643654, 0.01463147159665823, 0.0068356129340827465, 0.0064248982816934586, 0.01140033733099699, 0.011446354910731316, 0.006419538054615259, 0.001320457085967064, 0.005910266190767288, 0.005997257307171822, 0.0013789928052574396, 0.0016714413650333881, 0.005613489542156458, 0.005715003702789545, 0.0016811826499179006, 0.0008410816080868244, 0.00537782022729516, 0.005391878075897694, 0.0009311047615483403, 0.00089892593678087, 0.00524244736880064, 0.005172281060367823, 0.0009754554484970868, 0.012645771726965904, 0.006137289106845856, 0.006159432698041201, 0.01288958452641964, 0.012276957742869854, 0.006093831267207861, 0.0062274569645524025, 0.012358964420855045, 0.007329627871513367, 0.009675203822553158, 0.009893960319459438, 0.0076058111153542995, 0.005115133244544268, 0.009084146469831467, 0.009260530583560467, 0.005318196956068277, 0.004878113511949778, 0.0008311860729008913, 0.0008685653447173536, 0.004792552441358566, 0.004290181677788496, 0.0010152158793061972, 0.0010372118558734655, 0.004214653745293617, 0.006200323812663555, 0.0020043011754751205, 0.0018943515606224537, 0.00623168284073472, 0.005587071646004915, 0.0018098833970725536, 0.0018277798080816865, 0.00556618208065629, 0.007096942514181137, 0.0019895294681191444, 0.0018431771313771605, 0.007048485800623894, 0.006782933138310909, 0.0015252581797540188, 0.0014398855855688453, 0.00675801420584321, 0.009661462157964706, 0.009748350828886032, 0.00957733765244484, 0.009510247968137264, 0.00842320453375578, 0.009861552156507969, 0.009602653793990612, 0.008338775485754013, 0.007558575365692377, 0.010616653598845005, 0.010413434356451035, 0.007563842460513115, 0.008647987619042397, 0.010987360961735249, 0.010798217728734016, 0.0086037153378129, 0.0007722531445324421, 0.005668691359460354, 0.005857111886143684, 0.000863003428094089, 0.001029539736919105, 0.005330353043973446, 0.005578224081546068, 0.0010860232869163156, 0.005929564591497183, 0.0007260354468598962, 0.0007262076251208782, 0.006014657206833363, 0.006584117654711008, 0.000575456244405359, 0.0006021943408995867, 0.006725223269313574, 0.0060731698758900166, 0.007593917660415173, 0.007516840472817421, 0.005918911658227444, 0.008480438962578773, 0.006313432473689318, 0.006494555622339249, 0.008230838924646378, 0.009203556925058365, 0.014848209917545319, 0.014376399107277393, 0.009053289890289307, 0.010332311503589153, 0.01096306461840868, 0.010705648921430111, 0.010222511366009712, 0.010374559089541435, 0.01033368892967701, 0.010474308393895626, 0.010242562741041183, 0.009964345954358578, 0.011035507544875145, 0.011128822341561317, 0.009819726459681988, 0.0033918628469109535, 0.0029683515895158052, 0.002868005307391286, 0.0034149654675275087, 0.004344456363469362, 0.10838103294372559, 0.10900197178125381, 0.004400618840008974, 0.005571302492171526, 0.10510200262069702, 0.10561992973089218, 0.005911571439355612, 0.006830522324889898, 0.09667789191007614, 0.09733985364437103, 0.006238339468836784, 0.0070887161418795586, 0.08493049442768097, 0.0858088955283165, 0.0075031160376966, 0.008431917987763882, 0.07092586159706116, 0.07178359478712082, 0.008067767135798931, 0.009099416434764862, 0.05518694594502449, 0.05598798021674156, 0.009422649629414082, 0.006841809023171663, 0.040860556066036224, 0.041427258402109146, 0.006789111066609621, 0.00866254884749651, 0.026566823944449425, 0.026864854618906975, 0.008939992636442184], "label_norm": {}, "label_norm_mm": {}}';class MediaPipeFaceMeshCalculator{constructor(e,i=!1,s){var o=a1_0x131724;this[o(966)]=c=>__awaiter(this,void 0,void 0,function*(){var d=o;return this[d(547)].send({image:c})}),this.close=()=>{var c=o;this.model[c(574)]()},this[o(819)]=e,this[o(547)]=new face_mesh.FaceMesh({locateFile:c=>"https://hallway.nyc3.cdn.digitaloceanspaces.com/face_mesh/0.4.1633559619/"+c}),this[o(898)]({selfieMode:i,refineLandmarks:s}),this[o(547)][o(584)](this[o(819)])}[a1_0x131724(855)](){return __awaiter(this,void 0,void 0,function*(){var e=a1_0x9238;return this[e(547)][e(615)]()})}[a1_0x131724(898)]({selfieMode:e,refineLandmarks:i}){var s=a1_0x131724;this[s(547)][s(898)]({maxNumFaces:1,minDetectionConfidence:.5,minTrackingConfidence:.5,refineLandmarks:i,selfieMode:e})}}const requestVideoFrameCallback=(a,e)=>{var i=a1_0x131724;return a!=null&&a[i(432)]?a.requestVideoFrameCallback(e):window[i(782)](e)},cancelVideoFrameCallback=(a,e)=>{var i=a1_0x131724;a!=null&&a[i(834)]?a[i(834)](e):window[i(868)](e)};class Stats{constructor(){var e=a1_0x131724;this[e(858)]=0,this._numTimes=0,this[e(486)]=0,this[e(907)]=0,this.updateInterval=1e3}get[a1_0x131724(931)](){return this._startTime}get[a1_0x131724(692)](){return this._numTimes}get timeSum(){var e=a1_0x131724;return this[e(486)]}get[a1_0x131724(820)](){var e=a1_0x131724;return this[e(907)]}[a1_0x131724(674)](){var e=a1_0x131724;this._startTime=(performance||Date)[e(459)]()}[a1_0x131724(909)](){var e=a1_0x131724;const i=(performance||Date).now();if(this[e(486)]+=i-this[e(931)],this[e(587)]++,i-this[e(907)]>=this[e(451)]){const s=this[e(486)]/this[e(587)];this[e(486)]=0,this._numTimes=0,this[e(821)]&&this[e(821)](s),this[e(907)]=i}}}var _AUPredictor_authenticate;const DEFAULT_FPS=40,lockKey="predictor-lock",lock=new AsyncLock;class AUPredictor{constructor(e){var i=a1_0x131724;this[i(362)]=performance[i(459)](),this[i(412)]=!1,this[i(508)]=document[i(472)](i(999)),this._dataStream=new Subject,this[i(901)]=i(926),this[i(425)]=new Stats,this.authenticate=()=>__awaiter(this,void 0,void 0,function*(){var b=i;return __classPrivateFieldGet(this,_AUPredictor_authenticate,"f")[b(794)](this)}),_AUPredictor_authenticate.set(this,()=>__awaiter(this,void 0,void 0,function*(){var b=i;try{const $=yield a1_0x436209.get(b(930),{headers:{authorization:b(589)+this[b(725)]}}),j=yield importSPKI(b(716),b(583));return yield jwtVerify($[b(991)],j,{issuer:b(573),audience:"urn:hallway:audience"}),!0}catch($){throw console[b(1004)]($),Error(b(536)+this[b(725)])}})),this[i(489)]=b=>__awaiter(this,void 0,void 0,function*(){var $=i;if(this[$(810)]!==$(926)){if(this[$(973)]&&cancelVideoFrameCallback(this[$(508)],this[$(973)]),(!this[$(490)]||this[$(508)][$(644)])&&this[$(903)](),!this.requestFrameToken)return;this[$(845)]()}this.lastFrameTime=performance[$(459)]();const j=yield this[$(983)][$(502)](b);this._faceStats[$(909)](),j&&(this[$(650)]&&this[$(741)](j),this._dataStream[$(396)](j))}),this[i(925)]=b=>__awaiter(this,void 0,void 0,function*(){var $=i;this[$(810)]!==$(926)&&(console[$(791)]("AVATAR_WEBKIT: predict was called while stream was not stoppped. Stopping stream..."),yield this[$(903)]()),yield this[$(615)](),yield this[$(876)][$(966)](b)});const{apiToken:s,fps:o=DEFAULT_FPS,onPredict:c,predictionQuality:d=i(874),shouldMirrorOutput:h=!1,refineLandmarks:g}=e;console[i(442)](i(988)+version),!s&&console[i(1004)](i(388)),this[i(508)][i(936)]=!0,this[i(508)][i(400)]=!0,this._video[i(699)]=!0,this[i(725)]=s,this._predictionQuality=d,this.faceMeshCalculator=new MediaPipeFaceMeshCalculator(this[i(489)],h,g??d===i(874)),this[i(983)]=new AvatarDenseCombinePredictor,this[i(650)]=c;const _=o>0?o:DEFAULT_FPS;this[i(769)]=1e3/_}[a1_0x131724(615)](){return __awaiter(this,void 0,void 0,function*(){var e=a1_0x9238;return lock.acquire(lockKey,()=>this[e(1006)]())})}[a1_0x131724(1006)](){var e=a1_0x131724;return!this[e(997)]&&(console[e(442)](e(911)),this[e(997)]=__classPrivateFieldGet(this,_AUPredictor_authenticate,"f").call(this).then(()=>Promise[e(968)]([this[e(876)][e(855)](),this.avatarDensePredictor[e(855)](this[e(739)])])).then(()=>console.log("AUPredictor initialized."))),this[e(997)]}get[a1_0x131724(540)](){return this._faceStats}get[a1_0x131724(941)](){var e=a1_0x131724;return this[e(817)]}get[a1_0x131724(999)](){var e=a1_0x131724;return this[e(508)]}get[a1_0x131724(490)](){var e=a1_0x131724;return this[e(620)]}get[a1_0x131724(810)](){return this._state}get[a1_0x131724(741)](){return this._onPredict}set[a1_0x131724(741)](e){var i=a1_0x131724;this[i(650)]=e}get[a1_0x131724(666)](){var e=a1_0x131724;return this[e(983)][e(666)]}[a1_0x131724(898)]({shouldMirrorOutput:e,predictionQuality:i,customBinFileUrl:s,customModelMetaUrl:o,customModelUrl:c,refineLandmarks:d}){return __awaiter(this,void 0,void 0,function*(){var h=a1_0x9238;this[h(739)]=i??this[h(739)],this[h(412)]=e??this[h(412)],yield this[h(903)](),d=d??i===h(874),this[h(876)][h(898)]({selfieMode:e,refineLandmarks:d}),yield this[h(983)][h(898)]({predictionQuality:i,customBinFileUrl:s,customModelMetaUrl:o,customModelUrl:c}),yield this[h(967)]({stream:this[h(490)]})})}start(e){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;return lock[i(641)](lockKey,()=>this[i(793)](e))})}[a1_0x131724(793)]({stream:e}){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;if(!e)throw Error(i(896)+e);if(!e[i(754)]()[i(640)])throw Error(i(831));const s=e[i(754)]()[0],o=this[i(620)]===e;this._stream=e;try{(this[i(901)]!==i(926)||this[i(973)])&&this._stop({stopStream:!o}),this._state=i(548);const{width:c,height:d}=s[i(685)]();this[i(508)][i(744)]=c,this[i(508)][i(499)]=d,this[i(508)][i(806)]=e,yield Promise.all([this[i(1006)](),this[i(508)][i(604)]()]),this[i(845)](),this[i(901)]="started"}catch(c){throw this._stop({stopStream:!o}),c}})}[a1_0x131724(903)](e={}){return __awaiter(this,void 0,void 0,function*(){var i=a1_0x9238;return lock[i(641)](lockKey,()=>this._stop(e))})}_stop({stopStream:e=!1}){var i;return __awaiter(this,void 0,void 0,function*(){var s=a1_0x9238;cancelVideoFrameCallback(this[s(508)],this[s(973)]),this[s(973)]=void 0,this[s(999)][s(806)]=null,e&&((i=this[s(620)])===null||i===void 0||i[s(891)]()[s(781)](o=>o[s(903)]()),this[s(620)]=void 0),this[s(901)]=s(926)})}setVideoFrameCallback(){var e=a1_0x131724;this[e(973)]=requestVideoFrameCallback(this[e(508)],()=>{var i=e;this._faceStats[i(674)](),this[i(876)][i(966)](this[i(508)])})}}_AUPredictor_authenticate=new WeakMap;var commonjsGlobal=typeof globalThis!==a1_0x131724(789)?globalThis:typeof window!==a1_0x131724(789)?window:typeof global$1!==a1_0x131724(789)?global$1:typeof self!==a1_0x131724(789)?self:{},long=Long,wasm=null;try{wasm=new WebAssembly[a1_0x131724(972)](new WebAssembly[a1_0x131724(832)](new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{})[a1_0x131724(460)]}catch{}function Long(a,e,i){var s=a1_0x131724;this[s(1019)]=a|0,this[s(874)]=e|0,this[s(660)]=!!i}Long[a1_0x131724(985)][a1_0x131724(553)],Object[a1_0x131724(600)](Long.prototype,a1_0x131724(553),{value:!0});function isLong(a){var e=a1_0x131724;return(a&&a[e(553)])===!0}Long[a1_0x131724(479)]=isLong;var INT_CACHE={},UINT_CACHE={};function fromInt(a,e){var i,s,o;return e?(a>>>=0,(o=0<=a&&a<256)&&(s=UINT_CACHE[a],s)?s:(i=fromBits(a,(a|0)<0?-1:0,!0),o&&(UINT_CACHE[a]=i),i)):(a|=0,(o=-128<=a&&a<128)&&(s=INT_CACHE[a],s)?s:(i=fromBits(a,a<0?-1:0,!1),o&&(INT_CACHE[a]=i),i))}Long[a1_0x131724(885)]=fromInt;function fromNumber(a,e){var i=a1_0x131724;if(isNaN(a))return e?UZERO:ZERO;if(e){if(a<0)return UZERO;if(a>=TWO_PWR_64_DBL)return MAX_UNSIGNED_VALUE}else{if(a<=-TWO_PWR_63_DBL)return MIN_VALUE;if(a+1>=TWO_PWR_63_DBL)return MAX_VALUE}return a<0?fromNumber(-a,e)[i(559)]():fromBits(a%TWO_PWR_32_DBL|0,a/TWO_PWR_32_DBL|0,e)}Long[a1_0x131724(683)]=fromNumber;function fromBits(a,e,i){return new Long(a,e,i)}Long[a1_0x131724(621)]=fromBits;var pow_dbl=Math.pow;function fromString(a,e,i){var s=a1_0x131724;if(a[s(640)]===0)throw Error("empty string");if(a==="NaN"||a===s(419)||a===s(477)||a==="-Infinity")return ZERO;if(typeof e===s(753)?(i=e,e=!1):e=!!e,i=i||10,i<2||36<i)throw RangeError(s(995));var o;if((o=a[s(390)]("-"))>0)throw Error(s(746));if(o===0)return fromString(a[s(649)](1),e,i).neg();for(var c=fromNumber(pow_dbl(i,8)),d=ZERO,h=0;h<a.length;h+=8){var g=Math[s(827)](8,a.length-h),_=parseInt(a[s(649)](h,h+g),i);if(g<8){var b=fromNumber(pow_dbl(i,g));d=d.mul(b)[s(523)](fromNumber(_))}else d=d[s(358)](c),d=d.add(fromNumber(_))}return d[s(660)]=e,d}Long.fromString=fromString;function fromValue(a,e){var i=a1_0x131724;return typeof a===i(753)?fromNumber(a,e):typeof a===i(1002)?fromString(a,e):fromBits(a[i(1019)],a[i(874)],typeof e===i(672)?e:a[i(660)])}Long[a1_0x131724(476)]=fromValue;var TWO_PWR_16_DBL=65536,TWO_PWR_24_DBL=1<<24,TWO_PWR_32_DBL=TWO_PWR_16_DBL*TWO_PWR_16_DBL,TWO_PWR_64_DBL=TWO_PWR_32_DBL*TWO_PWR_32_DBL,TWO_PWR_63_DBL=TWO_PWR_64_DBL/2,TWO_PWR_24=fromInt(TWO_PWR_24_DBL),ZERO=fromInt(0);Long[a1_0x131724(908)]=ZERO;var UZERO=fromInt(0,!0);Long.UZERO=UZERO;function a1_0x9238(a,e){var i=a1_0x3acb();return a1_0x9238=function(s,o){s=s-341;var c=i[s];return c},a1_0x9238(a,e)}var ONE=fromInt(1);Long[a1_0x131724(463)]=ONE;var UONE=fromInt(1,!0);Long[a1_0x131724(353)]=UONE;var NEG_ONE=fromInt(-1);Long[a1_0x131724(980)]=NEG_ONE;var MAX_VALUE=fromBits(-1,2147483647,!1);Long.MAX_VALUE=MAX_VALUE;var MAX_UNSIGNED_VALUE=fromBits(-1,-1,!0);Long.MAX_UNSIGNED_VALUE=MAX_UNSIGNED_VALUE;var MIN_VALUE=fromBits(0,-2147483648,!1);Long.MIN_VALUE=MIN_VALUE;var LongPrototype=Long[a1_0x131724(985)];LongPrototype[a1_0x131724(401)]=function(){var e=a1_0x131724;return this[e(660)]?this[e(1019)]>>>0:this[e(1019)]},LongPrototype[a1_0x131724(594)]=function(){var e=a1_0x131724;return this[e(660)]?(this[e(874)]>>>0)*TWO_PWR_32_DBL+(this[e(1019)]>>>0):this.high*TWO_PWR_32_DBL+(this.low>>>0)},LongPrototype[a1_0x131724(808)]=function(e){var i=a1_0x131724;if(e=e||10,e<2||36<e)throw RangeError(i(995));if(this[i(1016)]())return"0";if(this.isNegative())if(this.eq(MIN_VALUE)){var s=fromNumber(e),o=this[i(989)](s),c=o[i(358)](s).sub(this);return o.toString(e)+c[i(401)]().toString(e)}else return"-"+this[i(559)]()[i(808)](e);for(var d=fromNumber(pow_dbl(e,6),this[i(660)]),h=this,g="";;){var _=h[i(989)](d),b=h[i(461)](_[i(358)](d)).toInt()>>>0,$=b[i(808)](e);if(h=_,h.isZero())return $+g;for(;$[i(640)]<6;)$="0"+$;g=""+$+g}},LongPrototype[a1_0x131724(829)]=function(){var e=a1_0x131724;return this[e(874)]},LongPrototype[a1_0x131724(743)]=function(){var e=a1_0x131724;return this[e(874)]>>>0},LongPrototype[a1_0x131724(755)]=function(){var e=a1_0x131724;return this[e(1019)]},LongPrototype[a1_0x131724(462)]=function(){return this.low>>>0},LongPrototype[a1_0x131724(418)]=function(){var e=a1_0x131724;if(this[e(533)]())return this.eq(MIN_VALUE)?64:this[e(559)]()[e(418)]();for(var i=this[e(874)]!=0?this[e(874)]:this[e(1019)],s=31;s>0&&!(i&1<<s);s--);return this[e(874)]!=0?s+33:s+1},LongPrototype[a1_0x131724(1016)]=function(){var e=a1_0x131724;return this[e(874)]===0&&this.low===0},LongPrototype.eqz=LongPrototype[a1_0x131724(1016)],LongPrototype[a1_0x131724(533)]=function(){var e=a1_0x131724;return!this[e(660)]&&this.high<0},LongPrototype.isPositive=function(){var e=a1_0x131724;return this[e(660)]||this[e(874)]>=0},LongPrototype[a1_0x131724(943)]=function(){var e=a1_0x131724;return(this[e(1019)]&1)===1},LongPrototype[a1_0x131724(897)]=function(){var e=a1_0x131724;return(this[e(1019)]&1)===0},LongPrototype[a1_0x131724(869)]=function(e){var i=a1_0x131724;return isLong(e)||(e=fromValue(e)),this[i(660)]!==e.unsigned&&this[i(874)]>>>31===1&&e[i(874)]>>>31===1?!1:this[i(874)]===e.high&&this[i(1019)]===e[i(1019)]},LongPrototype.eq=LongPrototype[a1_0x131724(869)],LongPrototype.notEquals=function(e){return!this.eq(e)},LongPrototype[a1_0x131724(565)]=LongPrototype[a1_0x131724(532)],LongPrototype.ne=LongPrototype[a1_0x131724(532)],LongPrototype[a1_0x131724(535)]=function(e){var i=a1_0x131724;return this[i(591)](e)<0},LongPrototype.lt=LongPrototype[a1_0x131724(535)],LongPrototype[a1_0x131724(526)]=function(e){return this.comp(e)<=0},LongPrototype[a1_0x131724(1005)]=LongPrototype[a1_0x131724(526)],LongPrototype.le=LongPrototype[a1_0x131724(526)],LongPrototype[a1_0x131724(582)]=function(e){return this.comp(e)>0},LongPrototype.gt=LongPrototype[a1_0x131724(582)],LongPrototype[a1_0x131724(830)]=function(e){var i=a1_0x131724;return this[i(591)](e)>=0},LongPrototype.gte=LongPrototype[a1_0x131724(830)],LongPrototype.ge=LongPrototype.greaterThanOrEqual,LongPrototype.compare=function(e){var i=a1_0x131724;if(isLong(e)||(e=fromValue(e)),this.eq(e))return 0;var s=this.isNegative(),o=e[i(533)]();return s&&!o?-1:!s&&o?1:this.unsigned?e.high>>>0>this[i(874)]>>>0||e.high===this[i(874)]&&e[i(1019)]>>>0>this[i(1019)]>>>0?-1:1:this.sub(e).isNegative()?-1:1},LongPrototype[a1_0x131724(591)]=LongPrototype[a1_0x131724(406)],LongPrototype[a1_0x131724(413)]=function(){var e=a1_0x131724;return!this.unsigned&&this.eq(MIN_VALUE)?MIN_VALUE:this[e(521)]().add(ONE)},LongPrototype.neg=LongPrototype[a1_0x131724(413)],LongPrototype.add=function(e){var i=a1_0x131724;isLong(e)||(e=fromValue(e));var s=this[i(874)]>>>16,o=this.high&65535,c=this[i(1019)]>>>16,d=this[i(1019)]&65535,h=e.high>>>16,g=e[i(874)]&65535,_=e[i(1019)]>>>16,b=e[i(1019)]&65535,$=0,j=0,_e=0,tt=0;return tt+=d+b,_e+=tt>>>16,tt&=65535,_e+=c+_,j+=_e>>>16,_e&=65535,j+=o+g,$+=j>>>16,j&=65535,$+=s+h,$&=65535,fromBits(_e<<16|tt,$<<16|j,this[i(660)])},LongPrototype.subtract=function(e){var i=a1_0x131724;return isLong(e)||(e=fromValue(e)),this[i(523)](e[i(559)]())},LongPrototype.sub=LongPrototype.subtract,LongPrototype.multiply=function(e){var i=a1_0x131724;if(this[i(1016)]())return ZERO;if(isLong(e)||(e=fromValue(e)),wasm){var s=wasm[i(358)](this[i(1019)],this.high,e.low,e[i(874)]);return fromBits(s,wasm.get_high(),this[i(660)])}if(e.isZero())return ZERO;if(this.eq(MIN_VALUE))return e.isOdd()?MIN_VALUE:ZERO;if(e.eq(MIN_VALUE))return this[i(943)]()?MIN_VALUE:ZERO;if(this[i(533)]())return e[i(533)]()?this[i(559)]().mul(e.neg()):this[i(559)]()[i(358)](e)[i(559)]();if(e.isNegative())return this[i(358)](e[i(559)]())[i(559)]();if(this.lt(TWO_PWR_24)&&e.lt(TWO_PWR_24))return fromNumber(this[i(594)]()*e[i(594)](),this[i(660)]);var o=this[i(874)]>>>16,c=this[i(874)]&65535,d=this[i(1019)]>>>16,h=this.low&65535,g=e[i(874)]>>>16,_=e[i(874)]&65535,b=e[i(1019)]>>>16,$=e.low&65535,j=0,_e=0,tt=0,et=0;return et+=h*$,tt+=et>>>16,et&=65535,tt+=d*$,_e+=tt>>>16,tt&=65535,tt+=h*b,_e+=tt>>>16,tt&=65535,_e+=c*$,j+=_e>>>16,_e&=65535,_e+=d*b,j+=_e>>>16,_e&=65535,_e+=h*_,j+=_e>>>16,_e&=65535,j+=o*$+c*b+d*_+h*g,j&=65535,fromBits(tt<<16|et,j<<16|_e,this[i(660)])},LongPrototype[a1_0x131724(358)]=LongPrototype[a1_0x131724(733)],LongPrototype.divide=function(e){var i=a1_0x131724;if(isLong(e)||(e=fromValue(e)),e[i(1016)]())throw Error(i(937));if(wasm){if(!this.unsigned&&this[i(874)]===-2147483648&&e[i(1019)]===-1&&e[i(874)]===-1)return this;var s=(this.unsigned?wasm[i(546)]:wasm[i(379)])(this[i(1019)],this[i(874)],e[i(1019)],e[i(874)]);return fromBits(s,wasm[i(680)](),this[i(660)])}if(this[i(1016)]())return this.unsigned?UZERO:ZERO;var o,c,d;if(this.unsigned){if(e[i(660)]||(e=e[i(606)]()),e.gt(this))return UZERO;if(e.gt(this.shru(1)))return UONE;d=UZERO}else{if(this.eq(MIN_VALUE)){if(e.eq(ONE)||e.eq(NEG_ONE))return MIN_VALUE;if(e.eq(MIN_VALUE))return ONE;var h=this[i(877)](1);return o=h[i(989)](e)[i(424)](1),o.eq(ZERO)?e[i(533)]()?ONE:NEG_ONE:(c=this[i(461)](e[i(358)](o)),d=o.add(c[i(989)](e)),d)}else if(e.eq(MIN_VALUE))return this[i(660)]?UZERO:ZERO;if(this[i(533)]())return e.isNegative()?this[i(559)]().div(e.neg()):this[i(559)]()[i(989)](e)[i(559)]();if(e[i(533)]())return this[i(989)](e[i(559)]())[i(559)]();d=ZERO}for(c=this;c[i(679)](e);){o=Math.max(1,Math[i(712)](c[i(594)]()/e[i(594)]()));for(var g=Math[i(363)](Math[i(442)](o)/Math[i(962)]),_=g<=48?1:pow_dbl(2,g-48),b=fromNumber(o),$=b[i(358)](e);$[i(533)]()||$.gt(c);)o-=_,b=fromNumber(o,this[i(660)]),$=b.mul(e);b.isZero()&&(b=ONE),d=d[i(523)](b),c=c[i(461)]($)}return d},LongPrototype[a1_0x131724(989)]=LongPrototype[a1_0x131724(848)],LongPrototype[a1_0x131724(946)]=function(e){var i=a1_0x131724;if(isLong(e)||(e=fromValue(e)),wasm){var s=(this[i(660)]?wasm[i(570)]:wasm.rem_s)(this.low,this[i(874)],e[i(1019)],e.high);return fromBits(s,wasm.get_high(),this[i(660)])}return this[i(461)](this[i(989)](e)[i(358)](e))},LongPrototype[a1_0x131724(689)]=LongPrototype.modulo,LongPrototype[a1_0x131724(735)]=LongPrototype[a1_0x131724(946)],LongPrototype[a1_0x131724(521)]=function(){var e=a1_0x131724;return fromBits(~this.low,~this[e(874)],this[e(660)])},LongPrototype[a1_0x131724(423)]=function(e){var i=a1_0x131724;return isLong(e)||(e=fromValue(e)),fromBits(this[i(1019)]&e[i(1019)],this[i(874)]&e[i(874)],this[i(660)])},LongPrototype.or=function(e){var i=a1_0x131724;return isLong(e)||(e=fromValue(e)),fromBits(this[i(1019)]|e[i(1019)],this[i(874)]|e[i(874)],this.unsigned)},LongPrototype[a1_0x131724(740)]=function(e){var i=a1_0x131724;return isLong(e)||(e=fromValue(e)),fromBits(this[i(1019)]^e[i(1019)],this[i(874)]^e[i(874)],this.unsigned)},LongPrototype[a1_0x131724(408)]=function(e){var i=a1_0x131724;return isLong(e)&&(e=e[i(401)]()),(e&=63)===0?this:e<32?fromBits(this.low<<e,this[i(874)]<<e|this[i(1019)]>>>32-e,this[i(660)]):fromBits(0,this.low<<e-32,this[i(660)])},LongPrototype[a1_0x131724(424)]=LongPrototype[a1_0x131724(408)],LongPrototype[a1_0x131724(882)]=function(e){var i=a1_0x131724;return isLong(e)&&(e=e[i(401)]()),(e&=63)===0?this:e<32?fromBits(this[i(1019)]>>>e|this[i(874)]<<32-e,this.high>>e,this[i(660)]):fromBits(this[i(874)]>>e-32,this.high>=0?0:-1,this.unsigned)},LongPrototype[a1_0x131724(877)]=LongPrototype[a1_0x131724(882)],LongPrototype[a1_0x131724(1021)]=function(e){var i=a1_0x131724;if(isLong(e)&&(e=e.toInt()),e&=63,e===0)return this;var s=this[i(874)];if(e<32){var o=this[i(1019)];return fromBits(o>>>e|s<<32-e,s>>>e,this[i(660)])}else return e===32?fromBits(s,0,this[i(660)]):fromBits(s>>>e-32,0,this.unsigned)},LongPrototype[a1_0x131724(854)]=LongPrototype[a1_0x131724(1021)],LongPrototype[a1_0x131724(894)]=LongPrototype[a1_0x131724(1021)],LongPrototype[a1_0x131724(633)]=function(){var e=a1_0x131724;return this.unsigned?fromBits(this[e(1019)],this[e(874)],!1):this},LongPrototype.toUnsigned=function(){var e=a1_0x131724;return this[e(660)]?this:fromBits(this[e(1019)],this.high,!0)},LongPrototype[a1_0x131724(617)]=function(e){var i=a1_0x131724;return e?this[i(760)]():this[i(922)]()},LongPrototype.toBytesLE=function(){var e=a1_0x131724,i=this[e(874)],s=this[e(1019)];return[s&255,s>>>8&255,s>>>16&255,s>>>24,i&255,i>>>8&255,i>>>16&255,i>>>24]},LongPrototype[a1_0x131724(922)]=function(){var e=a1_0x131724,i=this[e(874)],s=this[e(1019)];return[i>>>24,i>>>16&255,i>>>8&255,i&255,s>>>24,s>>>16&255,s>>>8&255,s&255]},Long[a1_0x131724(737)]=function(e,i,s){var o=a1_0x131724;return s?Long.fromBytesLE(e,i):Long[o(511)](e,i)},Long[a1_0x131724(398)]=function(e,i){return new Long(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,i)},Long[a1_0x131724(511)]=function(e,i){return new Long(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],i)};var minimal$1={exports:{}},indexMinimal={},minimal={},aspromise=asPromise;function asPromise(a,e){for(var i=a1_0x131724,s=new Array(arguments[i(640)]-1),o=0,c=2,d=!0;c<arguments[i(640)];)s[o++]=arguments[c++];return new Promise(function(g,_){var b=i;s[o]=function(j){var _e=a1_0x9238;if(d)if(d=!1,j)_(j);else{for(var tt=new Array(arguments[_e(640)]-1),et=0;et<tt[_e(640)];)tt[et++]=arguments[et];g.apply(null,tt)}};try{a[b(613)](e||null,s)}catch($){d&&(d=!1,_($))}})}var base64$1={};(function(a){var e=a1_0x131724,i=a;i[e(640)]=function(g){var _=e,b=g.length;if(!b)return 0;for(var $=0;--b%4>1&&g[_(702)](b)==="=";)++$;return Math[_(363)](g.length*3)/4-$};for(var s=new Array(64),o=new Array(123),c=0;c<64;)o[s[c]=c<26?c+65:c<52?c+71:c<62?c-4:c-59|43]=c++;i[e(884)]=function(g,_,b){for(var $=e,j=null,_e=[],tt=0,et=0,nt;_<b;){var rt=g[_++];switch(et){case 0:_e[tt++]=s[rt>>2],nt=(rt&3)<<4,et=1;break;case 1:_e[tt++]=s[nt|rt>>4],nt=(rt&15)<<2,et=2;break;case 2:_e[tt++]=s[nt|rt>>6],_e[tt++]=s[rt&63],et=0;break}tt>8191&&((j||(j=[]))[$(688)](String[$(1001)].apply(String,_e)),tt=0)}return et&&(_e[tt++]=s[nt],_e[tt++]=61,et===1&&(_e[tt++]=61)),j?(tt&&j.push(String[$(1001)][$(613)](String,_e[$(944)](0,tt))),j[$(867)]("")):String[$(1001)][$(613)](String,_e[$(944)](0,tt))};var d=e(701);i.decode=function(g,_,b){for(var $=e,j=b,_e=0,tt,et=0;et<g.length;){var nt=g[$(742)](et++);if(nt===61&&_e>1)break;if((nt=o[nt])===void 0)throw Error(d);switch(_e){case 0:tt=nt,_e=1;break;case 1:_[b++]=tt<<2|(nt&48)>>4,tt=nt,_e=2;break;case 2:_[b++]=(tt&15)<<4|(nt&60)>>2,tt=nt,_e=3;break;case 3:_[b++]=(tt&3)<<6|nt,_e=0;break}}if(_e===1)throw Error(d);return b-j},i.test=function(g){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(g)}})(base64$1);var eventemitter=EventEmitter;function EventEmitter(){var a=a1_0x131724;this[a(732)]={}}EventEmitter[a1_0x131724(985)].on=function(e,i,s){var o=a1_0x131724;return(this[o(732)][e]||(this[o(732)][e]=[]))[o(688)]({fn:i,ctx:s||this}),this},EventEmitter[a1_0x131724(985)][a1_0x131724(777)]=function(e,i){var s=a1_0x131724;if(e===void 0)this[s(732)]={};else if(i===void 0)this[s(732)][e]=[];else for(var o=this[s(732)][e],c=0;c<o[s(640)];)o[c].fn===i?o[s(510)](c,1):++c;return this},EventEmitter[a1_0x131724(985)].emit=function(e){var i=a1_0x131724,s=this._listeners[e];if(s){for(var o=[],c=1;c<arguments[i(640)];)o[i(688)](arguments[c++]);for(c=0;c<s[i(640)];)s[c].fn[i(613)](s[c++][i(500)],o)}return this};var float=factory(factory);function factory(a){var e=a1_0x131724;return typeof Float32Array!==e(789)?function(){var i=e,s=new Float32Array([-0]),o=new Uint8Array(s[i(786)]),c=o[3]===128;function d(b,$,j){s[0]=b,$[j]=o[0],$[j+1]=o[1],$[j+2]=o[2],$[j+3]=o[3]}function h(b,$,j){s[0]=b,$[j]=o[3],$[j+1]=o[2],$[j+2]=o[1],$[j+3]=o[0]}a[i(955)]=c?d:h,a[i(595)]=c?h:d;function g(b,$){return o[0]=b[$],o[1]=b[$+1],o[2]=b[$+2],o[3]=b[$+3],s[0]}function _(b,$){return o[3]=b[$],o[2]=b[$+1],o[1]=b[$+2],o[0]=b[$+3],s[0]}a.readFloatLE=c?g:_,a[i(805)]=c?_:g}():function(){var i=e;function s(c,d,h,g){var _=a1_0x9238,b=d<0?1:0;if(b&&(d=-d),d===0)c(1/d>0?0:2147483648,h,g);else if(isNaN(d))c(2143289344,h,g);else if(d>34028234663852886e22)c((b<<31|2139095040)>>>0,h,g);else if(d<11754943508222875e-54)c((b<<31|Math[_(372)](d/1401298464324817e-60))>>>0,h,g);else{var $=Math.floor(Math[_(442)](d)/Math[_(962)]),j=Math.round(d*Math[_(1011)](2,-$)*8388608)&8388607;c((b<<31|$+127<<23|j)>>>0,h,g)}}a[i(955)]=s.bind(null,writeUintLE),a.writeFloatBE=s[i(557)](null,writeUintBE);function o(c,d,h){var g=i,_=c(d,h),b=(_>>31)*2+1,$=_>>>23&255,j=_&8388607;return $===255?j?NaN:b*(1/0):$===0?b*1401298464324817e-60*j:b*Math[g(1011)](2,$-150)*(j+8388608)}a.readFloatLE=o[i(557)](null,readUintLE),a[i(805)]=o[i(557)](null,readUintBE)}(),typeof Float64Array!==e(789)?function(){var i=e,s=new Float64Array([-0]),o=new Uint8Array(s[i(786)]),c=o[7]===128;function d(b,$,j){s[0]=b,$[j]=o[0],$[j+1]=o[1],$[j+2]=o[2],$[j+3]=o[3],$[j+4]=o[4],$[j+5]=o[5],$[j+6]=o[6],$[j+7]=o[7]}function h(b,$,j){s[0]=b,$[j]=o[7],$[j+1]=o[6],$[j+2]=o[5],$[j+3]=o[4],$[j+4]=o[3],$[j+5]=o[2],$[j+6]=o[1],$[j+7]=o[0]}a[i(961)]=c?d:h,a[i(630)]=c?h:d;function g(b,$){return o[0]=b[$],o[1]=b[$+1],o[2]=b[$+2],o[3]=b[$+3],o[4]=b[$+4],o[5]=b[$+5],o[6]=b[$+6],o[7]=b[$+7],s[0]}function _(b,$){return o[7]=b[$],o[6]=b[$+1],o[5]=b[$+2],o[4]=b[$+3],o[3]=b[$+4],o[2]=b[$+5],o[1]=b[$+6],o[0]=b[$+7],s[0]}a[i(932)]=c?g:_,a[i(1018)]=c?_:g}():function(){var i=e;function s(c,d,h,g,_,b){var $=a1_0x9238,j=g<0?1:0;if(j&&(g=-g),g===0)c(0,_,b+d),c(1/g>0?0:2147483648,_,b+h);else if(isNaN(g))c(0,_,b+d),c(2146959360,_,b+h);else if(g>17976931348623157e292)c(0,_,b+d),c((j<<31|2146435072)>>>0,_,b+h);else{var _e;if(g<22250738585072014e-324)_e=g/5e-324,c(_e>>>0,_,b+d),c((j<<31|_e/4294967296)>>>0,_,b+h);else{var tt=Math.floor(Math.log(g)/Math[$(962)]);tt===1024&&(tt=1023),_e=g*Math.pow(2,-tt),c(_e*4503599627370496>>>0,_,b+d),c((j<<31|tt+1023<<20|_e*1048576&1048575)>>>0,_,b+h)}}}a.writeDoubleLE=s[i(557)](null,writeUintLE,0,4),a[i(630)]=s[i(557)](null,writeUintBE,4,0);function o(c,d,h,g,_){var b=i,$=c(g,_+d),j=c(g,_+h),_e=(j>>31)*2+1,tt=j>>>20&2047,et=4294967296*(j&1048575)+$;return tt===2047?et?NaN:_e*(1/0):tt===0?_e*5e-324*et:_e*Math[b(1011)](2,tt-1075)*(et+4503599627370496)}a[i(932)]=o[i(557)](null,readUintLE,0,4),a[i(1018)]=o[i(557)](null,readUintBE,4,0)}(),a}function writeUintLE(a,e,i){e[i]=a&255,e[i+1]=a>>>8&255,e[i+2]=a>>>16&255,e[i+3]=a>>>24}function writeUintBE(a,e,i){e[i]=a>>>24,e[i+1]=a>>>16&255,e[i+2]=a>>>8&255,e[i+3]=a&255}function readUintLE(a,e){return(a[e]|a[e+1]<<8|a[e+2]<<16|a[e+3]<<24)>>>0}function readUintBE(a,e){return(a[e]<<24|a[e+1]<<16|a[e+2]<<8|a[e+3])>>>0}var inquire_1=inquire;function inquire(_0x5312eb){var _0x389cb2=a1_0x131724;try{var _0x24c07a=eval("quire"[_0x389cb2(824)](/^/,"re"))(_0x5312eb);if(_0x24c07a&&(_0x24c07a.length||Object[_0x389cb2(637)](_0x24c07a)[_0x389cb2(640)]))return _0x24c07a}catch(a){}return null}var utf8$2={};(function(a){var e=a1_0x131724,i=a;i[e(640)]=function(o){for(var c=e,d=0,h=0,g=0;g<o[c(640)];++g)h=o[c(742)](g),h<128?d+=1:h<2048?d+=2:(h&64512)===55296&&(o[c(742)](g+1)&64512)===56320?(++g,d+=4):d+=3;return d},i[e(687)]=function(o,c,d){var h=e,g=d-c;if(g<1)return"";for(var _=null,b=[],$=0,j;c<d;)j=o[c++],j<128?b[$++]=j:j>191&&j<224?b[$++]=(j&31)<<6|o[c++]&63:j>239&&j<365?(j=((j&7)<<18|(o[c++]&63)<<12|(o[c++]&63)<<6|o[c++]&63)-65536,b[$++]=55296+(j>>10),b[$++]=56320+(j&1023)):b[$++]=(j&15)<<12|(o[c++]&63)<<6|o[c++]&63,$>8191&&((_||(_=[]))[h(688)](String[h(1001)][h(613)](String,b)),$=0);return _?($&&_[h(688)](String[h(1001)].apply(String,b[h(944)](0,$))),_[h(867)]("")):String[h(1001)].apply(String,b[h(944)](0,$))},i[e(1013)]=function(o,c,d){for(var h=e,g=d,_,b,$=0;$<o.length;++$)_=o[h(742)]($),_<128?c[d++]=_:_<2048?(c[d++]=_>>6|192,c[d++]=_&63|128):(_&64512)===55296&&((b=o[h(742)]($+1))&64512)===56320?(_=65536+((_&1023)<<10)+(b&1023),++$,c[d++]=_>>18|240,c[d++]=_>>12&63|128,c[d++]=_>>6&63|128,c[d++]=_&63|128):(c[d++]=_>>12|224,c[d++]=_>>6&63|128,c[d++]=_&63|128);return d-g}})(utf8$2);var pool_1=pool;function pool(a,e,i){var s=i||8192,o=s>>>1,c=null,d=s;return function(g){if(g<1||g>o)return a(g);d+g>s&&(c=a(s),d=0);var _=e.call(c,d,d+=g);return d&7&&(d=(d|7)+1),_}}var longbits,hasRequiredLongbits;function requireLongbits(){var a=a1_0x131724;if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=i;var e=requireMinimal();function i(d,h){this.lo=d>>>0,this.hi=h>>>0}var s=i.zero=new i(0,0);s[a(594)]=function(){return 0},s[a(382)]=s.zzDecode=function(){return this},s[a(640)]=function(){return 1};var o=i.zeroHash=a(964);i[a(683)]=function(h){if(h===0)return s;var g=h<0;g&&(h=-h);var _=h>>>0,b=(h-_)/4294967296>>>0;return g&&(b=~b>>>0,_=~_>>>0,++_>4294967295&&(_=0,++b>4294967295&&(b=0))),new i(_,b)},i[a(864)]=function(h){var g=a;if(typeof h=="number")return i[g(683)](h);if(e[g(776)](h))if(e[g(728)])h=e[g(728)][g(765)](h);else return i[g(683)](parseInt(h,10));return h[g(1019)]||h[g(874)]?new i(h[g(1019)]>>>0,h[g(874)]>>>0):s},i.prototype[a(594)]=function(h){if(!h&&this.hi>>>31){var g=~this.lo+1>>>0,_=~this.hi>>>0;return g||(_=_+1>>>0),-(g+_*4294967296)}return this.lo+this.hi*4294967296},i[a(985)].toLong=function(h){var g=a;return e[g(728)]?new e.Long(this.lo|0,this.hi|0,!!h):{low:this.lo|0,high:this.hi|0,unsigned:!!h}};var c=String[a(985)].charCodeAt;return i.fromHash=function(h){var g=a;return h===o?s:new i((c[g(794)](h,0)|c[g(794)](h,1)<<8|c[g(794)](h,2)<<16|c[g(794)](h,3)<<24)>>>0,(c.call(h,4)|c[g(794)](h,5)<<8|c[g(794)](h,6)<<16|c[g(794)](h,7)<<24)>>>0)},i[a(985)][a(586)]=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},i[a(985)][a(382)]=function(){var h=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^h)>>>0,this.lo=(this.lo<<1^h)>>>0,this},i[a(985)].zzDecode=function(){var h=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^h)>>>0,this.hi=(this.hi>>>1^h)>>>0,this},i.prototype.length=function(){var h=this.lo,g=(this.lo>>>28|this.hi<<4)>>>0,_=this.hi>>>24;return _===0?g===0?h<16384?h<128?1:2:h<2097152?3:4:g<16384?g<128?5:6:g<2097152?7:8:_<128?9:10},longbits}var hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,function(a){var e=a1_0x9238,i=a;i[e(429)]=aspromise,i[e(663)]=base64$1,i[e(426)]=eventemitter,i[e(835)]=float,i[e(527)]=inquire_1,i[e(872)]=utf8$2,i[e(708)]=pool_1,i[e(799)]=requireLongbits(),i[e(607)]=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal[e(436)]&&commonjsGlobal[e(436)][e(772)]&&commonjsGlobal[e(436)][e(772)][e(505)]),i.global=i.isNode&&commonjsGlobal||typeof window!==e(789)&&window||typeof self!==e(789)&&self||commonjsGlobal,i[e(647)]=Object.freeze?Object[e(378)]([]):[],i[e(915)]=Object[e(378)]?Object[e(378)]({}):{},i[e(632)]=Number.isInteger||function(d){var h=e;return typeof d===h(753)&&isFinite(d)&&Math[h(712)](d)===d},i[e(776)]=function(d){return typeof d=="string"||d instanceof String},i[e(659)]=function(d){var h=e;return d&&typeof d===h(984)},i[e(706)]=i[e(863)]=function(d,h){var g=e,_=d[h];return _!=null&&d[g(949)](h)?typeof _!==g(984)||(Array[g(571)](_)?_[g(640)]:Object[g(637)](_)[g(640)])>0:!1},i[e(934)]=function(){var c=e;try{var d=i[c(527)](c(786))[c(934)];return d[c(985)][c(491)]?d:null}catch{return null}}(),i[e(602)]=null,i[e(1e3)]=null,i.newBuffer=function(d){var h=e;return typeof d===h(753)?i[h(934)]?i._Buffer_allocUnsafe(d):new i[h(1007)](d):i[h(934)]?i._Buffer_from(d):typeof Uint8Array===h(789)?d:new Uint8Array(d)},i[e(1007)]=typeof Uint8Array!==e(789)?Uint8Array:Array,i[e(728)]=i[e(341)].dcodeIO&&i.global[e(514)].Long||i[e(341)][e(728)]||i[e(527)](e(465)),i[e(438)]=/^true|false|0|1$/,i[e(880)]=/^-?(?:0|[1-9][0-9]*)$/,i.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,i.longToHash=function(d){var h=e;return d?i[h(799)][h(864)](d)[h(586)]():i[h(799)].zeroHash},i[e(351)]=function(d,h){var g=e,_=i.LongBits.fromHash(d);return i.Long?i[g(728)][g(621)](_.lo,_.hi,h):_[g(594)](!!h)};function s(c,d,h){for(var g=e,_=Object[g(637)](d),b=0;b<_[g(640)];++b)(c[_[b]]===void 0||!h)&&(c[_[b]]=d[_[b]]);return c}i[e(493)]=s,i.lcFirst=function(d){var h=e;return d.charAt(0)[h(800)]()+d[h(649)](1)};function o(c){var d=e;function h(g,_){var b=a1_0x9238;if(!(this instanceof h))return new h(g,_);Object.defineProperty(this,b(519),{get:function(){return g}}),Error[b(469)]?Error[b(469)](this,h):Object[b(600)](this,"stack",{value:new Error()[b(403)]||""}),_&&s(this,_)}return(h[d(985)]=Object[d(811)](Error[d(985)]))[d(449)]=h,Object[d(600)](h[d(985)],"name",{get:function(){return c}}),h[d(985)][d(808)]=function(){var _=d;return this.name+": "+this[_(519)]},h}i[e(389)]=o,i[e(923)]=o(e(923)),i[e(381)]=function(d){for(var h={},g=0;g<d.length;++g)h[d[g]]=1;return function(){for(var _=a1_0x9238,b=Object[_(637)](this),$=b[_(640)]-1;$>-1;--$)if(h[b[$]]===1&&this[b[$]]!==void 0&&this[b[$]]!==null)return b[$]}},i[e(682)]=function(d){return function(h){for(var g=a1_0x9238,_=0;_<d[g(640)];++_)d[_]!==h&&delete this[d[_]]}},i[e(690)]={longs:String,enums:String,bytes:String,json:!0},i[e(441)]=function(){var c=e,d=i[c(934)];if(!d){i._Buffer_from=i[c(1e3)]=null;return}i[c(602)]=d.from!==Uint8Array[c(864)]&&d[c(864)]||function(g,_){return new d(g,_)},i[c(1e3)]=d.allocUnsafe||function(g){return new d(g)}}}(minimal)),minimal}var writer=Writer$1,util$4=requireMinimal(),BufferWriter$1,LongBits$1=util$4[a1_0x131724(799)],base64=util$4[a1_0x131724(663)],utf8$1=util$4[a1_0x131724(872)];function Op(a,e,i){var s=a1_0x131724;this.fn=a,this.len=e,this[s(396)]=void 0,this[s(730)]=i}function noop(){}function State(a){var e=a1_0x131724;this.head=a.head,this[e(718)]=a[e(718)],this[e(913)]=a.len,this[e(396)]=a[e(629)]}function Writer$1(){var a=a1_0x131724;this[a(913)]=0,this[a(410)]=new Op(noop,0,0),this[a(718)]=this[a(410)],this.states=null}var create$1=function a(){return util$4.Buffer?function(){var i=a1_0x9238;return(Writer$1[i(811)]=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1[a1_0x131724(811)]=create$1(),Writer$1[a1_0x131724(651)]=function a(e){return new util$4.Array(e)};util$4[a1_0x131724(1007)]!==Array&&(Writer$1[a1_0x131724(651)]=util$4[a1_0x131724(708)](Writer$1[a1_0x131724(651)],util$4[a1_0x131724(1007)][a1_0x131724(985)][a1_0x131724(694)]));Writer$1[a1_0x131724(985)]._push=function a(e,i,s){var o=a1_0x131724;return this[o(718)]=this[o(718)][o(396)]=new Op(e,i,s),this[o(913)]+=i,this};function writeByte(a,e,i){e[i]=a&255}function writeVarint32(a,e,i){for(;a>127;)e[i++]=a&127|128,a>>>=7;e[i]=a}function VarintOp(a,e){var i=a1_0x131724;this[i(913)]=a,this[i(396)]=void 0,this.val=e}VarintOp[a1_0x131724(985)]=Object[a1_0x131724(811)](Op.prototype),VarintOp.prototype.fn=writeVarint32,Writer$1[a1_0x131724(985)].uint32=function a(e){var i=a1_0x131724;return this[i(913)]+=(this.tail=this[i(718)][i(396)]=new VarintOp((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e))[i(913)],this},Writer$1.prototype[a1_0x131724(841)]=function a(e){var i=a1_0x131724;return e<0?this[i(969)](writeVarint64,10,LongBits$1[i(683)](e)):this[i(773)](e)},Writer$1.prototype[a1_0x131724(380)]=function a(e){var i=a1_0x131724;return this[i(773)]((e<<1^e>>31)>>>0)};function writeVarint64(a,e,i){for(;a.hi;)e[i++]=a.lo&127|128,a.lo=(a.lo>>>7|a.hi<<25)>>>0,a.hi>>>=7;for(;a.lo>127;)e[i++]=a.lo&127|128,a.lo=a.lo>>>7;e[i++]=a.lo}Writer$1[a1_0x131724(985)][a1_0x131724(795)]=function a(e){var i=a1_0x131724,s=LongBits$1.from(e);return this._push(writeVarint64,s[i(640)](),s)},Writer$1[a1_0x131724(985)].int64=Writer$1[a1_0x131724(985)][a1_0x131724(795)],Writer$1[a1_0x131724(985)][a1_0x131724(572)]=function a(e){var i=a1_0x131724,s=LongBits$1[i(864)](e)[i(382)]();return this[i(969)](writeVarint64,s.length(),s)},Writer$1[a1_0x131724(985)].bool=function a(e){var i=a1_0x131724;return this[i(969)](writeByte,1,e?1:0)};function writeFixed32(a,e,i){e[i]=a&255,e[i+1]=a>>>8&255,e[i+2]=a>>>16&255,e[i+3]=a>>>24}Writer$1[a1_0x131724(985)].fixed32=function a(e){var i=a1_0x131724;return this[i(969)](writeFixed32,4,e>>>0)},Writer$1[a1_0x131724(985)][a1_0x131724(480)]=Writer$1[a1_0x131724(985)][a1_0x131724(993)],Writer$1.prototype[a1_0x131724(665)]=function a(e){var i=a1_0x131724,s=LongBits$1[i(864)](e);return this._push(writeFixed32,4,s.lo)._push(writeFixed32,4,s.hi)},Writer$1[a1_0x131724(985)].sfixed64=Writer$1[a1_0x131724(985)][a1_0x131724(665)],Writer$1.prototype.float=function a(e){var i=a1_0x131724;return this._push(util$4[i(835)].writeFloatLE,4,e)},Writer$1[a1_0x131724(985)][a1_0x131724(952)]=function a(e){var i=a1_0x131724;return this[i(969)](util$4[i(835)].writeDoubleLE,8,e)};var writeBytes=util$4[a1_0x131724(1007)][a1_0x131724(985)].set?function a(e,i,s){var o=a1_0x131724;i[o(802)](e,s)}:function a(e,i,s){for(var o=a1_0x131724,c=0;c<e[o(640)];++c)i[s+c]=e[c]};Writer$1[a1_0x131724(985)].bytes=function a(e){var i=a1_0x131724,s=e[i(640)]>>>0;if(!s)return this[i(969)](writeByte,1,0);if(util$4[i(776)](e)){var o=Writer$1.alloc(s=base64[i(640)](e));base64[i(905)](e,o,0),e=o}return this[i(773)](s)[i(969)](writeBytes,s,e)},Writer$1[a1_0x131724(985)][a1_0x131724(1002)]=function a(e){var i=a1_0x131724,s=utf8$1[i(640)](e);return s?this[i(773)](s)[i(969)](utf8$1[i(1013)],s,e):this._push(writeByte,1,0)},Writer$1.prototype[a1_0x131724(365)]=function a(){var e=a1_0x131724;return this[e(629)]=new State(this),this[e(410)]=this[e(718)]=new Op(noop,0,0),this[e(913)]=0,this},Writer$1[a1_0x131724(985)][a1_0x131724(373)]=function a(){var e=a1_0x131724;return this[e(629)]?(this.head=this[e(629)].head,this.tail=this[e(629)].tail,this[e(913)]=this[e(629)].len,this[e(629)]=this[e(629)].next):(this.head=this[e(718)]=new Op(noop,0,0),this[e(913)]=0),this},Writer$1[a1_0x131724(985)][a1_0x131724(496)]=function a(){var e=a1_0x131724,i=this[e(410)],s=this.tail,o=this[e(913)];return this[e(373)]()[e(773)](o),o&&(this[e(718)][e(396)]=i[e(396)],this[e(718)]=s,this[e(913)]+=o),this},Writer$1[a1_0x131724(985)].finish=function a(){for(var e=a1_0x131724,i=this[e(410)][e(396)],s=this[e(449)][e(651)](this.len),o=0;i;)i.fn(i[e(730)],s,o),o+=i.len,i=i[e(396)];return s},Writer$1[a1_0x131724(441)]=function(a){BufferWriter$1=a,Writer$1.create=create$1(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter[a1_0x131724(985)]=Object[a1_0x131724(811)](Writer[a1_0x131724(985)]))[a1_0x131724(449)]=BufferWriter;var util$3=requireMinimal();function BufferWriter(){var a=a1_0x131724;Writer[a(794)](this)}BufferWriter[a1_0x131724(441)]=function(){var a=a1_0x131724;BufferWriter[a(651)]=util$3._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$3[a(934)]&&util$3[a(934)][a(985)]instanceof Uint8Array&&util$3.Buffer.prototype[a(802)][a(862)]===a(802)?function(i,s,o){var c=a;s[c(802)](i,o)}:function(i,s,o){var c=a;if(i.copy)i[c(611)](s,o,0,i.length);else for(var d=0;d<i.length;)s[o++]=i[d++]}},BufferWriter[a1_0x131724(985)][a1_0x131724(691)]=function a(e){var i=a1_0x131724;util$3[i(776)](e)&&(e=util$3._Buffer_from(e,i(663)));var s=e.length>>>0;return this[i(773)](s),s&&this._push(BufferWriter[i(873)],s,e),this};function writeStringBuffer(a,e,i){var s=a1_0x131724;a[s(640)]<40?util$3[s(872)].write(a,e,i):e.utf8Write?e[s(491)](a,i):e.write(a,i)}BufferWriter[a1_0x131724(985)][a1_0x131724(1002)]=function a(e){var i=a1_0x131724,s=util$3[i(934)][i(371)](e);return this.uint32(s),s&&this[i(969)](writeStringBuffer,s,e),this},BufferWriter[a1_0x131724(441)]();var reader=Reader$1,util$2=requireMinimal(),BufferReader$1,LongBits=util$2[a1_0x131724(799)],utf8=util$2[a1_0x131724(872)];function indexOutOfRange(a,e){var i=a1_0x131724;return RangeError("index out of range: "+a.pos+" + "+(e||1)+i(347)+a[i(913)])}function Reader$1(a){var e=a1_0x131724;this.buf=a,this[e(488)]=0,this.len=a.length}var create_array=typeof Uint8Array!==a1_0x131724(789)?function a(e){var i=a1_0x131724;if(e instanceof Uint8Array||Array[i(571)](e))return new Reader$1(e);throw Error(i(836))}:function a(e){var i=a1_0x131724;if(Array[i(571)](e))return new Reader$1(e);throw Error(i(836))},create=function a(){return util$2.Buffer?function(i){var s=a1_0x9238;return(Reader$1[s(811)]=function(c){var d=s;return util$2[d(934)][d(780)](c)?new BufferReader$1(c):create_array(c)})(i)}:create_array};Reader$1.create=create(),Reader$1[a1_0x131724(985)][a1_0x131724(844)]=util$2[a1_0x131724(1007)][a1_0x131724(985)][a1_0x131724(694)]||util$2.Array[a1_0x131724(985)][a1_0x131724(944)],Reader$1.prototype[a1_0x131724(773)]=function a(){var e=4294967295;return function(){var s=a1_0x9238;if(e=(this[s(837)][this[s(488)]]&127)>>>0,this[s(837)][this[s(488)]++]<128||(e=(e|(this[s(837)][this.pos]&127)<<7)>>>0,this[s(837)][this[s(488)]++]<128)||(e=(e|(this[s(837)][this[s(488)]]&127)<<14)>>>0,this[s(837)][this[s(488)]++]<128)||(e=(e|(this.buf[this[s(488)]]&127)<<21)>>>0,this[s(837)][this[s(488)]++]<128)||(e=(e|(this[s(837)][this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this[s(913)])throw this[s(488)]=this[s(913)],indexOutOfRange(this,10);return e}}(),Reader$1.prototype[a1_0x131724(841)]=function a(){return this.uint32()|0},Reader$1.prototype[a1_0x131724(380)]=function a(){var e=a1_0x131724,i=this[e(773)]();return i>>>1^-(i&1)|0};function readLongVarint(){var a=a1_0x131724,e=new LongBits(0,0),i=0;if(this[a(913)]-this[a(488)]>4){for(;i<4;++i)if(e.lo=(e.lo|(this[a(837)][this[a(488)]]&127)<<i*7)>>>0,this[a(837)][this.pos++]<128)return e;if(e.lo=(e.lo|(this[a(837)][this[a(488)]]&127)<<28)>>>0,e.hi=(e.hi|(this.buf[this[a(488)]]&127)>>4)>>>0,this[a(837)][this.pos++]<128)return e;i=0}else{for(;i<3;++i){if(this[a(488)]>=this[a(913)])throw indexOutOfRange(this);if(e.lo=(e.lo|(this.buf[this[a(488)]]&127)<<i*7)>>>0,this[a(837)][this[a(488)]++]<128)return e}return e.lo=(e.lo|(this[a(837)][this[a(488)]++]&127)<<i*7)>>>0,e}if(this[a(913)]-this[a(488)]>4){for(;i<5;++i)if(e.hi=(e.hi|(this.buf[this[a(488)]]&127)<<i*7+3)>>>0,this[a(837)][this[a(488)]++]<128)return e}else for(;i<5;++i){if(this[a(488)]>=this[a(913)])throw indexOutOfRange(this);if(e.hi=(e.hi|(this.buf[this[a(488)]]&127)<<i*7+3)>>>0,this[a(837)][this[a(488)]++]<128)return e}throw Error(a(376))}Reader$1[a1_0x131724(985)][a1_0x131724(766)]=function a(){return this.uint32()!==0};function readFixed32_end(a,e){return(a[e-4]|a[e-3]<<8|a[e-2]<<16|a[e-1]<<24)>>>0}Reader$1[a1_0x131724(985)][a1_0x131724(993)]=function a(){var e=a1_0x131724;if(this[e(488)]+4>this[e(913)])throw indexOutOfRange(this,4);return readFixed32_end(this[e(837)],this[e(488)]+=4)},Reader$1[a1_0x131724(985)][a1_0x131724(480)]=function a(){var e=a1_0x131724;if(this[e(488)]+4>this[e(913)])throw indexOutOfRange(this,4);return readFixed32_end(this[e(837)],this[e(488)]+=4)|0};function readFixed64(){var a=a1_0x131724;if(this[a(488)]+8>this[a(913)])throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this[a(488)]+=4),readFixed32_end(this.buf,this[a(488)]+=4))}Reader$1.prototype[a1_0x131724(835)]=function a(){var e=a1_0x131724;if(this.pos+4>this.len)throw indexOutOfRange(this,4);var i=util$2[e(835)][e(1010)](this[e(837)],this[e(488)]);return this.pos+=4,i},Reader$1.prototype[a1_0x131724(952)]=function a(){var e=a1_0x131724;if(this[e(488)]+8>this[e(913)])throw indexOutOfRange(this,4);var i=util$2[e(835)][e(932)](this[e(837)],this[e(488)]);return this.pos+=8,i},Reader$1[a1_0x131724(985)].bytes=function a(){var e=a1_0x131724,i=this[e(773)](),s=this.pos,o=this[e(488)]+i;if(o>this[e(913)])throw indexOutOfRange(this,i);return this[e(488)]+=i,Array[e(571)](this.buf)?this[e(837)].slice(s,o):s===o?new this[e(837)][e(449)](0):this._slice[e(794)](this[e(837)],s,o)},Reader$1[a1_0x131724(985)].string=function a(){var e=a1_0x131724,i=this[e(691)]();return utf8[e(687)](i,0,i.length)},Reader$1[a1_0x131724(985)][a1_0x131724(860)]=function a(e){var i=a1_0x131724;if(typeof e===i(753)){if(this[i(488)]+e>this[i(913)])throw indexOutOfRange(this,e);this.pos+=e}else do if(this[i(488)]>=this[i(913)])throw indexOutOfRange(this);while(this[i(837)][this[i(488)]++]&128);return this},Reader$1[a1_0x131724(985)][a1_0x131724(721)]=function(a){var e=a1_0x131724;switch(a){case 0:this[e(860)]();break;case 1:this[e(860)](8);break;case 2:this.skip(this[e(773)]());break;case 3:for(;(a=this[e(773)]()&7)!==4;)this[e(721)](a);break;case 5:this[e(860)](4);break;default:throw Error(e(575)+a+" at offset "+this[e(488)])}return this},Reader$1[a1_0x131724(441)]=function(a){var e=a1_0x131724;BufferReader$1=a,Reader$1[e(811)]=create(),BufferReader$1[e(441)]();var i=util$2[e(728)]?"toLong":"toNumber";util$2.merge(Reader$1[e(985)],{int64:function(){return readLongVarint.call(this)[i](!1)},uint64:function(){return readLongVarint.call(this)[i](!0)},sint64:function(){var o=e;return readLongVarint.call(this)[o(417)]()[i](!1)},fixed64:function(){var o=e;return readFixed64[o(794)](this)[i](!0)},sfixed64:function(){var o=e;return readFixed64[o(794)](this)[i](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader[a1_0x131724(985)]=Object[a1_0x131724(811)](Reader[a1_0x131724(985)])).constructor=BufferReader;var util$1=requireMinimal();function BufferReader(a){var e=a1_0x131724;Reader[e(794)](this,a)}BufferReader[a1_0x131724(441)]=function(){var a=a1_0x131724;util$1[a(934)]&&(BufferReader.prototype._slice=util$1[a(934)][a(985)][a(944)])},BufferReader[a1_0x131724(985)].string=function a(){var e=a1_0x131724,i=this[e(773)]();return this[e(837)][e(826)]?this.buf.utf8Slice(this.pos,this.pos=Math[e(827)](this[e(488)]+i,this[e(913)])):this[e(837)][e(808)](e(677),this[e(488)],this[e(488)]=Math[e(827)](this[e(488)]+i,this.len))},BufferReader[a1_0x131724(441)]();var rpc={},service=Service,util=requireMinimal();(Service[a1_0x131724(985)]=Object[a1_0x131724(811)](util.EventEmitter[a1_0x131724(985)]))[a1_0x131724(449)]=Service;function Service(a,e,i){var s=a1_0x131724;if(typeof a!="function")throw TypeError("rpcImpl must be a function");util[s(426)][s(794)](this),this[s(856)]=a,this[s(468)]=!!e,this[s(627)]=!!i}Service[a1_0x131724(985)].rpcCall=function a(e,i,s,o,c){var d=a1_0x131724;if(!o)throw TypeError(d(748));var h=this;if(!c)return util[d(429)](a,h,e,i,s,o);if(!h[d(856)])return setTimeout(function(){var g=d;c(Error(g(428)))},0),void 0;try{return h.rpcImpl(e,i[h.requestDelimited?d(445):d(884)](o)[d(981)](),function(_,b){var $=d;if(_)return h[$(562)]($(1004),_,e),c(_);if(b===null)return h[$(909)](!0),void 0;if(!(b instanceof s))try{b=s[h[$(627)]?$(516):$(905)](b)}catch(j){return h[$(562)]($(1004),j,e),c(j)}return h[$(562)]("data",b,e),c(null,b)})}catch(g){return h[d(562)](d(1004),g,e),setTimeout(function(){c(g)},0),void 0}},Service[a1_0x131724(985)][a1_0x131724(909)]=function a(e){var i=a1_0x131724;return this[i(856)]&&(e||this[i(856)](null,null,null),this.rpcImpl=null,this[i(562)](i(909))[i(777)]()),this},function(a){var e=a;e.Service=service}(rpc);var roots={};(function(a){var e=a1_0x131724,i=a;i.build="minimal",i[e(670)]=writer,i[e(561)]=writer_buffer,i.Reader=reader,i[e(598)]=reader_buffer,i[e(503)]=requireMinimal(),i.rpc=rpc,i[e(446)]=roots,i.configure=s;function s(){var o=e;i[o(503)]._configure(),i.Writer[o(441)](i[o(561)]),i[o(713)][o(441)](i[o(598)])}s()})(indexMinimal),function(a){var e=a1_0x131724;a[e(460)]=indexMinimal}(minimal$1);function createBaseAvatarPredictionMessage(){return{blendShapes:void 0,rotation:void 0,transform:void 0}}const AvatarPredictionMessage={encode(a,e=minimal$1.exports[a1_0x131724(670)][a1_0x131724(811)]()){var i=a1_0x131724;return a[i(933)]!==void 0&&BlendShapes[i(884)](a[i(933)],e[i(773)](10)[i(365)]())[i(496)](),a[i(385)]!==void 0&&Rotation.encode(a[i(385)],e[i(773)](18).fork()).ldelim(),a.transform!==void 0&&Transform[i(884)](a[i(405)],e.uint32(26)[i(365)]())[i(496)](),e},decode(a,e){var i=a1_0x131724;const s=a instanceof minimal$1.exports[i(713)]?a:new minimal$1[i(460)][i(713)](a);let o=e===void 0?s[i(913)]:s[i(488)]+e;const c=createBaseAvatarPredictionMessage();for(;s[i(488)]<o;){const d=s[i(773)]();switch(d>>>3){case 1:c[i(933)]=BlendShapes[i(905)](s,s[i(773)]());break;case 2:c[i(385)]=Rotation[i(905)](s,s[i(773)]());break;case 3:c[i(405)]=Transform[i(905)](s,s[i(773)]());break;default:s.skipType(d&7);break}}return c},fromJSON(a){var e=a1_0x131724;return{blendShapes:isSet(a.blendShapes)?BlendShapes[e(581)](a[e(933)]):void 0,rotation:isSet(a[e(385)])?Rotation[e(581)](a[e(385)]):void 0,transform:isSet(a[e(405)])?Transform[e(581)](a.transform):void 0}},toJSON(a){var e=a1_0x131724;const i={};return a[e(933)]!==void 0&&(i[e(933)]=a.blendShapes?BlendShapes[e(652)](a[e(933)]):void 0),a[e(385)]!==void 0&&(i[e(385)]=a.rotation?Rotation[e(652)](a[e(385)]):void 0),a[e(405)]!==void 0&&(i[e(405)]=a[e(405)]?Transform.toJSON(a[e(405)]):void 0),i},fromPartial(a){var e=a1_0x131724;const i=createBaseAvatarPredictionMessage();return i.blendShapes=a.blendShapes!==void 0&&a.blendShapes!==null?BlendShapes[e(655)](a.blendShapes):void 0,i.rotation=a[e(385)]!==void 0&&a[e(385)]!==null?Rotation[e(655)](a[e(385)]):void 0,i.transform=a[e(405)]!==void 0&&a[e(405)]!==null?Transform[e(655)](a[e(405)]):void 0,i}};function createBaseBlendShapes(){return{browDown_L:0,browDown_R:0,browInnerUp:0,browOuterUp_L:0,browOuterUp_R:0,cheekSquint_L:0,cheekSquint_R:0,eyeBlink_L:0,eyeBlink_R:0,eyeLookDown_L:0,eyeLookDown_R:0,eyeLookIn_L:0,eyeLookIn_R:0,eyeLookOut_L:0,eyeLookOut_R:0,eyeLookUp_L:0,eyeLookUp_R:0,eyeSquint_L:0,eyeSquint_R:0,eyeWide_L:0,eyeWide_R:0,jawLeft:0,jawOpen:0,jawRight:0,mouthClose:0,mouthDimple_L:0,mouthDimple_R:0,mouthFrown_L:0,mouthFrown_R:0,mouthFunnel:0,mouthLeft:0,mouthLowerDown_L:0,mouthLowerDown_R:0,mouthPress_L:0,mouthPress_R:0,mouthPucker:0,mouthRight:0,mouthRollLower:0,mouthRollUpper:0,mouthShrugLower:0,mouthShrugUpper:0,mouthSmile_L:0,mouthSmile_R:0,mouthStretch_L:0,mouthStretch_R:0,mouthUpperUp_L:0,mouthUpperUp_R:0,noseSneer_L:0,noseSneer_R:0,cheekPuff:0,jawForward:0,tongueOut:0}}const BlendShapes={encode(a,e=minimal$1[a1_0x131724(460)].Writer.create()){var i=a1_0x131724;return a.browDown_L!==0&&e.uint32(13).float(a[i(434)]),a[i(484)]!==0&&e[i(773)](21)[i(835)](a[i(484)]),a[i(890)]!==0&&e[i(773)](29)[i(835)](a.browInnerUp),a.browOuterUp_L!==0&&e[i(773)](37)[i(835)](a[i(719)]),a[i(643)]!==0&&e[i(773)](45)[i(835)](a.browOuterUp_R),a.cheekSquint_L!==0&&e[i(773)](53)[i(835)](a[i(664)]),a.cheekSquint_R!==0&&e[i(773)](61)[i(835)](a[i(344)]),a.eyeBlink_L!==0&&e[i(773)](69)[i(835)](a.eyeBlink_L),a[i(928)]!==0&&e[i(773)](77).float(a[i(928)]),a[i(1012)]!==0&&e[i(773)](85)[i(835)](a[i(1012)]),a[i(669)]!==0&&e[i(773)](93)[i(835)](a[i(669)]),a[i(963)]!==0&&e.uint32(101)[i(835)](a[i(963)]),a[i(342)]!==0&&e[i(773)](109)[i(835)](a.eyeLookIn_R),a[i(464)]!==0&&e.uint32(117)[i(835)](a[i(464)]),a[i(703)]!==0&&e.uint32(125)[i(835)](a[i(703)]),a[i(982)]!==0&&e.uint32(133)[i(835)](a[i(982)]),a[i(940)]!==0&&e[i(773)](141).float(a[i(940)]),a[i(622)]!==0&&e[i(773)](149)[i(835)](a[i(622)]),a[i(1003)]!==0&&e[i(773)](157)[i(835)](a[i(1003)]),a[i(711)]!==0&&e[i(773)](165)[i(835)](a[i(711)]),a.eyeWide_R!==0&&e.uint32(173)[i(835)](a[i(422)]),a[i(917)]!==0&&e[i(773)](181).float(a[i(917)]),a[i(892)]!==0&&e[i(773)](189).float(a[i(892)]),a[i(704)]!==0&&e[i(773)](197)[i(835)](a[i(704)]),a[i(576)]!==0&&e.uint32(205)[i(835)](a.mouthClose),a.mouthDimple_L!==0&&e[i(773)](213)[i(835)](a[i(731)]),a[i(976)]!==0&&e[i(773)](221)[i(835)](a[i(976)]),a[i(971)]!==0&&e.uint32(229)[i(835)](a.mouthFrown_L),a.mouthFrown_R!==0&&e[i(773)](237)[i(835)](a.mouthFrown_R),a[i(551)]!==0&&e.uint32(245)[i(835)](a[i(551)]),a[i(673)]!==0&&e[i(773)](253)[i(835)](a[i(673)]),a[i(366)]!==0&&e.uint32(261)[i(835)](a.mouthLowerDown_L),a.mouthLowerDown_R!==0&&e[i(773)](269)[i(835)](a[i(608)]),a[i(784)]!==0&&e[i(773)](277)[i(835)](a[i(784)]),a[i(538)]!==0&&e.uint32(285)[i(835)](a[i(538)]),a[i(618)]!==0&&e[i(773)](293)[i(835)](a.mouthPucker),a[i(518)]!==0&&e[i(773)](301)[i(835)](a[i(518)]),a[i(792)]!==0&&e[i(773)](309)[i(835)](a[i(792)]),a[i(391)]!==0&&e.uint32(317).float(a[i(391)]),a.mouthShrugLower!==0&&e[i(773)](325)[i(835)](a[i(492)]),a[i(851)]!==0&&e[i(773)](333)[i(835)](a.mouthShrugUpper),a[i(736)]!==0&&e[i(773)](341)[i(835)](a.mouthSmile_L),a.mouthSmile_R!==0&&e[i(773)](349)[i(835)](a.mouthSmile_R),a[i(758)]!==0&&e[i(773)](357)[i(835)](a[i(758)]),a[i(544)]!==0&&e.uint32(365)[i(835)](a[i(544)]),a[i(927)]!==0&&e.uint32(373)[i(835)](a[i(927)]),a.mouthUpperUp_R!==0&&e[i(773)](381)[i(835)](a[i(383)]),a[i(850)]!==0&&e[i(773)](389)[i(835)](a.noseSneer_L),a[i(648)]!==0&&e[i(773)](397)[i(835)](a[i(648)]),a[i(470)]!==0&&e[i(773)](405)[i(835)](a[i(470)]),a[i(588)]!==0&&e.uint32(413).float(a.jawForward),a[i(354)]!==0&&e[i(773)](421)[i(835)](a[i(354)]),e},decode(a,e){var i=a1_0x131724;const s=a instanceof minimal$1[i(460)][i(713)]?a:new minimal$1[i(460)][i(713)](a);let o=e===void 0?s.len:s.pos+e;const c=createBaseBlendShapes();for(;s[i(488)]<o;){const d=s[i(773)]();switch(d>>>3){case 1:c[i(434)]=s[i(835)]();break;case 2:c.browDown_R=s[i(835)]();break;case 3:c[i(890)]=s[i(835)]();break;case 4:c[i(719)]=s[i(835)]();break;case 5:c[i(643)]=s[i(835)]();break;case 6:c[i(664)]=s.float();break;case 7:c.cheekSquint_R=s[i(835)]();break;case 8:c[i(592)]=s[i(835)]();break;case 9:c.eyeBlink_R=s[i(835)]();break;case 10:c[i(1012)]=s[i(835)]();break;case 11:c[i(669)]=s[i(835)]();break;case 12:c[i(963)]=s[i(835)]();break;case 13:c[i(342)]=s[i(835)]();break;case 14:c[i(464)]=s[i(835)]();break;case 15:c[i(703)]=s[i(835)]();break;case 16:c.eyeLookUp_L=s[i(835)]();break;case 17:c[i(940)]=s[i(835)]();break;case 18:c[i(622)]=s[i(835)]();break;case 19:c[i(1003)]=s.float();break;case 20:c[i(711)]=s[i(835)]();break;case 21:c[i(422)]=s[i(835)]();break;case 22:c[i(917)]=s[i(835)]();break;case 23:c.jawOpen=s[i(835)]();break;case 24:c.jawRight=s[i(835)]();break;case 25:c[i(576)]=s[i(835)]();break;case 26:c[i(731)]=s.float();break;case 27:c[i(976)]=s.float();break;case 28:c.mouthFrown_L=s[i(835)]();break;case 29:c[i(609)]=s[i(835)]();break;case 30:c[i(551)]=s.float();break;case 31:c[i(673)]=s.float();break;case 32:c.mouthLowerDown_L=s[i(835)]();break;case 33:c[i(608)]=s[i(835)]();break;case 34:c[i(784)]=s[i(835)]();break;case 35:c.mouthPress_R=s[i(835)]();break;case 36:c.mouthPucker=s.float();break;case 37:c[i(518)]=s[i(835)]();break;case 38:c.mouthRollLower=s[i(835)]();break;case 39:c[i(391)]=s[i(835)]();break;case 40:c.mouthShrugLower=s[i(835)]();break;case 41:c[i(851)]=s[i(835)]();break;case 42:c[i(736)]=s.float();break;case 43:c[i(879)]=s[i(835)]();break;case 44:c[i(758)]=s[i(835)]();break;case 45:c.mouthStretch_R=s[i(835)]();break;case 46:c.mouthUpperUp_L=s[i(835)]();break;case 47:c.mouthUpperUp_R=s.float();break;case 48:c.noseSneer_L=s[i(835)]();break;case 49:c.noseSneer_R=s[i(835)]();break;case 50:c[i(470)]=s[i(835)]();break;case 51:c[i(588)]=s.float();break;case 52:c[i(354)]=s[i(835)]();break;default:s[i(721)](d&7);break}}return c},fromJSON(a){var e=a1_0x131724;return{browDown_L:isSet(a[e(434)])?Number(a[e(434)]):0,browDown_R:isSet(a[e(484)])?Number(a.browDown_R):0,browInnerUp:isSet(a[e(890)])?Number(a[e(890)]):0,browOuterUp_L:isSet(a.browOuterUp_L)?Number(a[e(719)]):0,browOuterUp_R:isSet(a.browOuterUp_R)?Number(a.browOuterUp_R):0,cheekSquint_L:isSet(a.cheekSquint_L)?Number(a[e(664)]):0,cheekSquint_R:isSet(a[e(344)])?Number(a[e(344)]):0,eyeBlink_L:isSet(a[e(592)])?Number(a[e(592)]):0,eyeBlink_R:isSet(a[e(928)])?Number(a[e(928)]):0,eyeLookDown_L:isSet(a.eyeLookDown_L)?Number(a[e(1012)]):0,eyeLookDown_R:isSet(a[e(669)])?Number(a[e(669)]):0,eyeLookIn_L:isSet(a[e(963)])?Number(a.eyeLookIn_L):0,eyeLookIn_R:isSet(a[e(342)])?Number(a.eyeLookIn_R):0,eyeLookOut_L:isSet(a[e(464)])?Number(a.eyeLookOut_L):0,eyeLookOut_R:isSet(a.eyeLookOut_R)?Number(a[e(703)]):0,eyeLookUp_L:isSet(a[e(982)])?Number(a.eyeLookUp_L):0,eyeLookUp_R:isSet(a[e(940)])?Number(a.eyeLookUp_R):0,eyeSquint_L:isSet(a[e(622)])?Number(a[e(622)]):0,eyeSquint_R:isSet(a[e(1003)])?Number(a[e(1003)]):0,eyeWide_L:isSet(a[e(711)])?Number(a[e(711)]):0,eyeWide_R:isSet(a[e(422)])?Number(a[e(422)]):0,jawLeft:isSet(a[e(917)])?Number(a[e(917)]):0,jawOpen:isSet(a[e(892)])?Number(a[e(892)]):0,jawRight:isSet(a[e(704)])?Number(a[e(704)]):0,mouthClose:isSet(a[e(576)])?Number(a.mouthClose):0,mouthDimple_L:isSet(a[e(731)])?Number(a[e(731)]):0,mouthDimple_R:isSet(a[e(976)])?Number(a[e(976)]):0,mouthFrown_L:isSet(a.mouthFrown_L)?Number(a[e(971)]):0,mouthFrown_R:isSet(a.mouthFrown_R)?Number(a.mouthFrown_R):0,mouthFunnel:isSet(a[e(551)])?Number(a.mouthFunnel):0,mouthLeft:isSet(a[e(673)])?Number(a[e(673)]):0,mouthLowerDown_L:isSet(a[e(366)])?Number(a.mouthLowerDown_L):0,mouthLowerDown_R:isSet(a.mouthLowerDown_R)?Number(a.mouthLowerDown_R):0,mouthPress_L:isSet(a[e(784)])?Number(a[e(784)]):0,mouthPress_R:isSet(a.mouthPress_R)?Number(a[e(538)]):0,mouthPucker:isSet(a[e(618)])?Number(a[e(618)]):0,mouthRight:isSet(a[e(518)])?Number(a[e(518)]):0,mouthRollLower:isSet(a[e(792)])?Number(a.mouthRollLower):0,mouthRollUpper:isSet(a[e(391)])?Number(a[e(391)]):0,mouthShrugLower:isSet(a[e(492)])?Number(a[e(492)]):0,mouthShrugUpper:isSet(a[e(851)])?Number(a[e(851)]):0,mouthSmile_L:isSet(a[e(736)])?Number(a[e(736)]):0,mouthSmile_R:isSet(a.mouthSmile_R)?Number(a[e(879)]):0,mouthStretch_L:isSet(a[e(758)])?Number(a[e(758)]):0,mouthStretch_R:isSet(a[e(544)])?Number(a[e(544)]):0,mouthUpperUp_L:isSet(a.mouthUpperUp_L)?Number(a[e(927)]):0,mouthUpperUp_R:isSet(a[e(383)])?Number(a[e(383)]):0,noseSneer_L:isSet(a[e(850)])?Number(a[e(850)]):0,noseSneer_R:isSet(a[e(648)])?Number(a[e(648)]):0,cheekPuff:isSet(a[e(470)])?Number(a[e(470)]):0,jawForward:isSet(a[e(588)])?Number(a[e(588)]):0,tongueOut:isSet(a[e(354)])?Number(a.tongueOut):0}},toJSON(a){var e=a1_0x131724;const i={};return a.browDown_L!==void 0&&(i[e(434)]=a[e(434)]),a[e(484)]!==void 0&&(i[e(484)]=a.browDown_R),a[e(890)]!==void 0&&(i.browInnerUp=a.browInnerUp),a[e(719)]!==void 0&&(i.browOuterUp_L=a[e(719)]),a.browOuterUp_R!==void 0&&(i.browOuterUp_R=a[e(643)]),a[e(664)]!==void 0&&(i[e(664)]=a[e(664)]),a[e(344)]!==void 0&&(i[e(344)]=a[e(344)]),a[e(592)]!==void 0&&(i[e(592)]=a.eyeBlink_L),a[e(928)]!==void 0&&(i.eyeBlink_R=a.eyeBlink_R),a.eyeLookDown_L!==void 0&&(i.eyeLookDown_L=a[e(1012)]),a.eyeLookDown_R!==void 0&&(i[e(669)]=a[e(669)]),a[e(963)]!==void 0&&(i.eyeLookIn_L=a[e(963)]),a[e(342)]!==void 0&&(i[e(342)]=a.eyeLookIn_R),a[e(464)]!==void 0&&(i[e(464)]=a.eyeLookOut_L),a.eyeLookOut_R!==void 0&&(i[e(703)]=a[e(703)]),a[e(982)]!==void 0&&(i[e(982)]=a.eyeLookUp_L),a[e(940)]!==void 0&&(i[e(940)]=a[e(940)]),a[e(622)]!==void 0&&(i[e(622)]=a[e(622)]),a[e(1003)]!==void 0&&(i[e(1003)]=a.eyeSquint_R),a[e(711)]!==void 0&&(i[e(711)]=a.eyeWide_L),a[e(422)]!==void 0&&(i[e(422)]=a[e(422)]),a[e(917)]!==void 0&&(i[e(917)]=a.jawLeft),a[e(892)]!==void 0&&(i[e(892)]=a[e(892)]),a[e(704)]!==void 0&&(i.jawRight=a.jawRight),a.mouthClose!==void 0&&(i[e(576)]=a.mouthClose),a[e(731)]!==void 0&&(i[e(731)]=a.mouthDimple_L),a[e(976)]!==void 0&&(i[e(976)]=a[e(976)]),a[e(971)]!==void 0&&(i.mouthFrown_L=a[e(971)]),a[e(609)]!==void 0&&(i[e(609)]=a[e(609)]),a.mouthFunnel!==void 0&&(i[e(551)]=a.mouthFunnel),a[e(673)]!==void 0&&(i[e(673)]=a[e(673)]),a.mouthLowerDown_L!==void 0&&(i[e(366)]=a.mouthLowerDown_L),a[e(608)]!==void 0&&(i.mouthLowerDown_R=a[e(608)]),a[e(784)]!==void 0&&(i[e(784)]=a[e(784)]),a.mouthPress_R!==void 0&&(i[e(538)]=a[e(538)]),a[e(618)]!==void 0&&(i[e(618)]=a[e(618)]),a.mouthRight!==void 0&&(i[e(518)]=a[e(518)]),a[e(792)]!==void 0&&(i[e(792)]=a.mouthRollLower),a[e(391)]!==void 0&&(i[e(391)]=a[e(391)]),a[e(492)]!==void 0&&(i[e(492)]=a.mouthShrugLower),a.mouthShrugUpper!==void 0&&(i[e(851)]=a[e(851)]),a[e(736)]!==void 0&&(i[e(736)]=a[e(736)]),a[e(879)]!==void 0&&(i.mouthSmile_R=a[e(879)]),a[e(758)]!==void 0&&(i[e(758)]=a[e(758)]),a[e(544)]!==void 0&&(i.mouthStretch_R=a[e(544)]),a[e(927)]!==void 0&&(i.mouthUpperUp_L=a[e(927)]),a[e(383)]!==void 0&&(i[e(383)]=a[e(383)]),a.noseSneer_L!==void 0&&(i[e(850)]=a[e(850)]),a[e(648)]!==void 0&&(i.noseSneer_R=a.noseSneer_R),a[e(470)]!==void 0&&(i.cheekPuff=a.cheekPuff),a.jawForward!==void 0&&(i.jawForward=a.jawForward),a[e(354)]!==void 0&&(i[e(354)]=a[e(354)]),i},fromPartial(a){var e=a1_0x131724,i,s,o,c,d,h,g,_,b,$,j,_e,tt,et,nt,rt,it,at,st,ot,ct,lt,dt,xt,ut,ft,mt,yt,St,Et,vt,Nt,wt,$t,Ct,Mt,Ot,Dt,At,kt,Ft,Bt,Ht,Wt,Ut,Rt,un,rn,mn,sn,hn,gn;const Xt=createBaseBlendShapes();return Xt[e(434)]=(i=a[e(434)])!==null&&i!==void 0?i:0,Xt[e(484)]=(s=a[e(484)])!==null&&s!==void 0?s:0,Xt[e(890)]=(o=a.browInnerUp)!==null&&o!==void 0?o:0,Xt.browOuterUp_L=(c=a[e(719)])!==null&&c!==void 0?c:0,Xt[e(643)]=(d=a.browOuterUp_R)!==null&&d!==void 0?d:0,Xt.cheekSquint_L=(h=a[e(664)])!==null&&h!==void 0?h:0,Xt[e(344)]=(g=a[e(344)])!==null&&g!==void 0?g:0,Xt[e(592)]=(_=a[e(592)])!==null&&_!==void 0?_:0,Xt.eyeBlink_R=(b=a[e(928)])!==null&&b!==void 0?b:0,Xt[e(1012)]=($=a.eyeLookDown_L)!==null&&$!==void 0?$:0,Xt.eyeLookDown_R=(j=a[e(669)])!==null&&j!==void 0?j:0,Xt[e(963)]=(_e=a[e(963)])!==null&&_e!==void 0?_e:0,Xt.eyeLookIn_R=(tt=a[e(342)])!==null&&tt!==void 0?tt:0,Xt[e(464)]=(et=a[e(464)])!==null&&et!==void 0?et:0,Xt[e(703)]=(nt=a[e(703)])!==null&&nt!==void 0?nt:0,Xt[e(982)]=(rt=a[e(982)])!==null&&rt!==void 0?rt:0,Xt[e(940)]=(it=a[e(940)])!==null&&it!==void 0?it:0,Xt[e(622)]=(at=a[e(622)])!==null&&at!==void 0?at:0,Xt[e(1003)]=(st=a[e(1003)])!==null&&st!==void 0?st:0,Xt.eyeWide_L=(ot=a.eyeWide_L)!==null&&ot!==void 0?ot:0,Xt.eyeWide_R=(ct=a[e(422)])!==null&&ct!==void 0?ct:0,Xt.jawLeft=(lt=a.jawLeft)!==null&&lt!==void 0?lt:0,Xt[e(892)]=(dt=a[e(892)])!==null&&dt!==void 0?dt:0,Xt[e(704)]=(xt=a[e(704)])!==null&&xt!==void 0?xt:0,Xt[e(576)]=(ut=a[e(576)])!==null&&ut!==void 0?ut:0,Xt[e(731)]=(ft=a[e(731)])!==null&&ft!==void 0?ft:0,Xt.mouthDimple_R=(mt=a[e(976)])!==null&&mt!==void 0?mt:0,Xt[e(971)]=(yt=a.mouthFrown_L)!==null&&yt!==void 0?yt:0,Xt[e(609)]=(St=a[e(609)])!==null&&St!==void 0?St:0,Xt.mouthFunnel=(Et=a[e(551)])!==null&&Et!==void 0?Et:0,Xt[e(673)]=(vt=a.mouthLeft)!==null&&vt!==void 0?vt:0,Xt[e(366)]=(Nt=a.mouthLowerDown_L)!==null&&Nt!==void 0?Nt:0,Xt.mouthLowerDown_R=(wt=a.mouthLowerDown_R)!==null&&wt!==void 0?wt:0,Xt[e(784)]=($t=a[e(784)])!==null&&$t!==void 0?$t:0,Xt[e(538)]=(Ct=a.mouthPress_R)!==null&&Ct!==void 0?Ct:0,Xt.mouthPucker=(Mt=a[e(618)])!==null&&Mt!==void 0?Mt:0,Xt[e(518)]=(Ot=a[e(518)])!==null&&Ot!==void 0?Ot:0,Xt[e(792)]=(Dt=a.mouthRollLower)!==null&&Dt!==void 0?Dt:0,Xt.mouthRollUpper=(At=a[e(391)])!==null&&At!==void 0?At:0,Xt[e(492)]=(kt=a[e(492)])!==null&&kt!==void 0?kt:0,Xt[e(851)]=(Ft=a[e(851)])!==null&&Ft!==void 0?Ft:0,Xt.mouthSmile_L=(Bt=a[e(736)])!==null&&Bt!==void 0?Bt:0,Xt.mouthSmile_R=(Ht=a[e(879)])!==null&&Ht!==void 0?Ht:0,Xt[e(758)]=(Wt=a[e(758)])!==null&&Wt!==void 0?Wt:0,Xt.mouthStretch_R=(Ut=a[e(544)])!==null&&Ut!==void 0?Ut:0,Xt.mouthUpperUp_L=(Rt=a[e(927)])!==null&&Rt!==void 0?Rt:0,Xt[e(383)]=(un=a[e(383)])!==null&&un!==void 0?un:0,Xt.noseSneer_L=(rn=a.noseSneer_L)!==null&&rn!==void 0?rn:0,Xt[e(648)]=(mn=a[e(648)])!==null&&mn!==void 0?mn:0,Xt.cheekPuff=(sn=a[e(470)])!==null&&sn!==void 0?sn:0,Xt[e(588)]=(hn=a.jawForward)!==null&&hn!==void 0?hn:0,Xt[e(354)]=(gn=a[e(354)])!==null&&gn!==void 0?gn:0,Xt}};function createBaseRotation(){return{pitch:void 0,roll:void 0,yaw:void 0}}const Rotation={encode(a,e=minimal$1[a1_0x131724(460)][a1_0x131724(670)][a1_0x131724(811)]()){var i=a1_0x131724;return a[i(1022)]!==void 0&&e[i(773)](13)[i(835)](a[i(1022)]),a[i(710)]!==void 0&&e[i(773)](21)[i(835)](a[i(710)]),a.yaw!==void 0&&e[i(773)](29).float(a[i(992)]),e},decode(a,e){var i=a1_0x131724;const s=a instanceof minimal$1[i(460)].Reader?a:new minimal$1[i(460)][i(713)](a);let o=e===void 0?s[i(913)]:s.pos+e;const c=createBaseRotation();for(;s.pos<o;){const d=s[i(773)]();switch(d>>>3){case 1:c.pitch=s[i(835)]();break;case 2:c[i(710)]=s.float();break;case 3:c[i(992)]=s[i(835)]();break;default:s[i(721)](d&7);break}}return c},fromJSON(a){var e=a1_0x131724;return{pitch:isSet(a[e(1022)])?Number(a[e(1022)]):void 0,roll:isSet(a.roll)?Number(a[e(710)]):void 0,yaw:isSet(a[e(992)])?Number(a[e(992)]):void 0}},toJSON(a){var e=a1_0x131724;const i={};return a[e(1022)]!==void 0&&(i[e(1022)]=a[e(1022)]),a.roll!==void 0&&(i.roll=a.roll),a[e(992)]!==void 0&&(i[e(992)]=a.yaw),i},fromPartial(a){var e=a1_0x131724,i,s,o;const c=createBaseRotation();return c[e(1022)]=(i=a[e(1022)])!==null&&i!==void 0?i:void 0,c[e(710)]=(s=a[e(710)])!==null&&s!==void 0?s:void 0,c[e(992)]=(o=a[e(992)])!==null&&o!==void 0?o:void 0,c}};function createBaseTransform(){return{x:void 0,y:void 0,z:void 0}}const Transform={encode(a,e=minimal$1[a1_0x131724(460)][a1_0x131724(670)][a1_0x131724(811)]()){var i=a1_0x131724;return a.x!==void 0&&e[i(773)](13)[i(835)](a.x),a.y!==void 0&&e[i(773)](21)[i(835)](a.y),a.z!==void 0&&e.uint32(29)[i(835)](a.z),e},decode(a,e){var i=a1_0x131724;const s=a instanceof minimal$1[i(460)][i(713)]?a:new minimal$1[i(460)][i(713)](a);let o=e===void 0?s[i(913)]:s[i(488)]+e;const c=createBaseTransform();for(;s.pos<o;){const d=s[i(773)]();switch(d>>>3){case 1:c.x=s[i(835)]();break;case 2:c.y=s[i(835)]();break;case 3:c.z=s.float();break;default:s.skipType(d&7);break}}return c},fromJSON(a){return{x:isSet(a.x)?Number(a.x):void 0,y:isSet(a.y)?Number(a.y):void 0,z:isSet(a.z)?Number(a.z):void 0}},toJSON(a){const e={};return a.x!==void 0&&(e.x=a.x),a.y!==void 0&&(e.y=a.y),a.z!==void 0&&(e.z=a.z),e},fromPartial(a){var e,i,s;const o=createBaseTransform();return o.x=(e=a.x)!==null&&e!==void 0?e:void 0,o.y=(i=a.y)!==null&&i!==void 0?i:void 0,o.z=(s=a.z)!==null&&s!==void 0?s:void 0,o}};minimal$1[a1_0x131724(460)][a1_0x131724(503)].Long!==long&&(minimal$1.exports[a1_0x131724(503)].Long=long,minimal$1.exports[a1_0x131724(953)]());function isSet(a){return a!=null}class AvatarPredictionCoder{[a1_0x131724(884)](e){var i=a1_0x131724;return AvatarPredictionMessage.encode(e)[i(981)]()}decode(e){var i=a1_0x131724;return AvatarPredictionMessage[i(905)](e)}}class RGBELoader extends DataTextureLoader{constructor(e){super(e),this.type=HalfFloatType}parse(e){const d=function(dt,xt){switch(dt){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(xt||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(xt||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(xt||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(xt||""))}},b=`
`,$=function(dt,xt,ut){xt=xt||1024;let mt=dt.pos,yt=-1,St=0,Et="",vt=String.fromCharCode.apply(null,new Uint16Array(dt.subarray(mt,mt+128)));for(;0>(yt=vt.indexOf(b))&&St<xt&&mt<dt.byteLength;)Et+=vt,St+=vt.length,mt+=128,vt+=String.fromCharCode.apply(null,new Uint16Array(dt.subarray(mt,mt+128)));return-1<yt?(dt.pos+=St+yt+1,Et+vt.slice(0,yt)):!1},j=function(dt){const xt=/^#\?(\S+)/,ut=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,ft=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,mt=/^\s*FORMAT=(\S+)\s*$/,yt=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,St={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let Et,vt;for((dt.pos>=dt.byteLength||!(Et=$(dt)))&&d(1,"no header found"),(vt=Et.match(xt))||d(3,"bad initial token"),St.valid|=1,St.programtype=vt[1],St.string+=Et+`
`;Et=$(dt),Et!==!1;){if(St.string+=Et+`
`,Et.charAt(0)==="#"){St.comments+=Et+`
`;continue}if((vt=Et.match(ut))&&(St.gamma=parseFloat(vt[1])),(vt=Et.match(ft))&&(St.exposure=parseFloat(vt[1])),(vt=Et.match(mt))&&(St.valid|=2,St.format=vt[1]),(vt=Et.match(yt))&&(St.valid|=4,St.height=parseInt(vt[1],10),St.width=parseInt(vt[2],10)),St.valid&2&&St.valid&4)break}return St.valid&2||d(3,"missing format specifier"),St.valid&4||d(3,"missing image size specifier"),St},_e=function(dt,xt,ut){const ft=xt;if(ft<8||ft>32767||dt[0]!==2||dt[1]!==2||dt[2]&128)return new Uint8Array(dt);ft!==(dt[2]<<8|dt[3])&&d(3,"wrong scanline width");const mt=new Uint8Array(4*xt*ut);mt.length||d(4,"unable to allocate buffer space");let yt=0,St=0;const Et=4*ft,vt=new Uint8Array(4),Nt=new Uint8Array(Et);let wt=ut;for(;wt>0&&St<dt.byteLength;){St+4>dt.byteLength&&d(1),vt[0]=dt[St++],vt[1]=dt[St++],vt[2]=dt[St++],vt[3]=dt[St++],(vt[0]!=2||vt[1]!=2||(vt[2]<<8|vt[3])!=ft)&&d(3,"bad rgbe scanline format");let $t=0,Ct;for(;$t<Et&&St<dt.byteLength;){Ct=dt[St++];const Ot=Ct>128;if(Ot&&(Ct-=128),(Ct===0||$t+Ct>Et)&&d(3,"bad scanline data"),Ot){const Dt=dt[St++];for(let At=0;At<Ct;At++)Nt[$t++]=Dt}else Nt.set(dt.subarray(St,St+Ct),$t),$t+=Ct,St+=Ct}const Mt=ft;for(let Ot=0;Ot<Mt;Ot++){let Dt=0;mt[yt]=Nt[Ot+Dt],Dt+=ft,mt[yt+1]=Nt[Ot+Dt],Dt+=ft,mt[yt+2]=Nt[Ot+Dt],Dt+=ft,mt[yt+3]=Nt[Ot+Dt],yt+=4}wt--}return mt},tt=function(dt,xt,ut,ft){const mt=dt[xt+3],yt=Math.pow(2,mt-128)/255;ut[ft+0]=dt[xt+0]*yt,ut[ft+1]=dt[xt+1]*yt,ut[ft+2]=dt[xt+2]*yt,ut[ft+3]=1},et=function(dt,xt,ut,ft){const mt=dt[xt+3],yt=Math.pow(2,mt-128)/255;ut[ft+0]=DataUtils.toHalfFloat(Math.min(dt[xt+0]*yt,65504)),ut[ft+1]=DataUtils.toHalfFloat(Math.min(dt[xt+1]*yt,65504)),ut[ft+2]=DataUtils.toHalfFloat(Math.min(dt[xt+2]*yt,65504)),ut[ft+3]=DataUtils.toHalfFloat(1)},nt=new Uint8Array(e);nt.pos=0;const rt=j(nt),it=rt.width,at=rt.height,st=_e(nt.subarray(nt.pos),it,at);let ot,ct,lt;switch(this.type){case FloatType:lt=st.length/4;const dt=new Float32Array(lt*4);for(let ut=0;ut<lt;ut++)tt(st,ut*4,dt,ut*4);ot=dt,ct=FloatType;break;case HalfFloatType:lt=st.length/4;const xt=new Uint16Array(lt*4);for(let ut=0;ut<lt;ut++)et(st,ut*4,xt,ut*4);ot=xt,ct=HalfFloatType;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:it,height:at,data:ot,header:rt.string,gamma:rt.gamma,exposure:rt.exposure,type:ct}}setDataType(e){return this.type=e,this}load(e,i,s,o){function c(d,h){switch(d.type){case FloatType:case HalfFloatType:d.colorSpace=LinearSRGBColorSpace,d.minFilter=LinearFilter,d.magFilter=LinearFilter,d.generateMipmaps=!1,d.flipY=!0;break}i&&i(d,h)}return super.load(e,c,s,o)}}const navigationBarHeight=100,backgroundUrl="https://hallway-public.nyc3.digitaloceanspaces.com/backgrounds/aerodynamics_workshop_1k.hdr",SCALE=1,BlendShapeKeys={toARKitConvention:a=>({mouthSmile_L:"mouthSmileLeft",mouthSmile_R:"mouthSmileRight"})[a]||a};class AvatarView extends reactExports.Component{constructor(){super(...arguments);Fr(this,"mainViewRef",React.createRef());Fr(this,"predictor",new AUPredictor({apiToken:"110546ae-627f-48d4-9cf8-fd8850e0ac7f",shouldMirrorOutput:!0}));Fr(this,"onPredict",i=>{var b;const s=this.avatar.children.find($=>$.name==="react-three");Object.entries(i.blendShapes).forEach(function([$,j]){const _e=BlendShapeKeys.toARKitConvention($),tt=s.morphTargetDictionary[_e];s.morphTargetInfluences[tt]=j});const{pitch:o,yaw:c,roll:d}=i.rotation;(b=this.avatar)==null||b.rotation.set(-o,c,d);const{x:h,y:g,z:_}=i.transform;this.avatar.position.set(h*SCALE,-4+g*SCALE,_)});Fr(this,"render",()=>jsxRuntimeExports.jsx("div",{ref:this.mainViewRef,className:"avatarView",style:{display:`${this.props.showIFrame?"block":"none"}`,height:"calc(100vh - 100px)"}}))}async componentDidMount(){const i=this.mainViewRef.current;this.renderer=new WebGLRenderer({antialias:!0}),this.renderer.setSize(window.innerWidth,window.innerHeight-navigationBarHeight),this.renderer.outputEncoding=void 0,this.renderer.toneMapping=ACESFilmicToneMapping,i.appendChild(this.renderer.domElement),this.camera=new PerspectiveCamera(75,window.innerWidth/(window.innerHeight-navigationBarHeight),.1,1e3),this.camera.position.set(0,0,3),this.controls=new OrbitControls(this.camera,this.renderer.domElement);const s=await this.loadBackground(backgroundUrl);this.scene=new Scene,this.scene.background=s,this.loadModel(),this.renderer.setAnimationLoop(this.renderScene.bind(this)),this.predictor.onPredict=this.onPredict.bind(this)}async componentDidUpdate(i){var s,o,c,d;if((s=this.props)!=null&&s.avatarUrl&&((o=this.props)==null?void 0:o.avatarUrl)!==(i==null?void 0:i.avatarUrl)&&this.loadModel(),((c=this.props)==null?void 0:c.predicting)!==(i==null?void 0:i.predicting))if((d=this.props)!=null&&d.predicting&&this.predictor.state==="stopped"){let h=await navigator.mediaDevices.getUserMedia({audio:!1,video:{width:{ideal:640},height:{ideal:360},facingMode:"user"}});await this.predictor.start({stream:h})}else this.predictor.state!=="stopped"&&await this.predictor.stop();this.renderer.domElement.style.cssText=`display: ${this.props.showIFrame?"none":"block"}`}async loadModel(){const i=await this.loadGLTF(this.props.avatarUrl);this.avatar=i.scene.children[0],this.avatar.position.set(0,-4,0),this.avatar.scale.setScalar(SCALE),this.scene.add(this.avatar)}renderScene(){this.renderer.render(this.scene,this.camera)}loadGLTF(i){return new Promise(s=>{new GLTFLoader().load(i,c=>s(c))})}loadBackground(i){return new Promise(s=>{const o=new RGBELoader,c=new PMREMGenerator(this.renderer);o.load(i,d=>{const h=c.fromEquirectangular(d).texture;c.dispose(),d.dispose(),s(h)})})}}AvatarView.propTypes={showIFrame:PropTypes.bool.isRequired,avatarUrl:PropTypes.string,predicting:PropTypes.bool};function Home(){return jsxRuntimeExports.jsx("h1",{children:"Welcome to the Avatar Creator"})}const AvatarFrame=({subdomain:a,setAvatarUrl:e,setShowIFrame:i,showIFrame:s,setPredicting:o})=>{const c=reactExports.useRef(null);reactExports.useEffect(()=>{let g=c.current;g&&(g.src=`https://${a}.readyplayer.me/avatar?frameApi`)}),reactExports.useEffect(()=>(window.addEventListener("message",d),document.addEventListener("message",d),()=>{window.removeEventListener("message",d),document.removeEventListener("message",d)}));function d(g){const _=h(g);if((_==null?void 0:_.source)==="readyplayerme"){if(_.eventName==="v1.frame.ready"){let b=c.current;b&&b.contentWindow&&b.contentWindow.postMessage(JSON.stringify({target:"readyplayerme",type:"subscribe",eventName:"v1.**"}),"*")}_.eventName==="v1.avatar.exported"&&(e(_.data.url),i(!1),o(!0)),_.eventName==="v1.user.set"&&console.log(`User with id ${_.data.id} set: ${JSON.stringify(_)}`)}}function h(g){try{return JSON.parse(g.data)}catch{return null}}return jsxRuntimeExports.jsx("iframe",{allow:"camera *; microphone *",className:"iFrame",id:"frame",ref:c,style:{display:`${s?"block":"none"}`},title:"Ready Player Me"})};AvatarFrame.propTypes={subdomain:PropTypes.string.isRequired,setAvatarUrl:PropTypes.func.isRequired,setShowIFrame:PropTypes.func.isRequired,showIFrame:PropTypes.bool.isRequired,setPredicting:PropTypes.func.isRequired};function App(){const a="react-three-21na6j",[e,i]=reactExports.useState(""),[s,o]=reactExports.useState(!0),[c,d]=reactExports.useState(!1),h=useNavigate();return reactExports.useEffect(()=>{e&&h("/home")},[e,h]),jsxRuntimeExports.jsx("div",{className:"App",children:jsxRuntimeExports.jsxs(Routes,{children:[jsxRuntimeExports.jsx(Route,{exact:!0,path:"/home",element:jsxRuntimeExports.jsx(Home,{})}),jsxRuntimeExports.jsx(Route,{path:"/",element:jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment,{children:[jsxRuntimeExports.jsx(AvatarFrame,{subdomain:a,setAvatarUrl:i,avatarUrl:e,setShowIFrame:o,showIFrame:s,setPredicting:d,predicting:c}),e&&jsxRuntimeExports.jsx(AvatarView,{avatarUrl:e,predicting:c,showIFrame:s})]})})]})})}function AppWrapper(){return jsxRuntimeExports.jsx(BrowserRouter,{children:jsxRuntimeExports.jsx(App,{})})}client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode,{children:jsxRuntimeExports.jsx(AppWrapper,{})}));
